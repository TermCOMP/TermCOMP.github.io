YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/UhmgI.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given RelTRS could be proven:

(0) RelTRS
(1) RelTRS S Cleaner [EQUIVALENT, 0 ms]
(2) RelTRS
(3) RelTRStoRelADPProof [EQUIVALENT, 0 ms]
(4) RelADPP
(5) RelADPDepGraphProof [EQUIVALENT, 0 ms]
(6) AND
    (7) RelADPP
        (8) RelADPReductionPairProof [EQUIVALENT, 64 ms]
        (9) RelADPP
        (10) RelADPCleverAfsProof [SOUND, 4 ms]
        (11) QDP
        (12) MRRProof [EQUIVALENT, 4 ms]
        (13) QDP
        (14) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
        (15) YES
    (16) RelADPP
        (17) RelADPReductionPairProof [EQUIVALENT, 48 ms]
        (18) RelADPP
        (19) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
        (20) QDP
        (21) MRRProof [EQUIVALENT, 6 ms]
        (22) QDP
        (23) DependencyGraphProof [EQUIVALENT, 0 ms]
        (24) QDP
        (25) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
        (26) YES
    (27) RelADPP
        (28) RelADPReductionPairProof [EQUIVALENT, 33 ms]
        (29) RelADPP
        (30) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (31) YES
    (32) RelADPP
        (33) RelADPReductionPairProof [EQUIVALENT, 42 ms]
        (34) RelADPP
        (35) RelADPCleverAfsProof [SOUND, 4 ms]
        (36) QDP
        (37) QDPOrderProof [EQUIVALENT, 0 ms]
        (38) QDP
        (39) PisEmptyProof [EQUIVALENT, 0 ms]
        (40) YES
    (41) RelADPP
        (42) RelADPReductionPairProof [EQUIVALENT, 38 ms]
        (43) RelADPP
        (44) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (45) YES
    (46) RelADPP
        (47) RelADPReductionPairProof [EQUIVALENT, 49 ms]
        (48) RelADPP
        (49) RelADPCleverAfsProof [SOUND, 4 ms]
        (50) QDP
        (51) QDPOrderProof [EQUIVALENT, 0 ms]
        (52) QDP
        (53) PisEmptyProof [EQUIVALENT, 0 ms]
        (54) YES
    (55) RelADPP
        (56) RelADPReductionPairProof [EQUIVALENT, 49 ms]
        (57) RelADPP
        (58) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (59) TRUE
    (60) RelADPP
        (61) RelADPReductionPairProof [EQUIVALENT, 51 ms]
        (62) RelADPP
        (63) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (64) TRUE
    (65) RelADPP
        (66) RelADPReductionPairProof [EQUIVALENT, 73 ms]
        (67) RelADPP
        (68) RelADPCleverAfsProof [SOUND, 2 ms]
        (69) QDP
        (70) MRRProof [EQUIVALENT, 2 ms]
        (71) QDP
        (72) PisEmptyProof [EQUIVALENT, 0 ms]
        (73) YES
    (74) RelADPP
        (75) RelADPReductionPairProof [EQUIVALENT, 71 ms]
        (76) RelADPP
        (77) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (78) YES
    (79) RelADPP
        (80) RelADPReductionPairProof [EQUIVALENT, 45 ms]
        (81) RelADPP
        (82) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
        (83) QDP
        (84) MRRProof [EQUIVALENT, 3 ms]
        (85) QDP
        (86) DependencyGraphProof [EQUIVALENT, 0 ms]
        (87) TRUE
    (88) RelADPP
        (89) RelADPReductionPairProof [EQUIVALENT, 43 ms]
        (90) RelADPP
        (91) RelADPCleverAfsProof [SOUND, 1 ms]
        (92) QDP
        (93) MRRProof [EQUIVALENT, 2 ms]
        (94) QDP
        (95) PisEmptyProof [EQUIVALENT, 0 ms]
        (96) YES
    (97) RelADPP
        (98) RelADPReductionPairProof [EQUIVALENT, 50 ms]
        (99) RelADPP
        (100) RelADPCleverAfsProof [SOUND, 4 ms]
        (101) QDP
        (102) QDPOrderProof [EQUIVALENT, 4 ms]
        (103) QDP
        (104) PisEmptyProof [EQUIVALENT, 0 ms]
        (105) YES
    (106) RelADPP
        (107) RelADPReductionPairProof [EQUIVALENT, 47 ms]
        (108) RelADPP
        (109) RelADPCleverAfsProof [SOUND, 8 ms]
        (110) QDP
        (111) MRRProof [EQUIVALENT, 2 ms]
        (112) QDP
        (113) PisEmptyProof [EQUIVALENT, 0 ms]
        (114) YES
    (115) RelADPP
        (116) RelADPReductionPairProof [EQUIVALENT, 46 ms]
        (117) RelADPP
        (118) RelADPCleverAfsProof [SOUND, 4 ms]
        (119) QDP
        (120) QDPOrderProof [EQUIVALENT, 0 ms]
        (121) QDP
        (122) PisEmptyProof [EQUIVALENT, 0 ms]
        (123) YES
    (124) RelADPP
        (125) RelADPReductionPairProof [EQUIVALENT, 75 ms]
        (126) RelADPP
        (127) RelADPCleverAfsProof [SOUND, 2 ms]
        (128) QDP
        (129) MRRProof [EQUIVALENT, 5 ms]
        (130) QDP
        (131) PisEmptyProof [EQUIVALENT, 0 ms]
        (132) YES
    (133) RelADPP
        (134) RelADPReductionPairProof [EQUIVALENT, 55 ms]
        (135) RelADPP
        (136) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (137) YES
    (138) RelADPP
        (139) RelADPReductionPairProof [EQUIVALENT, 57 ms]
        (140) RelADPP
        (141) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (142) YES
    (143) RelADPP
        (144) RelADPReductionPairProof [EQUIVALENT, 49 ms]
        (145) RelADPP
        (146) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (147) YES
    (148) RelADPP
        (149) RelADPReductionPairProof [EQUIVALENT, 50 ms]
        (150) RelADPP
        (151) RelADPCleverAfsProof [SOUND, 9 ms]
        (152) QDP
        (153) MRRProof [EQUIVALENT, 3 ms]
        (154) QDP
        (155) RFCMatchBoundsDPProof [EQUIVALENT, 0 ms]
        (156) YES
    (157) RelADPP
        (158) RelADPReductionPairProof [EQUIVALENT, 52 ms]
        (159) RelADPP
        (160) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (161) YES
    (162) RelADPP
        (163) RelADPReductionPairProof [EQUIVALENT, 58 ms]
        (164) RelADPP
        (165) RelADPReductionPairProof [EQUIVALENT, 9 ms]
        (166) RelADPP
        (167) RelADPCleverAfsProof [SOUND, 5 ms]
        (168) QDP
        (169) QDPOrderProof [EQUIVALENT, 0 ms]
        (170) QDP
        (171) PisEmptyProof [EQUIVALENT, 0 ms]
        (172) YES
    (173) RelADPP
        (174) RelADPReductionPairProof [EQUIVALENT, 54 ms]
        (175) RelADPP
        (176) RelADPReductionPairProof [EQUIVALENT, 9 ms]
        (177) RelADPP
        (178) RelADPCleverAfsProof [SOUND, 1 ms]
        (179) QDP
        (180) MRRProof [EQUIVALENT, 1 ms]
        (181) QDP
        (182) PisEmptyProof [EQUIVALENT, 0 ms]
        (183) YES


----------------------------------------

(0)
Obligation:
Relative term rewrite system:
The relative TRS consists of the following R rules:

   b(a(a(x1))) -> c(b(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   c(a(c(x1))) -> c(c(c(x1)))

The relative TRS consists of the following S rules:

   a(a(b(x1))) -> b(a(b(x1)))
   c(a(a(x1))) -> c(a(a(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(1) RelTRS S Cleaner (EQUIVALENT)
We have deleted all rules from S that have the shape t -> t:

   c(a(a(x1))) -> c(a(a(x1)))


----------------------------------------

(2)
Obligation:
Relative term rewrite system:
The relative TRS consists of the following R rules:

   b(a(a(x1))) -> c(b(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   c(a(c(x1))) -> c(c(c(x1)))

The relative TRS consists of the following S rules:

   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(3) RelTRStoRelADPProof (EQUIVALENT)


We upgrade the RelTRS problem to an equivalent Relative ADP Problem [IJCAR24].

----------------------------------------

(4)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> C(b(b(x1)))
   b(a(a(x1))) -> c(B(b(x1)))
   b(a(a(x1))) -> c(b(B(x1)))
   a(a(a(x1))) -> A(c(c(x1)))
   a(a(a(x1))) -> a(C(c(x1)))
   a(a(a(x1))) -> a(c(C(x1)))
   a(c(b(x1))) -> A(a(b(x1)))
   a(c(b(x1))) -> a(A(b(x1)))
   a(c(b(x1))) -> a(a(B(x1)))
   c(a(c(x1))) -> C(c(c(x1)))
   c(a(c(x1))) -> c(C(c(x1)))
   c(a(c(x1))) -> c(c(C(x1)))

and relative ADPs:

   a(a(b(x1))) -> B(A(b(x1)))
   a(a(b(x1))) -> B(a(B(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   c(c(a(x1))) -> C(b(B(x1)))
   c(c(a(x1))) -> c(B(B(x1)))


----------------------------------------

(5) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  21 Lassos,
Result: This relative DT problem is equivalent to 23 subproblems.

----------------------------------------

(6)
Complex Obligation (AND)

----------------------------------------

(7)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> c(B(b(x1)))
   c(a(c(x1))) -> c(C(c(x1)))
   b(a(a(x1))) -> C(b(b(x1)))
   b(a(a(x1))) -> c(b(B(x1)))
   c(a(c(x1))) -> C(c(c(x1)))
   c(a(c(x1))) -> c(c(C(x1)))

and relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   c(c(a(x1))) -> c(B(B(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))


----------------------------------------

(8) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(a(x1))) -> c(B(b(x1)))
   c(a(c(x1))) -> c(C(c(x1)))
   b(a(a(x1))) -> C(b(b(x1)))
   b(a(a(x1))) -> c(b(B(x1)))
   c(a(c(x1))) -> c(c(C(x1)))

Relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   c(c(a(x1))) -> c(B(B(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(c(x1))) -> C(c(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 3*x_1 + 3*x_1^2
   POL(B(x_1)) = x_1
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = x_1
   POL(c(x_1)) = 2 + 2*x_1

----------------------------------------

(9)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(c(x1))) -> C(c(c(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(10) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

c(x1)  =  x1

b(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, a_1]

Status: C_1: multiset status
a_1: multiset status


----------------------------------------

(11)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(c0(x1))) -> C0(c0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(c0(x1))) -> c0(c0(c0(x1)))
   a0(a0(a0(x1))) -> a0(c0(c0(x1)))
   a0(c0(b0(x1))) -> a0(a0(b0(x1)))
   b0(a0(a0(x1))) -> c0(b0(b0(x1)))
   a0(a0(b0(x1))) -> b0(a0(b0(x1)))
   c0(c0(a0(x1))) -> c0(b0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(12) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.


Strictly oriented rules of the TRS R:

   b0(a0(a0(x1))) -> c0(b0(b0(x1)))
   a0(a0(b0(x1))) -> b0(a0(b0(x1)))
   c0(c0(a0(x1))) -> c0(b0(b0(x1)))

Used ordering: Polynomial interpretation [POLO]:

   POL(C0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(13)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(c0(x1))) -> C0(c0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(c0(x1))) -> c0(c0(c0(x1)))
   a0(a0(a0(x1))) -> a0(c0(c0(x1)))
   a0(c0(b0(x1))) -> a0(a0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(14) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 1. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c0(a0(c0(x1))) -> c0(c0(c0(x1)))
   a0(a0(a0(x1))) -> a0(c0(c0(x1)))
   a0(c0(b0(x1))) -> a0(a0(b0(x1)))
   C0(a0(c0(x1))) -> C0(c0(c0(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
1600, 1601, 1602, 1603, 1604, 1605, 1606, 1607

Node 1600 is start node and node 1601 is final node.

Those nodes are connected through the following edges:

* 1600 to 1602 labelled c0_1(0), a0_1(0), C0_1(0)* 1600 to 1604 labelled a0_1(0)* 1601 to 1601 labelled #_1(0)* 1602 to 1603 labelled c0_1(0)* 1603 to 1601 labelled c0_1(0)* 1603 to 1606 labelled c0_1(1)* 1604 to 1605 labelled a0_1(0)* 1605 to 1601 labelled b0_1(0)* 1606 to 1607 labelled c0_1(1)* 1607 to 1601 labelled c0_1(1)* 1607 to 1606 labelled c0_1(1)


----------------------------------------

(15)
YES

----------------------------------------

(16)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(c(c(x1)))
   a(c(b(x1))) -> a(A(b(x1)))
   a(c(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(17) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(c(b(x1))) -> a(A(b(x1)))

Relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(c(c(x1)))
   a(c(b(x1))) -> A(a(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 0
   POL(C(x_1)) = 2 + 3*x_1 + 3*x_1^2
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(18)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(c(c(x1)))
   a(c(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(19) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(20)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(a(a(x1))) -> A(c(c(x1)))
   A(c(b(x1))) -> A(a(b(x1)))

The TRS R consists of the following rules:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(21) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.


Strictly oriented rules of the TRS R:

   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))

Used ordering: Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2*x_1
   POL(c(x_1)) = 2 + 2*x_1


----------------------------------------

(22)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(a(a(x1))) -> A(c(c(x1)))
   A(c(b(x1))) -> A(a(b(x1)))

The TRS R consists of the following rules:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(23) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(24)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(a(a(x1))) -> A(c(c(x1)))

The TRS R consists of the following rules:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(25) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 1. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   A(a(a(x1))) -> A(c(c(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661

Node 1654 is start node and node 1655 is final node.

Those nodes are connected through the following edges:

* 1654 to 1656 labelled c_1(0), a_1(0), A_1(0)* 1654 to 1658 labelled a_1(0)* 1655 to 1655 labelled #_1(0)* 1656 to 1657 labelled c_1(0)* 1657 to 1655 labelled c_1(0)* 1657 to 1660 labelled c_1(1)* 1658 to 1659 labelled a_1(0)* 1659 to 1655 labelled b_1(0)* 1660 to 1661 labelled c_1(1)* 1661 to 1655 labelled c_1(1)* 1661 to 1660 labelled c_1(1)


----------------------------------------

(26)
YES

----------------------------------------

(27)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(c(C(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(28) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(c(C(x1)))

Relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 0
   POL(C(x_1)) = 1 + 2*x_1
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(29)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(30) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(31)
YES

----------------------------------------

(32)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> c(B(b(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> B(a(B(x1)))


----------------------------------------

(33) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> B(a(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(a(x1))) -> c(B(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 0
   POL(C(x_1)) = 1 + 3*x_1 + 3*x_1^2
   POL(a(x_1)) = 2
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(34)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> c(B(b(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(35) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  B(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: B_1 > [a_1, b, c]

Status: B_1: [1]
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(36)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(a0(a0(x1))) -> B0(b)

The TRS R consists of the following rules:

   c -> c
   a0(a0(a0(x1))) -> a0(c)
   a0(c) -> a0(a0(b))
   b -> c
   a0(a0(b)) -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(37) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   B0(a0(a0(x1))) -> B0(b)
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( c ) = 0
POL( a0_1(x_1) ) = 2
POL( b ) = 0
POL( B0_1(x_1) ) = max{0, 2x_1 - 2}

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   c -> c
   a0(a0(a0(x1))) -> a0(c)
   a0(c) -> a0(a0(b))
   b -> c
   a0(a0(b)) -> b


----------------------------------------

(38)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a0(a0(a0(x1))) -> a0(c)
   a0(c) -> a0(a0(b))
   b -> c
   a0(a0(b)) -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(39) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(40)
YES

----------------------------------------

(41)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> C(b(b(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(42) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(a(x1))) -> C(b(b(x1)))

Relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1
   POL(B(x_1)) = 3
   POL(C(x_1)) = 1
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 3 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(43)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(44) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(45)
YES

----------------------------------------

(46)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> c(B(b(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(47) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(a(x1))) -> c(B(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 0
   POL(C(x_1)) = 3 + 3*x_1 + x_1^2
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(48)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> c(B(b(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(49) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  B(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: B_1 > [a_1, b, c]

Status: B_1: [1]
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(50)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(a0(a0(x1))) -> B0(b)

The TRS R consists of the following rules:

   c -> c
   a0(a0(a0(x1))) -> a0(c)
   a0(c) -> a0(a0(b))
   b -> c
   a0(a0(b)) -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(51) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   B0(a0(a0(x1))) -> B0(b)
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
B0(x1)  =  x1

a0(x1)  =  a0

b  =  b

c  =  c


Knuth-Bendix order [KBO] with precedence:a0 > b > c

and weight map:

   a0=1
   b=1
   c=1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   c -> c
   a0(a0(a0(x1))) -> a0(c)
   a0(c) -> a0(a0(b))
   b -> c
   a0(a0(b)) -> b


----------------------------------------

(52)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a0(a0(a0(x1))) -> a0(c)
   a0(c) -> a0(a0(b))
   b -> c
   a0(a0(b)) -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(53) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(54)
YES

----------------------------------------

(55)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> a(a(B(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(56) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(b(x1))) -> a(a(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 0
   POL(C(x_1)) = 3 + 3*x_1 + 2*x_1^2
   POL(a(x_1)) = 3
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(57)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> a(a(B(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(58) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(59)
TRUE

----------------------------------------

(60)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> C(b(b(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> B(a(B(x1)))


----------------------------------------

(61) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> B(a(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(a(x1))) -> C(b(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 2*x_1
   POL(B(x_1)) = 0
   POL(C(x_1)) = 0
   POL(a(x_1)) = 2
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(62)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> C(b(b(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(63) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(64)
TRUE

----------------------------------------

(65)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> c(b(B(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(66) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(a(x1))) -> c(b(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 0
   POL(C(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(67)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> c(b(B(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(68) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: trivial

Status: a_1: multiset status


----------------------------------------

(69)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(a0(a0(x1))) -> B0(x1)

The TRS R consists of the following rules:

   c0(a0(c0(x1))) -> c0(c0(c0(x1)))
   a0(a0(a0(x1))) -> a0(c0(c0(x1)))
   a0(c0(b0(x1))) -> a0(a0(b0(x1)))
   b0(a0(a0(x1))) -> c0(b0(b0(x1)))
   a0(a0(b0(x1))) -> b0(a0(b0(x1)))
   c0(c0(a0(x1))) -> c0(b0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(70) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(a0(a0(x1))) -> B0(x1)

Strictly oriented rules of the TRS R:

   b0(a0(a0(x1))) -> c0(b0(b0(x1)))
   a0(a0(b0(x1))) -> b0(a0(b0(x1)))
   c0(c0(a0(x1))) -> c0(b0(b0(x1)))

Used ordering: Polynomial interpretation [POLO]:

   POL(B0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(71)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c0(a0(c0(x1))) -> c0(c0(c0(x1)))
   a0(a0(a0(x1))) -> a0(c0(c0(x1)))
   a0(c0(b0(x1))) -> a0(a0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(72) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(73)
YES

----------------------------------------

(74)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> a(C(c(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(75) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   a(a(a(x1))) -> a(C(c(x1)))

Relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(B(x_1)) = 0
   POL(C(x_1)) = 2*x_1
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(76)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(77) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(78)
YES

----------------------------------------

(79)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(80) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(b(x1))) -> A(a(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1
   POL(B(x_1)) = 0
   POL(C(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(81)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> A(a(b(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(82) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(83)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(b(x1))) -> A(a(b(x1)))

The TRS R consists of the following rules:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(84) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.


Strictly oriented rules of the TRS R:

   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))

Used ordering: Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = x_1
   POL(c(x_1)) = 1 + 2*x_1


----------------------------------------

(85)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A(c(b(x1))) -> A(a(b(x1)))

The TRS R consists of the following rules:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(86) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 1 less node.
----------------------------------------

(87)
TRUE

----------------------------------------

(88)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> c(b(B(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> B(a(B(x1)))


----------------------------------------

(89) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> B(a(B(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(a(x1))) -> c(b(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 3*x_1
   POL(B(x_1)) = 0
   POL(C(x_1)) = 1 + 3*x_1 + 3*x_1^2
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 2 + x_1

----------------------------------------

(90)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> c(b(B(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(91) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: trivial

Status: a_1: multiset status


----------------------------------------

(92)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(a0(a0(x1))) -> B0(x1)

The TRS R consists of the following rules:

   c0(a0(c0(x1))) -> c0(c0(c0(x1)))
   a0(a0(a0(x1))) -> a0(c0(c0(x1)))
   a0(c0(b0(x1))) -> a0(a0(b0(x1)))
   b0(a0(a0(x1))) -> c0(b0(b0(x1)))
   a0(a0(b0(x1))) -> b0(a0(b0(x1)))
   c0(c0(a0(x1))) -> c0(b0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(93) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(a0(a0(x1))) -> B0(x1)

Strictly oriented rules of the TRS R:

   b0(a0(a0(x1))) -> c0(b0(b0(x1)))
   a0(a0(b0(x1))) -> b0(a0(b0(x1)))
   c0(c0(a0(x1))) -> c0(b0(b0(x1)))

Used ordering: Polynomial interpretation [POLO]:

   POL(B0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(94)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c0(a0(c0(x1))) -> c0(c0(c0(x1)))
   a0(a0(a0(x1))) -> a0(c0(c0(x1)))
   a0(c0(b0(x1))) -> a0(a0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(95) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(96)
YES

----------------------------------------

(97)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(c(c(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(98) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(a(a(x1))) -> A(c(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 2*x_1
   POL(B(x_1)) = 0
   POL(C(x_1)) = 3*x_1 + x_1^2
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(99)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(a(a(x1))) -> A(c(c(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(100) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
A(x1)  =  A(x1)

a(x1)  =  a(x1)

c(x1)  =  x1

b(x1)  =  b


Recursive path order with status [RPO].
Quasi-Precedence: [a_1, b]

Status: A_1: multiset status
a_1: multiset status
b: multiset status


----------------------------------------

(101)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(a0(a0(x1))) -> A0(c0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(c0(x1))) -> c0(c0(c0(x1)))
   a0(a0(a0(x1))) -> a0(c0(c0(x1)))
   a0(c0(b)) -> a0(a0(b))
   b -> c0(b)
   a0(a0(b)) -> b
   c0(c0(a0(x1))) -> c0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(102) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   A0(a0(a0(x1))) -> A0(c0(c0(x1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
A0(x1)  =  x1

a0(x1)  =  a0

c0(x1)  =  c0

b  =  b


Knuth-Bendix order [KBO] with precedence:a0 > b > c0

and weight map:

   a0=1
   c0=1
   b=1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   c0(a0(c0(x1))) -> c0(c0(c0(x1)))
   a0(a0(a0(x1))) -> a0(c0(c0(x1)))
   a0(c0(b)) -> a0(a0(b))
   b -> c0(b)
   a0(a0(b)) -> b
   c0(c0(a0(x1))) -> c0(b)


----------------------------------------

(103)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c0(a0(c0(x1))) -> c0(c0(c0(x1)))
   a0(a0(a0(x1))) -> a0(c0(c0(x1)))
   a0(c0(b)) -> a0(a0(b))
   b -> c0(b)
   a0(a0(b)) -> b
   c0(c0(a0(x1))) -> c0(b)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(104) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(105)
YES

----------------------------------------

(106)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(107) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(b(x1))) -> B(A(b(x1)))
   a(a(b(x1))) -> b(A(B(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   a(c(b(x1))) -> a(A(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 2*x_1
   POL(B(x_1)) = 0
   POL(C(x_1)) = 3 + 3*x_1 + 2*x_1^2
   POL(a(x_1)) = 3
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(108)
Obligation:
Relative ADP Problem with
absolute ADPs:

   a(c(b(x1))) -> a(A(b(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(109) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
A_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Recursive path order with status [RPO].
Quasi-Precedence: A_1 > b_1
[c_1, a_1] > b_1

Status: A_1: [1]
c_1: multiset status
b_1: multiset status
a_1: multiset status


----------------------------------------

(110)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   A0(c0(b0(x1))) -> A0(b0(x1))

The TRS R consists of the following rules:

   c0(a0(c0(x1))) -> c0(c0(c0(x1)))
   a0(a0(a0(x1))) -> a0(c0(c0(x1)))
   a0(c0(b0(x1))) -> a0(a0(b0(x1)))
   b0(a0(a0(x1))) -> c0(b0(b0(x1)))
   a0(a0(b0(x1))) -> b0(a0(b0(x1)))
   c0(c0(a0(x1))) -> c0(b0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(111) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   A0(c0(b0(x1))) -> A0(b0(x1))

Strictly oriented rules of the TRS R:

   b0(a0(a0(x1))) -> c0(b0(b0(x1)))
   a0(a0(b0(x1))) -> b0(a0(b0(x1)))
   c0(c0(a0(x1))) -> c0(b0(b0(x1)))

Used ordering: Polynomial interpretation [POLO]:

   POL(A0(x_1)) = x_1
   POL(a0(x_1)) = 2 + 2*x_1
   POL(b0(x_1)) = 1 + x_1
   POL(c0(x_1)) = 2 + 2*x_1


----------------------------------------

(112)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c0(a0(c0(x1))) -> c0(c0(c0(x1)))
   a0(a0(a0(x1))) -> a0(c0(c0(x1)))
   a0(c0(b0(x1))) -> a0(a0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(113) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(114)
YES

----------------------------------------

(115)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> c(B(b(x1)))

and relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(a(c(x1))) -> c(c(c(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(116) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(a(c(x1))) -> c(c(c(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(a(x1))) -> c(B(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(B(x_1)) = 0
   POL(C(x_1)) = 3*x_1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(117)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> c(B(b(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(118) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  B(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: B_1 > [a_1, b, c]

Status: B_1: [1]
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(119)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(a0(a0(x1))) -> B0(b)

The TRS R consists of the following rules:

   c -> c
   a0(a0(a0(x1))) -> a0(c)
   a0(c) -> a0(a0(b))
   b -> c
   a0(a0(b)) -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(120) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   B0(a0(a0(x1))) -> B0(b)
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
B0(x1)  =  x1

a0(x1)  =  a0

b  =  b

c  =  c


Knuth-Bendix order [KBO] with precedence:a0 > b > c

and weight map:

   a0=1
   b=1
   c=1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   c -> c
   a0(a0(a0(x1))) -> a0(c)
   a0(c) -> a0(a0(b))
   b -> c
   a0(a0(b)) -> b


----------------------------------------

(121)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a0(a0(a0(x1))) -> a0(c)
   a0(c) -> a0(a0(b))
   b -> c
   a0(a0(b)) -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(122) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(123)
YES

----------------------------------------

(124)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> c(b(B(x1)))

and relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(a(c(x1))) -> c(c(c(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(125) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(a(c(x1))) -> c(c(c(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(a(x1))) -> c(b(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(B(x_1)) = 0
   POL(C(x_1)) = 3*x_1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(126)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> c(b(B(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(127) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: trivial

Status: a_1: multiset status


----------------------------------------

(128)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(a0(a0(x1))) -> B0(x1)

The TRS R consists of the following rules:

   c0(a0(c0(x1))) -> c0(c0(c0(x1)))
   a0(a0(a0(x1))) -> a0(c0(c0(x1)))
   a0(c0(b0(x1))) -> a0(a0(b0(x1)))
   b0(a0(a0(x1))) -> c0(b0(b0(x1)))
   a0(a0(b0(x1))) -> b0(a0(b0(x1)))
   c0(c0(a0(x1))) -> c0(b0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(129) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(a0(a0(x1))) -> B0(x1)

Strictly oriented rules of the TRS R:

   b0(a0(a0(x1))) -> c0(b0(b0(x1)))
   a0(a0(b0(x1))) -> b0(a0(b0(x1)))
   c0(c0(a0(x1))) -> c0(b0(b0(x1)))

Used ordering: Polynomial interpretation [POLO]:

   POL(B0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(130)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c0(a0(c0(x1))) -> c0(c0(c0(x1)))
   a0(a0(a0(x1))) -> a0(c0(c0(x1)))
   a0(c0(b0(x1))) -> a0(a0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(131) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(132)
YES

----------------------------------------

(133)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(c(x1))) -> c(c(C(x1)))

and relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(a(c(x1))) -> c(c(c(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(134) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(a(c(x1))) -> c(c(C(x1)))

Relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(a(c(x1))) -> c(c(c(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 3*x_1 + 3*x_1^2
   POL(B(x_1)) = 0
   POL(C(x_1)) = 3 + x_1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(135)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(136) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(137)
YES

----------------------------------------

(138)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(c(x1))) -> c(C(c(x1)))

and relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(a(c(x1))) -> c(c(c(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(139) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   c(a(c(x1))) -> c(C(c(x1)))

Relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(a(c(x1))) -> c(c(c(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1 + 3*x_1 + 3*x_1^2
   POL(B(x_1)) = 0
   POL(C(x_1)) = 1 + x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = x_1
   POL(c(x_1)) = 2 + x_1

----------------------------------------

(140)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(141) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(142)
YES

----------------------------------------

(143)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> C(b(b(x1)))

and relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(a(c(x1))) -> c(c(c(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(144) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(a(x1))) -> C(b(b(x1)))

Relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(a(c(x1))) -> c(c(c(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 3*x_1 + 3*x_1^2
   POL(B(x_1)) = 2*x_1
   POL(C(x_1)) = x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(145)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(146) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(147)
YES

----------------------------------------

(148)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(c(x1))) -> C(c(c(x1)))

and relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(a(c(x1))) -> c(c(c(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(149) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(a(c(x1))) -> c(c(c(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   c(a(c(x1))) -> C(c(c(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(B(x_1)) = 0
   POL(C(x_1)) = 3 + x_1
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = x_1
   POL(c(x_1)) = 3 + x_1

----------------------------------------

(150)
Obligation:
Relative ADP Problem with
absolute ADPs:

   c(a(c(x1))) -> C(c(c(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(151) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
C_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
C(x1)  =  C(x1)

a(x1)  =  a(x1)

c(x1)  =  x1

b(x1)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: [C_1, a_1]

Status: C_1: multiset status
a_1: multiset status


----------------------------------------

(152)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(c0(x1))) -> C0(c0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(c0(x1))) -> c0(c0(c0(x1)))
   a0(a0(a0(x1))) -> a0(c0(c0(x1)))
   a0(c0(b0(x1))) -> a0(a0(b0(x1)))
   b0(a0(a0(x1))) -> c0(b0(b0(x1)))
   a0(a0(b0(x1))) -> b0(a0(b0(x1)))
   c0(c0(a0(x1))) -> c0(b0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(153) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.


Strictly oriented rules of the TRS R:

   b0(a0(a0(x1))) -> c0(b0(b0(x1)))
   a0(a0(b0(x1))) -> b0(a0(b0(x1)))
   c0(c0(a0(x1))) -> c0(b0(b0(x1)))

Used ordering: Polynomial interpretation [POLO]:

   POL(C0(x_1)) = 2*x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(154)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   C0(a0(c0(x1))) -> C0(c0(c0(x1)))

The TRS R consists of the following rules:

   c0(a0(c0(x1))) -> c0(c0(c0(x1)))
   a0(a0(a0(x1))) -> a0(c0(c0(x1)))
   a0(c0(b0(x1))) -> a0(a0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(155) RFCMatchBoundsDPProof (EQUIVALENT)
Termination of the TRS P cup R can be shown by a matchbound [MATCHBOUNDS1,MATCHBOUNDS2] of 1. This implies finiteness of the given DP problem.
The following rules (P cup R) were used to construct the certificate:

   c0(a0(c0(x1))) -> c0(c0(c0(x1)))
   a0(a0(a0(x1))) -> a0(c0(c0(x1)))
   a0(c0(b0(x1))) -> a0(a0(b0(x1)))
   C0(a0(c0(x1))) -> C0(c0(c0(x1)))

The certificate found is represented by the following graph.
The certificate consists of the following enumerated nodes:
1704, 1705, 1706, 1707, 1708, 1709, 1710, 1711

Node 1704 is start node and node 1705 is final node.

Those nodes are connected through the following edges:

* 1704 to 1706 labelled c0_1(0), a0_1(0), C0_1(0)* 1704 to 1708 labelled a0_1(0)* 1705 to 1705 labelled #_1(0)* 1706 to 1707 labelled c0_1(0)* 1707 to 1705 labelled c0_1(0)* 1707 to 1710 labelled c0_1(1)* 1708 to 1709 labelled a0_1(0)* 1709 to 1705 labelled b0_1(0)* 1710 to 1711 labelled c0_1(1)* 1711 to 1705 labelled c0_1(1)* 1711 to 1710 labelled c0_1(1)


----------------------------------------

(156)
YES

----------------------------------------

(157)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> C(b(b(x1)))

and relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(a(c(x1))) -> c(c(c(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   c(c(a(x1))) -> c(B(B(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))


----------------------------------------

(158) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(a(a(x1))) -> C(b(b(x1)))

Relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(a(c(x1))) -> c(c(c(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   c(c(a(x1))) -> c(B(B(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(B(x_1)) = x_1
   POL(C(x_1)) = 2 + 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = x_1
   POL(c(x_1)) = 1 + 2*x_1

----------------------------------------

(159)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(160) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(161)
YES

----------------------------------------

(162)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> c(B(b(x1)))

and relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(a(c(x1))) -> c(c(c(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   c(c(a(x1))) -> c(B(B(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))


----------------------------------------

(163) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   c(c(a(x1))) -> c(B(B(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(a(x1))) -> c(B(b(x1)))

Relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(c(a(x1))) -> C(B(b(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(B(x_1)) = 0
   POL(C(x_1)) = 2
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(164)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> c(B(b(x1)))

and relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(a(c(x1))) -> c(c(c(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(165) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(a(c(x1))) -> c(c(c(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(a(x1))) -> c(B(b(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(B(x_1)) = 0
   POL(C(x_1)) = 3*x_1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(166)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> c(B(b(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(167) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 0
c_1 = 0
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  B(x1)

a(x1)  =  a(x1)

b(x1)  =  b

c(x1)  =  c


Recursive path order with status [RPO].
Quasi-Precedence: B_1 > [a_1, b, c]

Status: B_1: [1]
a_1: multiset status
b: multiset status
c: multiset status


----------------------------------------

(168)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(a0(a0(x1))) -> B0(b)

The TRS R consists of the following rules:

   c -> c
   a0(a0(a0(x1))) -> a0(c)
   a0(c) -> a0(a0(b))
   b -> c
   a0(a0(b)) -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(169) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   B0(a0(a0(x1))) -> B0(b)
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
B0(x1)  =  x1

a0(x1)  =  a0

b  =  b

c  =  c


Knuth-Bendix order [KBO] with precedence:a0 > b > c

and weight map:

   a0=1
   b=1
   c=1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   c -> c
   a0(a0(a0(x1))) -> a0(c)
   a0(c) -> a0(a0(b))
   b -> c
   a0(a0(b)) -> b


----------------------------------------

(170)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c -> c
   a0(a0(a0(x1))) -> a0(c)
   a0(c) -> a0(a0(b))
   b -> c
   a0(a0(b)) -> b

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(171) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(172)
YES

----------------------------------------

(173)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> c(b(B(x1)))

and relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(a(c(x1))) -> c(c(c(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   c(c(a(x1))) -> c(B(B(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))


----------------------------------------

(174) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   c(c(a(x1))) -> c(B(B(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(a(x1))) -> c(b(B(x1)))

Relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(c(a(x1))) -> C(B(b(x1)))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(B(x_1)) = 0
   POL(C(x_1)) = 2
   POL(a(x_1)) = 0
   POL(b(x_1)) = 0
   POL(c(x_1)) = 0

----------------------------------------

(175)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> c(b(B(x1)))

and relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(a(c(x1))) -> c(c(c(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(176) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   c(c(a(x1))) -> C(b(B(x1)))
   c(a(c(x1))) -> c(c(c(x1)))
   c(c(a(x1))) -> C(B(b(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(a(a(x1))) -> c(b(B(x1)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(B(x_1)) = 0
   POL(C(x_1)) = 3*x_1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = x_1
   POL(c(x_1)) = 1 + x_1

----------------------------------------

(177)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(a(a(x1))) -> c(b(B(x1)))

and relative ADPs:

   c(a(c(x1))) -> c(c(c(x1)))
   a(a(a(x1))) -> a(c(c(x1)))
   a(c(b(x1))) -> a(a(b(x1)))
   b(a(a(x1))) -> c(b(b(x1)))
   a(a(b(x1))) -> b(a(b(x1)))
   c(c(a(x1))) -> c(b(b(x1)))


----------------------------------------

(178) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:a_1 = 
b_1 = 
c_1 = 
B_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
B(x1)  =  x1

a(x1)  =  a(x1)


Recursive path order with status [RPO].
Quasi-Precedence: trivial

Status: a_1: multiset status


----------------------------------------

(179)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   B0(a0(a0(x1))) -> B0(x1)

The TRS R consists of the following rules:

   c0(a0(c0(x1))) -> c0(c0(c0(x1)))
   a0(a0(a0(x1))) -> a0(c0(c0(x1)))
   a0(c0(b0(x1))) -> a0(a0(b0(x1)))
   b0(a0(a0(x1))) -> c0(b0(b0(x1)))
   a0(a0(b0(x1))) -> b0(a0(b0(x1)))
   c0(c0(a0(x1))) -> c0(b0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(180) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   B0(a0(a0(x1))) -> B0(x1)

Strictly oriented rules of the TRS R:

   b0(a0(a0(x1))) -> c0(b0(b0(x1)))
   a0(a0(b0(x1))) -> b0(a0(b0(x1)))
   c0(c0(a0(x1))) -> c0(b0(b0(x1)))

Used ordering: Polynomial interpretation [POLO]:

   POL(B0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = 2*x_1
   POL(c0(x_1)) = 1 + 2*x_1


----------------------------------------

(181)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   c0(a0(c0(x1))) -> c0(c0(c0(x1)))
   a0(a0(a0(x1))) -> a0(c0(c0(x1)))
   a0(c0(b0(x1))) -> a0(a0(b0(x1)))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(182) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(183)
YES
