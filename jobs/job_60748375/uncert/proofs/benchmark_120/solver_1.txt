SAST
proof of /home/ff862203/input_sK32mi1fkO.ari
# AProVE Commit ID: 1c9e2a6453f9f0dca490585733f1cff3767d3e54 jan-christoph 20250828 unpublished


Complexity of the given CpxPTRS could be proven:

(0) CpxPTRS
(1) CpxPTRS_ToInnermostProof [BOTH BOUNDS(ID, ID), 0 ms]
(2) CpxPTRS
(3) CpxPTRS_DerivationToRuntimeComplexityProof [UNSOUND LOWER BOUND(ID)SOUND UPPER BOUND(ID), 0 ms]
(4) CpxPTRS
(5) CpxPTRS_ToPQTRSProof [BOTH BOUNDS(ID, ID), 0 ms]
(6) PQTRS
(7) CpxPQTRS_ToADPProblemProof [BOTH BOUNDS(ID, ID), 18 ms]
(8) ADP
(9) CpxADP_SCCSplitProof [UPPER BOUND(ID), 1 ms]
(10) MAX
    (11) ADP
        (12) CpxADP_UsableTermsProof [UPPER BOUND(ID), 1 ms]
        (13) ADP
        (14) CpxADP_UsableRulesProof [BOTH BOUNDS(ID, ID), 0 ms]
        (15) ADP
        (16) CpxADP_ProbabilityRemovalProof [UPPER BOUND(ID), 0 ms]
        (17) CdtProblem
        (18) CdtLeafRemovalProof [ComplexityIfPolyImplication, 0 ms]
        (19) CdtProblem
        (20) CdtToCpxRelTrsProof [BOTH BOUNDS(ID, ID), 0 ms]
        (21) CpxTRS
        (22) RelTrsToTrsProof [UPPER BOUND(ID), 0 ms]
        (23) CpxTRS
        (24) CpxTrsMatchBoundsProof [FINISHED, 0 ms]
        (25) BOUNDS(1, n^1)
    (26) ADP
        (27) CpxADP_UsableTermsProof [UPPER BOUND(ID), 0 ms]
        (28) ADP
        (29) CpxADP_UsableRulesProof [BOTH BOUNDS(ID, ID), 0 ms]
        (30) ADP
        (31) CpxADP_ReductionPairProof [UPPER BOUND(ADD(EXP)), 58 ms]
        (32) ADP
        (33) SisEmptyProof [FINISHED, 0 ms]
        (34) BOUNDS(1, 1)
    (35) ADP
        (36) CpxADP_UsableTermsProof [UPPER BOUND(ID), 0 ms]
        (37) ADP
        (38) CpxADP_UsableRulesProof [BOTH BOUNDS(ID, ID), 0 ms]
        (39) ADP
        (40) CpxADP_ReductionPairProof [UPPER BOUND(ADD(EXP)), 68 ms]
        (41) ADP
        (42) CpxADP_KnowledgePropagationProof [BOTH BOUNDS(ID, ID), 0 ms]
        (43) ADP
        (44) SisEmptyProof [FINISHED, 0 ms]
        (45) BOUNDS(1, 1)
    (46) ADP
        (47) CpxADP_UsableTermsProof [UPPER BOUND(ID), 0 ms]
        (48) ADP
        (49) CpxADP_UsableRulesProof [BOTH BOUNDS(ID, ID), 0 ms]
        (50) ADP
        (51) CpxADP_ReductionPairProof [UPPER BOUND(ADD(EXP)), 80 ms]
        (52) ADP
        (53) CpxADP_KnowledgePropagationProof [BOTH BOUNDS(ID, ID), 0 ms]
        (54) ADP
        (55) SisEmptyProof [FINISHED, 0 ms]
        (56) BOUNDS(1, 1)


----------------------------------------

(0)
Obligation:
Probabilistic term rewrite system:
The TRS has the following probabilistic rules:

   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateOOI -> 1 : s(s(s(s(O))))
   stateIII -> 1 : O
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateOOO -> 1 : s(s(s(s(s(O)))))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateIOO -> 1 : s(s(O))
   stateIOI -> 1 : s(O)
   walk(s(s(s(O)))) -> 1 : walk(dice)
   stateOII -> 1 : s(s(s(O)))
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI

and uses the full rewrite strategy.

----------------------------------------

(1) CpxPTRS_ToInnermostProof (BOTH BOUNDS(ID, ID))
Switched from non-innermost to innermost rewriting[FoSSaCS24].

The system is non-overlapping, left-linear and right-linear, so its complexity is the same as its innermost complexity.


----------------------------------------

(2)
Obligation:
Probabilistic term rewrite system:
The TRS has the following probabilistic rules:

   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateOOI -> 1 : s(s(s(s(O))))
   stateIII -> 1 : O
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateOOO -> 1 : s(s(s(s(s(O)))))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateIOO -> 1 : s(s(O))
   stateIOI -> 1 : s(O)
   walk(s(s(s(O)))) -> 1 : walk(dice)
   stateOII -> 1 : s(s(s(O)))
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI

and uses the innermost rewrite strategy.

----------------------------------------

(3) CpxPTRS_DerivationToRuntimeComplexityProof (UNSOUND LOWER BOUND(ID)SOUND UPPER BOUND(ID))
The following rules have been added to R to convert the given derivational complexity problem to a runtime complexity problem:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(cons_dice) -> 1 : dice
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   encode_dice -> 1 : dice
   encode_stateO -> 1 : stateO
   encode_stateI -> 1 : stateI
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_O -> 1 : O
   encode_stateOO -> 1 : stateOO
   encode_stateOI -> 1 : stateOI
   encode_stateOII -> 1 : stateOII
   encode_stateOOI -> 1 : stateOOI
   encode_stateII -> 1 : stateII
   encode_stateIII -> 1 : stateIII
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encode_stateIOO -> 1 : stateIOO
   encode_stateOOO -> 1 : stateOOO


----------------------------------------

(4)
Obligation:
Probabilistic term rewrite system:
The TRS has the following probabilistic rules:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(cons_dice) -> 1 : dice
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   encode_dice -> 1 : dice
   encode_stateO -> 1 : stateO
   encode_stateI -> 1 : stateI
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_O -> 1 : O
   encode_stateOO -> 1 : stateOO
   encode_stateOI -> 1 : stateOI
   encode_stateOII -> 1 : stateOII
   encode_stateOOI -> 1 : stateOOI
   encode_stateII -> 1 : stateII
   encode_stateIII -> 1 : stateIII
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encode_stateIOO -> 1 : stateIOO
   encode_stateOOO -> 1 : stateOOO
   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateOOI -> 1 : s(s(s(s(O))))
   stateIII -> 1 : O
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateOOO -> 1 : s(s(s(s(s(O)))))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateIOO -> 1 : s(s(O))
   stateIOI -> 1 : s(O)
   walk(s(s(s(O)))) -> 1 : walk(dice)
   stateOII -> 1 : s(s(s(O)))
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI

and uses the innermost rewrite strategy.

----------------------------------------

(5) CpxPTRS_ToPQTRSProof (BOTH BOUNDS(ID, ID))
Transformed PTRS into PQTRS. Q is:
   encArg(s(x_1)), encArg(O), encArg(cons_dice), encArg(cons_walk(x_1)), encArg(cons_stateO), encArg(cons_stateOII), encArg(cons_stateOO), encArg(cons_stateII), encArg(cons_stateIO), encArg(cons_stateIOO), encArg(cons_stateIOI), encArg(cons_stateI), encArg(cons_stateOOO), encArg(cons_stateOOI), encArg(cons_stateOI), encArg(cons_stateIII), encode_dice, encode_stateO, encode_stateI, encode_walk(x_1), encode_s(x_1), encode_O, encode_stateOO, encode_stateOI, encode_stateOII, encode_stateOOI, encode_stateII, encode_stateIII, encode_stateIO, encode_stateIOI, encode_stateIOO, encode_stateOOO, dice, stateIO, stateOOI, stateIII, stateOO, stateOI, stateOOO, stateO, stateIOO, stateIOI, walk(s(s(s(O)))), stateOII, stateI, stateII
----------------------------------------

(6)
Obligation:
Probabilistic Q term rewrite system:
The PQTRS has the following probabilistic rules:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(cons_dice) -> 1 : dice
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   encode_dice -> 1 : dice
   encode_stateO -> 1 : stateO
   encode_stateI -> 1 : stateI
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_O -> 1 : O
   encode_stateOO -> 1 : stateOO
   encode_stateOI -> 1 : stateOI
   encode_stateOII -> 1 : stateOII
   encode_stateOOI -> 1 : stateOOI
   encode_stateII -> 1 : stateII
   encode_stateIII -> 1 : stateIII
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encode_stateIOO -> 1 : stateIOO
   encode_stateOOO -> 1 : stateOOO
   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateOOI -> 1 : s(s(s(s(O))))
   stateIII -> 1 : O
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateOOO -> 1 : s(s(s(s(s(O)))))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateIOO -> 1 : s(s(O))
   stateIOI -> 1 : s(O)
   walk(s(s(s(O)))) -> 1 : walk(dice)
   stateOII -> 1 : s(s(s(O)))
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI

And Q contains the following terms:
   encArg(s(x0)), encArg(O), encArg(cons_dice), encArg(cons_walk(x0)), encArg(cons_stateO), encArg(cons_stateOII), encArg(cons_stateOO), encArg(cons_stateII), encArg(cons_stateIO), encArg(cons_stateIOO), encArg(cons_stateIOI), encArg(cons_stateI), encArg(cons_stateOOO), encArg(cons_stateOOI), encArg(cons_stateOI), encArg(cons_stateIII), encode_dice, encode_stateO, encode_stateI, encode_walk(x0), encode_s(x0), encode_O, encode_stateOO, encode_stateOI, encode_stateOII, encode_stateOOI, encode_stateII, encode_stateIII, encode_stateIO, encode_stateIOI, encode_stateIOO, encode_stateOOO, dice, stateIO, stateOOI, stateIII, stateOO, stateOI, stateOOO, stateO, stateIOO, stateIOI, walk(s(s(s(O)))), stateOII, stateI, stateII

----------------------------------------

(7) CpxPQTRS_ToADPProblemProof (BOTH BOUNDS(ID, ID))


The complexity of a PQTRS (R,Q) is equivalent to the complexity of the ADP Problem A(R) (Chain-Criterion) (Leon's master's thesis).
The ADPs are:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(cons_dice) -> 1 : dice
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   encode_dice -> 1 : dice
   encode_stateO -> 1 : stateO
   encode_stateI -> 1 : stateI
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_O -> 1 : O
   encode_stateOO -> 1 : stateOO
   encode_stateOI -> 1 : stateOI
   encode_stateOII -> 1 : stateOII
   encode_stateOOI -> 1 : stateOOI
   encode_stateII -> 1 : stateII
   encode_stateIII -> 1 : stateIII
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encode_stateIOO -> 1 : stateIOO
   encode_stateOOO -> 1 : stateOOO
   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateOOI -> 1 : s(s(s(s(O))))
   stateIII -> 1 : O
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateOOO -> 1 : s(s(s(s(s(O)))))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateIOO -> 1 : s(s(O))
   stateIOI -> 1 : s(O)
   walk(s(s(s(O)))) -> 1 : walk(dice)
   stateOII -> 1 : s(s(s(O)))
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI

Rules with annotation in P:

   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(O) -> 1 : O
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCARG(cons_stateO) -> 1 : STATEO
   ENCARG(cons_stateOII) -> 1 : STATEOII
   ENCARG(cons_stateOO) -> 1 : STATEOO
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(cons_stateIO) -> 1 : STATEIO
   ENCARG(cons_stateIOO) -> 1 : STATEIOO
   ENCARG(cons_stateIOI) -> 1 : STATEIOI
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCARG(cons_stateOOO) -> 1 : STATEOOO
   ENCARG(cons_stateOOI) -> 1 : STATEOOI
   ENCARG(cons_stateOI) -> 1 : STATEOI
   ENCARG(cons_stateIII) -> 1 : STATEIII
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEO -> 1 : STATEO
   ENCODE_STATEI -> 1 : STATEI
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_O -> 1 : O
   ENCODE_STATEOO -> 1 : STATEOO
   ENCODE_STATEOI -> 1 : STATEOI
   ENCODE_STATEOII -> 1 : STATEOII
   ENCODE_STATEOOI -> 1 : STATEOOI
   ENCODE_STATEII -> 1 : STATEII
   ENCODE_STATEIII -> 1 : STATEIII
   ENCODE_STATEIO -> 1 : STATEIO
   ENCODE_STATEIOI -> 1 : STATEIOI
   ENCODE_STATEIOO -> 1 : STATEIOO
   ENCODE_STATEOOO -> 1 : STATEOOO
   DICE -> 1 / 2 : STATEI || 1 / 2 : STATEO
   STATEIO -> 1 / 2 : STATEIOI || 1 / 2 : STATEIOO
   STATEOOI -> 1 : s(s(s(s(O))))
   STATEIII -> 1 : O
   STATEOO -> 1 / 2 : STATEOOI || 1 / 2 : STATEOOO
   STATEOI -> 1 / 2 : STATEOII || 1 / 2 : STATEO
   STATEOOO -> 1 : s(s(s(s(s(O)))))
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : STATEOO
   STATEIOO -> 1 : s(s(O))
   STATEIOI -> 1 : s(O)
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   STATEOII -> 1 : s(s(s(O)))
   STATEI -> 1 / 2 : STATEII || 1 / 2 : STATEIO
   STATEII -> 1 / 2 : STATEIII || 1 / 2 : STATEI

Rules with annotation in S:

   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(O) -> 1 : O
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCARG(cons_stateO) -> 1 : STATEO
   ENCARG(cons_stateOII) -> 1 : STATEOII
   ENCARG(cons_stateOO) -> 1 : STATEOO
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(cons_stateIO) -> 1 : STATEIO
   ENCARG(cons_stateIOO) -> 1 : STATEIOO
   ENCARG(cons_stateIOI) -> 1 : STATEIOI
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCARG(cons_stateOOO) -> 1 : STATEOOO
   ENCARG(cons_stateOOI) -> 1 : STATEOOI
   ENCARG(cons_stateOI) -> 1 : STATEOI
   ENCARG(cons_stateIII) -> 1 : STATEIII
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEO -> 1 : STATEO
   ENCODE_STATEI -> 1 : STATEI
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_O -> 1 : O
   ENCODE_STATEOO -> 1 : STATEOO
   ENCODE_STATEOI -> 1 : STATEOI
   ENCODE_STATEOII -> 1 : STATEOII
   ENCODE_STATEOOI -> 1 : STATEOOI
   ENCODE_STATEII -> 1 : STATEII
   ENCODE_STATEIII -> 1 : STATEIII
   ENCODE_STATEIO -> 1 : STATEIO
   ENCODE_STATEIOI -> 1 : STATEIOI
   ENCODE_STATEIOO -> 1 : STATEIOO
   ENCODE_STATEOOO -> 1 : STATEOOO
   DICE -> 1 / 2 : STATEI || 1 / 2 : STATEO
   STATEIO -> 1 / 2 : STATEIOI || 1 / 2 : STATEIOO
   STATEOOI -> 1 : s(s(s(s(O))))
   STATEIII -> 1 : O
   STATEOO -> 1 / 2 : STATEOOI || 1 / 2 : STATEOOO
   STATEOI -> 1 / 2 : STATEOII || 1 / 2 : STATEO
   STATEOOO -> 1 : s(s(s(s(s(O)))))
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : STATEOO
   STATEIOO -> 1 : s(s(O))
   STATEIOI -> 1 : s(O)
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   STATEOII -> 1 : s(s(s(O)))
   STATEI -> 1 / 2 : STATEII || 1 / 2 : STATEIO
   STATEII -> 1 / 2 : STATEIII || 1 / 2 : STATEI

Rules with annotation and a known complexity:

   none

----------------------------------------

(8)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(cons_dice) -> 1 : dice
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   encode_dice -> 1 : dice
   encode_stateO -> 1 : stateO
   encode_stateI -> 1 : stateI
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_O -> 1 : O
   encode_stateOO -> 1 : stateOO
   encode_stateOI -> 1 : stateOI
   encode_stateOII -> 1 : stateOII
   encode_stateOOI -> 1 : stateOOI
   encode_stateII -> 1 : stateII
   encode_stateIII -> 1 : stateIII
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encode_stateIOO -> 1 : stateIOO
   encode_stateOOO -> 1 : stateOOO
   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateOOI -> 1 : s(s(s(s(O))))
   stateIII -> 1 : O
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateOOO -> 1 : s(s(s(s(s(O)))))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateIOO -> 1 : s(s(O))
   stateIOI -> 1 : s(O)
   walk(s(s(s(O)))) -> 1 : walk(dice)
   stateOII -> 1 : s(s(s(O)))
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI

Rules with annotation in P:

   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(O) -> 1 : O
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCARG(cons_stateO) -> 1 : STATEO
   ENCARG(cons_stateOII) -> 1 : STATEOII
   ENCARG(cons_stateOO) -> 1 : STATEOO
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(cons_stateIO) -> 1 : STATEIO
   ENCARG(cons_stateIOO) -> 1 : STATEIOO
   ENCARG(cons_stateIOI) -> 1 : STATEIOI
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCARG(cons_stateOOO) -> 1 : STATEOOO
   ENCARG(cons_stateOOI) -> 1 : STATEOOI
   ENCARG(cons_stateOI) -> 1 : STATEOI
   ENCARG(cons_stateIII) -> 1 : STATEIII
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEO -> 1 : STATEO
   ENCODE_STATEI -> 1 : STATEI
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_O -> 1 : O
   ENCODE_STATEOO -> 1 : STATEOO
   ENCODE_STATEOI -> 1 : STATEOI
   ENCODE_STATEOII -> 1 : STATEOII
   ENCODE_STATEOOI -> 1 : STATEOOI
   ENCODE_STATEII -> 1 : STATEII
   ENCODE_STATEIII -> 1 : STATEIII
   ENCODE_STATEIO -> 1 : STATEIO
   ENCODE_STATEIOI -> 1 : STATEIOI
   ENCODE_STATEIOO -> 1 : STATEIOO
   ENCODE_STATEOOO -> 1 : STATEOOO
   DICE -> 1 / 2 : STATEI || 1 / 2 : STATEO
   STATEIO -> 1 / 2 : STATEIOI || 1 / 2 : STATEIOO
   STATEOOI -> 1 : s(s(s(s(O))))
   STATEIII -> 1 : O
   STATEOO -> 1 / 2 : STATEOOI || 1 / 2 : STATEOOO
   STATEOI -> 1 / 2 : STATEOII || 1 / 2 : STATEO
   STATEOOO -> 1 : s(s(s(s(s(O)))))
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : STATEOO
   STATEIOO -> 1 : s(s(O))
   STATEIOI -> 1 : s(O)
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   STATEOII -> 1 : s(s(s(O)))
   STATEI -> 1 / 2 : STATEII || 1 / 2 : STATEIO
   STATEII -> 1 / 2 : STATEIII || 1 / 2 : STATEI

Rules with annotation in S:

   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(O) -> 1 : O
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCARG(cons_stateO) -> 1 : STATEO
   ENCARG(cons_stateOII) -> 1 : STATEOII
   ENCARG(cons_stateOO) -> 1 : STATEOO
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(cons_stateIO) -> 1 : STATEIO
   ENCARG(cons_stateIOO) -> 1 : STATEIOO
   ENCARG(cons_stateIOI) -> 1 : STATEIOI
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCARG(cons_stateOOO) -> 1 : STATEOOO
   ENCARG(cons_stateOOI) -> 1 : STATEOOI
   ENCARG(cons_stateOI) -> 1 : STATEOI
   ENCARG(cons_stateIII) -> 1 : STATEIII
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEO -> 1 : STATEO
   ENCODE_STATEI -> 1 : STATEI
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_O -> 1 : O
   ENCODE_STATEOO -> 1 : STATEOO
   ENCODE_STATEOI -> 1 : STATEOI
   ENCODE_STATEOII -> 1 : STATEOII
   ENCODE_STATEOOI -> 1 : STATEOOI
   ENCODE_STATEII -> 1 : STATEII
   ENCODE_STATEIII -> 1 : STATEIII
   ENCODE_STATEIO -> 1 : STATEIO
   ENCODE_STATEIOI -> 1 : STATEIOI
   ENCODE_STATEIOO -> 1 : STATEIOO
   ENCODE_STATEOOO -> 1 : STATEOOO
   DICE -> 1 / 2 : STATEI || 1 / 2 : STATEO
   STATEIO -> 1 / 2 : STATEIOI || 1 / 2 : STATEIOO
   STATEOOI -> 1 : s(s(s(s(O))))
   STATEIII -> 1 : O
   STATEOO -> 1 / 2 : STATEOOI || 1 / 2 : STATEOOO
   STATEOI -> 1 / 2 : STATEOII || 1 / 2 : STATEO
   STATEOOO -> 1 : s(s(s(s(s(O)))))
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : STATEOO
   STATEIOO -> 1 : s(s(O))
   STATEIOI -> 1 : s(O)
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   STATEOII -> 1 : s(s(s(O)))
   STATEI -> 1 / 2 : STATEII || 1 / 2 : STATEIO
   STATEII -> 1 / 2 : STATEIII || 1 / 2 : STATEI

Rules with annotation and a known complexity:

   none

----------------------------------------

(9) CpxADP_SCCSplitProof (UPPER BOUND(ID))
As part of the dependency graph processor, we can split problem in 4 new components.
----------------------------------------

(10)
Complex Obligation (MAX)

----------------------------------------

(11)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(cons_dice) -> 1 : dice
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   encode_dice -> 1 : dice
   encode_stateO -> 1 : stateO
   encode_stateI -> 1 : stateI
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_O -> 1 : O
   encode_stateOO -> 1 : stateOO
   encode_stateOI -> 1 : stateOI
   encode_stateOII -> 1 : stateOII
   encode_stateOOI -> 1 : stateOOI
   encode_stateII -> 1 : stateII
   encode_stateIII -> 1 : stateIII
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encode_stateIOO -> 1 : stateIOO
   encode_stateOOO -> 1 : stateOOO
   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateOOI -> 1 : s(s(s(s(O))))
   stateIII -> 1 : O
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateOOO -> 1 : s(s(s(s(s(O)))))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateIOO -> 1 : s(s(O))
   stateIOI -> 1 : s(O)
   walk(s(s(s(O)))) -> 1 : walk(dice)
   stateOII -> 1 : s(s(s(O)))
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI

Rules with annotation in P:

   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation in S:

   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation and a known complexity:

   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))


----------------------------------------

(12) CpxADP_UsableTermsProof (UPPER BOUND(ID))


The approximation of the Dependency Graph  gives us the following unusable Terms: 
   WALK(encArg(x_1))
Hence, as part of the dependency graph processor, we can remove the annotations from these terms from every RHS of every ADP in P and S.

----------------------------------------

(13)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(cons_dice) -> 1 : dice
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   encode_dice -> 1 : dice
   encode_stateO -> 1 : stateO
   encode_stateI -> 1 : stateI
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_O -> 1 : O
   encode_stateOO -> 1 : stateOO
   encode_stateOI -> 1 : stateOI
   encode_stateOII -> 1 : stateOII
   encode_stateOOI -> 1 : stateOOI
   encode_stateII -> 1 : stateII
   encode_stateIII -> 1 : stateIII
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encode_stateIOO -> 1 : stateIOO
   encode_stateOOO -> 1 : stateOOO
   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateOOI -> 1 : s(s(s(s(O))))
   stateIII -> 1 : O
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateOOO -> 1 : s(s(s(s(s(O)))))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateIOO -> 1 : s(s(O))
   stateIOI -> 1 : s(O)
   walk(s(s(s(O)))) -> 1 : walk(dice)
   stateOII -> 1 : s(s(s(O)))
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI

Rules with annotation in P:

   ENCODE_WALK(x_1) -> 1 : walk(ENCARG(x_1))
   ENCARG(cons_walk(x_1)) -> 1 : walk(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation in S:

   ENCARG(cons_walk(x_1)) -> 1 : walk(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation and a known complexity:

   ENCODE_WALK(x_1) -> 1 : walk(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))


----------------------------------------

(14) CpxADP_UsableRulesProof (BOTH BOUNDS(ID, ID))


We use the usable rules processor.
We can deactivate the flags for all non-usable rules [FROCOS05]

Rules which have been flagged as non usable in this step:

   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   encArg(cons_stateOOI) -> 1 : stateOOI
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encode_stateIOO -> 1 : stateIOO
   encode_stateO -> 1 : stateO
   stateIII -> 1 : O
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   encode_stateOO -> 1 : stateOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   encArg(O) -> 1 : O
   encode_stateI -> 1 : stateI
   encode_stateOI -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   stateIOI -> 1 : s(O)
   encArg(cons_stateOOO) -> 1 : stateOOO
   stateOII -> 1 : s(s(s(O)))
   encode_dice -> 1 : dice
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   encode_O -> 1 : O
   encode_stateIO -> 1 : stateIO
   encode_stateOOO -> 1 : stateOOO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   encArg(cons_stateIOO) -> 1 : stateIOO
   encode_stateIOI -> 1 : stateIOI
   encArg(cons_stateOII) -> 1 : stateOII
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encArg(cons_stateIOI) -> 1 : stateIOI
   stateOOI -> 1 : s(s(s(s(O))))
   encode_stateIII -> 1 : stateIII
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateII) -> 1 : stateII
   encode_stateII -> 1 : stateII
   stateOOO -> 1 : s(s(s(s(s(O)))))
   encArg(cons_stateIO) -> 1 : stateIO
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateIOO -> 1 : s(s(O))
   encArg(cons_stateO) -> 1 : stateO
   walk(s(s(s(O)))) -> 1 : walk(dice)
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_dice) -> 1 : dice
   encode_stateOII -> 1 : stateOII
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_stateOOI -> 1 : stateOOI

----------------------------------------

(15)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:
   none
Rules with annotation in P:

   ENCODE_WALK(x_1) -> 1 : walk(ENCARG(x_1))
   ENCARG(cons_walk(x_1)) -> 1 : walk(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation in S:

   ENCARG(cons_walk(x_1)) -> 1 : walk(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation and a known complexity:

   ENCODE_WALK(x_1) -> 1 : walk(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))


----------------------------------------

(16) CpxADP_ProbabilityRemovalProof (UPPER BOUND(ID))


We use the probability removal processor to move to dependecy tuples without probabilities.
As all rules have a trivial probability (1:r), we can transform it into a non-probabilistic DT problem

----------------------------------------

(17)
Obligation:
Complexity Dependency Tuples Problem

Rules:none
Tuples:
   ENCODE_WALK(x_1) -> c(ENCARG(x_1))
   ENCARG(cons_walk(x_1)) -> c1(ENCARG(x_1))
   ENCODE_S(x_1) -> c2(ENCARG(x_1))
   ENCARG(s(x_1)) -> c3(ENCARG(x_1))
S tuples:
   ENCODE_WALK(x_1) -> c(ENCARG(x_1))
   ENCARG(cons_walk(x_1)) -> c1(ENCARG(x_1))
   ENCODE_S(x_1) -> c2(ENCARG(x_1))
   ENCARG(s(x_1)) -> c3(ENCARG(x_1))
K tuples:none
Defined Rule Symbols:   encArg_1, encode_dice, encode_stateO, encode_stateI, encode_walk_1, encode_s_1, encode_O, encode_stateOO, encode_stateOI, encode_stateOII, encode_stateOOI, encode_stateII, encode_stateIII, encode_stateIO, encode_stateIOI, encode_stateIOO, encode_stateOOO, dice, stateIO, stateOOI, stateIII, stateOO, stateOI, stateOOO, stateO, stateIOO, stateIOI, walk_1, stateOII, stateI, stateII

Defined Pair Symbols:none

Compound Symbols:   c_1, c1_1, c2_1, c3_1


----------------------------------------

(18) CdtLeafRemovalProof (ComplexityIfPolyImplication)
Removed 2 leading nodes:
   ENCODE_WALK(x_1) -> c(ENCARG(x_1))
   ENCODE_S(x_1) -> c2(ENCARG(x_1))

----------------------------------------

(19)
Obligation:
Complexity Dependency Tuples Problem

Rules:none
Tuples:
   ENCARG(cons_walk(x_1)) -> c1(ENCARG(x_1))
   ENCARG(s(x_1)) -> c3(ENCARG(x_1))
S tuples:
   ENCARG(cons_walk(x_1)) -> c1(ENCARG(x_1))
   ENCARG(s(x_1)) -> c3(ENCARG(x_1))
K tuples:none
Defined Rule Symbols:   encArg_1, encode_dice, encode_stateO, encode_stateI, encode_walk_1, encode_s_1, encode_O, encode_stateOO, encode_stateOI, encode_stateOII, encode_stateOOI, encode_stateII, encode_stateIII, encode_stateIO, encode_stateIOI, encode_stateIOO, encode_stateOOO, dice, stateIO, stateOOI, stateIII, stateOO, stateOI, stateOOO, stateO, stateIOO, stateIOI, walk_1, stateOII, stateI, stateII

Defined Pair Symbols:   ENCARG_1

Compound Symbols:   c1_1, c3_1


----------------------------------------

(20) CdtToCpxRelTrsProof (BOTH BOUNDS(ID, ID))
Converted S to standard rules, and D \ S as well as R to relative rules.
----------------------------------------

(21)
Obligation:
The Runtime Complexity (innermost) of the given CpxTRS could be proven to be BOUNDS(1, n^1).


The TRS R consists of the following rules:

   ENCARG(cons_walk(x_1)) -> c1(ENCARG(x_1))
   ENCARG(s(x_1)) -> c3(ENCARG(x_1))

S is empty.
Rewrite Strategy: INNERMOST
----------------------------------------

(22) RelTrsToTrsProof (UPPER BOUND(ID))
transformed relative TRS to TRS
----------------------------------------

(23)
Obligation:
The Runtime Complexity (innermost) of the given CpxTRS could be proven to be BOUNDS(1, n^1).


The TRS R consists of the following rules:

   ENCARG(cons_walk(x_1)) -> c1(ENCARG(x_1))
   ENCARG(s(x_1)) -> c3(ENCARG(x_1))

S is empty.
Rewrite Strategy: INNERMOST
----------------------------------------

(24) CpxTrsMatchBoundsProof (FINISHED)
A linear upper bound on the runtime complexity of the TRS R could be shown with a Match Bound [MATCHBOUNDS1,MATCHBOUNDS2] of 1. 
The certificate found is represented by the following graph.

"[971, 972, 973, 974]
{(971,972,[ENCARG_1|0]), (971,973,[c1_1|1]), (971,974,[c3_1|1]), (972,972,[cons_walk_1|0, c1_1|0, s_1|0, c3_1|0]), (973,972,[ENCARG_1|1]), (973,973,[c1_1|1]), (973,974,[c3_1|1]), (974,972,[ENCARG_1|1]), (974,973,[c1_1|1]), (974,974,[c3_1|1])}"
----------------------------------------

(25)
BOUNDS(1, n^1)

----------------------------------------

(26)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(cons_dice) -> 1 : dice
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   encode_dice -> 1 : dice
   encode_stateO -> 1 : stateO
   encode_stateI -> 1 : stateI
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_O -> 1 : O
   encode_stateOO -> 1 : stateOO
   encode_stateOI -> 1 : stateOI
   encode_stateOII -> 1 : stateOII
   encode_stateOOI -> 1 : stateOOI
   encode_stateII -> 1 : stateII
   encode_stateIII -> 1 : stateIII
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encode_stateIOO -> 1 : stateIOO
   encode_stateOOO -> 1 : stateOOO
   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateOOI -> 1 : s(s(s(s(O))))
   stateIII -> 1 : O
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateOOO -> 1 : s(s(s(s(s(O)))))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateIOO -> 1 : s(s(O))
   stateIOI -> 1 : s(O)
   walk(s(s(s(O)))) -> 1 : walk(dice)
   stateOII -> 1 : s(s(s(O)))
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI

Rules with annotation in P:

   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)

Rules with annotation in S:

   WALK(s(s(s(O)))) -> 1 : WALK(DICE)

Rules with annotation and a known complexity:

   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))


----------------------------------------

(27) CpxADP_UsableTermsProof (UPPER BOUND(ID))


The approximation of the Dependency Graph  gives us the following unusable Terms: 
   DICE
Hence, as part of the dependency graph processor, we can remove the annotations from these terms from every RHS of every ADP in P and S.

----------------------------------------

(28)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(cons_dice) -> 1 : dice
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   encode_dice -> 1 : dice
   encode_stateO -> 1 : stateO
   encode_stateI -> 1 : stateI
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_O -> 1 : O
   encode_stateOO -> 1 : stateOO
   encode_stateOI -> 1 : stateOI
   encode_stateOII -> 1 : stateOII
   encode_stateOOI -> 1 : stateOOI
   encode_stateII -> 1 : stateII
   encode_stateIII -> 1 : stateIII
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encode_stateIOO -> 1 : stateIOO
   encode_stateOOO -> 1 : stateOOO
   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateOOI -> 1 : s(s(s(s(O))))
   stateIII -> 1 : O
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateOOO -> 1 : s(s(s(s(s(O)))))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateIOO -> 1 : s(s(O))
   stateIOI -> 1 : s(O)
   walk(s(s(s(O)))) -> 1 : walk(dice)
   stateOII -> 1 : s(s(s(O)))
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI

Rules with annotation in P:

   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   WALK(s(s(s(O)))) -> 1 : WALK(dice)
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation in S:

   WALK(s(s(s(O)))) -> 1 : WALK(dice)

Rules with annotation and a known complexity:

   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))


----------------------------------------

(29) CpxADP_UsableRulesProof (BOTH BOUNDS(ID, ID))


We use the usable rules processor.
We can deactivate the flags for all non-usable rules [FROCOS05]

Rules which have been flagged as non usable in this step:

   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_stateIII -> 1 : stateIII
   encode_stateIOO -> 1 : stateIOO
   encode_stateO -> 1 : stateO
   encode_stateOO -> 1 : stateOO
   encode_stateII -> 1 : stateII
   encode_stateI -> 1 : stateI
   encode_stateOI -> 1 : stateOI
   encode_dice -> 1 : dice
   encode_O -> 1 : O
   encode_stateOII -> 1 : stateOII
   encode_stateIO -> 1 : stateIO
   encode_stateOOO -> 1 : stateOOO
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_stateOOI -> 1 : stateOOI
   encode_stateIOI -> 1 : stateIOI

----------------------------------------

(30)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(cons_dice) -> 1 : dice
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   stateIII -> 1 : O
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateOII -> 1 : s(s(s(O)))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOOI -> 1 : s(s(s(s(O))))
   stateOOO -> 1 : s(s(s(s(s(O)))))
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateIOI -> 1 : s(O)
   stateIOO -> 1 : s(s(O))
   walk(s(s(s(O)))) -> 1 : walk(dice)
   dice -> 1 / 2 : stateI || 1 / 2 : stateO

Rules with annotation in P:

   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   WALK(s(s(s(O)))) -> 1 : WALK(dice)
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation in S:

   WALK(s(s(s(O)))) -> 1 : WALK(dice)

Rules with annotation and a known complexity:

   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))


----------------------------------------

(31) CpxADP_ReductionPairProof (UPPER BOUND(ADD(EXP)))


We use the reduction pair processor.
The following pairs can be oriented strictly and are moved from S:

   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   WALK(s(s(s(O)))) -> 1 : WALK(dice)
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

The remaining pairs can at least be oriented weakly:
none

Used ordering:Polynomial interpretation [POLO]:

   POL(DICE) = 0
   POL(ENCARG(x_1)) = x_1
   POL(ENCODE_DICE) = 0
   POL(ENCODE_O) = 0
   POL(ENCODE_S(x_1)) = 6 + 5*x_1
   POL(ENCODE_STATEI) = 0
   POL(ENCODE_STATEII) = 0
   POL(ENCODE_STATEIII) = 0
   POL(ENCODE_STATEIO) = 0
   POL(ENCODE_STATEIOI) = 0
   POL(ENCODE_STATEIOO) = 0
   POL(ENCODE_STATEO) = 0
   POL(ENCODE_STATEOI) = 0
   POL(ENCODE_STATEOII) = 0
   POL(ENCODE_STATEOO) = 0
   POL(ENCODE_STATEOOI) = 0
   POL(ENCODE_STATEOOO) = 0
   POL(ENCODE_WALK(x_1)) = 10 + 10*x_1
   POL(O) = 0
   POL(STATEI) = 0
   POL(STATEII) = 0
   POL(STATEIII) = 0
   POL(STATEIO) = 0
   POL(STATEIOI) = 0
   POL(STATEIOO) = 0
   POL(STATEO) = 0
   POL(STATEOI) = 0
   POL(STATEOII) = 0
   POL(STATEOO) = 0
   POL(STATEOOI) = 0
   POL(STATEOOO) = 0
   POL(WALK(x_1)) = 8*x_1
   POL(cons_dice) = 6
   POL(cons_stateI) = 4
   POL(cons_stateII) = 1
   POL(cons_stateIII) = 10
   POL(cons_stateIO) = 3
   POL(cons_stateIOI) = 4
   POL(cons_stateIOO) = 5
   POL(cons_stateO) = 10
   POL(cons_stateOI) = 7
   POL(cons_stateOII) = 8
   POL(cons_stateOO) = 10
   POL(cons_stateOOI) = 9
   POL(cons_stateOOO) = 10
   POL(cons_walk(x_1)) = 1 + 9*x_1
   POL(dice) = 5
   POL(encArg(x_1)) = x_1
   POL(s(x_1)) = 2 + x_1
   POL(stateI) = 2
   POL(stateII) = 1
   POL(stateIII) = 0
   POL(stateIO) = 3
   POL(stateIOI) = 2
   POL(stateIOO) = 4
   POL(stateO) = 8
   POL(stateOI) = 7
   POL(stateOII) = 6
   POL(stateOO) = 9
   POL(stateOOI) = 8
   POL(stateOOO) = 10
   POL(walk(x_1)) = 0

The complexity of the removed ADPs is bounded by:EXP
----------------------------------------

(32)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(cons_dice) -> 1 : dice
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   stateIII -> 1 : O
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateOII -> 1 : s(s(s(O)))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOOI -> 1 : s(s(s(s(O))))
   stateOOO -> 1 : s(s(s(s(s(O)))))
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateIOI -> 1 : s(O)
   stateIOO -> 1 : s(s(O))
   walk(s(s(s(O)))) -> 1 : walk(dice)
   dice -> 1 / 2 : stateI || 1 / 2 : stateO

Rules with annotation in P:

   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   WALK(s(s(s(O)))) -> 1 : WALK(dice)
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation in S:

   none

Rules with annotation and a known complexity:

   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   WALK(s(s(s(O)))) -> 1 : WALK(dice)
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))


----------------------------------------

(33) SisEmptyProof (FINISHED)


S contains no annotations anymore. Hence, there exists no P-CT with infinitely many S-Nodes.
Resulting upper bound: O(1)

----------------------------------------

(34)
BOUNDS(1, 1)

----------------------------------------

(35)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(cons_dice) -> 1 : dice
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   encode_dice -> 1 : dice
   encode_stateO -> 1 : stateO
   encode_stateI -> 1 : stateI
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_O -> 1 : O
   encode_stateOO -> 1 : stateOO
   encode_stateOI -> 1 : stateOI
   encode_stateOII -> 1 : stateOII
   encode_stateOOI -> 1 : stateOOI
   encode_stateII -> 1 : stateII
   encode_stateIII -> 1 : stateIII
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encode_stateIOO -> 1 : stateIOO
   encode_stateOOO -> 1 : stateOOO
   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateOOI -> 1 : s(s(s(s(O))))
   stateIII -> 1 : O
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateOOO -> 1 : s(s(s(s(s(O)))))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateIOO -> 1 : s(s(O))
   stateIOI -> 1 : s(O)
   walk(s(s(s(O)))) -> 1 : walk(dice)
   stateOII -> 1 : s(s(s(O)))
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI

Rules with annotation in P:

   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEI -> 1 : STATEI
   ENCODE_STATEII -> 1 : STATEII
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   DICE -> 1 / 2 : STATEI || 1 / 2 : STATEO
   STATEII -> 1 / 2 : STATEIII || 1 / 2 : STATEI
   STATEI -> 1 / 2 : STATEII || 1 / 2 : STATEIO

Rules with annotation in S:

   STATEII -> 1 / 2 : STATEIII || 1 / 2 : STATEI
   STATEI -> 1 / 2 : STATEII || 1 / 2 : STATEIO

Rules with annotation and a known complexity:

   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEI -> 1 : STATEI
   ENCODE_STATEII -> 1 : STATEII
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   DICE -> 1 / 2 : STATEI || 1 / 2 : STATEO


----------------------------------------

(36) CpxADP_UsableTermsProof (UPPER BOUND(ID))


The approximation of the Dependency Graph  gives us the following unusable Terms: 
   STATEIO, STATEIII, STATEO
Hence, as part of the dependency graph processor, we can remove the annotations from these terms from every RHS of every ADP in P and S.

----------------------------------------

(37)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(cons_dice) -> 1 : dice
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   encode_dice -> 1 : dice
   encode_stateO -> 1 : stateO
   encode_stateI -> 1 : stateI
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_O -> 1 : O
   encode_stateOO -> 1 : stateOO
   encode_stateOI -> 1 : stateOI
   encode_stateOII -> 1 : stateOII
   encode_stateOOI -> 1 : stateOOI
   encode_stateII -> 1 : stateII
   encode_stateIII -> 1 : stateIII
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encode_stateIOO -> 1 : stateIOO
   encode_stateOOO -> 1 : stateOOO
   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateOOI -> 1 : s(s(s(s(O))))
   stateIII -> 1 : O
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateOOO -> 1 : s(s(s(s(s(O)))))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateIOO -> 1 : s(s(O))
   stateIOI -> 1 : s(O)
   walk(s(s(s(O)))) -> 1 : walk(dice)
   stateOII -> 1 : s(s(s(O)))
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI

Rules with annotation in P:

   ENCODE_STATEII -> 1 : STATEII
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateI) -> 1 : STATEI
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   STATEII -> 1 / 2 : stateIII || 1 / 2 : STATEI
   DICE -> 1 / 2 : STATEI || 1 / 2 : stateO
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCODE_DICE -> 1 : DICE
   STATEI -> 1 / 2 : STATEII || 1 / 2 : stateIO
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCODE_STATEI -> 1 : STATEI
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation in S:

   STATEI -> 1 / 2 : STATEII || 1 / 2 : stateIO
   STATEII -> 1 / 2 : stateIII || 1 / 2 : STATEI

Rules with annotation and a known complexity:

   ENCODE_STATEII -> 1 : STATEII
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCODE_DICE -> 1 : DICE
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   DICE -> 1 / 2 : STATEI || 1 / 2 : stateO
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCODE_STATEI -> 1 : STATEI
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))


----------------------------------------

(38) CpxADP_UsableRulesProof (BOTH BOUNDS(ID, ID))


We use the usable rules processor.
We can deactivate the flags for all non-usable rules [FROCOS05]

Rules which have been flagged as non usable in this step:

   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_stateIII -> 1 : stateIII
   encode_stateIOO -> 1 : stateIOO
   encode_stateO -> 1 : stateO
   encode_stateOO -> 1 : stateOO
   encode_stateII -> 1 : stateII
   encode_stateI -> 1 : stateI
   encode_stateOI -> 1 : stateOI
   encode_dice -> 1 : dice
   encode_O -> 1 : O
   encode_stateOII -> 1 : stateOII
   encode_stateIO -> 1 : stateIO
   encode_stateOOO -> 1 : stateOOO
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_stateOOI -> 1 : stateOOI
   encode_stateIOI -> 1 : stateIOI

----------------------------------------

(39)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(cons_dice) -> 1 : dice
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   stateIII -> 1 : O
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateOII -> 1 : s(s(s(O)))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOOI -> 1 : s(s(s(s(O))))
   stateOOO -> 1 : s(s(s(s(s(O)))))
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateIOI -> 1 : s(O)
   stateIOO -> 1 : s(s(O))
   walk(s(s(s(O)))) -> 1 : walk(dice)
   dice -> 1 / 2 : stateI || 1 / 2 : stateO

Rules with annotation in P:

   ENCODE_STATEII -> 1 : STATEII
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateI) -> 1 : STATEI
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   STATEII -> 1 / 2 : stateIII || 1 / 2 : STATEI
   DICE -> 1 / 2 : STATEI || 1 / 2 : stateO
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCODE_DICE -> 1 : DICE
   STATEI -> 1 / 2 : STATEII || 1 / 2 : stateIO
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCODE_STATEI -> 1 : STATEI
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation in S:

   STATEI -> 1 / 2 : STATEII || 1 / 2 : stateIO
   STATEII -> 1 / 2 : stateIII || 1 / 2 : STATEI

Rules with annotation and a known complexity:

   ENCODE_STATEII -> 1 : STATEII
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCODE_DICE -> 1 : DICE
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   DICE -> 1 / 2 : STATEI || 1 / 2 : stateO
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCODE_STATEI -> 1 : STATEI
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))


----------------------------------------

(40) CpxADP_ReductionPairProof (UPPER BOUND(ADD(EXP)))


We use the reduction pair processor.
The following pairs can be oriented strictly and are moved from S:

   ENCODE_STATEII -> 1 : STATEII
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCODE_DICE -> 1 : DICE
   STATEI -> 1 / 2 : STATEII || 1 / 2 : stateIO
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCODE_STATEI -> 1 : STATEI
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

The remaining pairs can at least be oriented weakly:

   STATEII -> 1 / 2 : stateIII || 1 / 2 : STATEI
   DICE -> 1 / 2 : STATEI || 1 / 2 : stateO
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))

Used ordering:Polynomial interpretation [POLO]:

   POL(DICE) = 1
   POL(ENCARG(x_1)) = 8 + x_1
   POL(ENCODE_DICE) = 5
   POL(ENCODE_O) = 0
   POL(ENCODE_S(x_1)) = 8 + 10*x_1
   POL(ENCODE_STATEI) = 5
   POL(ENCODE_STATEII) = 10
   POL(ENCODE_STATEIII) = 0
   POL(ENCODE_STATEIO) = 0
   POL(ENCODE_STATEIOI) = 0
   POL(ENCODE_STATEIOO) = 0
   POL(ENCODE_STATEO) = 0
   POL(ENCODE_STATEOI) = 0
   POL(ENCODE_STATEOII) = 0
   POL(ENCODE_STATEOO) = 0
   POL(ENCODE_STATEOOI) = 0
   POL(ENCODE_STATEOOO) = 0
   POL(ENCODE_WALK(x_1)) = 9 + 7*x_1
   POL(O) = 0
   POL(STATEI) = 2
   POL(STATEII) = 1
   POL(STATEIII) = 0
   POL(STATEIO) = 0
   POL(STATEIOI) = 0
   POL(STATEIOO) = 0
   POL(STATEO) = 0
   POL(STATEOI) = 0
   POL(STATEOII) = 0
   POL(STATEOO) = 0
   POL(STATEOOI) = 0
   POL(STATEOOO) = 0
   POL(WALK(x_1)) = 2*x_1
   POL(cons_dice) = 3
   POL(cons_stateI) = 8
   POL(cons_stateII) = 8
   POL(cons_stateIII) = 5
   POL(cons_stateIO) = 2
   POL(cons_stateIOI) = 1
   POL(cons_stateIOO) = 2
   POL(cons_stateO) = 8
   POL(cons_stateOI) = 4
   POL(cons_stateOII) = 3
   POL(cons_stateOO) = 6
   POL(cons_stateOOI) = 10
   POL(cons_stateOOO) = 8
   POL(cons_walk(x_1)) = 6 + 5*x_1
   POL(dice) = 5
   POL(encArg(x_1)) = 2*x_1
   POL(s(x_1)) = 2 + x_1
   POL(stateI) = 2
   POL(stateII) = 1
   POL(stateIII) = 0
   POL(stateIO) = 3
   POL(stateIOI) = 2
   POL(stateIOO) = 4
   POL(stateO) = 8
   POL(stateOI) = 7
   POL(stateOII) = 6
   POL(stateOO) = 9
   POL(stateOOI) = 8
   POL(stateOOO) = 10
   POL(walk(x_1)) = 0

The complexity of the removed ADPs is bounded by:EXP
----------------------------------------

(41)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(cons_dice) -> 1 : dice
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   stateIII -> 1 : O
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateOII -> 1 : s(s(s(O)))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOOI -> 1 : s(s(s(s(O))))
   stateOOO -> 1 : s(s(s(s(s(O)))))
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateIOI -> 1 : s(O)
   stateIOO -> 1 : s(s(O))
   walk(s(s(s(O)))) -> 1 : walk(dice)
   dice -> 1 / 2 : stateI || 1 / 2 : stateO

Rules with annotation in P:

   ENCODE_STATEII -> 1 : STATEII
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateI) -> 1 : STATEI
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   STATEII -> 1 / 2 : stateIII || 1 / 2 : STATEI
   DICE -> 1 / 2 : STATEI || 1 / 2 : stateO
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCODE_DICE -> 1 : DICE
   STATEI -> 1 / 2 : STATEII || 1 / 2 : stateIO
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCODE_STATEI -> 1 : STATEI
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation in S:

   STATEII -> 1 / 2 : stateIII || 1 / 2 : STATEI

Rules with annotation and a known complexity:

   ENCODE_STATEII -> 1 : STATEII
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateI) -> 1 : STATEI
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   DICE -> 1 / 2 : STATEI || 1 / 2 : stateO
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCODE_DICE -> 1 : DICE
   STATEI -> 1 / 2 : STATEII || 1 / 2 : stateIO
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCODE_STATEI -> 1 : STATEI
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))


----------------------------------------

(42) CpxADP_KnowledgePropagationProof (BOTH BOUNDS(ID, ID))


We use the knowledge propagation processor .
We can remove rules from S, if in the dependency graph no predecessor is in S (all predecessors have a known complexity bound).

Following rules are removed from S:

   STATEII -> 1 / 2 : stateIII || 1 / 2 : STATEI

----------------------------------------

(43)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(cons_dice) -> 1 : dice
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   stateIII -> 1 : O
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateOII -> 1 : s(s(s(O)))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOOI -> 1 : s(s(s(s(O))))
   stateOOO -> 1 : s(s(s(s(s(O)))))
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateIOI -> 1 : s(O)
   stateIOO -> 1 : s(s(O))
   walk(s(s(s(O)))) -> 1 : walk(dice)
   dice -> 1 / 2 : stateI || 1 / 2 : stateO

Rules with annotation in P:

   ENCODE_STATEII -> 1 : STATEII
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateI) -> 1 : STATEI
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   STATEII -> 1 / 2 : stateIII || 1 / 2 : STATEI
   DICE -> 1 / 2 : STATEI || 1 / 2 : stateO
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCODE_DICE -> 1 : DICE
   STATEI -> 1 / 2 : STATEII || 1 / 2 : stateIO
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCODE_STATEI -> 1 : STATEI
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation in S:

   none

Rules with annotation and a known complexity:

   ENCODE_STATEII -> 1 : STATEII
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateI) -> 1 : STATEI
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   STATEII -> 1 / 2 : stateIII || 1 / 2 : STATEI
   DICE -> 1 / 2 : STATEI || 1 / 2 : stateO
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCODE_DICE -> 1 : DICE
   STATEI -> 1 / 2 : STATEII || 1 / 2 : stateIO
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCODE_STATEI -> 1 : STATEI
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))


----------------------------------------

(44) SisEmptyProof (FINISHED)


S contains no annotations anymore. Hence, there exists no P-CT with infinitely many S-Nodes.
Resulting upper bound: O(1)

----------------------------------------

(45)
BOUNDS(1, 1)

----------------------------------------

(46)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(cons_dice) -> 1 : dice
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   encode_dice -> 1 : dice
   encode_stateO -> 1 : stateO
   encode_stateI -> 1 : stateI
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_O -> 1 : O
   encode_stateOO -> 1 : stateOO
   encode_stateOI -> 1 : stateOI
   encode_stateOII -> 1 : stateOII
   encode_stateOOI -> 1 : stateOOI
   encode_stateII -> 1 : stateII
   encode_stateIII -> 1 : stateIII
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encode_stateIOO -> 1 : stateIOO
   encode_stateOOO -> 1 : stateOOO
   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateOOI -> 1 : s(s(s(s(O))))
   stateIII -> 1 : O
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateOOO -> 1 : s(s(s(s(s(O)))))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateIOO -> 1 : s(s(O))
   stateIOI -> 1 : s(O)
   walk(s(s(s(O)))) -> 1 : walk(dice)
   stateOII -> 1 : s(s(s(O)))
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI

Rules with annotation in P:

   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateO) -> 1 : STATEO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEO -> 1 : STATEO
   ENCODE_STATEOI -> 1 : STATEOI
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   DICE -> 1 / 2 : STATEI || 1 / 2 : STATEO
   STATEOI -> 1 / 2 : STATEOII || 1 / 2 : STATEO
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : STATEOO

Rules with annotation in S:

   STATEOI -> 1 / 2 : STATEOII || 1 / 2 : STATEO
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : STATEOO

Rules with annotation and a known complexity:

   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateO) -> 1 : STATEO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEO -> 1 : STATEO
   ENCODE_STATEOI -> 1 : STATEOI
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   DICE -> 1 / 2 : STATEI || 1 / 2 : STATEO


----------------------------------------

(47) CpxADP_UsableTermsProof (UPPER BOUND(ID))


The approximation of the Dependency Graph  gives us the following unusable Terms: 
   STATEOO, STATEI, STATEOII
Hence, as part of the dependency graph processor, we can remove the annotations from these terms from every RHS of every ADP in P and S.

----------------------------------------

(48)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(cons_dice) -> 1 : dice
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   encode_dice -> 1 : dice
   encode_stateO -> 1 : stateO
   encode_stateI -> 1 : stateI
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_O -> 1 : O
   encode_stateOO -> 1 : stateOO
   encode_stateOI -> 1 : stateOI
   encode_stateOII -> 1 : stateOII
   encode_stateOOI -> 1 : stateOOI
   encode_stateII -> 1 : stateII
   encode_stateIII -> 1 : stateIII
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encode_stateIOO -> 1 : stateIOO
   encode_stateOOO -> 1 : stateOOO
   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateOOI -> 1 : s(s(s(s(O))))
   stateIII -> 1 : O
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateOOO -> 1 : s(s(s(s(s(O)))))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateIOO -> 1 : s(s(O))
   stateIOI -> 1 : s(O)
   walk(s(s(s(O)))) -> 1 : walk(dice)
   stateOII -> 1 : s(s(s(O)))
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI

Rules with annotation in P:

   ENCARG(cons_dice) -> 1 : DICE
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   DICE -> 1 / 2 : stateI || 1 / 2 : STATEO
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_stateO) -> 1 : STATEO
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : stateOO
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEOI -> 1 : STATEOI
   ENCODE_STATEO -> 1 : STATEO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   STATEOI -> 1 / 2 : stateOII || 1 / 2 : STATEO
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation in S:

   STATEO -> 1 / 2 : STATEOI || 1 / 2 : stateOO
   STATEOI -> 1 / 2 : stateOII || 1 / 2 : STATEO

Rules with annotation and a known complexity:

   ENCARG(cons_stateO) -> 1 : STATEO
   ENCARG(cons_dice) -> 1 : DICE
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEOI -> 1 : STATEOI
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   ENCODE_STATEO -> 1 : STATEO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   DICE -> 1 / 2 : stateI || 1 / 2 : STATEO
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))


----------------------------------------

(49) CpxADP_UsableRulesProof (BOTH BOUNDS(ID, ID))


We use the usable rules processor.
We can deactivate the flags for all non-usable rules [FROCOS05]

Rules which have been flagged as non usable in this step:

   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_stateIII -> 1 : stateIII
   encode_stateIOO -> 1 : stateIOO
   encode_stateO -> 1 : stateO
   encode_stateOO -> 1 : stateOO
   encode_stateII -> 1 : stateII
   encode_stateI -> 1 : stateI
   encode_stateOI -> 1 : stateOI
   encode_dice -> 1 : dice
   encode_O -> 1 : O
   encode_stateOII -> 1 : stateOII
   encode_stateIO -> 1 : stateIO
   encode_stateOOO -> 1 : stateOOO
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_stateOOI -> 1 : stateOOI
   encode_stateIOI -> 1 : stateIOI

----------------------------------------

(50)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(cons_dice) -> 1 : dice
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   stateIII -> 1 : O
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateOII -> 1 : s(s(s(O)))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOOI -> 1 : s(s(s(s(O))))
   stateOOO -> 1 : s(s(s(s(s(O)))))
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateIOI -> 1 : s(O)
   stateIOO -> 1 : s(s(O))
   walk(s(s(s(O)))) -> 1 : walk(dice)
   dice -> 1 / 2 : stateI || 1 / 2 : stateO

Rules with annotation in P:

   ENCARG(cons_dice) -> 1 : DICE
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   DICE -> 1 / 2 : stateI || 1 / 2 : STATEO
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_stateO) -> 1 : STATEO
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : stateOO
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEOI -> 1 : STATEOI
   ENCODE_STATEO -> 1 : STATEO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   STATEOI -> 1 / 2 : stateOII || 1 / 2 : STATEO
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation in S:

   STATEO -> 1 / 2 : STATEOI || 1 / 2 : stateOO
   STATEOI -> 1 / 2 : stateOII || 1 / 2 : STATEO

Rules with annotation and a known complexity:

   ENCARG(cons_stateO) -> 1 : STATEO
   ENCARG(cons_dice) -> 1 : DICE
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEOI -> 1 : STATEOI
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   ENCODE_STATEO -> 1 : STATEO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   DICE -> 1 / 2 : stateI || 1 / 2 : STATEO
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))


----------------------------------------

(51) CpxADP_ReductionPairProof (UPPER BOUND(ADD(EXP)))


We use the reduction pair processor.
The following pairs can be oriented strictly and are moved from S:

   ENCARG(cons_stateO) -> 1 : STATEO
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : stateOO
   ENCARG(cons_dice) -> 1 : DICE
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEOI -> 1 : STATEOI
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   ENCODE_STATEO -> 1 : STATEO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

The remaining pairs can at least be oriented weakly:

   DICE -> 1 / 2 : stateI || 1 / 2 : STATEO
   STATEOI -> 1 / 2 : stateOII || 1 / 2 : STATEO
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))

Used ordering:Polynomial interpretation [POLO]:

   POL(DICE) = 1
   POL(ENCARG(x_1)) = 4 + x_1
   POL(ENCODE_DICE) = 4
   POL(ENCODE_O) = 0
   POL(ENCODE_S(x_1)) = 8 + 6*x_1
   POL(ENCODE_STATEI) = 0
   POL(ENCODE_STATEII) = 0
   POL(ENCODE_STATEIII) = 0
   POL(ENCODE_STATEIO) = 0
   POL(ENCODE_STATEIOI) = 0
   POL(ENCODE_STATEIOO) = 0
   POL(ENCODE_STATEO) = 4
   POL(ENCODE_STATEOI) = 8
   POL(ENCODE_STATEOII) = 0
   POL(ENCODE_STATEOO) = 0
   POL(ENCODE_STATEOOI) = 0
   POL(ENCODE_STATEOOO) = 0
   POL(ENCODE_WALK(x_1)) = 7 + 10*x_1
   POL(O) = 0
   POL(STATEI) = 0
   POL(STATEII) = 0
   POL(STATEIII) = 0
   POL(STATEIO) = 0
   POL(STATEIOI) = 0
   POL(STATEIOO) = 0
   POL(STATEO) = 2
   POL(STATEOI) = 1
   POL(STATEOII) = 0
   POL(STATEOO) = 0
   POL(STATEOOI) = 0
   POL(STATEOOO) = 0
   POL(WALK(x_1)) = 8*x_1
   POL(cons_dice) = 5
   POL(cons_stateI) = 8
   POL(cons_stateII) = 6
   POL(cons_stateIII) = 0
   POL(cons_stateIO) = 3
   POL(cons_stateIOI) = 4
   POL(cons_stateIOO) = 8
   POL(cons_stateO) = 8
   POL(cons_stateOI) = 8
   POL(cons_stateOII) = 8
   POL(cons_stateOO) = 9
   POL(cons_stateOOI) = 8
   POL(cons_stateOOO) = 10
   POL(cons_walk(x_1)) = 10*x_1
   POL(dice) = 5
   POL(encArg(x_1)) = x_1
   POL(s(x_1)) = 2 + x_1
   POL(stateI) = 2
   POL(stateII) = 1
   POL(stateIII) = 0
   POL(stateIO) = 3
   POL(stateIOI) = 2
   POL(stateIOO) = 4
   POL(stateO) = 8
   POL(stateOI) = 7
   POL(stateOII) = 6
   POL(stateOO) = 9
   POL(stateOOI) = 8
   POL(stateOOO) = 10
   POL(walk(x_1)) = 0

The complexity of the removed ADPs is bounded by:EXP
----------------------------------------

(52)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(cons_dice) -> 1 : dice
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   stateIII -> 1 : O
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateOII -> 1 : s(s(s(O)))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOOI -> 1 : s(s(s(s(O))))
   stateOOO -> 1 : s(s(s(s(s(O)))))
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateIOI -> 1 : s(O)
   stateIOO -> 1 : s(s(O))
   walk(s(s(s(O)))) -> 1 : walk(dice)
   dice -> 1 / 2 : stateI || 1 / 2 : stateO

Rules with annotation in P:

   ENCARG(cons_dice) -> 1 : DICE
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   DICE -> 1 / 2 : stateI || 1 / 2 : STATEO
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_stateO) -> 1 : STATEO
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : stateOO
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEOI -> 1 : STATEOI
   ENCODE_STATEO -> 1 : STATEO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   STATEOI -> 1 / 2 : stateOII || 1 / 2 : STATEO
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation in S:

   STATEOI -> 1 / 2 : stateOII || 1 / 2 : STATEO

Rules with annotation and a known complexity:

   ENCARG(cons_dice) -> 1 : DICE
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   DICE -> 1 / 2 : stateI || 1 / 2 : STATEO
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_stateO) -> 1 : STATEO
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : stateOO
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEOI -> 1 : STATEOI
   ENCODE_STATEO -> 1 : STATEO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))


----------------------------------------

(53) CpxADP_KnowledgePropagationProof (BOTH BOUNDS(ID, ID))


We use the knowledge propagation processor .
We can remove rules from S, if in the dependency graph no predecessor is in S (all predecessors have a known complexity bound).

Following rules are removed from S:

   STATEOI -> 1 / 2 : stateOII || 1 / 2 : STATEO

----------------------------------------

(54)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(cons_dice) -> 1 : dice
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   stateIII -> 1 : O
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateOII -> 1 : s(s(s(O)))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOOI -> 1 : s(s(s(s(O))))
   stateOOO -> 1 : s(s(s(s(s(O)))))
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateIOI -> 1 : s(O)
   stateIOO -> 1 : s(s(O))
   walk(s(s(s(O)))) -> 1 : walk(dice)
   dice -> 1 / 2 : stateI || 1 / 2 : stateO

Rules with annotation in P:

   ENCARG(cons_dice) -> 1 : DICE
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   DICE -> 1 / 2 : stateI || 1 / 2 : STATEO
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_stateO) -> 1 : STATEO
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : stateOO
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEOI -> 1 : STATEOI
   ENCODE_STATEO -> 1 : STATEO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   STATEOI -> 1 / 2 : stateOII || 1 / 2 : STATEO
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation in S:

   none

Rules with annotation and a known complexity:

   ENCARG(cons_dice) -> 1 : DICE
   WALK(s(s(s(O)))) -> 1 : WALK(DICE)
   DICE -> 1 / 2 : stateI || 1 / 2 : STATEO
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_stateO) -> 1 : STATEO
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : stateOO
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEOI -> 1 : STATEOI
   ENCODE_STATEO -> 1 : STATEO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   STATEOI -> 1 / 2 : stateOII || 1 / 2 : STATEO
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))


----------------------------------------

(55) SisEmptyProof (FINISHED)


S contains no annotations anymore. Hence, there exists no P-CT with infinitely many S-Nodes.
Resulting upper bound: O(1)

----------------------------------------

(56)
BOUNDS(1, 1)
