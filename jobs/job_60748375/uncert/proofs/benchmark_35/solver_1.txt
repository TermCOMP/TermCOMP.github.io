SAST
proof of /home/ff862203/input_ELCNZdluhG.ari
# AProVE Commit ID: 1c9e2a6453f9f0dca490585733f1cff3767d3e54 jan-christoph 20250828 unpublished


Complexity of the given CpxPTRS could be proven:

(0) CpxPTRS
(1) CpxPTRS_ToInnermostProof [BOTH BOUNDS(ID, ID), 0 ms]
(2) CpxPTRS
(3) CpxPTRS_DerivationToRuntimeComplexityProof [UNSOUND LOWER BOUND(ID)SOUND UPPER BOUND(ID), 0 ms]
(4) CpxPTRS
(5) CpxPTRS_ToPQTRSProof [BOTH BOUNDS(ID, ID), 0 ms]
(6) PQTRS
(7) CpxPQTRS_ToADPProblemProof [BOTH BOUNDS(ID, ID), 27 ms]
(8) ADP
(9) CpxADP_SCCSplitProof [UPPER BOUND(ID), 0 ms]
(10) MAX
    (11) ADP
        (12) CpxADP_UsableTermsProof [UPPER BOUND(ID), 0 ms]
        (13) ADP
        (14) CpxADP_UsableRulesProof [BOTH BOUNDS(ID, ID), 0 ms]
        (15) ADP
        (16) CpxADP_ProbabilityRemovalProof [UPPER BOUND(ID), 0 ms]
        (17) CdtProblem
        (18) CdtLeafRemovalProof [ComplexityIfPolyImplication, 1 ms]
        (19) CdtProblem
        (20) CdtToCpxRelTrsProof [BOTH BOUNDS(ID, ID), 0 ms]
        (21) CpxTRS
        (22) RelTrsToTrsProof [UPPER BOUND(ID), 0 ms]
        (23) CpxTRS
        (24) CpxTrsMatchBoundsProof [FINISHED, 0 ms]
        (25) BOUNDS(1, n^1)
    (26) ADP
        (27) CpxADP_UsableTermsProof [UPPER BOUND(ID), 0 ms]
        (28) ADP
        (29) CpxADP_UsableRulesProof [BOTH BOUNDS(ID, ID), 0 ms]
        (30) ADP
        (31) CpxADP_ReductionPairProof [UPPER BOUND(ADD(n^1)), 0 ms]
        (32) ADP
        (33) CpxADP_KnowledgePropagationProof [BOTH BOUNDS(ID, ID), 0 ms]
        (34) ADP
        (35) CpxADP_KnowledgePropagationProof [BOTH BOUNDS(ID, ID), 0 ms]
        (36) ADP
        (37) CpxADP_ReductionPairProof [UPPER BOUND(ADD(n^1)), 6 ms]
        (38) ADP
        (39) CpxADP_ReductionPairProof [UPPER BOUND(ADD(n^1)), 6 ms]
        (40) ADP
        (41) CpxADP_ReductionPairProof [UPPER BOUND(ADD(EXP)), 17 ms]
        (42) ADP
        (43) SisEmptyProof [FINISHED, 0 ms]
        (44) BOUNDS(1, 1)


----------------------------------------

(0)
Obligation:
Probabilistic term rewrite system:
The TRS has the following probabilistic rules:

   walk(a) -> 1 / 2 : walk(a) || 1 / 2 : walk(b)
   walk(d) -> 1 / 4 : walk(a) || 1 / 4 : walk(e) || 1 / 4 : walk(f) || 1 / 4 : walk(g)
   walk(e) -> 1 : walk(f)
   walk(f) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(c) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(b) -> 1 / 2 : walk(a) || 1 / 2 : walk(c)

and uses the full rewrite strategy.

----------------------------------------

(1) CpxPTRS_ToInnermostProof (BOTH BOUNDS(ID, ID))
Switched from non-innermost to innermost rewriting[FoSSaCS24].

The system is non-overlapping, left-linear and right-linear, so its complexity is the same as its innermost complexity.


----------------------------------------

(2)
Obligation:
Probabilistic term rewrite system:
The TRS has the following probabilistic rules:

   walk(a) -> 1 / 2 : walk(a) || 1 / 2 : walk(b)
   walk(d) -> 1 / 4 : walk(a) || 1 / 4 : walk(e) || 1 / 4 : walk(f) || 1 / 4 : walk(g)
   walk(e) -> 1 : walk(f)
   walk(f) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(c) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(b) -> 1 / 2 : walk(a) || 1 / 2 : walk(c)

and uses the innermost rewrite strategy.

----------------------------------------

(3) CpxPTRS_DerivationToRuntimeComplexityProof (UNSOUND LOWER BOUND(ID)SOUND UPPER BOUND(ID))
The following rules have been added to R to convert the given derivational complexity problem to a runtime complexity problem:

   encArg(e) -> 1 : e
   encArg(f) -> 1 : f
   encArg(b) -> 1 : b
   encArg(c) -> 1 : c
   encArg(d) -> 1 : d
   encArg(g) -> 1 : g
   encArg(a) -> 1 : a
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_e -> 1 : e
   encode_f -> 1 : f
   encode_b -> 1 : b
   encode_c -> 1 : c
   encode_d -> 1 : d
   encode_g -> 1 : g
   encode_a -> 1 : a


----------------------------------------

(4)
Obligation:
Probabilistic term rewrite system:
The TRS has the following probabilistic rules:

   encArg(e) -> 1 : e
   encArg(f) -> 1 : f
   encArg(b) -> 1 : b
   encArg(c) -> 1 : c
   encArg(d) -> 1 : d
   encArg(g) -> 1 : g
   encArg(a) -> 1 : a
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_e -> 1 : e
   encode_f -> 1 : f
   encode_b -> 1 : b
   encode_c -> 1 : c
   encode_d -> 1 : d
   encode_g -> 1 : g
   encode_a -> 1 : a
   walk(a) -> 1 / 2 : walk(a) || 1 / 2 : walk(b)
   walk(d) -> 1 / 4 : walk(a) || 1 / 4 : walk(e) || 1 / 4 : walk(f) || 1 / 4 : walk(g)
   walk(e) -> 1 : walk(f)
   walk(f) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(c) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(b) -> 1 / 2 : walk(a) || 1 / 2 : walk(c)

and uses the innermost rewrite strategy.

----------------------------------------

(5) CpxPTRS_ToPQTRSProof (BOTH BOUNDS(ID, ID))
Transformed PTRS into PQTRS. Q is:
   encArg(e), encArg(f), encArg(b), encArg(c), encArg(d), encArg(g), encArg(a), encArg(cons_walk(x_1)), encode_walk(x_1), encode_e, encode_f, encode_b, encode_c, encode_d, encode_g, encode_a, walk(a), walk(d), walk(e), walk(f), walk(c), walk(b)
----------------------------------------

(6)
Obligation:
Probabilistic Q term rewrite system:
The PQTRS has the following probabilistic rules:

   encArg(e) -> 1 : e
   encArg(f) -> 1 : f
   encArg(b) -> 1 : b
   encArg(c) -> 1 : c
   encArg(d) -> 1 : d
   encArg(g) -> 1 : g
   encArg(a) -> 1 : a
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_e -> 1 : e
   encode_f -> 1 : f
   encode_b -> 1 : b
   encode_c -> 1 : c
   encode_d -> 1 : d
   encode_g -> 1 : g
   encode_a -> 1 : a
   walk(a) -> 1 / 2 : walk(a) || 1 / 2 : walk(b)
   walk(d) -> 1 / 4 : walk(a) || 1 / 4 : walk(e) || 1 / 4 : walk(f) || 1 / 4 : walk(g)
   walk(e) -> 1 : walk(f)
   walk(f) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(c) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(b) -> 1 / 2 : walk(a) || 1 / 2 : walk(c)

And Q contains the following terms:
   encArg(e), encArg(f), encArg(b), encArg(c), encArg(d), encArg(g), encArg(a), encArg(cons_walk(x0)), encode_walk(x0), encode_e, encode_f, encode_b, encode_c, encode_d, encode_g, encode_a, walk(a), walk(d), walk(e), walk(f), walk(c), walk(b)

----------------------------------------

(7) CpxPQTRS_ToADPProblemProof (BOTH BOUNDS(ID, ID))


The complexity of a PQTRS (R,Q) is equivalent to the complexity of the ADP Problem A(R) (Chain-Criterion) (Leon's master's thesis).
The ADPs are:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(e) -> 1 : e
   encArg(f) -> 1 : f
   encArg(b) -> 1 : b
   encArg(c) -> 1 : c
   encArg(d) -> 1 : d
   encArg(g) -> 1 : g
   encArg(a) -> 1 : a
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_e -> 1 : e
   encode_f -> 1 : f
   encode_b -> 1 : b
   encode_c -> 1 : c
   encode_d -> 1 : d
   encode_g -> 1 : g
   encode_a -> 1 : a
   walk(a) -> 1 / 2 : walk(a) || 1 / 2 : walk(b)
   walk(d) -> 1 / 4 : walk(a) || 1 / 4 : walk(e) || 1 / 4 : walk(f) || 1 / 4 : walk(g)
   walk(e) -> 1 : walk(f)
   walk(f) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(c) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(b) -> 1 / 2 : walk(a) || 1 / 2 : walk(c)

Rules with annotation in P:

   ENCARG(e) -> 1 : e
   ENCARG(f) -> 1 : f
   ENCARG(b) -> 1 : b
   ENCARG(c) -> 1 : c
   ENCARG(d) -> 1 : d
   ENCARG(g) -> 1 : g
   ENCARG(a) -> 1 : a
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_E -> 1 : e
   ENCODE_F -> 1 : f
   ENCODE_B -> 1 : b
   ENCODE_C -> 1 : c
   ENCODE_D -> 1 : d
   ENCODE_G -> 1 : g
   ENCODE_A -> 1 : a
   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : WALK(g)
   WALK(e) -> 1 : WALK(f)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)

Rules with annotation in S:

   ENCARG(e) -> 1 : e
   ENCARG(f) -> 1 : f
   ENCARG(b) -> 1 : b
   ENCARG(c) -> 1 : c
   ENCARG(d) -> 1 : d
   ENCARG(g) -> 1 : g
   ENCARG(a) -> 1 : a
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_E -> 1 : e
   ENCODE_F -> 1 : f
   ENCODE_B -> 1 : b
   ENCODE_C -> 1 : c
   ENCODE_D -> 1 : d
   ENCODE_G -> 1 : g
   ENCODE_A -> 1 : a
   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : WALK(g)
   WALK(e) -> 1 : WALK(f)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)

Rules with annotation and a known complexity:

   none

----------------------------------------

(8)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(e) -> 1 : e
   encArg(f) -> 1 : f
   encArg(b) -> 1 : b
   encArg(c) -> 1 : c
   encArg(d) -> 1 : d
   encArg(g) -> 1 : g
   encArg(a) -> 1 : a
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_e -> 1 : e
   encode_f -> 1 : f
   encode_b -> 1 : b
   encode_c -> 1 : c
   encode_d -> 1 : d
   encode_g -> 1 : g
   encode_a -> 1 : a
   walk(a) -> 1 / 2 : walk(a) || 1 / 2 : walk(b)
   walk(d) -> 1 / 4 : walk(a) || 1 / 4 : walk(e) || 1 / 4 : walk(f) || 1 / 4 : walk(g)
   walk(e) -> 1 : walk(f)
   walk(f) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(c) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(b) -> 1 / 2 : walk(a) || 1 / 2 : walk(c)

Rules with annotation in P:

   ENCARG(e) -> 1 : e
   ENCARG(f) -> 1 : f
   ENCARG(b) -> 1 : b
   ENCARG(c) -> 1 : c
   ENCARG(d) -> 1 : d
   ENCARG(g) -> 1 : g
   ENCARG(a) -> 1 : a
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_E -> 1 : e
   ENCODE_F -> 1 : f
   ENCODE_B -> 1 : b
   ENCODE_C -> 1 : c
   ENCODE_D -> 1 : d
   ENCODE_G -> 1 : g
   ENCODE_A -> 1 : a
   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : WALK(g)
   WALK(e) -> 1 : WALK(f)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)

Rules with annotation in S:

   ENCARG(e) -> 1 : e
   ENCARG(f) -> 1 : f
   ENCARG(b) -> 1 : b
   ENCARG(c) -> 1 : c
   ENCARG(d) -> 1 : d
   ENCARG(g) -> 1 : g
   ENCARG(a) -> 1 : a
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCODE_E -> 1 : e
   ENCODE_F -> 1 : f
   ENCODE_B -> 1 : b
   ENCODE_C -> 1 : c
   ENCODE_D -> 1 : d
   ENCODE_G -> 1 : g
   ENCODE_A -> 1 : a
   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : WALK(g)
   WALK(e) -> 1 : WALK(f)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)

Rules with annotation and a known complexity:

   none

----------------------------------------

(9) CpxADP_SCCSplitProof (UPPER BOUND(ID))
As part of the dependency graph processor, we can split problem in 2 new components.
----------------------------------------

(10)
Complex Obligation (MAX)

----------------------------------------

(11)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(e) -> 1 : e
   encArg(f) -> 1 : f
   encArg(b) -> 1 : b
   encArg(c) -> 1 : c
   encArg(d) -> 1 : d
   encArg(g) -> 1 : g
   encArg(a) -> 1 : a
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_e -> 1 : e
   encode_f -> 1 : f
   encode_b -> 1 : b
   encode_c -> 1 : c
   encode_d -> 1 : d
   encode_g -> 1 : g
   encode_a -> 1 : a
   walk(a) -> 1 / 2 : walk(a) || 1 / 2 : walk(b)
   walk(d) -> 1 / 4 : walk(a) || 1 / 4 : walk(e) || 1 / 4 : walk(f) || 1 / 4 : walk(g)
   walk(e) -> 1 : walk(f)
   walk(f) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(c) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(b) -> 1 / 2 : walk(a) || 1 / 2 : walk(c)

Rules with annotation in P:

   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))

Rules with annotation in S:

   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))

Rules with annotation and a known complexity:

   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))


----------------------------------------

(12) CpxADP_UsableTermsProof (UPPER BOUND(ID))


The approximation of the Dependency Graph  gives us the following unusable Terms: 
   WALK(encArg(x_1))
Hence, as part of the dependency graph processor, we can remove the annotations from these terms from every RHS of every ADP in P and S.

----------------------------------------

(13)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(e) -> 1 : e
   encArg(f) -> 1 : f
   encArg(b) -> 1 : b
   encArg(c) -> 1 : c
   encArg(d) -> 1 : d
   encArg(g) -> 1 : g
   encArg(a) -> 1 : a
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_e -> 1 : e
   encode_f -> 1 : f
   encode_b -> 1 : b
   encode_c -> 1 : c
   encode_d -> 1 : d
   encode_g -> 1 : g
   encode_a -> 1 : a
   walk(a) -> 1 / 2 : walk(a) || 1 / 2 : walk(b)
   walk(d) -> 1 / 4 : walk(a) || 1 / 4 : walk(e) || 1 / 4 : walk(f) || 1 / 4 : walk(g)
   walk(e) -> 1 : walk(f)
   walk(f) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(c) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(b) -> 1 / 2 : walk(a) || 1 / 2 : walk(c)

Rules with annotation in P:

   ENCODE_WALK(x_1) -> 1 : walk(ENCARG(x_1))
   ENCARG(cons_walk(x_1)) -> 1 : walk(ENCARG(x_1))

Rules with annotation in S:

   ENCARG(cons_walk(x_1)) -> 1 : walk(ENCARG(x_1))

Rules with annotation and a known complexity:

   ENCODE_WALK(x_1) -> 1 : walk(ENCARG(x_1))


----------------------------------------

(14) CpxADP_UsableRulesProof (BOTH BOUNDS(ID, ID))


We use the usable rules processor.
We can deactivate the flags for all non-usable rules [FROCOS05]

Rules which have been flagged as non usable in this step:

   encArg(e) -> 1 : e
   encode_f -> 1 : f
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encArg(f) -> 1 : f
   encode_d -> 1 : d
   encode_g -> 1 : g
   walk(d) -> 1 / 4 : walk(a) || 1 / 4 : walk(e) || 1 / 4 : walk(f) || 1 / 4 : walk(g)
   encArg(g) -> 1 : g
   encode_b -> 1 : b
   encArg(c) -> 1 : c
   walk(b) -> 1 / 2 : walk(a) || 1 / 2 : walk(c)
   encArg(d) -> 1 : d
   encode_a -> 1 : a
   encArg(b) -> 1 : b
   walk(a) -> 1 / 2 : walk(a) || 1 / 2 : walk(b)
   encArg(a) -> 1 : a
   encode_c -> 1 : c
   walk(e) -> 1 : walk(f)
   walk(f) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(c) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   encode_e -> 1 : e
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))

----------------------------------------

(15)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:
   none
Rules with annotation in P:

   ENCODE_WALK(x_1) -> 1 : walk(ENCARG(x_1))
   ENCARG(cons_walk(x_1)) -> 1 : walk(ENCARG(x_1))

Rules with annotation in S:

   ENCARG(cons_walk(x_1)) -> 1 : walk(ENCARG(x_1))

Rules with annotation and a known complexity:

   ENCODE_WALK(x_1) -> 1 : walk(ENCARG(x_1))


----------------------------------------

(16) CpxADP_ProbabilityRemovalProof (UPPER BOUND(ID))


We use the probability removal processor to move to dependecy tuples without probabilities.
As all rules have a trivial probability (1:r), we can transform it into a non-probabilistic DT problem

----------------------------------------

(17)
Obligation:
Complexity Dependency Tuples Problem

Rules:none
Tuples:
   ENCODE_WALK(x_1) -> c(ENCARG(x_1))
   ENCARG(cons_walk(x_1)) -> c1(ENCARG(x_1))
S tuples:
   ENCODE_WALK(x_1) -> c(ENCARG(x_1))
   ENCARG(cons_walk(x_1)) -> c1(ENCARG(x_1))
K tuples:none
Defined Rule Symbols:   encArg_1, encode_walk_1, encode_e, encode_f, encode_b, encode_c, encode_d, encode_g, encode_a, walk_1

Defined Pair Symbols:none

Compound Symbols:   c_1, c1_1


----------------------------------------

(18) CdtLeafRemovalProof (ComplexityIfPolyImplication)
Removed 1 leading nodes:
   ENCODE_WALK(x_1) -> c(ENCARG(x_1))

----------------------------------------

(19)
Obligation:
Complexity Dependency Tuples Problem

Rules:none
Tuples:
   ENCARG(cons_walk(x_1)) -> c1(ENCARG(x_1))
S tuples:
   ENCARG(cons_walk(x_1)) -> c1(ENCARG(x_1))
K tuples:none
Defined Rule Symbols:   encArg_1, encode_walk_1, encode_e, encode_f, encode_b, encode_c, encode_d, encode_g, encode_a, walk_1

Defined Pair Symbols:   ENCARG_1

Compound Symbols:   c1_1


----------------------------------------

(20) CdtToCpxRelTrsProof (BOTH BOUNDS(ID, ID))
Converted S to standard rules, and D \ S as well as R to relative rules.
----------------------------------------

(21)
Obligation:
The Runtime Complexity (innermost) of the given CpxTRS could be proven to be BOUNDS(1, n^1).


The TRS R consists of the following rules:

   ENCARG(cons_walk(x_1)) -> c1(ENCARG(x_1))

S is empty.
Rewrite Strategy: INNERMOST
----------------------------------------

(22) RelTrsToTrsProof (UPPER BOUND(ID))
transformed relative TRS to TRS
----------------------------------------

(23)
Obligation:
The Runtime Complexity (innermost) of the given CpxTRS could be proven to be BOUNDS(1, n^1).


The TRS R consists of the following rules:

   ENCARG(cons_walk(x_1)) -> c1(ENCARG(x_1))

S is empty.
Rewrite Strategy: INNERMOST
----------------------------------------

(24) CpxTrsMatchBoundsProof (FINISHED)
A linear upper bound on the runtime complexity of the TRS R could be shown with a Match Bound [MATCHBOUNDS1,MATCHBOUNDS2] of 1. 
The certificate found is represented by the following graph.

"[390, 391, 399]
{(390,391,[ENCARG_1|0]), (390,399,[c1_1|1]), (391,391,[cons_walk_1|0, c1_1|0]), (399,391,[ENCARG_1|1]), (399,399,[c1_1|1])}"
----------------------------------------

(25)
BOUNDS(1, n^1)

----------------------------------------

(26)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(e) -> 1 : e
   encArg(f) -> 1 : f
   encArg(b) -> 1 : b
   encArg(c) -> 1 : c
   encArg(d) -> 1 : d
   encArg(g) -> 1 : g
   encArg(a) -> 1 : a
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_e -> 1 : e
   encode_f -> 1 : f
   encode_b -> 1 : b
   encode_c -> 1 : c
   encode_d -> 1 : d
   encode_g -> 1 : g
   encode_a -> 1 : a
   walk(a) -> 1 / 2 : walk(a) || 1 / 2 : walk(b)
   walk(d) -> 1 / 4 : walk(a) || 1 / 4 : walk(e) || 1 / 4 : walk(f) || 1 / 4 : walk(g)
   walk(e) -> 1 : walk(f)
   walk(f) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(c) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(b) -> 1 / 2 : walk(a) || 1 / 2 : walk(c)

Rules with annotation in P:

   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)
   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : WALK(g)
   WALK(e) -> 1 : WALK(f)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)

Rules with annotation in S:

   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)
   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : WALK(g)
   WALK(e) -> 1 : WALK(f)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)

Rules with annotation and a known complexity:

   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))


----------------------------------------

(27) CpxADP_UsableTermsProof (UPPER BOUND(ID))


The approximation of the Dependency Graph  gives us the following unusable Terms: 
   WALK(g)
Hence, as part of the dependency graph processor, we can remove the annotations from these terms from every RHS of every ADP in P and S.

----------------------------------------

(28)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(e) -> 1 : e
   encArg(f) -> 1 : f
   encArg(b) -> 1 : b
   encArg(c) -> 1 : c
   encArg(d) -> 1 : d
   encArg(g) -> 1 : g
   encArg(a) -> 1 : a
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_e -> 1 : e
   encode_f -> 1 : f
   encode_b -> 1 : b
   encode_c -> 1 : c
   encode_d -> 1 : d
   encode_g -> 1 : g
   encode_a -> 1 : a
   walk(a) -> 1 / 2 : walk(a) || 1 / 2 : walk(b)
   walk(d) -> 1 / 4 : walk(a) || 1 / 4 : walk(e) || 1 / 4 : walk(f) || 1 / 4 : walk(g)
   walk(e) -> 1 : walk(f)
   walk(f) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(c) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(b) -> 1 / 2 : walk(a) || 1 / 2 : walk(c)

Rules with annotation in P:

   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : walk(g)
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   WALK(e) -> 1 : WALK(f)

Rules with annotation in S:

   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : walk(g)
   WALK(e) -> 1 : WALK(f)

Rules with annotation and a known complexity:

   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))


----------------------------------------

(29) CpxADP_UsableRulesProof (BOTH BOUNDS(ID, ID))


We use the usable rules processor.
We can deactivate the flags for all non-usable rules [FROCOS05]

Rules which have been flagged as non usable in this step:

   encode_f -> 1 : f
   encode_walk(x_1) -> 1 : walk(encArg(x_1))
   encode_d -> 1 : d
   encode_g -> 1 : g
   encode_c -> 1 : c
   encode_e -> 1 : e
   encode_b -> 1 : b
   encode_a -> 1 : a

----------------------------------------

(30)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(e) -> 1 : e
   encArg(f) -> 1 : f
   encArg(b) -> 1 : b
   encArg(c) -> 1 : c
   encArg(d) -> 1 : d
   encArg(g) -> 1 : g
   encArg(a) -> 1 : a
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   walk(b) -> 1 / 2 : walk(a) || 1 / 2 : walk(c)
   walk(a) -> 1 / 2 : walk(a) || 1 / 2 : walk(b)
   walk(c) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(d) -> 1 / 4 : walk(a) || 1 / 4 : walk(e) || 1 / 4 : walk(f) || 1 / 4 : walk(g)
   walk(e) -> 1 : walk(f)
   walk(f) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)

Rules with annotation in P:

   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : walk(g)
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   WALK(e) -> 1 : WALK(f)

Rules with annotation in S:

   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : walk(g)
   WALK(e) -> 1 : WALK(f)

Rules with annotation and a known complexity:

   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))


----------------------------------------

(31) CpxADP_ReductionPairProof (UPPER BOUND(ADD(n^1)))


We use the reduction pair processor.
The following pairs can be oriented strictly and are moved from S:

   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : walk(g)

The remaining pairs can at least be oriented weakly:

   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   WALK(e) -> 1 : WALK(f)

Used ordering:Polynomial interpretation [POLO]:

   POL(ENCARG(x_1)) = x_1
   POL(ENCODE_A) = 0
   POL(ENCODE_B) = 0
   POL(ENCODE_C) = 0
   POL(ENCODE_D) = 0
   POL(ENCODE_E) = 0
   POL(ENCODE_F) = 0
   POL(ENCODE_G) = 0
   POL(ENCODE_WALK(x_1)) = 1 + x_1
   POL(WALK(x_1)) = 1
   POL(a) = 0
   POL(b) = 0
   POL(c) = 0
   POL(cons_walk(x_1)) = 1 + x_1
   POL(d) = 0
   POL(e) = 0
   POL(encArg(x_1)) = 1 + x_1
   POL(f) = 0
   POL(g) = 1
   POL(walk(x_1)) = 1

The complexity of the removed ADPs is bounded by:n^1
----------------------------------------

(32)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(e) -> 1 : e
   encArg(f) -> 1 : f
   encArg(b) -> 1 : b
   encArg(c) -> 1 : c
   encArg(d) -> 1 : d
   encArg(g) -> 1 : g
   encArg(a) -> 1 : a
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   walk(b) -> 1 / 2 : walk(a) || 1 / 2 : walk(c)
   walk(a) -> 1 / 2 : walk(a) || 1 / 2 : walk(b)
   walk(c) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(d) -> 1 / 4 : walk(a) || 1 / 4 : walk(e) || 1 / 4 : walk(f) || 1 / 4 : walk(g)
   walk(e) -> 1 : walk(f)
   walk(f) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)

Rules with annotation in P:

   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : walk(g)
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   WALK(e) -> 1 : WALK(f)

Rules with annotation in S:

   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)
   WALK(e) -> 1 : WALK(f)

Rules with annotation and a known complexity:

   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : walk(g)
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))


----------------------------------------

(33) CpxADP_KnowledgePropagationProof (BOTH BOUNDS(ID, ID))


We use the knowledge propagation processor .
We can remove rules from S, if in the dependency graph no predecessor is in S (all predecessors have a known complexity bound).

Following rules are removed from S:

   WALK(e) -> 1 : WALK(f)

----------------------------------------

(34)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(e) -> 1 : e
   encArg(f) -> 1 : f
   encArg(b) -> 1 : b
   encArg(c) -> 1 : c
   encArg(d) -> 1 : d
   encArg(g) -> 1 : g
   encArg(a) -> 1 : a
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   walk(b) -> 1 / 2 : walk(a) || 1 / 2 : walk(c)
   walk(a) -> 1 / 2 : walk(a) || 1 / 2 : walk(b)
   walk(c) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(d) -> 1 / 4 : walk(a) || 1 / 4 : walk(e) || 1 / 4 : walk(f) || 1 / 4 : walk(g)
   walk(e) -> 1 : walk(f)
   walk(f) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)

Rules with annotation in P:

   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : walk(g)
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   WALK(e) -> 1 : WALK(f)

Rules with annotation in S:

   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)

Rules with annotation and a known complexity:

   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : walk(g)
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   WALK(e) -> 1 : WALK(f)


----------------------------------------

(35) CpxADP_KnowledgePropagationProof (BOTH BOUNDS(ID, ID))


We use the knowledge propagation processor .
We can remove rules from S, if in the dependency graph no predecessor is in S (all predecessors have a known complexity bound).

Following rules are removed from S:

   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)

----------------------------------------

(36)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(e) -> 1 : e
   encArg(f) -> 1 : f
   encArg(b) -> 1 : b
   encArg(c) -> 1 : c
   encArg(d) -> 1 : d
   encArg(g) -> 1 : g
   encArg(a) -> 1 : a
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   walk(b) -> 1 / 2 : walk(a) || 1 / 2 : walk(c)
   walk(a) -> 1 / 2 : walk(a) || 1 / 2 : walk(b)
   walk(c) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(d) -> 1 / 4 : walk(a) || 1 / 4 : walk(e) || 1 / 4 : walk(f) || 1 / 4 : walk(g)
   walk(e) -> 1 : walk(f)
   walk(f) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)

Rules with annotation in P:

   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : walk(g)
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   WALK(e) -> 1 : WALK(f)

Rules with annotation in S:

   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)

Rules with annotation and a known complexity:

   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : walk(g)
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   WALK(e) -> 1 : WALK(f)


----------------------------------------

(37) CpxADP_ReductionPairProof (UPPER BOUND(ADD(n^1)))


We use the reduction pair processor.
The following pairs can be oriented strictly and are moved from S:

   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : walk(g)

The remaining pairs can at least be oriented weakly:

   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   WALK(e) -> 1 : WALK(f)

Used ordering:Polynomial interpretation [POLO]:

   POL(ENCARG(x_1)) = x_1
   POL(ENCODE_A) = 0
   POL(ENCODE_B) = 0
   POL(ENCODE_C) = 0
   POL(ENCODE_D) = 0
   POL(ENCODE_E) = 0
   POL(ENCODE_F) = 0
   POL(ENCODE_G) = 0
   POL(ENCODE_WALK(x_1)) = 10 + 9*x_1
   POL(WALK(x_1)) = 6 + x_1
   POL(a) = 1
   POL(b) = 1
   POL(c) = 1
   POL(cons_walk(x_1)) = 10 + x_1
   POL(d) = 0
   POL(e) = 2
   POL(encArg(x_1)) = 4
   POL(f) = 2
   POL(g) = 2
   POL(walk(x_1)) = 4

The complexity of the removed ADPs is bounded by:n^1
----------------------------------------

(38)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(e) -> 1 : e
   encArg(f) -> 1 : f
   encArg(b) -> 1 : b
   encArg(c) -> 1 : c
   encArg(d) -> 1 : d
   encArg(g) -> 1 : g
   encArg(a) -> 1 : a
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   walk(b) -> 1 / 2 : walk(a) || 1 / 2 : walk(c)
   walk(a) -> 1 / 2 : walk(a) || 1 / 2 : walk(b)
   walk(c) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(d) -> 1 / 4 : walk(a) || 1 / 4 : walk(e) || 1 / 4 : walk(f) || 1 / 4 : walk(g)
   walk(e) -> 1 : walk(f)
   walk(f) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)

Rules with annotation in P:

   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : walk(g)
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   WALK(e) -> 1 : WALK(f)

Rules with annotation in S:

   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)

Rules with annotation and a known complexity:

   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : walk(g)
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   WALK(e) -> 1 : WALK(f)


----------------------------------------

(39) CpxADP_ReductionPairProof (UPPER BOUND(ADD(n^1)))


We use the reduction pair processor.
The following pairs can be oriented strictly and are moved from S:

   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   WALK(e) -> 1 : WALK(f)

The remaining pairs can at least be oriented weakly:

   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : walk(g)

Used ordering:Polynomial interpretation [POLO]:

   POL(ENCARG(x_1)) = x_1
   POL(ENCODE_A) = 0
   POL(ENCODE_B) = 0
   POL(ENCODE_C) = 0
   POL(ENCODE_D) = 0
   POL(ENCODE_E) = 0
   POL(ENCODE_F) = 0
   POL(ENCODE_G) = 0
   POL(ENCODE_WALK(x_1)) = 10 + 7*x_1
   POL(WALK(x_1)) = 5 + x_1
   POL(a) = 2
   POL(b) = 2
   POL(c) = 1
   POL(cons_walk(x_1)) = 8 + x_1
   POL(d) = 0
   POL(e) = 2
   POL(encArg(x_1)) = 2
   POL(f) = 1
   POL(g) = 0
   POL(walk(x_1)) = 0

The complexity of the removed ADPs is bounded by:n^1
----------------------------------------

(40)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(e) -> 1 : e
   encArg(f) -> 1 : f
   encArg(b) -> 1 : b
   encArg(c) -> 1 : c
   encArg(d) -> 1 : d
   encArg(g) -> 1 : g
   encArg(a) -> 1 : a
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   walk(b) -> 1 / 2 : walk(a) || 1 / 2 : walk(c)
   walk(a) -> 1 / 2 : walk(a) || 1 / 2 : walk(b)
   walk(c) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(d) -> 1 / 4 : walk(a) || 1 / 4 : walk(e) || 1 / 4 : walk(f) || 1 / 4 : walk(g)
   walk(e) -> 1 : walk(f)
   walk(f) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)

Rules with annotation in P:

   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : walk(g)
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   WALK(e) -> 1 : WALK(f)

Rules with annotation in S:

   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)

Rules with annotation and a known complexity:

   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : walk(g)
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   WALK(e) -> 1 : WALK(f)


----------------------------------------

(41) CpxADP_ReductionPairProof (UPPER BOUND(ADD(EXP)))


We use the reduction pair processor.
The following pairs can be oriented strictly and are moved from S:

   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))

The remaining pairs can at least be oriented weakly:

   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : walk(g)
   WALK(e) -> 1 : WALK(f)

Used ordering:Polynomial interpretation [POLO]:

   POL(ENCARG(x_1)) = x_1
   POL(ENCODE_A) = 0
   POL(ENCODE_B) = 0
   POL(ENCODE_C) = 0
   POL(ENCODE_D) = 0
   POL(ENCODE_E) = 0
   POL(ENCODE_F) = 0
   POL(ENCODE_G) = 0
   POL(ENCODE_WALK(x_1)) = 9 + 7*x_1
   POL(WALK(x_1)) = 8 + x_1
   POL(a) = 4
   POL(b) = 3
   POL(c) = 2
   POL(cons_walk(x_1)) = 8 + 8*x_1
   POL(d) = 0
   POL(e) = 2
   POL(encArg(x_1)) = 2*x_1
   POL(f) = 2
   POL(g) = 0
   POL(walk(x_1)) = 4

The complexity of the removed ADPs is bounded by:EXP
----------------------------------------

(42)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(e) -> 1 : e
   encArg(f) -> 1 : f
   encArg(b) -> 1 : b
   encArg(c) -> 1 : c
   encArg(d) -> 1 : d
   encArg(g) -> 1 : g
   encArg(a) -> 1 : a
   encArg(cons_walk(x_1)) -> 1 : walk(encArg(x_1))
   walk(b) -> 1 / 2 : walk(a) || 1 / 2 : walk(c)
   walk(a) -> 1 / 2 : walk(a) || 1 / 2 : walk(b)
   walk(c) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)
   walk(d) -> 1 / 4 : walk(a) || 1 / 4 : walk(e) || 1 / 4 : walk(f) || 1 / 4 : walk(g)
   walk(e) -> 1 : walk(f)
   walk(f) -> 1 / 2 : walk(a) || 1 / 2 : walk(d)

Rules with annotation in P:

   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : walk(g)
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   WALK(e) -> 1 : WALK(f)

Rules with annotation in S:

   none

Rules with annotation and a known complexity:

   WALK(a) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(b)
   WALK(c) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(f) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(d)
   WALK(b) -> 1 / 2 : WALK(a) || 1 / 2 : WALK(c)
   ENCARG(cons_walk(x_1)) -> 1 : WALK(ENCARG(x_1))
   WALK(d) -> 1 / 4 : WALK(a) || 1 / 4 : WALK(e) || 1 / 4 : WALK(f) || 1 / 4 : walk(g)
   ENCODE_WALK(x_1) -> 1 : WALK(ENCARG(x_1))
   WALK(e) -> 1 : WALK(f)


----------------------------------------

(43) SisEmptyProof (FINISHED)


S contains no annotations anymore. Hence, there exists no P-CT with infinitely many S-Nodes.
Resulting upper bound: O(1)

----------------------------------------

(44)
BOUNDS(1, 1)
