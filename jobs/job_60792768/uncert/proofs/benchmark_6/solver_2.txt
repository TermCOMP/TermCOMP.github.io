YES

Problem 1: 

(VAR vu95NonEmpty X Y Z)
(STRATEGY CONTEXTSENSITIVE
(add 1)
(and 1)
(first 1 2)
(from)
(if 1)
(num0)
(cons)
(fSNonEmpty)
(ffalse)
(nil)
(s)
(ftrue)
)
(RULES
add(num0,X) -> X
add(s(X),Y) -> s(add(X,Y))
and(ffalse,Y) -> ffalse
and(ftrue,X) -> X
first(num0,X) -> nil
first(s(X),cons(Y,Z)) -> cons(Y,first(X,Z))
from(X) -> cons(X,from(s(X)))
if(ffalse,X,Y) -> Y
if(ftrue,X,Y) -> X
)


Problem 1: 

Innermost Equivalent Processor:
-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 and(ffalse,Y) -> ffalse
 and(ftrue,X) -> X
 first(num0,X) -> nil
 first(s(X),cons(Y,Z)) -> cons(Y,first(X,Z))
 from(X) -> cons(X,from(s(X)))
 if(ffalse,X,Y) -> Y
 if(ftrue,X,Y) -> X
-> The context-sensitive term rewriting system is an orthogonal system. Therefore, innermost cs-termination implies cs-termination.
 

Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 ADD(num0,X) -> X
 AND(ftrue,X) -> X
 IF(ffalse,X,Y) -> Y
 IF(ftrue,X,Y) -> X
-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 and(ffalse,Y) -> ffalse
 and(ftrue,X) -> X
 first(num0,X) -> nil
 first(s(X),cons(Y,Z)) -> cons(Y,first(X,Z))
 from(X) -> cons(X,from(s(X)))
 if(ffalse,X,Y) -> Y
 if(ftrue,X,Y) -> X
-> Unhiding Rules:
 add(X,Y) -> ADD(X,Y)
 add(x4,Y) -> x4
 first(X,Z) -> FIRST(X,Z)
 first(X,x4) -> x4
 first(x4,Z) -> x4
 from(s(X)) -> FROM(s(X))

Problem 1: 

Basic Processor:
-> Pairs:
 ADD(num0,X) -> X
 AND(ftrue,X) -> X
 IF(ffalse,X,Y) -> Y
 IF(ftrue,X,Y) -> X
-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 and(ffalse,Y) -> ffalse
 and(ftrue,X) -> X
 first(num0,X) -> nil
 first(s(X),cons(Y,Z)) -> cons(Y,first(X,Z))
 from(X) -> cons(X,from(s(X)))
 if(ffalse,X,Y) -> Y
 if(ftrue,X,Y) -> X
-> Unhiding rules:
 add(X,Y) -> ADD(X,Y)
 add(x4,Y) -> x4
 first(X,Z) -> FIRST(X,Z)
 first(X,x4) -> x4
 first(x4,Z) -> x4
 from(s(X)) -> FROM(s(X))
-> Result:
 All pairs P are from Px1

The problem is finite.
