YES

Problem 1: 

(VAR vu95NonEmpty N X XS)
(STRATEGY CONTEXTSENSITIVE
(after 1 2)
(from 1)
(num0)
(cons 1)
(fSNonEmpty)
(s 1)
)
(RULES
after(num0,XS) -> XS
after(s(N),cons(X,XS)) -> after(N,XS)
from(X) -> cons(X,from(s(X)))
)


Problem 1: 

Innermost Equivalent Processor:
-> Rules:
 after(num0,XS) -> XS
 after(s(N),cons(X,XS)) -> after(N,XS)
 from(X) -> cons(X,from(s(X)))
-> The context-sensitive term rewriting system is an orthogonal system. Therefore, innermost cs-termination implies cs-termination.
 

Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 AFTER(s(N),cons(X,XS)) -> AFTER(N,XS)
 AFTER(s(N),cons(X,XS)) -> XS
-> Rules:
 after(num0,XS) -> XS
 after(s(N),cons(X,XS)) -> after(N,XS)
 from(X) -> cons(X,from(s(X)))
-> Unhiding Rules:
 from(s(X)) -> FROM(s(X))

Problem 1: 

SCC Processor:
-> Pairs:
 AFTER(s(N),cons(X,XS)) -> AFTER(N,XS)
 AFTER(s(N),cons(X,XS)) -> XS
-> Rules:
 after(num0,XS) -> XS
 after(s(N),cons(X,XS)) -> after(N,XS)
 from(X) -> cons(X,from(s(X)))
-> Unhiding rules:
 from(s(X)) -> FROM(s(X))
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 AFTER(s(N),cons(X,XS)) -> AFTER(N,XS)
->->-> Rules:
 after(num0,XS) -> XS
 after(s(N),cons(X,XS)) -> after(N,XS)
 from(X) -> cons(X,from(s(X)))
->->-> Unhiding rules:
 Empty

Problem 1: 

SubNColl Processor:
-> Pairs:
 AFTER(s(N),cons(X,XS)) -> AFTER(N,XS)
-> Rules:
 after(num0,XS) -> XS
 after(s(N),cons(X,XS)) -> after(N,XS)
 from(X) -> cons(X,from(s(X)))
-> Unhiding rules:
 Empty
->Projection:
 pi(AFTER) = 1

Problem 1: 

Basic Processor:
-> Pairs:
 Empty
-> Rules:
 after(num0,XS) -> XS
 after(s(N),cons(X,XS)) -> after(N,XS)
 from(X) -> cons(X,from(s(X)))
-> Unhiding rules:
 Empty
-> Result:
 Set P is empty

The problem is finite.
