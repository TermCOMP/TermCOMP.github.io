YES

Problem 1: 

(VAR vu95NonEmpty M N X Y)
(STRATEGY CONTEXTSENSITIVE
(filter 1 2 3)
(nats 1)
(sieve 1)
(zprimes)
(num0)
(cons 1)
(fSNonEmpty)
(s 1)
)
(RULES
filter(cons(X,Y),num0,M) -> cons(num0,filter(Y,M,M))
filter(cons(X,Y),s(N),M) -> cons(X,filter(Y,N,M))
nats(N) -> cons(N,nats(s(N)))
sieve(cons(num0,Y)) -> cons(num0,sieve(Y))
sieve(cons(s(N),Y)) -> cons(s(N),sieve(filter(Y,N,N)))
zprimes -> sieve(nats(s(s(num0))))
)


Problem 1: 

Innermost Equivalent Processor:
-> Rules:
 filter(cons(X,Y),num0,M) -> cons(num0,filter(Y,M,M))
 filter(cons(X,Y),s(N),M) -> cons(X,filter(Y,N,M))
 nats(N) -> cons(N,nats(s(N)))
 sieve(cons(num0,Y)) -> cons(num0,sieve(Y))
 sieve(cons(s(N),Y)) -> cons(s(N),sieve(filter(Y,N,N)))
 zprimes -> sieve(nats(s(s(num0))))
-> The context-sensitive term rewriting system is an orthogonal system. Therefore, innermost cs-termination implies cs-termination.
 

Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 ZPRIMES -> NATS(s(s(num0)))
 ZPRIMES -> SIEVE(nats(s(s(num0))))
-> Rules:
 filter(cons(X,Y),num0,M) -> cons(num0,filter(Y,M,M))
 filter(cons(X,Y),s(N),M) -> cons(X,filter(Y,N,M))
 nats(N) -> cons(N,nats(s(N)))
 sieve(cons(num0,Y)) -> cons(num0,sieve(Y))
 sieve(cons(s(N),Y)) -> cons(s(N),sieve(filter(Y,N,N)))
 zprimes -> sieve(nats(s(s(num0))))
-> Unhiding Rules:
 Empty

Problem 1: 

SCC Processor:
-> Pairs:
 ZPRIMES -> NATS(s(s(num0)))
 ZPRIMES -> SIEVE(nats(s(s(num0))))
-> Rules:
 filter(cons(X,Y),num0,M) -> cons(num0,filter(Y,M,M))
 filter(cons(X,Y),s(N),M) -> cons(X,filter(Y,N,M))
 nats(N) -> cons(N,nats(s(N)))
 sieve(cons(num0,Y)) -> cons(num0,sieve(Y))
 sieve(cons(s(N),Y)) -> cons(s(N),sieve(filter(Y,N,N)))
 zprimes -> sieve(nats(s(s(num0))))
-> Unhiding rules:
 Empty
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
