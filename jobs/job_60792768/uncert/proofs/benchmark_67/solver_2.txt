YES

Problem 1: 

(VAR vu95NonEmpty N X XS Y YS ZS)
(STRATEGY CONTEXTSENSITIVE
(U11 1)
(U12 1)
(U21 1)
(U22 1)
(U31 1)
(U32 1)
(U41 1)
(U42 1)
(U51 1)
(U52 1)
(U61 1)
(U62 1)
(U63 1)
(U64 1)
(U71 1)
(U72 1)
(U81 1)
(U82 1)
(afterNth 1 2)
(fst 1)
(head 1)
(natsFrom 1)
(sel 1 2)
(snd 1)
(splitAt 1 2)
(tail 1)
(take 1 2)
(num0)
(cons 1)
(fSNonEmpty)
(nil)
(pair 1 2)
(s 1)
(tt)
)
(RULES
U11(tt,N,XS) -> U12(tt,N,XS)
U12(tt,N,XS) -> snd(splitAt(N,XS))
U21(tt,X) -> U22(tt,X)
U22(tt,X) -> X
U31(tt,N) -> U32(tt,N)
U32(tt,N) -> N
U41(tt,N,XS) -> U42(tt,N,XS)
U42(tt,N,XS) -> head(afterNth(N,XS))
U51(tt,Y) -> U52(tt,Y)
U52(tt,Y) -> Y
U61(tt,N,X,XS) -> U62(tt,N,X,XS)
U62(tt,N,X,XS) -> U63(tt,N,X,XS)
U63(tt,N,X,XS) -> U64(splitAt(N,XS),X)
U64(pair(YS,ZS),X) -> pair(cons(X,YS),ZS)
U71(tt,XS) -> U72(tt,XS)
U72(tt,XS) -> XS
U81(tt,N,XS) -> U82(tt,N,XS)
U82(tt,N,XS) -> fst(splitAt(N,XS))
afterNth(N,XS) -> U11(tt,N,XS)
fst(pair(X,Y)) -> U21(tt,X)
head(cons(N,XS)) -> U31(tt,N)
natsFrom(N) -> cons(N,natsFrom(s(N)))
sel(N,XS) -> U41(tt,N,XS)
snd(pair(X,Y)) -> U51(tt,Y)
splitAt(num0,XS) -> pair(nil,XS)
splitAt(s(N),cons(X,XS)) -> U61(tt,N,X,XS)
tail(cons(N,XS)) -> U71(tt,XS)
take(N,XS) -> U81(tt,N,XS)
)


Problem 1: 

Innermost Equivalent Processor:
-> Rules:
 U11(tt,N,XS) -> U12(tt,N,XS)
 U12(tt,N,XS) -> snd(splitAt(N,XS))
 U21(tt,X) -> U22(tt,X)
 U22(tt,X) -> X
 U31(tt,N) -> U32(tt,N)
 U32(tt,N) -> N
 U41(tt,N,XS) -> U42(tt,N,XS)
 U42(tt,N,XS) -> head(afterNth(N,XS))
 U51(tt,Y) -> U52(tt,Y)
 U52(tt,Y) -> Y
 U61(tt,N,X,XS) -> U62(tt,N,X,XS)
 U62(tt,N,X,XS) -> U63(tt,N,X,XS)
 U63(tt,N,X,XS) -> U64(splitAt(N,XS),X)
 U64(pair(YS,ZS),X) -> pair(cons(X,YS),ZS)
 U71(tt,XS) -> U72(tt,XS)
 U72(tt,XS) -> XS
 U81(tt,N,XS) -> U82(tt,N,XS)
 U82(tt,N,XS) -> fst(splitAt(N,XS))
 afterNth(N,XS) -> U11(tt,N,XS)
 fst(pair(X,Y)) -> U21(tt,X)
 head(cons(N,XS)) -> U31(tt,N)
 natsFrom(N) -> cons(N,natsFrom(s(N)))
 sel(N,XS) -> U41(tt,N,XS)
 snd(pair(X,Y)) -> U51(tt,Y)
 splitAt(num0,XS) -> pair(nil,XS)
 splitAt(s(N),cons(X,XS)) -> U61(tt,N,X,XS)
 tail(cons(N,XS)) -> U71(tt,XS)
 take(N,XS) -> U81(tt,N,XS)
-> The context-sensitive term rewriting system is an orthogonal system. Therefore, innermost cs-termination implies cs-termination.
 

Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 U11Sharp(tt,N,XS) -> U12Sharp(tt,N,XS)
 U12Sharp(tt,N,XS) -> SND(splitAt(N,XS))
 U12Sharp(tt,N,XS) -> SPLITAT(N,XS)
 U12Sharp(tt,N,XS) -> N
 U12Sharp(tt,N,XS) -> XS
 U21Sharp(tt,X) -> U22Sharp(tt,X)
 U22Sharp(tt,X) -> X
 U31Sharp(tt,N) -> U32Sharp(tt,N)
 U32Sharp(tt,N) -> N
 U41Sharp(tt,N,XS) -> U42Sharp(tt,N,XS)
 U42Sharp(tt,N,XS) -> AFTERNTH(N,XS)
 U42Sharp(tt,N,XS) -> HEAD(afterNth(N,XS))
 U42Sharp(tt,N,XS) -> N
 U42Sharp(tt,N,XS) -> XS
 U51Sharp(tt,Y) -> U52Sharp(tt,Y)
 U52Sharp(tt,Y) -> Y
 U61Sharp(tt,N,X,XS) -> U62Sharp(tt,N,X,XS)
 U62Sharp(tt,N,X,XS) -> U63Sharp(tt,N,X,XS)
 U63Sharp(tt,N,X,XS) -> U64Sharp(splitAt(N,XS),X)
 U63Sharp(tt,N,X,XS) -> SPLITAT(N,XS)
 U63Sharp(tt,N,X,XS) -> N
 U63Sharp(tt,N,X,XS) -> XS
 U64Sharp(pair(YS,ZS),X) -> X
 U71Sharp(tt,XS) -> U72Sharp(tt,XS)
 U72Sharp(tt,XS) -> XS
 U81Sharp(tt,N,XS) -> U82Sharp(tt,N,XS)
 U82Sharp(tt,N,XS) -> FST(splitAt(N,XS))
 U82Sharp(tt,N,XS) -> SPLITAT(N,XS)
 U82Sharp(tt,N,XS) -> N
 U82Sharp(tt,N,XS) -> XS
 AFTERNTH(N,XS) -> U11Sharp(tt,N,XS)
 FST(pair(X,Y)) -> U21Sharp(tt,X)
 HEAD(cons(N,XS)) -> U31Sharp(tt,N)
 SEL(N,XS) -> U41Sharp(tt,N,XS)
 SND(pair(X,Y)) -> U51Sharp(tt,Y)
 SPLITAT(s(N),cons(X,XS)) -> U61Sharp(tt,N,X,XS)
 TAIL(cons(N,XS)) -> U71Sharp(tt,XS)
 TAKE(N,XS) -> U81Sharp(tt,N,XS)
-> Rules:
 U11(tt,N,XS) -> U12(tt,N,XS)
 U12(tt,N,XS) -> snd(splitAt(N,XS))
 U21(tt,X) -> U22(tt,X)
 U22(tt,X) -> X
 U31(tt,N) -> U32(tt,N)
 U32(tt,N) -> N
 U41(tt,N,XS) -> U42(tt,N,XS)
 U42(tt,N,XS) -> head(afterNth(N,XS))
 U51(tt,Y) -> U52(tt,Y)
 U52(tt,Y) -> Y
 U61(tt,N,X,XS) -> U62(tt,N,X,XS)
 U62(tt,N,X,XS) -> U63(tt,N,X,XS)
 U63(tt,N,X,XS) -> U64(splitAt(N,XS),X)
 U64(pair(YS,ZS),X) -> pair(cons(X,YS),ZS)
 U71(tt,XS) -> U72(tt,XS)
 U72(tt,XS) -> XS
 U81(tt,N,XS) -> U82(tt,N,XS)
 U82(tt,N,XS) -> fst(splitAt(N,XS))
 afterNth(N,XS) -> U11(tt,N,XS)
 fst(pair(X,Y)) -> U21(tt,X)
 head(cons(N,XS)) -> U31(tt,N)
 natsFrom(N) -> cons(N,natsFrom(s(N)))
 sel(N,XS) -> U41(tt,N,XS)
 snd(pair(X,Y)) -> U51(tt,Y)
 splitAt(num0,XS) -> pair(nil,XS)
 splitAt(s(N),cons(X,XS)) -> U61(tt,N,X,XS)
 tail(cons(N,XS)) -> U71(tt,XS)
 take(N,XS) -> U81(tt,N,XS)
-> Unhiding Rules:
 natsFrom(s(N)) -> NATSFROM(s(N))

Problem 1: 

SCC Processor:
-> Pairs:
 U11Sharp(tt,N,XS) -> U12Sharp(tt,N,XS)
 U12Sharp(tt,N,XS) -> SND(splitAt(N,XS))
 U12Sharp(tt,N,XS) -> SPLITAT(N,XS)
 U12Sharp(tt,N,XS) -> N
 U12Sharp(tt,N,XS) -> XS
 U21Sharp(tt,X) -> U22Sharp(tt,X)
 U22Sharp(tt,X) -> X
 U31Sharp(tt,N) -> U32Sharp(tt,N)
 U32Sharp(tt,N) -> N
 U41Sharp(tt,N,XS) -> U42Sharp(tt,N,XS)
 U42Sharp(tt,N,XS) -> AFTERNTH(N,XS)
 U42Sharp(tt,N,XS) -> HEAD(afterNth(N,XS))
 U42Sharp(tt,N,XS) -> N
 U42Sharp(tt,N,XS) -> XS
 U51Sharp(tt,Y) -> U52Sharp(tt,Y)
 U52Sharp(tt,Y) -> Y
 U61Sharp(tt,N,X,XS) -> U62Sharp(tt,N,X,XS)
 U62Sharp(tt,N,X,XS) -> U63Sharp(tt,N,X,XS)
 U63Sharp(tt,N,X,XS) -> U64Sharp(splitAt(N,XS),X)
 U63Sharp(tt,N,X,XS) -> SPLITAT(N,XS)
 U63Sharp(tt,N,X,XS) -> N
 U63Sharp(tt,N,X,XS) -> XS
 U64Sharp(pair(YS,ZS),X) -> X
 U71Sharp(tt,XS) -> U72Sharp(tt,XS)
 U72Sharp(tt,XS) -> XS
 U81Sharp(tt,N,XS) -> U82Sharp(tt,N,XS)
 U82Sharp(tt,N,XS) -> FST(splitAt(N,XS))
 U82Sharp(tt,N,XS) -> SPLITAT(N,XS)
 U82Sharp(tt,N,XS) -> N
 U82Sharp(tt,N,XS) -> XS
 AFTERNTH(N,XS) -> U11Sharp(tt,N,XS)
 FST(pair(X,Y)) -> U21Sharp(tt,X)
 HEAD(cons(N,XS)) -> U31Sharp(tt,N)
 SEL(N,XS) -> U41Sharp(tt,N,XS)
 SND(pair(X,Y)) -> U51Sharp(tt,Y)
 SPLITAT(s(N),cons(X,XS)) -> U61Sharp(tt,N,X,XS)
 TAIL(cons(N,XS)) -> U71Sharp(tt,XS)
 TAKE(N,XS) -> U81Sharp(tt,N,XS)
-> Rules:
 U11(tt,N,XS) -> U12(tt,N,XS)
 U12(tt,N,XS) -> snd(splitAt(N,XS))
 U21(tt,X) -> U22(tt,X)
 U22(tt,X) -> X
 U31(tt,N) -> U32(tt,N)
 U32(tt,N) -> N
 U41(tt,N,XS) -> U42(tt,N,XS)
 U42(tt,N,XS) -> head(afterNth(N,XS))
 U51(tt,Y) -> U52(tt,Y)
 U52(tt,Y) -> Y
 U61(tt,N,X,XS) -> U62(tt,N,X,XS)
 U62(tt,N,X,XS) -> U63(tt,N,X,XS)
 U63(tt,N,X,XS) -> U64(splitAt(N,XS),X)
 U64(pair(YS,ZS),X) -> pair(cons(X,YS),ZS)
 U71(tt,XS) -> U72(tt,XS)
 U72(tt,XS) -> XS
 U81(tt,N,XS) -> U82(tt,N,XS)
 U82(tt,N,XS) -> fst(splitAt(N,XS))
 afterNth(N,XS) -> U11(tt,N,XS)
 fst(pair(X,Y)) -> U21(tt,X)
 head(cons(N,XS)) -> U31(tt,N)
 natsFrom(N) -> cons(N,natsFrom(s(N)))
 sel(N,XS) -> U41(tt,N,XS)
 snd(pair(X,Y)) -> U51(tt,Y)
 splitAt(num0,XS) -> pair(nil,XS)
 splitAt(s(N),cons(X,XS)) -> U61(tt,N,X,XS)
 tail(cons(N,XS)) -> U71(tt,XS)
 take(N,XS) -> U81(tt,N,XS)
-> Unhiding rules:
 natsFrom(s(N)) -> NATSFROM(s(N))
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 U61Sharp(tt,N,X,XS) -> U62Sharp(tt,N,X,XS)
 U62Sharp(tt,N,X,XS) -> U63Sharp(tt,N,X,XS)
 U63Sharp(tt,N,X,XS) -> SPLITAT(N,XS)
 SPLITAT(s(N),cons(X,XS)) -> U61Sharp(tt,N,X,XS)
->->-> Rules:
 U11(tt,N,XS) -> U12(tt,N,XS)
 U12(tt,N,XS) -> snd(splitAt(N,XS))
 U21(tt,X) -> U22(tt,X)
 U22(tt,X) -> X
 U31(tt,N) -> U32(tt,N)
 U32(tt,N) -> N
 U41(tt,N,XS) -> U42(tt,N,XS)
 U42(tt,N,XS) -> head(afterNth(N,XS))
 U51(tt,Y) -> U52(tt,Y)
 U52(tt,Y) -> Y
 U61(tt,N,X,XS) -> U62(tt,N,X,XS)
 U62(tt,N,X,XS) -> U63(tt,N,X,XS)
 U63(tt,N,X,XS) -> U64(splitAt(N,XS),X)
 U64(pair(YS,ZS),X) -> pair(cons(X,YS),ZS)
 U71(tt,XS) -> U72(tt,XS)
 U72(tt,XS) -> XS
 U81(tt,N,XS) -> U82(tt,N,XS)
 U82(tt,N,XS) -> fst(splitAt(N,XS))
 afterNth(N,XS) -> U11(tt,N,XS)
 fst(pair(X,Y)) -> U21(tt,X)
 head(cons(N,XS)) -> U31(tt,N)
 natsFrom(N) -> cons(N,natsFrom(s(N)))
 sel(N,XS) -> U41(tt,N,XS)
 snd(pair(X,Y)) -> U51(tt,Y)
 splitAt(num0,XS) -> pair(nil,XS)
 splitAt(s(N),cons(X,XS)) -> U61(tt,N,X,XS)
 tail(cons(N,XS)) -> U71(tt,XS)
 take(N,XS) -> U81(tt,N,XS)
->->-> Unhiding rules:
 Empty

Problem 1: 

SubNColl Processor:
-> Pairs:
 U61Sharp(tt,N,X,XS) -> U62Sharp(tt,N,X,XS)
 U62Sharp(tt,N,X,XS) -> U63Sharp(tt,N,X,XS)
 U63Sharp(tt,N,X,XS) -> SPLITAT(N,XS)
 SPLITAT(s(N),cons(X,XS)) -> U61Sharp(tt,N,X,XS)
-> Rules:
 U11(tt,N,XS) -> U12(tt,N,XS)
 U12(tt,N,XS) -> snd(splitAt(N,XS))
 U21(tt,X) -> U22(tt,X)
 U22(tt,X) -> X
 U31(tt,N) -> U32(tt,N)
 U32(tt,N) -> N
 U41(tt,N,XS) -> U42(tt,N,XS)
 U42(tt,N,XS) -> head(afterNth(N,XS))
 U51(tt,Y) -> U52(tt,Y)
 U52(tt,Y) -> Y
 U61(tt,N,X,XS) -> U62(tt,N,X,XS)
 U62(tt,N,X,XS) -> U63(tt,N,X,XS)
 U63(tt,N,X,XS) -> U64(splitAt(N,XS),X)
 U64(pair(YS,ZS),X) -> pair(cons(X,YS),ZS)
 U71(tt,XS) -> U72(tt,XS)
 U72(tt,XS) -> XS
 U81(tt,N,XS) -> U82(tt,N,XS)
 U82(tt,N,XS) -> fst(splitAt(N,XS))
 afterNth(N,XS) -> U11(tt,N,XS)
 fst(pair(X,Y)) -> U21(tt,X)
 head(cons(N,XS)) -> U31(tt,N)
 natsFrom(N) -> cons(N,natsFrom(s(N)))
 sel(N,XS) -> U41(tt,N,XS)
 snd(pair(X,Y)) -> U51(tt,Y)
 splitAt(num0,XS) -> pair(nil,XS)
 splitAt(s(N),cons(X,XS)) -> U61(tt,N,X,XS)
 tail(cons(N,XS)) -> U71(tt,XS)
 take(N,XS) -> U81(tt,N,XS)
-> Unhiding rules:
 Empty
->Projection:
 pi(U61Sharp) = 2
 pi(U62Sharp) = 2
 pi(U63Sharp) = 2
 pi(SPLITAT) = 1

Problem 1: 

SCC Processor:
-> Pairs:
 U61Sharp(tt,N,X,XS) -> U62Sharp(tt,N,X,XS)
 U62Sharp(tt,N,X,XS) -> U63Sharp(tt,N,X,XS)
 U63Sharp(tt,N,X,XS) -> SPLITAT(N,XS)
-> Rules:
 U11(tt,N,XS) -> U12(tt,N,XS)
 U12(tt,N,XS) -> snd(splitAt(N,XS))
 U21(tt,X) -> U22(tt,X)
 U22(tt,X) -> X
 U31(tt,N) -> U32(tt,N)
 U32(tt,N) -> N
 U41(tt,N,XS) -> U42(tt,N,XS)
 U42(tt,N,XS) -> head(afterNth(N,XS))
 U51(tt,Y) -> U52(tt,Y)
 U52(tt,Y) -> Y
 U61(tt,N,X,XS) -> U62(tt,N,X,XS)
 U62(tt,N,X,XS) -> U63(tt,N,X,XS)
 U63(tt,N,X,XS) -> U64(splitAt(N,XS),X)
 U64(pair(YS,ZS),X) -> pair(cons(X,YS),ZS)
 U71(tt,XS) -> U72(tt,XS)
 U72(tt,XS) -> XS
 U81(tt,N,XS) -> U82(tt,N,XS)
 U82(tt,N,XS) -> fst(splitAt(N,XS))
 afterNth(N,XS) -> U11(tt,N,XS)
 fst(pair(X,Y)) -> U21(tt,X)
 head(cons(N,XS)) -> U31(tt,N)
 natsFrom(N) -> cons(N,natsFrom(s(N)))
 sel(N,XS) -> U41(tt,N,XS)
 snd(pair(X,Y)) -> U51(tt,Y)
 splitAt(num0,XS) -> pair(nil,XS)
 splitAt(s(N),cons(X,XS)) -> U61(tt,N,X,XS)
 tail(cons(N,XS)) -> U71(tt,XS)
 take(N,XS) -> U81(tt,N,XS)
-> Unhiding rules:
 Empty
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
