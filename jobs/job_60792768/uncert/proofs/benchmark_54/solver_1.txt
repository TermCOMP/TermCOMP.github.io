YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/2zaer.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given CSR could be proven:

(0) CSR
(1) CSRInnermostProof [EQUIVALENT, 0 ms]
(2) CSR
(3) CSDependencyPairsProof [EQUIVALENT, 0 ms]
(4) QCSDP
(5) QCSDependencyGraphProof [EQUIVALENT, 0 ms]
(6) AND
    (7) QCSDP
        (8) QCSDPReductionPairProof [EQUIVALENT, 24 ms]
        (9) QCSDP
        (10) QCSDPInstantiationProcessor [EQUIVALENT, 0 ms]
        (11) QCSDP
        (12) QCSDPReductionPairProof [EQUIVALENT, 0 ms]
        (13) QCSDP
        (14) QCSDependencyGraphProof [EQUIVALENT, 0 ms]
        (15) AND
            (16) QCSDP
                (17) QCSDPReductionPairProof [EQUIVALENT, 29 ms]
                (18) QCSDP
                (19) QCSDependencyGraphProof [EQUIVALENT, 0 ms]
                (20) TRUE
            (21) QCSDP
                (22) QCSDPSubtermProof [EQUIVALENT, 0 ms]
                (23) QCSDP
                (24) PIsEmptyProof [EQUIVALENT, 0 ms]
                (25) YES
    (26) QCSDP
        (27) QCSDPReductionPairProof [EQUIVALENT, 4 ms]
        (28) QCSDP
        (29) PIsEmptyProof [EQUIVALENT, 0 ms]
        (30) YES
    (31) QCSDP
        (32) QCSDPSubtermProof [EQUIVALENT, 0 ms]
        (33) QCSDP
        (34) PIsEmptyProof [EQUIVALENT, 0 ms]
        (35) YES


----------------------------------------

(0)
Obligation:
Context-sensitive rewrite system:
The TRS R consists of the following rules:

   gt(0, Y) -> false
   gt(s(X), 0) -> true
   gt(s(X), s(Y)) -> gt(X, Y)
   p(0) -> 0
   p(s(X)) -> X
   if(true, X, Y) -> X
   if(false, X, Y) -> Y
   minus(X, Y) -> if(gt(Y, 0), minus(p(X), p(Y)), X)
   div(0, s(Y)) -> 0
   div(s(X), s(Y)) -> s(div(minus(X, Y), s(Y)))

The replacement map contains the following entries:

gt: {1, 2}
0: empty set
false: empty set
s: {1}
true: empty set
p: {1}
if: {1}
minus: {1, 2}
div: {1, 2}

----------------------------------------

(1) CSRInnermostProof (EQUIVALENT)
The CSR is orthogonal. By [CS_Inn] we can switch to innermost.
----------------------------------------

(2)
Obligation:
Context-sensitive rewrite system:
The TRS R consists of the following rules:

   gt(0, Y) -> false
   gt(s(X), 0) -> true
   gt(s(X), s(Y)) -> gt(X, Y)
   p(0) -> 0
   p(s(X)) -> X
   if(true, X, Y) -> X
   if(false, X, Y) -> Y
   minus(X, Y) -> if(gt(Y, 0), minus(p(X), p(Y)), X)
   div(0, s(Y)) -> 0
   div(s(X), s(Y)) -> s(div(minus(X, Y), s(Y)))

The replacement map contains the following entries:

gt: {1, 2}
0: empty set
false: empty set
s: {1}
true: empty set
p: {1}
if: {1}
minus: {1, 2}
div: {1, 2}


Innermost Strategy.

----------------------------------------

(3) CSDependencyPairsProof (EQUIVALENT)
Using Improved CS-DPs [LPAR08] we result in the following initial Q-CSDP problem.
----------------------------------------

(4)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {gt_2, s_1, p_1, minus_2, div_2, GT_2, MINUS_2, DIV_2, P_1} are replacing on all positions.
For all symbols f in {if_3, IF_3} we have mu(f) = {1}.
The symbols in {U_1} are not replacing on any position.

The ordinary context-sensitive dependency pairs DP_o are:
   GT(s(X), s(Y)) -> GT(X, Y)
   MINUS(X, Y) -> IF(gt(Y, 0), minus(p(X), p(Y)), X)
   MINUS(X, Y) -> GT(Y, 0)
   DIV(s(X), s(Y)) -> DIV(minus(X, Y), s(Y))
   DIV(s(X), s(Y)) -> MINUS(X, Y)

The collapsing dependency pairs are DP_c:
   IF(true, X, Y) -> X
   IF(false, X, Y) -> Y


The hidden terms of R are:

   minus(p(x0), p(x1))
   p(x0)

Every hiding context is built from:
   aprove.DPFramework.CSDPProblem.QCSDPProblem$1@14ca3109
   aprove.DPFramework.CSDPProblem.QCSDPProblem$1@33fd59f7

Hence, the new unhiding pairs DP_u are :
   IF(true, X, Y) -> U(X)
   IF(false, X, Y) -> U(Y)
   U(p(x_0)) -> U(x_0)
   U(minus(x_0, x_1)) -> U(x_0)
   U(minus(x_0, x_1)) -> U(x_1)
   U(minus(p(x0), p(x1))) -> MINUS(p(x0), p(x1))
   U(p(x0)) -> P(x0)

The TRS R consists of the following rules:

   gt(0, Y) -> false
   gt(s(X), 0) -> true
   gt(s(X), s(Y)) -> gt(X, Y)
   p(0) -> 0
   p(s(X)) -> X
   if(true, X, Y) -> X
   if(false, X, Y) -> Y
   minus(X, Y) -> if(gt(Y, 0), minus(p(X), p(Y)), X)
   div(0, s(Y)) -> 0
   div(s(X), s(Y)) -> s(div(minus(X, Y), s(Y)))

The set Q consists of the following terms:

   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   p(0)
   p(s(x0))
   if(true, x0, x1)
   if(false, x0, x1)
   minus(x0, x1)
   div(0, s(x0))
   div(s(x0), s(x1))


----------------------------------------

(5) QCSDependencyGraphProof (EQUIVALENT)
The approximation of the Context-Sensitive Dependency Graph [LPAR08] contains 3 SCCs with 3 less nodes.
The rules MINUS(z0, z1) -> GT(z1, 0) and GT(s(x0), s(x1)) -> GT(x0, x1) form no chain, because ECap^mu(GT(z1, 0)) = GT(z1, 0) does not unify with GT(s(x0), s(x1)). 
----------------------------------------

(6)
Complex Obligation (AND)

----------------------------------------

(7)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {gt_2, s_1, p_1, minus_2, div_2, MINUS_2} are replacing on all positions.
For all symbols f in {if_3, IF_3} we have mu(f) = {1}.
The symbols in {U_1} are not replacing on any position.

The TRS P consists of the following rules:

   IF(true, X, Y) -> U(X)
   U(p(x_0)) -> U(x_0)
   U(minus(x_0, x_1)) -> U(x_0)
   U(minus(x_0, x_1)) -> U(x_1)
   U(minus(p(x0), p(x1))) -> MINUS(p(x0), p(x1))
   MINUS(X, Y) -> IF(gt(Y, 0), minus(p(X), p(Y)), X)
   IF(false, X, Y) -> U(Y)

The TRS R consists of the following rules:

   gt(0, Y) -> false
   gt(s(X), 0) -> true
   gt(s(X), s(Y)) -> gt(X, Y)
   p(0) -> 0
   p(s(X)) -> X
   if(true, X, Y) -> X
   if(false, X, Y) -> Y
   minus(X, Y) -> if(gt(Y, 0), minus(p(X), p(Y)), X)
   div(0, s(Y)) -> 0
   div(s(X), s(Y)) -> s(div(minus(X, Y), s(Y)))

The set Q consists of the following terms:

   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   p(0)
   p(s(x0))
   if(true, x0, x1)
   if(false, x0, x1)
   minus(x0, x1)
   div(0, s(x0))
   div(s(x0), s(x1))


----------------------------------------

(8) QCSDPReductionPairProof (EQUIVALENT)
Using the order

Polynomial interpretation with max and min functions [POLO,MAXPOLO]:

   POL(0) = 0
   POL(IF(x_1, x_2, x_3)) = max(x_2, x_3)
   POL(MINUS(x_1, x_2)) = 1 + x_1 + x_2
   POL(U(x_1)) = x_1
   POL(false) = 0
   POL(gt(x_1, x_2)) = 0
   POL(if(x_1, x_2, x_3)) = max(x_2, x_3)
   POL(minus(x_1, x_2)) = 1 + x_1 + x_2
   POL(p(x_1)) = x_1
   POL(s(x_1)) = 1 + x_1
   POL(true) = 0


the following usable rules


   p(0) -> 0
   p(s(X)) -> X
   minus(X, Y) -> if(gt(Y, 0), minus(p(X), p(Y)), X)
   if(true, X, Y) -> X
   if(false, X, Y) -> Y
   gt(0, Y) -> false
   gt(s(X), 0) -> true
   gt(s(X), s(Y)) -> gt(X, Y)


could all be oriented weakly.

Furthermore, the pairs


   U(minus(x_0, x_1)) -> U(x_0)
   U(minus(x_0, x_1)) -> U(x_1)


could be oriented strictly and thus removed by the CS-Reduction Pair Processor [LPAR08,DA_EMMES].


----------------------------------------

(9)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {gt_2, s_1, p_1, minus_2, div_2, MINUS_2} are replacing on all positions.
For all symbols f in {if_3, IF_3} we have mu(f) = {1}.
The symbols in {U_1} are not replacing on any position.

The TRS P consists of the following rules:

   IF(true, X, Y) -> U(X)
   U(p(x_0)) -> U(x_0)
   U(minus(p(x0), p(x1))) -> MINUS(p(x0), p(x1))
   MINUS(X, Y) -> IF(gt(Y, 0), minus(p(X), p(Y)), X)
   IF(false, X, Y) -> U(Y)

The TRS R consists of the following rules:

   gt(0, Y) -> false
   gt(s(X), 0) -> true
   gt(s(X), s(Y)) -> gt(X, Y)
   p(0) -> 0
   p(s(X)) -> X
   if(true, X, Y) -> X
   if(false, X, Y) -> Y
   minus(X, Y) -> if(gt(Y, 0), minus(p(X), p(Y)), X)
   div(0, s(Y)) -> 0
   div(s(X), s(Y)) -> s(div(minus(X, Y), s(Y)))

The set Q consists of the following terms:

   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   p(0)
   p(s(x0))
   if(true, x0, x1)
   if(false, x0, x1)
   minus(x0, x1)
   div(0, s(x0))
   div(s(x0), s(x1))


----------------------------------------

(10) QCSDPInstantiationProcessor (EQUIVALENT)
Using the Context-Sensitive Instantiation[LPAR08,DA_EMMES] Processor

the pair IF(true, X, Y) -> U(X)

was transformed to the following new pairs: 
   IF(true, minus(p(z0), p(z1)), z0) -> U(minus(p(z0), p(z1)))



----------------------------------------

(11)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {gt_2, s_1, p_1, minus_2, div_2, MINUS_2} are replacing on all positions.
For all symbols f in {if_3, IF_3} we have mu(f) = {1}.
The symbols in {U_1} are not replacing on any position.

The TRS P consists of the following rules:

   U(p(x_0)) -> U(x_0)
   U(minus(p(x0), p(x1))) -> MINUS(p(x0), p(x1))
   MINUS(X, Y) -> IF(gt(Y, 0), minus(p(X), p(Y)), X)
   IF(false, X, Y) -> U(Y)
   IF(true, minus(p(z0), p(z1)), z0) -> U(minus(p(z0), p(z1)))

The TRS R consists of the following rules:

   gt(0, Y) -> false
   gt(s(X), 0) -> true
   gt(s(X), s(Y)) -> gt(X, Y)
   p(0) -> 0
   p(s(X)) -> X
   if(true, X, Y) -> X
   if(false, X, Y) -> Y
   minus(X, Y) -> if(gt(Y, 0), minus(p(X), p(Y)), X)
   div(0, s(Y)) -> 0
   div(s(X), s(Y)) -> s(div(minus(X, Y), s(Y)))

The set Q consists of the following terms:

   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   p(0)
   p(s(x0))
   if(true, x0, x1)
   if(false, x0, x1)
   minus(x0, x1)
   div(0, s(x0))
   div(s(x0), s(x1))


----------------------------------------

(12) QCSDPReductionPairProof (EQUIVALENT)
Using the order

Polynomial interpretation with max and min functions [POLO,MAXPOLO]:

   POL(0) = 0
   POL(IF(x_1, x_2, x_3)) = 1 + x_3
   POL(MINUS(x_1, x_2)) = 1 + x_1
   POL(U(x_1)) = x_1
   POL(false) = 0
   POL(gt(x_1, x_2)) = 0
   POL(if(x_1, x_2, x_3)) = x_1 + max(x_2, x_3)
   POL(minus(x_1, x_2)) = 1 + x_1
   POL(p(x_1)) = x_1
   POL(s(x_1)) = 1 + x_1
   POL(true) = 0


the following usable rules


   p(0) -> 0
   p(s(X)) -> X
   minus(X, Y) -> if(gt(Y, 0), minus(p(X), p(Y)), X)
   if(true, X, Y) -> X
   if(false, X, Y) -> Y
   gt(0, Y) -> false
   gt(s(X), 0) -> true
   gt(s(X), s(Y)) -> gt(X, Y)


could all be oriented weakly.

Furthermore, the pairs


   IF(false, X, Y) -> U(Y)


could be oriented strictly and thus removed by the CS-Reduction Pair Processor [LPAR08,DA_EMMES].


----------------------------------------

(13)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {gt_2, s_1, p_1, minus_2, div_2, MINUS_2} are replacing on all positions.
For all symbols f in {if_3, IF_3} we have mu(f) = {1}.
The symbols in {U_1} are not replacing on any position.

The TRS P consists of the following rules:

   U(p(x_0)) -> U(x_0)
   U(minus(p(x0), p(x1))) -> MINUS(p(x0), p(x1))
   MINUS(X, Y) -> IF(gt(Y, 0), minus(p(X), p(Y)), X)
   IF(true, minus(p(z0), p(z1)), z0) -> U(minus(p(z0), p(z1)))

The TRS R consists of the following rules:

   gt(0, Y) -> false
   gt(s(X), 0) -> true
   gt(s(X), s(Y)) -> gt(X, Y)
   p(0) -> 0
   p(s(X)) -> X
   if(true, X, Y) -> X
   if(false, X, Y) -> Y
   minus(X, Y) -> if(gt(Y, 0), minus(p(X), p(Y)), X)
   div(0, s(Y)) -> 0
   div(s(X), s(Y)) -> s(div(minus(X, Y), s(Y)))

The set Q consists of the following terms:

   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   p(0)
   p(s(x0))
   if(true, x0, x1)
   if(false, x0, x1)
   minus(x0, x1)
   div(0, s(x0))
   div(s(x0), s(x1))


----------------------------------------

(14) QCSDependencyGraphProof (EQUIVALENT)
The approximation of the Context-Sensitive Dependency Graph [LPAR08] contains 2 SCCs.

----------------------------------------

(15)
Complex Obligation (AND)

----------------------------------------

(16)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {gt_2, s_1, p_1, minus_2, div_2, MINUS_2} are replacing on all positions.
For all symbols f in {if_3, IF_3} we have mu(f) = {1}.
The symbols in {U_1} are not replacing on any position.

The TRS P consists of the following rules:

   MINUS(X, Y) -> IF(gt(Y, 0), minus(p(X), p(Y)), X)
   IF(true, minus(p(z0), p(z1)), z0) -> U(minus(p(z0), p(z1)))
   U(minus(p(x0), p(x1))) -> MINUS(p(x0), p(x1))

The TRS R consists of the following rules:

   gt(0, Y) -> false
   gt(s(X), 0) -> true
   gt(s(X), s(Y)) -> gt(X, Y)
   p(0) -> 0
   p(s(X)) -> X
   if(true, X, Y) -> X
   if(false, X, Y) -> Y
   minus(X, Y) -> if(gt(Y, 0), minus(p(X), p(Y)), X)
   div(0, s(Y)) -> 0
   div(s(X), s(Y)) -> s(div(minus(X, Y), s(Y)))

The set Q consists of the following terms:

   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   p(0)
   p(s(x0))
   if(true, x0, x1)
   if(false, x0, x1)
   minus(x0, x1)
   div(0, s(x0))
   div(s(x0), s(x1))


----------------------------------------

(17) QCSDPReductionPairProof (EQUIVALENT)
Using the order

Polynomial interpretation [POLO,RATPOLO]:

   POL(0) = 0
   POL(IF(x_1, x_2, x_3)) = [1/2]x_1 + x_2
   POL(MINUS(x_1, x_2)) = [2]x_1 + [1/4]x_2
   POL(U(x_1)) = x_1
   POL(false) = 0
   POL(gt(x_1, x_2)) = [1/4]x_1
   POL(if(x_1, x_2, x_3)) = [2]x_2 + x_3
   POL(minus(x_1, x_2)) = [2]x_1 + [1/4]x_2
   POL(p(x_1)) = [1/4]x_1
   POL(s(x_1)) = [1] + [4]x_1
   POL(true) = [1/4]


the following usable rules


   gt(0, Y) -> false
   gt(s(X), 0) -> true
   gt(s(X), s(Y)) -> gt(X, Y)
   minus(X, Y) -> if(gt(Y, 0), minus(p(X), p(Y)), X)
   if(true, X, Y) -> X
   if(false, X, Y) -> Y
   p(0) -> 0
   p(s(X)) -> X


could all be oriented weakly.

Furthermore, the pairs


   IF(true, minus(p(z0), p(z1)), z0) -> U(minus(p(z0), p(z1)))


could be oriented strictly and thus removed by the CS-Reduction Pair Processor [LPAR08,DA_EMMES].


----------------------------------------

(18)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {gt_2, s_1, p_1, minus_2, div_2, MINUS_2} are replacing on all positions.
For all symbols f in {if_3, IF_3} we have mu(f) = {1}.
The symbols in {U_1} are not replacing on any position.

The TRS P consists of the following rules:

   MINUS(X, Y) -> IF(gt(Y, 0), minus(p(X), p(Y)), X)
   U(minus(p(x0), p(x1))) -> MINUS(p(x0), p(x1))

The TRS R consists of the following rules:

   gt(0, Y) -> false
   gt(s(X), 0) -> true
   gt(s(X), s(Y)) -> gt(X, Y)
   p(0) -> 0
   p(s(X)) -> X
   if(true, X, Y) -> X
   if(false, X, Y) -> Y
   minus(X, Y) -> if(gt(Y, 0), minus(p(X), p(Y)), X)
   div(0, s(Y)) -> 0
   div(s(X), s(Y)) -> s(div(minus(X, Y), s(Y)))

The set Q consists of the following terms:

   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   p(0)
   p(s(x0))
   if(true, x0, x1)
   if(false, x0, x1)
   minus(x0, x1)
   div(0, s(x0))
   div(s(x0), s(x1))


----------------------------------------

(19) QCSDependencyGraphProof (EQUIVALENT)
The approximation of the Context-Sensitive Dependency Graph [LPAR08] contains 0 SCCs with 2 less nodes.

----------------------------------------

(20)
TRUE

----------------------------------------

(21)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {gt_2, s_1, p_1, minus_2, div_2} are replacing on all positions.
For all symbols f in {if_3} we have mu(f) = {1}.
The symbols in {U_1} are not replacing on any position.

The TRS P consists of the following rules:

   U(p(x_0)) -> U(x_0)

The TRS R consists of the following rules:

   gt(0, Y) -> false
   gt(s(X), 0) -> true
   gt(s(X), s(Y)) -> gt(X, Y)
   p(0) -> 0
   p(s(X)) -> X
   if(true, X, Y) -> X
   if(false, X, Y) -> Y
   minus(X, Y) -> if(gt(Y, 0), minus(p(X), p(Y)), X)
   div(0, s(Y)) -> 0
   div(s(X), s(Y)) -> s(div(minus(X, Y), s(Y)))

The set Q consists of the following terms:

   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   p(0)
   p(s(x0))
   if(true, x0, x1)
   if(false, x0, x1)
   minus(x0, x1)
   div(0, s(x0))
   div(s(x0), s(x1))


----------------------------------------

(22) QCSDPSubtermProof (EQUIVALENT)
We use the subterm processor [DA_EMMES].


The following pairs can be oriented strictly and are deleted.

   U(p(x_0)) -> U(x_0)
The remaining pairs can at least be oriented weakly.
none
Used ordering:  Combined order from the following AFS and order.
U(x1)  =  x1


Subterm Order

----------------------------------------

(23)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {gt_2, s_1, p_1, minus_2, div_2} are replacing on all positions.
For all symbols f in {if_3} we have mu(f) = {1}.

The TRS P consists of the following rules:
none

The TRS R consists of the following rules:

   gt(0, Y) -> false
   gt(s(X), 0) -> true
   gt(s(X), s(Y)) -> gt(X, Y)
   p(0) -> 0
   p(s(X)) -> X
   if(true, X, Y) -> X
   if(false, X, Y) -> Y
   minus(X, Y) -> if(gt(Y, 0), minus(p(X), p(Y)), X)
   div(0, s(Y)) -> 0
   div(s(X), s(Y)) -> s(div(minus(X, Y), s(Y)))

The set Q consists of the following terms:

   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   p(0)
   p(s(x0))
   if(true, x0, x1)
   if(false, x0, x1)
   minus(x0, x1)
   div(0, s(x0))
   div(s(x0), s(x1))


----------------------------------------

(24) PIsEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R,mu)-chain.
----------------------------------------

(25)
YES

----------------------------------------

(26)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {gt_2, s_1, p_1, minus_2, div_2, DIV_2} are replacing on all positions.
For all symbols f in {if_3} we have mu(f) = {1}.

The TRS P consists of the following rules:

   DIV(s(X), s(Y)) -> DIV(minus(X, Y), s(Y))

The TRS R consists of the following rules:

   gt(0, Y) -> false
   gt(s(X), 0) -> true
   gt(s(X), s(Y)) -> gt(X, Y)
   p(0) -> 0
   p(s(X)) -> X
   if(true, X, Y) -> X
   if(false, X, Y) -> Y
   minus(X, Y) -> if(gt(Y, 0), minus(p(X), p(Y)), X)
   div(0, s(Y)) -> 0
   div(s(X), s(Y)) -> s(div(minus(X, Y), s(Y)))

The set Q consists of the following terms:

   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   p(0)
   p(s(x0))
   if(true, x0, x1)
   if(false, x0, x1)
   minus(x0, x1)
   div(0, s(x0))
   div(s(x0), s(x1))


----------------------------------------

(27) QCSDPReductionPairProof (EQUIVALENT)
Using the order

Polynomial interpretation with max and min functions [POLO,MAXPOLO]:

   POL(0) = 1
   POL(DIV(x_1, x_2)) = x_1
   POL(false) = 0
   POL(gt(x_1, x_2)) = 0
   POL(if(x_1, x_2, x_3)) = x_1 + max(x_2, x_3)
   POL(minus(x_1, x_2)) = x_1
   POL(p(x_1)) = x_1
   POL(s(x_1)) = 1 + x_1
   POL(true) = 0


the following usable rules


   minus(X, Y) -> if(gt(Y, 0), minus(p(X), p(Y)), X)
   if(true, X, Y) -> X
   if(false, X, Y) -> Y
   gt(0, Y) -> false
   gt(s(X), 0) -> true
   gt(s(X), s(Y)) -> gt(X, Y)
   p(0) -> 0
   p(s(X)) -> X


could all be oriented weakly.

Furthermore, the pairs


   DIV(s(X), s(Y)) -> DIV(minus(X, Y), s(Y))


could be oriented strictly and thus removed by the CS-Reduction Pair Processor [LPAR08,DA_EMMES].


----------------------------------------

(28)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {gt_2, s_1, p_1, minus_2, div_2} are replacing on all positions.
For all symbols f in {if_3} we have mu(f) = {1}.

The TRS P consists of the following rules:
none

The TRS R consists of the following rules:

   gt(0, Y) -> false
   gt(s(X), 0) -> true
   gt(s(X), s(Y)) -> gt(X, Y)
   p(0) -> 0
   p(s(X)) -> X
   if(true, X, Y) -> X
   if(false, X, Y) -> Y
   minus(X, Y) -> if(gt(Y, 0), minus(p(X), p(Y)), X)
   div(0, s(Y)) -> 0
   div(s(X), s(Y)) -> s(div(minus(X, Y), s(Y)))

The set Q consists of the following terms:

   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   p(0)
   p(s(x0))
   if(true, x0, x1)
   if(false, x0, x1)
   minus(x0, x1)
   div(0, s(x0))
   div(s(x0), s(x1))


----------------------------------------

(29) PIsEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R,mu)-chain.
----------------------------------------

(30)
YES

----------------------------------------

(31)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {gt_2, s_1, p_1, minus_2, div_2, GT_2} are replacing on all positions.
For all symbols f in {if_3} we have mu(f) = {1}.

The TRS P consists of the following rules:

   GT(s(X), s(Y)) -> GT(X, Y)

The TRS R consists of the following rules:

   gt(0, Y) -> false
   gt(s(X), 0) -> true
   gt(s(X), s(Y)) -> gt(X, Y)
   p(0) -> 0
   p(s(X)) -> X
   if(true, X, Y) -> X
   if(false, X, Y) -> Y
   minus(X, Y) -> if(gt(Y, 0), minus(p(X), p(Y)), X)
   div(0, s(Y)) -> 0
   div(s(X), s(Y)) -> s(div(minus(X, Y), s(Y)))

The set Q consists of the following terms:

   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   p(0)
   p(s(x0))
   if(true, x0, x1)
   if(false, x0, x1)
   minus(x0, x1)
   div(0, s(x0))
   div(s(x0), s(x1))


----------------------------------------

(32) QCSDPSubtermProof (EQUIVALENT)
We use the subterm processor [DA_EMMES].


The following pairs can be oriented strictly and are deleted.

   GT(s(X), s(Y)) -> GT(X, Y)
The remaining pairs can at least be oriented weakly.
none
Used ordering:  Combined order from the following AFS and order.
GT(x1, x2)  =  x1


Subterm Order

----------------------------------------

(33)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {gt_2, s_1, p_1, minus_2, div_2} are replacing on all positions.
For all symbols f in {if_3} we have mu(f) = {1}.

The TRS P consists of the following rules:
none

The TRS R consists of the following rules:

   gt(0, Y) -> false
   gt(s(X), 0) -> true
   gt(s(X), s(Y)) -> gt(X, Y)
   p(0) -> 0
   p(s(X)) -> X
   if(true, X, Y) -> X
   if(false, X, Y) -> Y
   minus(X, Y) -> if(gt(Y, 0), minus(p(X), p(Y)), X)
   div(0, s(Y)) -> 0
   div(s(X), s(Y)) -> s(div(minus(X, Y), s(Y)))

The set Q consists of the following terms:

   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   p(0)
   p(s(x0))
   if(true, x0, x1)
   if(false, x0, x1)
   minus(x0, x1)
   div(0, s(x0))
   div(s(x0), s(x1))


----------------------------------------

(34) PIsEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R,mu)-chain.
----------------------------------------

(35)
YES
