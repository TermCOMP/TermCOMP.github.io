YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/GGcTG.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given CSR could be proven:

(0) CSR
(1) CSRRRRProof [EQUIVALENT, 27 ms]
(2) CSR
(3) CSRRRRProof [EQUIVALENT, 0 ms]
(4) CSR
(5) CSDependencyPairsProof [EQUIVALENT, 0 ms]
(6) QCSDP
(7) QCSDependencyGraphProof [EQUIVALENT, 0 ms]
(8) AND
    (9) QCSDP
        (10) QCSUsableRulesProof [EQUIVALENT, 0 ms]
        (11) QCSDP
        (12) QCSDPMuMonotonicPoloProof [EQUIVALENT, 4 ms]
        (13) QCSDP
        (14) QCSDependencyGraphProof [EQUIVALENT, 0 ms]
        (15) AND
            (16) QCSDP
                (17) QCSDPMuMonotonicPoloProof [EQUIVALENT, 0 ms]
                (18) QCSDP
                (19) PIsEmptyProof [EQUIVALENT, 0 ms]
                (20) YES
            (21) QCSDP
                (22) QCSDPMuMonotonicPoloProof [EQUIVALENT, 0 ms]
                (23) QCSDP
                (24) PIsEmptyProof [EQUIVALENT, 0 ms]
                (25) YES
    (26) QCSDP
        (27) QCSDPSubtermProof [EQUIVALENT, 0 ms]
        (28) QCSDP
        (29) QCSDependencyGraphProof [EQUIVALENT, 0 ms]
        (30) TRUE
    (31) QCSDP
        (32) QCSDPReductionPairProof [EQUIVALENT, 35 ms]
        (33) QCSDP
        (34) QCSDependencyGraphProof [EQUIVALENT, 0 ms]
        (35) TRUE


----------------------------------------

(0)
Obligation:
Context-sensitive rewrite system:
The TRS R consists of the following rules:

   and(tt, T) -> T
   isNatIList(IL) -> isNatList(IL)
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)
   take(0, IL) -> uTake1(isNatIList(IL))
   uTake1(tt) -> nil
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))

The replacement map contains the following entries:

and: {1, 2}
tt: empty set
isNatIList: empty set
isNatList: empty set
isNat: empty set
0: empty set
s: {1}
length: {1}
zeros: empty set
cons: {1}
nil: empty set
take: {1, 2}
uTake1: {1}
uTake2: {1}
uLength: {1}

----------------------------------------

(1) CSRRRRProof (EQUIVALENT)
The following CSR is given: Context-sensitive rewrite system:
The TRS R consists of the following rules:

   and(tt, T) -> T
   isNatIList(IL) -> isNatList(IL)
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)
   take(0, IL) -> uTake1(isNatIList(IL))
   uTake1(tt) -> nil
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))

The replacement map contains the following entries:

and: {1, 2}
tt: empty set
isNatIList: empty set
isNatList: empty set
isNat: empty set
0: empty set
s: {1}
length: {1}
zeros: empty set
cons: {1}
nil: empty set
take: {1, 2}
uTake1: {1}
uTake2: {1}
uLength: {1}
Used ordering:
Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(and(x_1, x_2)) = x_1 + x_2
   POL(cons(x_1, x_2)) = x_1 + x_2
   POL(isNat(x_1)) = 0
   POL(isNatIList(x_1)) = 0
   POL(isNatList(x_1)) = 0
   POL(length(x_1)) = 1 + x_1
   POL(nil) = 0
   POL(s(x_1)) = x_1
   POL(take(x_1, x_2)) = 1 + x_1 + x_2
   POL(tt) = 0
   POL(uLength(x_1, x_2)) = 1 + x_1 + x_2
   POL(uTake1(x_1)) = 1 + x_1
   POL(uTake2(x_1, x_2, x_3, x_4)) = 1 + x_1 + x_2 + x_3 + x_4
   POL(zeros) = 0
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   uTake1(tt) -> nil




----------------------------------------

(2)
Obligation:
Context-sensitive rewrite system:
The TRS R consists of the following rules:

   and(tt, T) -> T
   isNatIList(IL) -> isNatList(IL)
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)
   take(0, IL) -> uTake1(isNatIList(IL))
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))

The replacement map contains the following entries:

and: {1, 2}
tt: empty set
isNatIList: empty set
isNatList: empty set
isNat: empty set
0: empty set
s: {1}
length: {1}
zeros: empty set
cons: {1}
nil: empty set
take: {1, 2}
uTake1: {1}
uTake2: {1}
uLength: {1}

----------------------------------------

(3) CSRRRRProof (EQUIVALENT)
The following CSR is given: Context-sensitive rewrite system:
The TRS R consists of the following rules:

   and(tt, T) -> T
   isNatIList(IL) -> isNatList(IL)
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)
   take(0, IL) -> uTake1(isNatIList(IL))
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))

The replacement map contains the following entries:

and: {1, 2}
tt: empty set
isNatIList: empty set
isNatList: empty set
isNat: empty set
0: empty set
s: {1}
length: {1}
zeros: empty set
cons: {1}
nil: empty set
take: {1, 2}
uTake1: {1}
uTake2: {1}
uLength: {1}
Used ordering:
Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(and(x_1, x_2)) = x_1 + x_2
   POL(cons(x_1, x_2)) = x_1 + x_2
   POL(isNat(x_1)) = 0
   POL(isNatIList(x_1)) = 0
   POL(isNatList(x_1)) = 0
   POL(length(x_1)) = 1 + x_1
   POL(nil) = 0
   POL(s(x_1)) = x_1
   POL(take(x_1, x_2)) = 1 + x_1 + x_2
   POL(tt) = 0
   POL(uLength(x_1, x_2)) = 1 + x_1 + x_2
   POL(uTake1(x_1)) = x_1
   POL(uTake2(x_1, x_2, x_3, x_4)) = 1 + x_1 + x_2 + x_3 + x_4
   POL(zeros) = 0
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   take(0, IL) -> uTake1(isNatIList(IL))




----------------------------------------

(4)
Obligation:
Context-sensitive rewrite system:
The TRS R consists of the following rules:

   and(tt, T) -> T
   isNatIList(IL) -> isNatList(IL)
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))

The replacement map contains the following entries:

and: {1, 2}
tt: empty set
isNatIList: empty set
isNatList: empty set
isNat: empty set
0: empty set
s: {1}
length: {1}
zeros: empty set
cons: {1}
nil: empty set
take: {1, 2}
uTake2: {1}
uLength: {1}

----------------------------------------

(5) CSDependencyPairsProof (EQUIVALENT)
Using Improved CS-DPs [LPAR08] we result in the following initial Q-CSDP problem.
----------------------------------------

(6)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {and_2, s_1, length_1, take_2, AND_2, TAKE_2, LENGTH_1} are replacing on all positions.
For all symbols f in {cons_2, uTake2_4, uLength_2, UTAKE2_4, ULENGTH_2} we have mu(f) = {1}.
The symbols in {isNatIList_1, isNatList_1, isNat_1, ISNATLIST_1, ISNATILIST_1, ISNAT_1, U_1} are not replacing on any position.

The ordinary context-sensitive dependency pairs DP_o are:
   ISNATILIST(IL) -> ISNATLIST(IL)
   ISNAT(s(N)) -> ISNAT(N)
   ISNAT(length(L)) -> ISNATLIST(L)
   ISNATILIST(cons(N, IL)) -> AND(isNat(N), isNatIList(IL))
   ISNATILIST(cons(N, IL)) -> ISNAT(N)
   ISNATILIST(cons(N, IL)) -> ISNATILIST(IL)
   ISNATLIST(cons(N, L)) -> AND(isNat(N), isNatList(L))
   ISNATLIST(cons(N, L)) -> ISNAT(N)
   ISNATLIST(cons(N, L)) -> ISNATLIST(L)
   ISNATLIST(take(N, IL)) -> AND(isNat(N), isNatIList(IL))
   ISNATLIST(take(N, IL)) -> ISNAT(N)
   ISNATLIST(take(N, IL)) -> ISNATILIST(IL)
   TAKE(s(M), cons(N, IL)) -> UTAKE2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   TAKE(s(M), cons(N, IL)) -> AND(isNat(M), and(isNat(N), isNatIList(IL)))
   TAKE(s(M), cons(N, IL)) -> ISNAT(M)
   TAKE(s(M), cons(N, IL)) -> AND(isNat(N), isNatIList(IL))
   TAKE(s(M), cons(N, IL)) -> ISNAT(N)
   TAKE(s(M), cons(N, IL)) -> ISNATILIST(IL)
   LENGTH(cons(N, L)) -> ULENGTH(and(isNat(N), isNatList(L)), L)
   LENGTH(cons(N, L)) -> AND(isNat(N), isNatList(L))
   LENGTH(cons(N, L)) -> ISNAT(N)
   LENGTH(cons(N, L)) -> ISNATLIST(L)
   ULENGTH(tt, L) -> LENGTH(L)

The collapsing dependency pairs are DP_c:
   UTAKE2(tt, M, N, IL) -> N
   ULENGTH(tt, L) -> L


The hidden terms of R are:

   zeros
   take(x0, x1)

Every hiding context is built from:
   aprove.DPFramework.CSDPProblem.QCSDPProblem$1@d3f593a

Hence, the new unhiding pairs DP_u are :
   UTAKE2(tt, M, N, IL) -> U(N)
   ULENGTH(tt, L) -> U(L)
   U(take(x_0, x_1)) -> U(x_0)
   U(take(x_0, x_1)) -> U(x_1)
   U(zeros) -> ZEROS
   U(take(x0, x1)) -> TAKE(x0, x1)

The TRS R consists of the following rules:

   and(tt, T) -> T
   isNatIList(IL) -> isNatList(IL)
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))

Q is empty.

----------------------------------------

(7) QCSDependencyGraphProof (EQUIVALENT)
The approximation of the Context-Sensitive Dependency Graph [LPAR08] contains 3 SCCs with 13 less nodes.

----------------------------------------

(8)
Complex Obligation (AND)

----------------------------------------

(9)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {and_2, s_1, length_1, take_2} are replacing on all positions.
For all symbols f in {cons_2, uTake2_4, uLength_2} we have mu(f) = {1}.
The symbols in {isNatIList_1, isNatList_1, isNat_1, ISNAT_1, ISNATLIST_1, ISNATILIST_1} are not replacing on any position.

The TRS P consists of the following rules:

   ISNATLIST(cons(N, L)) -> ISNAT(N)
   ISNAT(s(N)) -> ISNAT(N)
   ISNAT(length(L)) -> ISNATLIST(L)
   ISNATLIST(cons(N, L)) -> ISNATLIST(L)
   ISNATLIST(take(N, IL)) -> ISNAT(N)
   ISNATLIST(take(N, IL)) -> ISNATILIST(IL)
   ISNATILIST(IL) -> ISNATLIST(IL)
   ISNATILIST(cons(N, IL)) -> ISNAT(N)
   ISNATILIST(cons(N, IL)) -> ISNATILIST(IL)

The TRS R consists of the following rules:

   and(tt, T) -> T
   isNatIList(IL) -> isNatList(IL)
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))

Q is empty.

----------------------------------------

(10) QCSUsableRulesProof (EQUIVALENT)
The following rules are not useable [DA_EMMES] and can be deleted:

   and(tt, x0) -> x0
   isNatIList(x0) -> isNatList(x0)
   isNat(0) -> tt
   isNat(s(x0)) -> isNat(x0)
   isNat(length(x0)) -> isNatList(x0)
   isNatIList(zeros) -> tt
   isNatIList(cons(x0, x1)) -> and(isNat(x0), isNatIList(x1))
   isNatList(nil) -> tt
   isNatList(cons(x0, x1)) -> and(isNat(x0), isNatList(x1))
   isNatList(take(x0, x1)) -> and(isNat(x0), isNatIList(x1))
   zeros -> cons(0, zeros)
   take(s(x0), cons(x1, x2)) -> uTake2(and(isNat(x0), and(isNat(x1), isNatIList(x2))), x0, x1, x2)
   uTake2(tt, x0, x1, x2) -> cons(x1, take(x0, x2))
   length(cons(x0, x1)) -> uLength(and(isNat(x0), isNatList(x1)), x1)
   uLength(tt, x0) -> s(length(x0))

----------------------------------------

(11)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {s_1, length_1, take_2} are replacing on all positions.
For all symbols f in {cons_2} we have mu(f) = {1}.
The symbols in {ISNAT_1, ISNATLIST_1, ISNATILIST_1} are not replacing on any position.

The TRS P consists of the following rules:

   ISNATLIST(cons(N, L)) -> ISNAT(N)
   ISNAT(s(N)) -> ISNAT(N)
   ISNAT(length(L)) -> ISNATLIST(L)
   ISNATLIST(cons(N, L)) -> ISNATLIST(L)
   ISNATLIST(take(N, IL)) -> ISNAT(N)
   ISNATLIST(take(N, IL)) -> ISNATILIST(IL)
   ISNATILIST(IL) -> ISNATLIST(IL)
   ISNATILIST(cons(N, IL)) -> ISNAT(N)
   ISNATILIST(cons(N, IL)) -> ISNATILIST(IL)

R is empty.
Q is empty.

----------------------------------------

(12) QCSDPMuMonotonicPoloProof (EQUIVALENT)
By using the following mu-monotonic polynomial ordering [POLO], at least one Dependency Pair or term rewrite system rule of this Q-CSDP problem can be strictly oriented and thus deleted.

Strictly oriented dependency pairs:

   ISNAT(s(N)) -> ISNAT(N)
   ISNAT(length(L)) -> ISNATLIST(L)
   ISNATLIST(take(N, IL)) -> ISNAT(N)
   ISNATLIST(take(N, IL)) -> ISNATILIST(IL)
   ISNATILIST(IL) -> ISNATLIST(IL)
   ISNATILIST(cons(N, IL)) -> ISNAT(N)


Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(ISNAT(x_1)) = 1 + x_1
   POL(ISNATILIST(x_1)) = 2 + 2*x_1
   POL(ISNATLIST(x_1)) = 1 + 2*x_1
   POL(cons(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(length(x_1)) = 1 + 2*x_1
   POL(s(x_1)) = 2 + 2*x_1
   POL(take(x_1, x_2)) = 2 + 2*x_1 + x_2


----------------------------------------

(13)
Obligation:
Q-restricted context-sensitive dependency pair problem:
For all symbols f in {cons_2} we have mu(f) = {1}.
The symbols in {ISNAT_1, ISNATLIST_1, ISNATILIST_1} are not replacing on any position.

The TRS P consists of the following rules:

   ISNATLIST(cons(N, L)) -> ISNAT(N)
   ISNATLIST(cons(N, L)) -> ISNATLIST(L)
   ISNATILIST(cons(N, IL)) -> ISNATILIST(IL)

R is empty.
Q is empty.

----------------------------------------

(14) QCSDependencyGraphProof (EQUIVALENT)
The approximation of the Context-Sensitive Dependency Graph [LPAR08] contains 2 SCCs with 1 less node.

----------------------------------------

(15)
Complex Obligation (AND)

----------------------------------------

(16)
Obligation:
Q-restricted context-sensitive dependency pair problem:
For all symbols f in {cons_2} we have mu(f) = {1}.
The symbols in {ISNATILIST_1} are not replacing on any position.

The TRS P consists of the following rules:

   ISNATILIST(cons(N, IL)) -> ISNATILIST(IL)

R is empty.
Q is empty.

----------------------------------------

(17) QCSDPMuMonotonicPoloProof (EQUIVALENT)
By using the following mu-monotonic polynomial ordering [POLO], at least one Dependency Pair or term rewrite system rule of this Q-CSDP problem can be strictly oriented and thus deleted.

Strictly oriented dependency pairs:

   ISNATILIST(cons(N, IL)) -> ISNATILIST(IL)


Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(ISNATILIST(x_1)) = 2*x_1
   POL(cons(x_1, x_2)) = 1 + x_1 + x_2


----------------------------------------

(18)
Obligation:
Q-restricted context-sensitive dependency pair problem:

The TRS P consists of the following rules:
none

R is empty.
Q is empty.

----------------------------------------

(19) PIsEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R,mu)-chain.
----------------------------------------

(20)
YES

----------------------------------------

(21)
Obligation:
Q-restricted context-sensitive dependency pair problem:
For all symbols f in {cons_2} we have mu(f) = {1}.
The symbols in {ISNATLIST_1} are not replacing on any position.

The TRS P consists of the following rules:

   ISNATLIST(cons(N, L)) -> ISNATLIST(L)

R is empty.
Q is empty.

----------------------------------------

(22) QCSDPMuMonotonicPoloProof (EQUIVALENT)
By using the following mu-monotonic polynomial ordering [POLO], at least one Dependency Pair or term rewrite system rule of this Q-CSDP problem can be strictly oriented and thus deleted.

Strictly oriented dependency pairs:

   ISNATLIST(cons(N, L)) -> ISNATLIST(L)


Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(ISNATLIST(x_1)) = 2*x_1
   POL(cons(x_1, x_2)) = 1 + x_1 + x_2


----------------------------------------

(23)
Obligation:
Q-restricted context-sensitive dependency pair problem:

The TRS P consists of the following rules:
none

R is empty.
Q is empty.

----------------------------------------

(24) PIsEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R,mu)-chain.
----------------------------------------

(25)
YES

----------------------------------------

(26)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {and_2, s_1, length_1, take_2, TAKE_2} are replacing on all positions.
For all symbols f in {cons_2, uTake2_4, uLength_2, UTAKE2_4} we have mu(f) = {1}.
The symbols in {isNatIList_1, isNatList_1, isNat_1, U_1} are not replacing on any position.

The TRS P consists of the following rules:

   TAKE(s(M), cons(N, IL)) -> UTAKE2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   UTAKE2(tt, M, N, IL) -> U(N)
   U(take(x_0, x_1)) -> U(x_0)
   U(take(x_0, x_1)) -> U(x_1)
   U(take(x0, x1)) -> TAKE(x0, x1)

The TRS R consists of the following rules:

   and(tt, T) -> T
   isNatIList(IL) -> isNatList(IL)
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))

Q is empty.

----------------------------------------

(27) QCSDPSubtermProof (EQUIVALENT)
We use the subterm processor [DA_EMMES].


The following pairs can be oriented strictly and are deleted.

   TAKE(s(M), cons(N, IL)) -> UTAKE2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   U(take(x_0, x_1)) -> U(x_0)
   U(take(x_0, x_1)) -> U(x_1)
   U(take(x0, x1)) -> TAKE(x0, x1)
The remaining pairs can at least be oriented weakly.

   UTAKE2(tt, M, N, IL) -> U(N)
Used ordering:  Combined order from the following AFS and order.
UTAKE2(x1, x2, x3, x4)  =  x3

TAKE(x1, x2)  =  x2

U(x1)  =  x1


Subterm Order

----------------------------------------

(28)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {and_2, s_1, length_1, take_2} are replacing on all positions.
For all symbols f in {cons_2, uTake2_4, uLength_2, UTAKE2_4} we have mu(f) = {1}.
The symbols in {isNatIList_1, isNatList_1, isNat_1, U_1} are not replacing on any position.

The TRS P consists of the following rules:

   UTAKE2(tt, M, N, IL) -> U(N)

The TRS R consists of the following rules:

   and(tt, T) -> T
   isNatIList(IL) -> isNatList(IL)
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))

Q is empty.

----------------------------------------

(29) QCSDependencyGraphProof (EQUIVALENT)
The approximation of the Context-Sensitive Dependency Graph [LPAR08] contains 0 SCCs with 1 less node.

----------------------------------------

(30)
TRUE

----------------------------------------

(31)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {and_2, s_1, length_1, take_2, LENGTH_1} are replacing on all positions.
For all symbols f in {cons_2, uTake2_4, uLength_2, ULENGTH_2} we have mu(f) = {1}.
The symbols in {isNatIList_1, isNatList_1, isNat_1} are not replacing on any position.

The TRS P consists of the following rules:

   ULENGTH(tt, L) -> LENGTH(L)
   LENGTH(cons(N, L)) -> ULENGTH(and(isNat(N), isNatList(L)), L)

The TRS R consists of the following rules:

   and(tt, T) -> T
   isNatIList(IL) -> isNatList(IL)
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))

Q is empty.

----------------------------------------

(32) QCSDPReductionPairProof (EQUIVALENT)
Using the order

Matrix interpretation [MATRO]:

Non-tuple symbols: 
<<<
 M( isNat_1(x_1) ) =  	[[1], [1]] 	+ 	[[1, 0], [0, 0]] 	* 	x_1
>>>

<<<
 M( isNatIList_1(x_1) ) =  	[[1], [1]] 	+ 	[[1, 0], [0, 0]] 	* 	x_1
>>>

<<<
 M( and_2(x_1, x_2) ) =  	[[0], [0]] 	+ 	[[0, 0], [0, 0]] 	* 	x_1 	+ 	[[1, 0], [0, 1]] 	* 	x_2
>>>

<<<
 M( tt ) =  	[[1], [1]]
>>>

<<<
 M( uLength_2(x_1, x_2) ) =  	[[0], [0]] 	+ 	[[1, 0], [0, 0]] 	* 	x_1 	+ 	[[1, 1], [0, 0]] 	* 	x_2
>>>

<<<
 M( nil ) =  	[[1], [1]]
>>>

<<<
 M( s_1(x_1) ) =  	[[1], [0]] 	+ 	[[1, 0], [0, 0]] 	* 	x_1
>>>

<<<
 M( uTake2_4(x_1, ..., x_4) ) =  	[[0], [0]] 	+ 	[[0, 1], [0, 1]] 	* 	x_1 	+ 	[[0, 0], [1, 0]] 	* 	x_2 	+ 	[[0, 0], [0, 0]] 	* 	x_3 	+ 	[[1, 0], [1, 1]] 	* 	x_4
>>>

<<<
 M( length_1(x_1) ) =  	[[0], [0]] 	+ 	[[1, 1], [0, 0]] 	* 	x_1
>>>

<<<
 M( take_2(x_1, x_2) ) =  	[[1], [0]] 	+ 	[[0, 0], [1, 0]] 	* 	x_1 	+ 	[[1, 0], [0, 1]] 	* 	x_2
>>>

<<<
 M( zeros ) =  	[[0], [0]]
>>>

<<<
 M( 0 ) =  	[[0], [0]]
>>>

<<<
 M( cons_2(x_1, x_2) ) =  	[[0], [0]] 	+ 	[[0, 0], [0, 0]] 	* 	x_1 	+ 	[[1, 0], [1, 1]] 	* 	x_2
>>>

<<<
 M( isNatList_1(x_1) ) =  	[[0], [1]] 	+ 	[[1, 0], [0, 0]] 	* 	x_1
>>>

Tuple symbols: 
<<<
 M( LENGTH_1(x_1) ) =  	[[1]] 	+ 	[[0, 1]] 	* 	x_1
>>>

<<<
 M( ULENGTH_2(x_1, x_2) ) =  	[[0]] 	+ 	[[1, 0]] 	* 	x_1 	+ 	[[0, 1]] 	* 	x_2
>>>



Matrix type: 

We used a basic matrix type which is not further parametrizeable.





the following usable rules


   and(tt, T) -> T
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   isNatIList(IL) -> isNatList(IL)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)


could all be oriented weakly.

Furthermore, the pairs


   LENGTH(cons(N, L)) -> ULENGTH(and(isNat(N), isNatList(L)), L)


could be oriented strictly and thus removed by the CS-Reduction Pair Processor [LPAR08,DA_EMMES].


----------------------------------------

(33)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {and_2, s_1, length_1, take_2, LENGTH_1} are replacing on all positions.
For all symbols f in {cons_2, uTake2_4, uLength_2, ULENGTH_2} we have mu(f) = {1}.
The symbols in {isNatIList_1, isNatList_1, isNat_1} are not replacing on any position.

The TRS P consists of the following rules:

   ULENGTH(tt, L) -> LENGTH(L)

The TRS R consists of the following rules:

   and(tt, T) -> T
   isNatIList(IL) -> isNatList(IL)
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))

Q is empty.

----------------------------------------

(34) QCSDependencyGraphProof (EQUIVALENT)
The approximation of the Context-Sensitive Dependency Graph [LPAR08] contains 0 SCCs with 1 less node.

----------------------------------------

(35)
TRUE
