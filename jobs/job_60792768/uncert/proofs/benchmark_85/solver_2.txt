NO

Problem 1: 

(VAR vu95NonEmpty IL L M N)
(STRATEGY CONTEXTSENSITIVE
(U11 1)
(U12 1)
(U21 1)
(U22 1)
(U23 1)
(length 1)
(take 1 2)
(zeros)
(num0)
(cons 1)
(fSNonEmpty)
(nil)
(s 1)
(tt)
)
(RULES
U11(tt,L) -> U12(tt,L)
U12(tt,L) -> s(length(L))
U21(tt,IL,M,N) -> U22(tt,IL,M,N)
U22(tt,IL,M,N) -> U23(tt,IL,M,N)
U23(tt,IL,M,N) -> cons(N,take(M,IL))
length(cons(N,L)) -> U11(tt,L)
length(nil) -> num0
take(num0,IL) -> nil
take(s(M),cons(N,IL)) -> U21(tt,IL,M,N)
zeros -> cons(num0,zeros)
)


Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 U11Sharp(tt,L) -> U12Sharp(tt,L)
 U12Sharp(tt,L) -> LENGTH(L)
 U12Sharp(tt,L) -> L
 U21Sharp(tt,IL,M,N) -> U22Sharp(tt,IL,M,N)
 U22Sharp(tt,IL,M,N) -> U23Sharp(tt,IL,M,N)
 U23Sharp(tt,IL,M,N) -> N
 LENGTH(cons(N,L)) -> U11Sharp(tt,L)
 TAKE(s(M),cons(N,IL)) -> U21Sharp(tt,IL,M,N)
-> Rules:
 U11(tt,L) -> U12(tt,L)
 U12(tt,L) -> s(length(L))
 U21(tt,IL,M,N) -> U22(tt,IL,M,N)
 U22(tt,IL,M,N) -> U23(tt,IL,M,N)
 U23(tt,IL,M,N) -> cons(N,take(M,IL))
 length(cons(N,L)) -> U11(tt,L)
 length(nil) -> num0
 take(num0,IL) -> nil
 take(s(M),cons(N,IL)) -> U21(tt,IL,M,N)
 zeros -> cons(num0,zeros)
-> Unhiding Rules:
 take(M,IL) -> TAKE(M,IL)
 take(M,x5) -> x5
 take(x5,IL) -> x5
 zeros -> ZEROS

Problem 1: 

SCC Processor:
-> Pairs:
 U11Sharp(tt,L) -> U12Sharp(tt,L)
 U12Sharp(tt,L) -> LENGTH(L)
 U12Sharp(tt,L) -> L
 U21Sharp(tt,IL,M,N) -> U22Sharp(tt,IL,M,N)
 U22Sharp(tt,IL,M,N) -> U23Sharp(tt,IL,M,N)
 U23Sharp(tt,IL,M,N) -> N
 LENGTH(cons(N,L)) -> U11Sharp(tt,L)
 TAKE(s(M),cons(N,IL)) -> U21Sharp(tt,IL,M,N)
-> Rules:
 U11(tt,L) -> U12(tt,L)
 U12(tt,L) -> s(length(L))
 U21(tt,IL,M,N) -> U22(tt,IL,M,N)
 U22(tt,IL,M,N) -> U23(tt,IL,M,N)
 U23(tt,IL,M,N) -> cons(N,take(M,IL))
 length(cons(N,L)) -> U11(tt,L)
 length(nil) -> num0
 take(num0,IL) -> nil
 take(s(M),cons(N,IL)) -> U21(tt,IL,M,N)
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 take(M,IL) -> TAKE(M,IL)
 take(M,x5) -> x5
 take(x5,IL) -> x5
 zeros -> ZEROS
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 U21Sharp(tt,IL,M,N) -> U22Sharp(tt,IL,M,N)
 U22Sharp(tt,IL,M,N) -> U23Sharp(tt,IL,M,N)
 U23Sharp(tt,IL,M,N) -> N
 TAKE(s(M),cons(N,IL)) -> U21Sharp(tt,IL,M,N)
->->-> Rules:
 U11(tt,L) -> U12(tt,L)
 U12(tt,L) -> s(length(L))
 U21(tt,IL,M,N) -> U22(tt,IL,M,N)
 U22(tt,IL,M,N) -> U23(tt,IL,M,N)
 U23(tt,IL,M,N) -> cons(N,take(M,IL))
 length(cons(N,L)) -> U11(tt,L)
 length(nil) -> num0
 take(num0,IL) -> nil
 take(s(M),cons(N,IL)) -> U21(tt,IL,M,N)
 zeros -> cons(num0,zeros)
->->-> Unhiding rules:
 take(M,IL) -> TAKE(M,IL)
 take(M,x5) -> x5
 take(x5,IL) -> x5
->->Cycle:
->->-> Pairs:
 U11Sharp(tt,L) -> U12Sharp(tt,L)
 U12Sharp(tt,L) -> LENGTH(L)
 LENGTH(cons(N,L)) -> U11Sharp(tt,L)
->->-> Rules:
 U11(tt,L) -> U12(tt,L)
 U12(tt,L) -> s(length(L))
 U21(tt,IL,M,N) -> U22(tt,IL,M,N)
 U22(tt,IL,M,N) -> U23(tt,IL,M,N)
 U23(tt,IL,M,N) -> cons(N,take(M,IL))
 length(cons(N,L)) -> U11(tt,L)
 length(nil) -> num0
 take(num0,IL) -> nil
 take(s(M),cons(N,IL)) -> U21(tt,IL,M,N)
 zeros -> cons(num0,zeros)
->->-> Unhiding rules:
 Empty

Problem 1: 

Basic Processor:
-> Pairs:
 U11Sharp(tt,L) -> U12Sharp(tt,L)
 U12Sharp(tt,L) -> LENGTH(L)
 LENGTH(cons(N,L)) -> U11Sharp(tt,L)
-> Rules:
 U11(tt,L) -> U12(tt,L)
 U12(tt,L) -> s(length(L))
 U21(tt,IL,M,N) -> U22(tt,IL,M,N)
 U22(tt,IL,M,N) -> U23(tt,IL,M,N)
 U23(tt,IL,M,N) -> cons(N,take(M,IL))
 length(cons(N,L)) -> U11(tt,L)
 length(nil) -> num0
 take(num0,IL) -> nil
 take(s(M),cons(N,IL)) -> U21(tt,IL,M,N)
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 Empty
-> Pairs in cycle:
 U11Sharp(tt,zeros) -> U12Sharp(tt,zeros)
 U12Sharp(tt,zeros) -> LENGTH(zeros)
 LENGTH(zeros) -> LENGTH(cons(num0,zeros))
 LENGTH(cons(num0,zeros)) -> U11Sharp(tt,zeros)

The problem is infinite.
