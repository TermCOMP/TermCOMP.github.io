YES

Problem 1: 

(VAR vu95NonEmpty N X XS Y)
(STRATEGY CONTEXTSENSITIVE
(add 1 2)
(fib 1)
(fib1 1 2)
(sel 1 2)
(num0)
(cons 1)
(fSNonEmpty)
(s 1)
)
(RULES
add(num0,X) -> X
add(s(X),Y) -> s(add(X,Y))
fib(N) -> sel(N,fib1(s(num0),s(num0)))
fib1(X,Y) -> cons(X,fib1(Y,add(X,Y)))
sel(num0,cons(X,XS)) -> X
sel(s(N),cons(X,XS)) -> sel(N,XS)
)


Problem 1: 

Innermost Equivalent Processor:
-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fib(N) -> sel(N,fib1(s(num0),s(num0)))
 fib1(X,Y) -> cons(X,fib1(Y,add(X,Y)))
 sel(num0,cons(X,XS)) -> X
 sel(s(N),cons(X,XS)) -> sel(N,XS)
-> The context-sensitive term rewriting system is an orthogonal system. Therefore, innermost cs-termination implies cs-termination.
 

Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 ADD(s(X),Y) -> ADD(X,Y)
 FIB(N) -> FIB1(s(num0),s(num0))
 FIB(N) -> SEL(N,fib1(s(num0),s(num0)))
 SEL(s(N),cons(X,XS)) -> SEL(N,XS)
 SEL(s(N),cons(X,XS)) -> XS
-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fib(N) -> sel(N,fib1(s(num0),s(num0)))
 fib1(X,Y) -> cons(X,fib1(Y,add(X,Y)))
 sel(num0,cons(X,XS)) -> X
 sel(s(N),cons(X,XS)) -> sel(N,XS)
-> Unhiding Rules:
 fib1(Y,add(X,Y)) -> ADD(X,Y)
 fib1(Y,add(X,Y)) -> FIB1(Y,add(X,Y))

Problem 1: 

SCC Processor:
-> Pairs:
 ADD(s(X),Y) -> ADD(X,Y)
 FIB(N) -> FIB1(s(num0),s(num0))
 FIB(N) -> SEL(N,fib1(s(num0),s(num0)))
 SEL(s(N),cons(X,XS)) -> SEL(N,XS)
 SEL(s(N),cons(X,XS)) -> XS
-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fib(N) -> sel(N,fib1(s(num0),s(num0)))
 fib1(X,Y) -> cons(X,fib1(Y,add(X,Y)))
 sel(num0,cons(X,XS)) -> X
 sel(s(N),cons(X,XS)) -> sel(N,XS)
-> Unhiding rules:
 fib1(Y,add(X,Y)) -> ADD(X,Y)
 fib1(Y,add(X,Y)) -> FIB1(Y,add(X,Y))
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 ADD(s(X),Y) -> ADD(X,Y)
->->-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fib(N) -> sel(N,fib1(s(num0),s(num0)))
 fib1(X,Y) -> cons(X,fib1(Y,add(X,Y)))
 sel(num0,cons(X,XS)) -> X
 sel(s(N),cons(X,XS)) -> sel(N,XS)
->->-> Unhiding rules:
 Empty
->->Cycle:
->->-> Pairs:
 SEL(s(N),cons(X,XS)) -> SEL(N,XS)
->->-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fib(N) -> sel(N,fib1(s(num0),s(num0)))
 fib1(X,Y) -> cons(X,fib1(Y,add(X,Y)))
 sel(num0,cons(X,XS)) -> X
 sel(s(N),cons(X,XS)) -> sel(N,XS)
->->-> Unhiding rules:
 Empty


The problem is decomposed in 2 subproblems.

Problem 1.1: 

SubNColl Processor:
-> Pairs:
 ADD(s(X),Y) -> ADD(X,Y)
-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fib(N) -> sel(N,fib1(s(num0),s(num0)))
 fib1(X,Y) -> cons(X,fib1(Y,add(X,Y)))
 sel(num0,cons(X,XS)) -> X
 sel(s(N),cons(X,XS)) -> sel(N,XS)
-> Unhiding rules:
 Empty
->Projection:
 pi(ADD) = 1

Problem 1.1: 

Basic Processor:
-> Pairs:
 Empty
-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fib(N) -> sel(N,fib1(s(num0),s(num0)))
 fib1(X,Y) -> cons(X,fib1(Y,add(X,Y)))
 sel(num0,cons(X,XS)) -> X
 sel(s(N),cons(X,XS)) -> sel(N,XS)
-> Unhiding rules:
 Empty
-> Result:
 Set P is empty

The problem is finite.

Problem 1.2: 

SubNColl Processor:
-> Pairs:
 SEL(s(N),cons(X,XS)) -> SEL(N,XS)
-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fib(N) -> sel(N,fib1(s(num0),s(num0)))
 fib1(X,Y) -> cons(X,fib1(Y,add(X,Y)))
 sel(num0,cons(X,XS)) -> X
 sel(s(N),cons(X,XS)) -> sel(N,XS)
-> Unhiding rules:
 Empty
->Projection:
 pi(SEL) = 1

Problem 1.2: 

Basic Processor:
-> Pairs:
 Empty
-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fib(N) -> sel(N,fib1(s(num0),s(num0)))
 fib1(X,Y) -> cons(X,fib1(Y,add(X,Y)))
 sel(num0,cons(X,XS)) -> X
 sel(s(N),cons(X,XS)) -> sel(N,XS)
-> Unhiding rules:
 Empty
-> Result:
 Set P is empty

The problem is finite.
