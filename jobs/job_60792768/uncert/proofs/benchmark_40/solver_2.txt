YES

Problem 1: 

(VAR vu95NonEmpty N X XS)
(STRATEGY CONTEXTSENSITIVE
(num2nd 1)
(from 1)
(head 1)
(sel 1 2)
(take 1 2)
(num0)
(cons 1)
(fSNonEmpty)
(nil)
(s 1)
)
(RULES
num2nd(cons(X,XS)) -> head(XS)
from(X) -> cons(X,from(s(X)))
head(cons(X,XS)) -> X
sel(num0,cons(X,XS)) -> X
sel(s(N),cons(X,XS)) -> sel(N,XS)
take(num0,XS) -> nil
take(s(N),cons(X,XS)) -> cons(X,take(N,XS))
)


Problem 1: 

Innermost Equivalent Processor:
-> Rules:
 num2nd(cons(X,XS)) -> head(XS)
 from(X) -> cons(X,from(s(X)))
 head(cons(X,XS)) -> X
 sel(num0,cons(X,XS)) -> X
 sel(s(N),cons(X,XS)) -> sel(N,XS)
 take(num0,XS) -> nil
 take(s(N),cons(X,XS)) -> cons(X,take(N,XS))
-> The context-sensitive term rewriting system is an orthogonal system. Therefore, innermost cs-termination implies cs-termination.
 

Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 NUM2ND(cons(X,XS)) -> HEAD(XS)
 NUM2ND(cons(X,XS)) -> XS
 SEL(s(N),cons(X,XS)) -> SEL(N,XS)
 SEL(s(N),cons(X,XS)) -> XS
-> Rules:
 num2nd(cons(X,XS)) -> head(XS)
 from(X) -> cons(X,from(s(X)))
 head(cons(X,XS)) -> X
 sel(num0,cons(X,XS)) -> X
 sel(s(N),cons(X,XS)) -> sel(N,XS)
 take(num0,XS) -> nil
 take(s(N),cons(X,XS)) -> cons(X,take(N,XS))
-> Unhiding Rules:
 from(s(X)) -> FROM(s(X))
 take(N,XS) -> TAKE(N,XS)
 take(N,x4) -> x4

Problem 1: 

SCC Processor:
-> Pairs:
 NUM2ND(cons(X,XS)) -> HEAD(XS)
 NUM2ND(cons(X,XS)) -> XS
 SEL(s(N),cons(X,XS)) -> SEL(N,XS)
 SEL(s(N),cons(X,XS)) -> XS
-> Rules:
 num2nd(cons(X,XS)) -> head(XS)
 from(X) -> cons(X,from(s(X)))
 head(cons(X,XS)) -> X
 sel(num0,cons(X,XS)) -> X
 sel(s(N),cons(X,XS)) -> sel(N,XS)
 take(num0,XS) -> nil
 take(s(N),cons(X,XS)) -> cons(X,take(N,XS))
-> Unhiding rules:
 from(s(X)) -> FROM(s(X))
 take(N,XS) -> TAKE(N,XS)
 take(N,x4) -> x4
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 SEL(s(N),cons(X,XS)) -> SEL(N,XS)
->->-> Rules:
 num2nd(cons(X,XS)) -> head(XS)
 from(X) -> cons(X,from(s(X)))
 head(cons(X,XS)) -> X
 sel(num0,cons(X,XS)) -> X
 sel(s(N),cons(X,XS)) -> sel(N,XS)
 take(num0,XS) -> nil
 take(s(N),cons(X,XS)) -> cons(X,take(N,XS))
->->-> Unhiding rules:
 Empty

Problem 1: 

SubNColl Processor:
-> Pairs:
 SEL(s(N),cons(X,XS)) -> SEL(N,XS)
-> Rules:
 num2nd(cons(X,XS)) -> head(XS)
 from(X) -> cons(X,from(s(X)))
 head(cons(X,XS)) -> X
 sel(num0,cons(X,XS)) -> X
 sel(s(N),cons(X,XS)) -> sel(N,XS)
 take(num0,XS) -> nil
 take(s(N),cons(X,XS)) -> cons(X,take(N,XS))
-> Unhiding rules:
 Empty
->Projection:
 pi(SEL) = 1

Problem 1: 

Basic Processor:
-> Pairs:
 Empty
-> Rules:
 num2nd(cons(X,XS)) -> head(XS)
 from(X) -> cons(X,from(s(X)))
 head(cons(X,XS)) -> X
 sel(num0,cons(X,XS)) -> X
 sel(s(N),cons(X,XS)) -> sel(N,XS)
 take(num0,XS) -> nil
 take(s(N),cons(X,XS)) -> cons(X,take(N,XS))
-> Unhiding rules:
 Empty
-> Result:
 Set P is empty

The problem is finite.
