YES

Problem 1: 

(VAR vu95NonEmpty X Y)
(STRATEGY CONTEXTSENSITIVE
(add 1 2)
(fact 1)
(if 1)
(p 1)
(prod 1 2)
(zero 1)
(num0)
(fSNonEmpty)
(ffalse)
(s 1)
(ftrue)
)
(RULES
add(num0,X) -> X
add(s(X),Y) -> s(add(X,Y))
fact(X) -> if(zero(X),s(num0),prod(X,fact(p(X))))
if(ffalse,X,Y) -> Y
if(ftrue,X,Y) -> X
p(s(X)) -> X
prod(num0,X) -> num0
prod(s(X),Y) -> add(Y,prod(X,Y))
zero(num0) -> ftrue
zero(s(X)) -> ffalse
)


Problem 1: 

Innermost Equivalent Processor:
-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fact(X) -> if(zero(X),s(num0),prod(X,fact(p(X))))
 if(ffalse,X,Y) -> Y
 if(ftrue,X,Y) -> X
 p(s(X)) -> X
 prod(num0,X) -> num0
 prod(s(X),Y) -> add(Y,prod(X,Y))
 zero(num0) -> ftrue
 zero(s(X)) -> ffalse
-> The context-sensitive term rewriting system is an orthogonal system. Therefore, innermost cs-termination implies cs-termination.
 

Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 ADD(s(X),Y) -> ADD(X,Y)
 FACT(X) -> IF(zero(X),s(num0),prod(X,fact(p(X))))
 FACT(X) -> ZERO(X)
 IF(ffalse,X,Y) -> Y
 IF(ftrue,X,Y) -> X
 PROD(s(X),Y) -> ADD(Y,prod(X,Y))
 PROD(s(X),Y) -> PROD(X,Y)
-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fact(X) -> if(zero(X),s(num0),prod(X,fact(p(X))))
 if(ffalse,X,Y) -> Y
 if(ftrue,X,Y) -> X
 p(s(X)) -> X
 prod(num0,X) -> num0
 prod(s(X),Y) -> add(Y,prod(X,Y))
 zero(num0) -> ftrue
 zero(s(X)) -> ffalse
-> Unhiding Rules:
 prod(X,fact(p(X))) -> FACT(p(X))
 prod(X,fact(p(X))) -> P(X)
 prod(X,fact(p(X))) -> PROD(X,fact(p(X)))

Problem 1: 

SCC Processor:
-> Pairs:
 ADD(s(X),Y) -> ADD(X,Y)
 FACT(X) -> IF(zero(X),s(num0),prod(X,fact(p(X))))
 FACT(X) -> ZERO(X)
 IF(ffalse,X,Y) -> Y
 IF(ftrue,X,Y) -> X
 PROD(s(X),Y) -> ADD(Y,prod(X,Y))
 PROD(s(X),Y) -> PROD(X,Y)
-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fact(X) -> if(zero(X),s(num0),prod(X,fact(p(X))))
 if(ffalse,X,Y) -> Y
 if(ftrue,X,Y) -> X
 p(s(X)) -> X
 prod(num0,X) -> num0
 prod(s(X),Y) -> add(Y,prod(X,Y))
 zero(num0) -> ftrue
 zero(s(X)) -> ffalse
-> Unhiding rules:
 prod(X,fact(p(X))) -> FACT(p(X))
 prod(X,fact(p(X))) -> P(X)
 prod(X,fact(p(X))) -> PROD(X,fact(p(X)))
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 ADD(s(X),Y) -> ADD(X,Y)
->->-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fact(X) -> if(zero(X),s(num0),prod(X,fact(p(X))))
 if(ffalse,X,Y) -> Y
 if(ftrue,X,Y) -> X
 p(s(X)) -> X
 prod(num0,X) -> num0
 prod(s(X),Y) -> add(Y,prod(X,Y))
 zero(num0) -> ftrue
 zero(s(X)) -> ffalse
->->-> Unhiding rules:
 Empty
->->Cycle:
->->-> Pairs:
 PROD(s(X),Y) -> PROD(X,Y)
->->-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fact(X) -> if(zero(X),s(num0),prod(X,fact(p(X))))
 if(ffalse,X,Y) -> Y
 if(ftrue,X,Y) -> X
 p(s(X)) -> X
 prod(num0,X) -> num0
 prod(s(X),Y) -> add(Y,prod(X,Y))
 zero(num0) -> ftrue
 zero(s(X)) -> ffalse
->->-> Unhiding rules:
 Empty
->->Cycle:
->->-> Pairs:
 FACT(X) -> IF(zero(X),s(num0),prod(X,fact(p(X))))
 IF(ffalse,X,Y) -> Y
 IF(ftrue,X,Y) -> X
->->-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fact(X) -> if(zero(X),s(num0),prod(X,fact(p(X))))
 if(ffalse,X,Y) -> Y
 if(ftrue,X,Y) -> X
 p(s(X)) -> X
 prod(num0,X) -> num0
 prod(s(X),Y) -> add(Y,prod(X,Y))
 zero(num0) -> ftrue
 zero(s(X)) -> ffalse
->->-> Unhiding rules:
 prod(X,fact(p(X))) -> FACT(p(X))


The problem is decomposed in 3 subproblems.

Problem 1.1: 

SubNColl Processor:
-> Pairs:
 ADD(s(X),Y) -> ADD(X,Y)
-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fact(X) -> if(zero(X),s(num0),prod(X,fact(p(X))))
 if(ffalse,X,Y) -> Y
 if(ftrue,X,Y) -> X
 p(s(X)) -> X
 prod(num0,X) -> num0
 prod(s(X),Y) -> add(Y,prod(X,Y))
 zero(num0) -> ftrue
 zero(s(X)) -> ffalse
-> Unhiding rules:
 Empty
->Projection:
 pi(ADD) = 1

Problem 1.1: 

Basic Processor:
-> Pairs:
 Empty
-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fact(X) -> if(zero(X),s(num0),prod(X,fact(p(X))))
 if(ffalse,X,Y) -> Y
 if(ftrue,X,Y) -> X
 p(s(X)) -> X
 prod(num0,X) -> num0
 prod(s(X),Y) -> add(Y,prod(X,Y))
 zero(num0) -> ftrue
 zero(s(X)) -> ffalse
-> Unhiding rules:
 Empty
-> Result:
 Set P is empty

The problem is finite.

Problem 1.2: 

SubNColl Processor:
-> Pairs:
 PROD(s(X),Y) -> PROD(X,Y)
-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fact(X) -> if(zero(X),s(num0),prod(X,fact(p(X))))
 if(ffalse,X,Y) -> Y
 if(ftrue,X,Y) -> X
 p(s(X)) -> X
 prod(num0,X) -> num0
 prod(s(X),Y) -> add(Y,prod(X,Y))
 zero(num0) -> ftrue
 zero(s(X)) -> ffalse
-> Unhiding rules:
 Empty
->Projection:
 pi(PROD) = 1

Problem 1.2: 

Basic Processor:
-> Pairs:
 Empty
-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fact(X) -> if(zero(X),s(num0),prod(X,fact(p(X))))
 if(ffalse,X,Y) -> Y
 if(ftrue,X,Y) -> X
 p(s(X)) -> X
 prod(num0,X) -> num0
 prod(s(X),Y) -> add(Y,prod(X,Y))
 zero(num0) -> ftrue
 zero(s(X)) -> ffalse
-> Unhiding rules:
 Empty
-> Result:
 Set P is empty

The problem is finite.

Problem 1.3: 

Reduction Triple Processor:
-> Pairs:
 FACT(X) -> IF(zero(X),s(num0),prod(X,fact(p(X))))
 IF(ffalse,X,Y) -> Y
 IF(ftrue,X,Y) -> X
-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fact(X) -> if(zero(X),s(num0),prod(X,fact(p(X))))
 if(ffalse,X,Y) -> Y
 if(ftrue,X,Y) -> X
 p(s(X)) -> X
 prod(num0,X) -> num0
 prod(s(X),Y) -> add(Y,prod(X,Y))
 zero(num0) -> ftrue
 zero(s(X)) -> ffalse
-> Unhiding rules:
 prod(X,fact(p(X))) -> FACT(p(X))
-> Usable rules:
 p(s(X)) -> X
 zero(num0) -> ftrue
 zero(s(X)) -> ffalse
->Interpretation type:
 Simple mixed
->Coefficients:
 All rationals
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[add](X1,X2) = 0
[fact](X) = 1/2.X
[if](X1,X2,X3) = 0
[p](X) = 1/2.X
[prod](X1,X2) = 2.X1.X2 + X1 + 2
[zero](X) = 1/2.X.X
[num0] = 2
[fSNonEmpty] = 0
[ffalse] = 1/2
[s](X) = 2.X + 1
[ftrue] = 2
[ADD](X1,X2) = 0
[FACT](X) = 2.X.X + 2.X + 2
[IF](X1,X2,X3) = 1/2.X1.X2 + 1/2.X1 + X3
[P](X) = 0
[PROD](X1,X2) = 0
[ZERO](X) = 0

Problem 1.3: 

SCC Processor:
-> Pairs:
 FACT(X) -> IF(zero(X),s(num0),prod(X,fact(p(X))))
 IF(ftrue,X,Y) -> X
-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fact(X) -> if(zero(X),s(num0),prod(X,fact(p(X))))
 if(ffalse,X,Y) -> Y
 if(ftrue,X,Y) -> X
 p(s(X)) -> X
 prod(num0,X) -> num0
 prod(s(X),Y) -> add(Y,prod(X,Y))
 zero(num0) -> ftrue
 zero(s(X)) -> ffalse
-> Unhiding rules:
 prod(X,fact(p(X))) -> FACT(p(X))
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 FACT(X) -> IF(zero(X),s(num0),prod(X,fact(p(X))))
 IF(ftrue,X,Y) -> X
->->-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fact(X) -> if(zero(X),s(num0),prod(X,fact(p(X))))
 if(ffalse,X,Y) -> Y
 if(ftrue,X,Y) -> X
 p(s(X)) -> X
 prod(num0,X) -> num0
 prod(s(X),Y) -> add(Y,prod(X,Y))
 zero(num0) -> ftrue
 zero(s(X)) -> ffalse
->->-> Unhiding rules:
 prod(X,fact(p(X))) -> FACT(p(X))

Problem 1.3: 

Reduction Triple Processor:
-> Pairs:
 FACT(X) -> IF(zero(X),s(num0),prod(X,fact(p(X))))
 IF(ftrue,X,Y) -> X
-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fact(X) -> if(zero(X),s(num0),prod(X,fact(p(X))))
 if(ffalse,X,Y) -> Y
 if(ftrue,X,Y) -> X
 p(s(X)) -> X
 prod(num0,X) -> num0
 prod(s(X),Y) -> add(Y,prod(X,Y))
 zero(num0) -> ftrue
 zero(s(X)) -> ffalse
-> Unhiding rules:
 prod(X,fact(p(X))) -> FACT(p(X))
-> Usable rules:
 p(s(X)) -> X
 zero(num0) -> ftrue
 zero(s(X)) -> ffalse
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[add](X1,X2) = 0
[fact](X) = 2.X
[if](X1,X2,X3) = 0
[p](X) = 2.X + 2
[prod](X1,X2) = 2.X2 + 1
[zero](X) = 2.X
[num0] = 0
[fSNonEmpty] = 0
[ffalse] = 0
[s](X) = 2.X
[ftrue] = 0
[ADD](X1,X2) = 0
[FACT](X) = 2.X + 1
[IF](X1,X2,X3) = X1 + X2 + 1
[P](X) = 0
[PROD](X1,X2) = 0
[ZERO](X) = 0

Problem 1.3: 

SCC Processor:
-> Pairs:
 FACT(X) -> IF(zero(X),s(num0),prod(X,fact(p(X))))
 IF(ftrue,X,Y) -> X
-> Rules:
 add(num0,X) -> X
 add(s(X),Y) -> s(add(X,Y))
 fact(X) -> if(zero(X),s(num0),prod(X,fact(p(X))))
 if(ffalse,X,Y) -> Y
 if(ftrue,X,Y) -> X
 p(s(X)) -> X
 prod(num0,X) -> num0
 prod(s(X),Y) -> add(Y,prod(X,Y))
 zero(num0) -> ftrue
 zero(s(X)) -> ffalse
-> Unhiding rules:
 Empty
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
