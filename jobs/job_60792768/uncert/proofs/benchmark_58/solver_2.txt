YES

Problem 1: 

(VAR vu95NonEmpty L N V V1 V2 X)
(STRATEGY CONTEXTSENSITIVE
(U11 1)
(and 1)
(isNat)
(isNatIList)
(isNatList)
(length 1)
(zeros)
(num0)
(cons 1)
(fSNonEmpty)
(nil)
(s 1)
(tt)
)
(RULES
U11(tt,L) -> s(length(L))
and(tt,X) -> X
isNat(length(V1)) -> isNatList(V1)
isNat(num0) -> tt
isNat(s(V1)) -> isNat(V1)
isNatIList(zeros) -> tt
isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
isNatIList(V) -> isNatList(V)
isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
isNatList(nil) -> tt
length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
length(nil) -> num0
zeros -> cons(num0,zeros)
)


Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 U11Sharp(tt,L) -> LENGTH(L)
 U11Sharp(tt,L) -> L
 AND(tt,X) -> X
 ISNAT(length(V1)) -> ISNATLIST(V1)
 ISNAT(s(V1)) -> ISNAT(V1)
 ISNATILIST(cons(V1,V2)) -> AND(isNat(V1),isNatIList(V2))
 ISNATILIST(cons(V1,V2)) -> ISNAT(V1)
 ISNATILIST(V) -> ISNATLIST(V)
 ISNATLIST(cons(V1,V2)) -> AND(isNat(V1),isNatList(V2))
 ISNATLIST(cons(V1,V2)) -> ISNAT(V1)
 LENGTH(cons(N,L)) -> U11Sharp(and(isNatList(L),isNat(N)),L)
 LENGTH(cons(N,L)) -> AND(isNatList(L),isNat(N))
 LENGTH(cons(N,L)) -> ISNATLIST(L)
-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding Rules:
 isNat(N) -> ISNAT(N)
 isNatIList(V2) -> ISNATILIST(V2)
 isNatList(V2) -> ISNATLIST(V2)
 zeros -> ZEROS

Problem 1: 

SCC Processor:
-> Pairs:
 U11Sharp(tt,L) -> LENGTH(L)
 U11Sharp(tt,L) -> L
 AND(tt,X) -> X
 ISNAT(length(V1)) -> ISNATLIST(V1)
 ISNAT(s(V1)) -> ISNAT(V1)
 ISNATILIST(cons(V1,V2)) -> AND(isNat(V1),isNatIList(V2))
 ISNATILIST(cons(V1,V2)) -> ISNAT(V1)
 ISNATILIST(V) -> ISNATLIST(V)
 ISNATLIST(cons(V1,V2)) -> AND(isNat(V1),isNatList(V2))
 ISNATLIST(cons(V1,V2)) -> ISNAT(V1)
 LENGTH(cons(N,L)) -> U11Sharp(and(isNatList(L),isNat(N)),L)
 LENGTH(cons(N,L)) -> AND(isNatList(L),isNat(N))
 LENGTH(cons(N,L)) -> ISNATLIST(L)
-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 isNat(N) -> ISNAT(N)
 isNatIList(V2) -> ISNATILIST(V2)
 isNatList(V2) -> ISNATLIST(V2)
 zeros -> ZEROS
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 AND(tt,X) -> X
 ISNAT(length(V1)) -> ISNATLIST(V1)
 ISNAT(s(V1)) -> ISNAT(V1)
 ISNATILIST(cons(V1,V2)) -> AND(isNat(V1),isNatIList(V2))
 ISNATILIST(cons(V1,V2)) -> ISNAT(V1)
 ISNATILIST(V) -> ISNATLIST(V)
 ISNATLIST(cons(V1,V2)) -> AND(isNat(V1),isNatList(V2))
 ISNATLIST(cons(V1,V2)) -> ISNAT(V1)
->->-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->->-> Unhiding rules:
 isNat(N) -> ISNAT(N)
 isNatIList(V2) -> ISNATILIST(V2)
 isNatList(V2) -> ISNATLIST(V2)
->->Cycle:
->->-> Pairs:
 U11Sharp(tt,L) -> LENGTH(L)
 LENGTH(cons(N,L)) -> U11Sharp(and(isNatList(L),isNat(N)),L)
->->-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->->-> Unhiding rules:
 Empty


The problem is decomposed in 2 subproblems.

Problem 1.1: 

Reduction Triple Processor:
-> Pairs:
 AND(tt,X) -> X
 ISNAT(length(V1)) -> ISNATLIST(V1)
 ISNAT(s(V1)) -> ISNAT(V1)
 ISNATILIST(cons(V1,V2)) -> AND(isNat(V1),isNatIList(V2))
 ISNATILIST(cons(V1,V2)) -> ISNAT(V1)
 ISNATILIST(V) -> ISNATLIST(V)
 ISNATLIST(cons(V1,V2)) -> AND(isNat(V1),isNatList(V2))
 ISNATLIST(cons(V1,V2)) -> ISNAT(V1)
-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 isNat(N) -> ISNAT(N)
 isNatIList(V2) -> ISNATILIST(V2)
 isNatList(V2) -> ISNATLIST(V2)
-> Usable rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[U11](X1,X2) = 2.X2
[and](X1,X2) = 2.X2
[isNat](X) = 2.X + 2
[isNatIList](X) = 2.X
[isNatList](X) = 2.X
[length](X) = X
[zeros] = 0
[num0] = 0
[cons](X1,X2) = 2.X1 + 2.X2
[fSNonEmpty] = 0
[nil] = 2
[s](X) = 2.X
[tt] = 0
[U11Sharp](X1,X2) = 0
[AND](X1,X2) = X2
[ISNAT](X) = 2.X
[ISNATILIST](X) = 2.X
[ISNATLIST](X) = 2.X
[LENGTH](X) = 0
[ZEROS] = 0

Problem 1.1: 

SCC Processor:
-> Pairs:
 AND(tt,X) -> X
 ISNAT(length(V1)) -> ISNATLIST(V1)
 ISNAT(s(V1)) -> ISNAT(V1)
 ISNATILIST(cons(V1,V2)) -> AND(isNat(V1),isNatIList(V2))
 ISNATILIST(cons(V1,V2)) -> ISNAT(V1)
 ISNATILIST(V) -> ISNATLIST(V)
 ISNATLIST(cons(V1,V2)) -> AND(isNat(V1),isNatList(V2))
 ISNATLIST(cons(V1,V2)) -> ISNAT(V1)
-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 isNatIList(V2) -> ISNATILIST(V2)
 isNatList(V2) -> ISNATLIST(V2)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 AND(tt,X) -> X
 ISNAT(length(V1)) -> ISNATLIST(V1)
 ISNAT(s(V1)) -> ISNAT(V1)
 ISNATILIST(cons(V1,V2)) -> AND(isNat(V1),isNatIList(V2))
 ISNATILIST(cons(V1,V2)) -> ISNAT(V1)
 ISNATILIST(V) -> ISNATLIST(V)
 ISNATLIST(cons(V1,V2)) -> AND(isNat(V1),isNatList(V2))
 ISNATLIST(cons(V1,V2)) -> ISNAT(V1)
->->-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->->-> Unhiding rules:
 isNatIList(V2) -> ISNATILIST(V2)
 isNatList(V2) -> ISNATLIST(V2)

Problem 1.1: 

Reduction Triple Processor:
-> Pairs:
 AND(tt,X) -> X
 ISNAT(length(V1)) -> ISNATLIST(V1)
 ISNAT(s(V1)) -> ISNAT(V1)
 ISNATILIST(cons(V1,V2)) -> AND(isNat(V1),isNatIList(V2))
 ISNATILIST(cons(V1,V2)) -> ISNAT(V1)
 ISNATILIST(V) -> ISNATLIST(V)
 ISNATLIST(cons(V1,V2)) -> AND(isNat(V1),isNatList(V2))
 ISNATLIST(cons(V1,V2)) -> ISNAT(V1)
-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 isNatIList(V2) -> ISNATILIST(V2)
 isNatList(V2) -> ISNATLIST(V2)
-> Usable rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[U11](X1,X2) = X1 + 2.X2 + 2
[and](X1,X2) = 2.X2
[isNat](X) = 2.X
[isNatIList](X) = 2.X
[isNatList](X) = 2.X
[length](X) = 2.X + 2
[zeros] = 0
[num0] = 0
[cons](X1,X2) = 2.X1 + 2.X2
[fSNonEmpty] = 0
[nil] = 1
[s](X) = X
[tt] = 0
[U11Sharp](X1,X2) = 0
[AND](X1,X2) = X2
[ISNAT](X) = X
[ISNATILIST](X) = 2.X
[ISNATLIST](X) = X
[LENGTH](X) = 0
[ZEROS] = 0

Problem 1.1: 

SCC Processor:
-> Pairs:
 AND(tt,X) -> X
 ISNAT(s(V1)) -> ISNAT(V1)
 ISNATILIST(cons(V1,V2)) -> AND(isNat(V1),isNatIList(V2))
 ISNATILIST(cons(V1,V2)) -> ISNAT(V1)
 ISNATILIST(V) -> ISNATLIST(V)
 ISNATLIST(cons(V1,V2)) -> AND(isNat(V1),isNatList(V2))
 ISNATLIST(cons(V1,V2)) -> ISNAT(V1)
-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 isNatIList(V2) -> ISNATILIST(V2)
 isNatList(V2) -> ISNATLIST(V2)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 ISNAT(s(V1)) -> ISNAT(V1)
->->-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->->-> Unhiding rules:
 Empty
->->Cycle:
->->-> Pairs:
 AND(tt,X) -> X
 ISNATILIST(cons(V1,V2)) -> AND(isNat(V1),isNatIList(V2))
 ISNATILIST(V) -> ISNATLIST(V)
 ISNATLIST(cons(V1,V2)) -> AND(isNat(V1),isNatList(V2))
->->-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->->-> Unhiding rules:
 isNatIList(V2) -> ISNATILIST(V2)
 isNatList(V2) -> ISNATLIST(V2)


The problem is decomposed in 2 subproblems.

Problem 1.1.1: 

SubNColl Processor:
-> Pairs:
 ISNAT(s(V1)) -> ISNAT(V1)
-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 Empty
->Projection:
 pi(ISNAT) = 1

Problem 1.1.1: 

Basic Processor:
-> Pairs:
 Empty
-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 Empty
-> Result:
 Set P is empty

The problem is finite.

Problem 1.1.2: 

Reduction Triple Processor:
-> Pairs:
 AND(tt,X) -> X
 ISNATILIST(cons(V1,V2)) -> AND(isNat(V1),isNatIList(V2))
 ISNATILIST(V) -> ISNATLIST(V)
 ISNATLIST(cons(V1,V2)) -> AND(isNat(V1),isNatList(V2))
-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 isNatIList(V2) -> ISNATILIST(V2)
 isNatList(V2) -> ISNATLIST(V2)
-> Usable rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[U11](X1,X2) = 2.X2 + 2
[and](X1,X2) = X2
[isNat](X) = 2.X + 2
[isNatIList](X) = 2.X + 2
[isNatList](X) = 2.X + 1
[length](X) = 2.X + 2
[zeros] = 2
[num0] = 2
[cons](X1,X2) = X2
[fSNonEmpty] = 0
[nil] = 0
[s](X) = X
[tt] = 1
[U11Sharp](X1,X2) = 0
[AND](X1,X2) = X2
[ISNAT](X) = 0
[ISNATILIST](X) = 2.X + 2
[ISNATLIST](X) = 2.X + 1
[LENGTH](X) = 0
[ZEROS] = 0

Problem 1.1.2: 

SCC Processor:
-> Pairs:
 AND(tt,X) -> X
 ISNATILIST(cons(V1,V2)) -> AND(isNat(V1),isNatIList(V2))
 ISNATLIST(cons(V1,V2)) -> AND(isNat(V1),isNatList(V2))
-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 isNatIList(V2) -> ISNATILIST(V2)
 isNatList(V2) -> ISNATLIST(V2)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 AND(tt,X) -> X
 ISNATILIST(cons(V1,V2)) -> AND(isNat(V1),isNatIList(V2))
 ISNATLIST(cons(V1,V2)) -> AND(isNat(V1),isNatList(V2))
->->-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->->-> Unhiding rules:
 isNatIList(V2) -> ISNATILIST(V2)
 isNatList(V2) -> ISNATLIST(V2)

Problem 1.1.2: 

Non-Replacing Projection Processor:
-> Pairs:
 AND(tt,X) -> X
 ISNATILIST(cons(V1,V2)) -> AND(isNat(V1),isNatIList(V2))
 ISNATLIST(cons(V1,V2)) -> AND(isNat(V1),isNatList(V2))
-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 isNatIList(V2) -> ISNATILIST(V2)
 isNatList(V2) -> ISNATLIST(V2)
->Projection:
 pi(AND) = 2
 pi(ISNATILIST) = 1
 pi(ISNATLIST) = 1
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[U11](X1,X2) = 0
[and](X1,X2) = 0
[isNat](X) = 0
[isNatIList](X) = 2.X + 1
[isNatList](X) = 2.X + 2
[length](X) = 0
[zeros] = 0
[num0] = 0
[cons](X1,X2) = 2.X2 + 2
[fSNonEmpty] = 0
[nil] = 0
[s](X) = 0
[tt] = 0
[U11Sharp](X1,X2) = 0
[AND](X1,X2) = 0
[ISNAT](X) = 0
[ISNATILIST](X) = 0
[ISNATLIST](X) = 0
[LENGTH](X) = 0
[ZEROS] = 0

Problem 1.1.2: 

SCC Processor:
-> Pairs:
 AND(tt,X) -> X
 ISNATLIST(cons(V1,V2)) -> AND(isNat(V1),isNatList(V2))
-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 isNatIList(V2) -> ISNATILIST(V2)
 isNatList(V2) -> ISNATLIST(V2)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 AND(tt,X) -> X
 ISNATLIST(cons(V1,V2)) -> AND(isNat(V1),isNatList(V2))
->->-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->->-> Unhiding rules:
 isNatList(V2) -> ISNATLIST(V2)

Problem 1.1.2: 

Non-Replacing Projection Processor:
-> Pairs:
 AND(tt,X) -> X
 ISNATLIST(cons(V1,V2)) -> AND(isNat(V1),isNatList(V2))
-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 isNatList(V2) -> ISNATLIST(V2)
->Projection:
 pi(AND) = 2
 pi(ISNATLIST) = 1
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[U11](X1,X2) = 0
[and](X1,X2) = 0
[isNat](X) = 0
[isNatIList](X) = 0
[isNatList](X) = 2.X
[length](X) = 0
[zeros] = 0
[num0] = 0
[cons](X1,X2) = 2.X2 + 1
[fSNonEmpty] = 0
[nil] = 0
[s](X) = 0
[tt] = 0
[U11Sharp](X1,X2) = 0
[AND](X1,X2) = 0
[ISNAT](X) = 0
[ISNATILIST](X) = 0
[ISNATLIST](X) = 0
[LENGTH](X) = 0
[ZEROS] = 0

Problem 1.1.2: 

Basic Processor:
-> Pairs:
 AND(tt,X) -> X
-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 isNatList(V2) -> ISNATLIST(V2)
-> Result:
 All pairs P are from Px1

The problem is finite.

Problem 1.2: 

Reduction Triple Processor:
-> Pairs:
 U11Sharp(tt,L) -> LENGTH(L)
 LENGTH(cons(N,L)) -> U11Sharp(and(isNatList(L),isNat(N)),L)
-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 Empty
-> Usable rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->Interpretation type:
 Simple mixed
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[U11](X1,X2) = 2.X2
[and](X1,X2) = X1.X2
[isNat](X) = 2.X + 1
[isNatIList](X) = 2.X.X + 2.X + 2
[isNatList](X) = X
[length](X) = X
[zeros] = 0
[num0] = 0
[cons](X1,X2) = 2.X1.X2 + 2.X1 + 2.X2
[fSNonEmpty] = 0
[nil] = 2
[s](X) = 2.X
[tt] = 1
[U11Sharp](X1,X2) = 2.X1 + 2.X2 + 2
[AND](X1,X2) = 0
[ISNAT](X) = 0
[ISNATILIST](X) = 0
[ISNATLIST](X) = 0
[LENGTH](X) = 2.X + 2
[ZEROS] = 0

Problem 1.2: 

SCC Processor:
-> Pairs:
 LENGTH(cons(N,L)) -> U11Sharp(and(isNatList(L),isNat(N)),L)
-> Rules:
 U11(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> isNatList(V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> isNat(V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> and(isNat(V1),isNatIList(V2))
 isNatIList(V) -> isNatList(V)
 isNatList(cons(V1,V2)) -> and(isNat(V1),isNatList(V2))
 isNatList(nil) -> tt
 length(cons(N,L)) -> U11(and(isNatList(L),isNat(N)),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 Empty
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
