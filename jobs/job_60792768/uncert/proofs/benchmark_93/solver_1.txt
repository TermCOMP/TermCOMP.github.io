YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/Aopgo.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given CSR could be proven:

(0) CSR
(1) CSDependencyPairsProof [EQUIVALENT, 0 ms]
(2) QCSDP
(3) QCSDependencyGraphProof [EQUIVALENT, 0 ms]
(4) QCSDP
(5) QCSDPReductionPairProof [EQUIVALENT, 9 ms]
(6) QCSDP
(7) QCSDependencyGraphProof [EQUIVALENT, 0 ms]
(8) QCSDP
(9) QCSDPSubtermProof [EQUIVALENT, 0 ms]
(10) QCSDP
(11) PIsEmptyProof [EQUIVALENT, 0 ms]
(12) YES


----------------------------------------

(0)
Obligation:
Context-sensitive rewrite system:
The TRS R consists of the following rules:

   cons_1(x, cons_1(y, z)) -> big_0
   cons_1(x, cons_0(y, z)) -> big_0
   *top*_0(inf_1(x)) -> *top*_0(cons_0(x, inf_1(s_0(x))))
   s_0(inf_1(x)) -> s_0(cons_0(x, inf_1(s_0(x))))
   cons_0(inf_1(x), x0) -> cons_0(cons_0(x, inf_1(s_0(x))), x0)
   cons_0(x0, inf_1(x)) -> cons_1(x0, cons_0(x, inf_1(s_0(x))))

The replacement map contains the following entries:

cons_1: empty set
big_0: empty set
cons_0: {1, 2}
*top*_0: {1}
inf_1: empty set
s_0: {1}

----------------------------------------

(1) CSDependencyPairsProof (EQUIVALENT)
Using Improved CS-DPs [LPAR08] we result in the following initial Q-CSDP problem.
----------------------------------------

(2)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {cons_0_2, *top*_0_1, s_0_1, *TOP*_0_1, CONS_0_2, S_0_1} are replacing on all positions.
The symbols in {cons_1_2, inf_1_1, CONS_1_2, U_1} are not replacing on any position.

The ordinary context-sensitive dependency pairs DP_o are:
   *TOP*_0(inf_1(x)) -> *TOP*_0(cons_0(x, inf_1(s_0(x))))
   *TOP*_0(inf_1(x)) -> CONS_0(x, inf_1(s_0(x)))
   S_0(inf_1(x)) -> S_0(cons_0(x, inf_1(s_0(x))))
   S_0(inf_1(x)) -> CONS_0(x, inf_1(s_0(x)))
   CONS_0(inf_1(x), x0) -> CONS_0(cons_0(x, inf_1(s_0(x))), x0)
   CONS_0(inf_1(x), x0) -> CONS_0(x, inf_1(s_0(x)))
   CONS_0(x0, inf_1(x)) -> CONS_1(x0, cons_0(x, inf_1(s_0(x))))

The collapsing dependency pairs are DP_c:
   *TOP*_0(inf_1(x)) -> x
   S_0(inf_1(x)) -> x
   CONS_0(inf_1(x), x0) -> x


The hidden terms of R are:

   s_0(x0)
   cons_0(x0, inf_1(s_0(x0)))

Every hiding context is built from:
   aprove.DPFramework.CSDPProblem.QCSDPProblem$1@40e93e36
   aprove.DPFramework.CSDPProblem.QCSDPProblem$1@41e4a690

Hence, the new unhiding pairs DP_u are :
   *TOP*_0(inf_1(x)) -> U(x)
   S_0(inf_1(x)) -> U(x)
   CONS_0(inf_1(x), x0) -> U(x)
   U(s_0(x_0)) -> U(x_0)
   U(cons_0(x_0, x_1)) -> U(x_0)
   U(s_0(x0)) -> S_0(x0)
   U(cons_0(x0, inf_1(s_0(x0)))) -> CONS_0(x0, inf_1(s_0(x0)))

The TRS R consists of the following rules:

   cons_1(x, cons_1(y, z)) -> big_0
   cons_1(x, cons_0(y, z)) -> big_0
   *top*_0(inf_1(x)) -> *top*_0(cons_0(x, inf_1(s_0(x))))
   s_0(inf_1(x)) -> s_0(cons_0(x, inf_1(s_0(x))))
   cons_0(inf_1(x), x0) -> cons_0(cons_0(x, inf_1(s_0(x))), x0)
   cons_0(x0, inf_1(x)) -> cons_1(x0, cons_0(x, inf_1(s_0(x))))

Q is empty.

----------------------------------------

(3) QCSDependencyGraphProof (EQUIVALENT)
The approximation of the Context-Sensitive Dependency Graph [LPAR08] contains 1 SCC with 5 less nodes.
The rules *TOP*_0(inf_1(x0)) -> *TOP*_0(cons_0(x0, inf_1(s_0(x0)))) and *TOP*_0(inf_1(z0)) -> *TOP*_0(cons_0(z0, inf_1(s_0(z0)))) form no chain, because ECap^mu_R'(*TOP*_0(inf_1(z0))) = *TOP*_0(inf_1(z0)) does not unify with *TOP*_0(cons_0(x0, inf_1(s_0(x0)))). 
R' = 
   ( big_0, cons_1(x, cons_1(y, z)))
   ( big_0, cons_1(x, cons_0(y, z)))
   ( *top*_0(cons_0(x, inf_1(s_0(x)))), *top*_0(inf_1(x)))
   ( s_0(cons_0(x, inf_1(s_0(x)))), s_0(inf_1(x)))
   ( cons_0(cons_0(x, inf_1(s_0(x))), x0), cons_0(inf_1(x), x0))
   ( cons_1(x0, cons_0(x, inf_1(s_0(x)))), cons_0(x0, inf_1(x)))


The rules *TOP*_0(inf_1(x0)) -> *TOP*_0(cons_0(x0, inf_1(s_0(x0)))) and *TOP*_0(inf_1(z0)) -> CONS_0(z0, inf_1(s_0(z0))) form no chain, because ECap^mu_R'(*TOP*_0(inf_1(z0))) = *TOP*_0(inf_1(z0)) does not unify with *TOP*_0(cons_0(x0, inf_1(s_0(x0)))). 
R' = 
   ( big_0, cons_1(x, cons_1(y, z)))
   ( big_0, cons_1(x, cons_0(y, z)))
   ( *top*_0(cons_0(x, inf_1(s_0(x)))), *top*_0(inf_1(x)))
   ( s_0(cons_0(x, inf_1(s_0(x)))), s_0(inf_1(x)))
   ( cons_0(cons_0(x, inf_1(s_0(x))), x0), cons_0(inf_1(x), x0))
   ( cons_1(x0, cons_0(x, inf_1(s_0(x)))), cons_0(x0, inf_1(x)))


The rules *TOP*_0(inf_1(x0)) -> *TOP*_0(cons_0(x0, inf_1(s_0(x0)))) and *TOP*_0(inf_1(z0)) -> U(z0) form no chain, because ECap^mu_R'(*TOP*_0(inf_1(z0))) = *TOP*_0(inf_1(z0)) does not unify with *TOP*_0(cons_0(x0, inf_1(s_0(x0)))). 
R' = 
   ( big_0, cons_1(x, cons_1(y, z)))
   ( big_0, cons_1(x, cons_0(y, z)))
   ( *top*_0(cons_0(x, inf_1(s_0(x)))), *top*_0(inf_1(x)))
   ( s_0(cons_0(x, inf_1(s_0(x)))), s_0(inf_1(x)))
   ( cons_0(cons_0(x, inf_1(s_0(x))), x0), cons_0(inf_1(x), x0))
   ( cons_1(x0, cons_0(x, inf_1(s_0(x)))), cons_0(x0, inf_1(x)))


The rules S_0(inf_1(x0)) -> S_0(cons_0(x0, inf_1(s_0(x0)))) and S_0(inf_1(z0)) -> S_0(cons_0(z0, inf_1(s_0(z0)))) form no chain, because ECap^mu_R'(S_0(inf_1(z0))) = S_0(inf_1(z0)) does not unify with S_0(cons_0(x0, inf_1(s_0(x0)))). 
R' = 
   ( big_0, cons_1(x, cons_1(y, z)))
   ( big_0, cons_1(x, cons_0(y, z)))
   ( *top*_0(cons_0(x, inf_1(s_0(x)))), *top*_0(inf_1(x)))
   ( s_0(cons_0(x, inf_1(s_0(x)))), s_0(inf_1(x)))
   ( cons_0(cons_0(x, inf_1(s_0(x))), x0), cons_0(inf_1(x), x0))
   ( cons_1(x0, cons_0(x, inf_1(s_0(x)))), cons_0(x0, inf_1(x)))


The rules S_0(inf_1(x0)) -> S_0(cons_0(x0, inf_1(s_0(x0)))) and S_0(inf_1(z0)) -> CONS_0(z0, inf_1(s_0(z0))) form no chain, because ECap^mu_R'(S_0(inf_1(z0))) = S_0(inf_1(z0)) does not unify with S_0(cons_0(x0, inf_1(s_0(x0)))). 
R' = 
   ( big_0, cons_1(x, cons_1(y, z)))
   ( big_0, cons_1(x, cons_0(y, z)))
   ( *top*_0(cons_0(x, inf_1(s_0(x)))), *top*_0(inf_1(x)))
   ( s_0(cons_0(x, inf_1(s_0(x)))), s_0(inf_1(x)))
   ( cons_0(cons_0(x, inf_1(s_0(x))), x0), cons_0(inf_1(x), x0))
   ( cons_1(x0, cons_0(x, inf_1(s_0(x)))), cons_0(x0, inf_1(x)))


The rules S_0(inf_1(x0)) -> S_0(cons_0(x0, inf_1(s_0(x0)))) and S_0(inf_1(z0)) -> U(z0) form no chain, because ECap^mu_R'(S_0(inf_1(z0))) = S_0(inf_1(z0)) does not unify with S_0(cons_0(x0, inf_1(s_0(x0)))). 
R' = 
   ( big_0, cons_1(x, cons_1(y, z)))
   ( big_0, cons_1(x, cons_0(y, z)))
   ( *top*_0(cons_0(x, inf_1(s_0(x)))), *top*_0(inf_1(x)))
   ( s_0(cons_0(x, inf_1(s_0(x)))), s_0(inf_1(x)))
   ( cons_0(cons_0(x, inf_1(s_0(x))), x0), cons_0(inf_1(x), x0))
   ( cons_1(x0, cons_0(x, inf_1(s_0(x)))), cons_0(x0, inf_1(x)))


The rules CONS_0(inf_1(x0), x1) -> CONS_0(cons_0(x0, inf_1(s_0(x0))), x1) and CONS_0(inf_1(z0), z1) -> CONS_0(cons_0(z0, inf_1(s_0(z0))), z1) form no chain, because ECap^mu_R'(CONS_0(inf_1(z0), z1)) = CONS_0(inf_1(z0), x_1) does not unify with CONS_0(cons_0(x0, inf_1(s_0(x0))), x1). 
R' = 
   ( big_0, cons_1(x, cons_1(y, z)))
   ( big_0, cons_1(x, cons_0(y, z)))
   ( *top*_0(cons_0(x, inf_1(s_0(x)))), *top*_0(inf_1(x)))
   ( s_0(cons_0(x, inf_1(s_0(x)))), s_0(inf_1(x)))
   ( cons_0(cons_0(x, inf_1(s_0(x))), x0), cons_0(inf_1(x), x0))
   ( cons_1(x0, cons_0(x, inf_1(s_0(x)))), cons_0(x0, inf_1(x)))


The rules CONS_0(inf_1(x0), x1) -> CONS_0(cons_0(x0, inf_1(s_0(x0))), x1) and CONS_0(inf_1(z0), z1) -> CONS_0(z0, inf_1(s_0(z0))) form no chain, because ECap^mu_R'(CONS_0(inf_1(z0), z1)) = CONS_0(inf_1(z0), x_1) does not unify with CONS_0(cons_0(x0, inf_1(s_0(x0))), x1). 
R' = 
   ( big_0, cons_1(x, cons_1(y, z)))
   ( big_0, cons_1(x, cons_0(y, z)))
   ( *top*_0(cons_0(x, inf_1(s_0(x)))), *top*_0(inf_1(x)))
   ( s_0(cons_0(x, inf_1(s_0(x)))), s_0(inf_1(x)))
   ( cons_0(cons_0(x, inf_1(s_0(x))), x0), cons_0(inf_1(x), x0))
   ( cons_1(x0, cons_0(x, inf_1(s_0(x)))), cons_0(x0, inf_1(x)))


The rules CONS_0(inf_1(x0), x1) -> CONS_0(cons_0(x0, inf_1(s_0(x0))), x1) and CONS_0(inf_1(z0), z1) -> U(z0) form no chain, because ECap^mu_R'(CONS_0(inf_1(z0), z1)) = CONS_0(inf_1(z0), x_1) does not unify with CONS_0(cons_0(x0, inf_1(s_0(x0))), x1). 
R' = 
   ( big_0, cons_1(x, cons_1(y, z)))
   ( big_0, cons_1(x, cons_0(y, z)))
   ( *top*_0(cons_0(x, inf_1(s_0(x)))), *top*_0(inf_1(x)))
   ( s_0(cons_0(x, inf_1(s_0(x)))), s_0(inf_1(x)))
   ( cons_0(cons_0(x, inf_1(s_0(x))), x0), cons_0(inf_1(x), x0))
   ( cons_1(x0, cons_0(x, inf_1(s_0(x)))), cons_0(x0, inf_1(x)))



----------------------------------------

(4)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {cons_0_2, *top*_0_1, s_0_1, CONS_0_2, S_0_1} are replacing on all positions.
The symbols in {cons_1_2, inf_1_1, U_1} are not replacing on any position.

The TRS P consists of the following rules:

   CONS_0(inf_1(x), x0) -> CONS_0(x, inf_1(s_0(x)))
   CONS_0(inf_1(x), x0) -> U(x)
   U(s_0(x_0)) -> U(x_0)
   U(cons_0(x_0, x_1)) -> U(x_0)
   U(s_0(x0)) -> S_0(x0)
   S_0(inf_1(x)) -> CONS_0(x, inf_1(s_0(x)))
   S_0(inf_1(x)) -> U(x)
   U(cons_0(x0, inf_1(s_0(x0)))) -> CONS_0(x0, inf_1(s_0(x0)))

The TRS R consists of the following rules:

   cons_1(x, cons_1(y, z)) -> big_0
   cons_1(x, cons_0(y, z)) -> big_0
   *top*_0(inf_1(x)) -> *top*_0(cons_0(x, inf_1(s_0(x))))
   s_0(inf_1(x)) -> s_0(cons_0(x, inf_1(s_0(x))))
   cons_0(inf_1(x), x0) -> cons_0(cons_0(x, inf_1(s_0(x))), x0)
   cons_0(x0, inf_1(x)) -> cons_1(x0, cons_0(x, inf_1(s_0(x))))

Q is empty.

----------------------------------------

(5) QCSDPReductionPairProof (EQUIVALENT)
Using the order

Polynomial interpretation with max and min functions [POLO,MAXPOLO]:

   POL(CONS_0(x_1, x_2)) = x_1
   POL(S_0(x_1)) = x_1
   POL(U(x_1)) = x_1
   POL(big_0) = 0
   POL(cons_0(x_1, x_2)) = x_1
   POL(cons_1(x_1, x_2)) = x_1
   POL(inf_1(x_1)) = 1 + x_1
   POL(s_0(x_1)) = x_1


the following usable rules


   s_0(inf_1(x)) -> s_0(cons_0(x, inf_1(s_0(x))))
   cons_0(inf_1(x), x0) -> cons_0(cons_0(x, inf_1(s_0(x))), x0)
   cons_0(x0, inf_1(x)) -> cons_1(x0, cons_0(x, inf_1(s_0(x))))
   cons_1(x, cons_1(y, z)) -> big_0
   cons_1(x, cons_0(y, z)) -> big_0


could all be oriented weakly.

Furthermore, the pairs


   CONS_0(inf_1(x), x0) -> CONS_0(x, inf_1(s_0(x)))
   CONS_0(inf_1(x), x0) -> U(x)
   S_0(inf_1(x)) -> CONS_0(x, inf_1(s_0(x)))
   S_0(inf_1(x)) -> U(x)


could be oriented strictly and thus removed by the CS-Reduction Pair Processor [LPAR08,DA_EMMES].


----------------------------------------

(6)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {cons_0_2, *top*_0_1, s_0_1, S_0_1, CONS_0_2} are replacing on all positions.
The symbols in {cons_1_2, inf_1_1, U_1} are not replacing on any position.

The TRS P consists of the following rules:

   U(s_0(x_0)) -> U(x_0)
   U(cons_0(x_0, x_1)) -> U(x_0)
   U(s_0(x0)) -> S_0(x0)
   U(cons_0(x0, inf_1(s_0(x0)))) -> CONS_0(x0, inf_1(s_0(x0)))

The TRS R consists of the following rules:

   cons_1(x, cons_1(y, z)) -> big_0
   cons_1(x, cons_0(y, z)) -> big_0
   *top*_0(inf_1(x)) -> *top*_0(cons_0(x, inf_1(s_0(x))))
   s_0(inf_1(x)) -> s_0(cons_0(x, inf_1(s_0(x))))
   cons_0(inf_1(x), x0) -> cons_0(cons_0(x, inf_1(s_0(x))), x0)
   cons_0(x0, inf_1(x)) -> cons_1(x0, cons_0(x, inf_1(s_0(x))))

Q is empty.

----------------------------------------

(7) QCSDependencyGraphProof (EQUIVALENT)
The approximation of the Context-Sensitive Dependency Graph [LPAR08] contains 1 SCC with 2 less nodes.

----------------------------------------

(8)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {cons_0_2, *top*_0_1, s_0_1} are replacing on all positions.
The symbols in {cons_1_2, inf_1_1, U_1} are not replacing on any position.

The TRS P consists of the following rules:

   U(s_0(x_0)) -> U(x_0)
   U(cons_0(x_0, x_1)) -> U(x_0)

The TRS R consists of the following rules:

   cons_1(x, cons_1(y, z)) -> big_0
   cons_1(x, cons_0(y, z)) -> big_0
   *top*_0(inf_1(x)) -> *top*_0(cons_0(x, inf_1(s_0(x))))
   s_0(inf_1(x)) -> s_0(cons_0(x, inf_1(s_0(x))))
   cons_0(inf_1(x), x0) -> cons_0(cons_0(x, inf_1(s_0(x))), x0)
   cons_0(x0, inf_1(x)) -> cons_1(x0, cons_0(x, inf_1(s_0(x))))

Q is empty.

----------------------------------------

(9) QCSDPSubtermProof (EQUIVALENT)
We use the subterm processor [DA_EMMES].


The following pairs can be oriented strictly and are deleted.

   U(s_0(x_0)) -> U(x_0)
   U(cons_0(x_0, x_1)) -> U(x_0)
The remaining pairs can at least be oriented weakly.
none
Used ordering:  Combined order from the following AFS and order.
U(x1)  =  x1


Subterm Order

----------------------------------------

(10)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {cons_0_2, *top*_0_1, s_0_1} are replacing on all positions.
The symbols in {cons_1_2, inf_1_1} are not replacing on any position.

The TRS P consists of the following rules:
none

The TRS R consists of the following rules:

   cons_1(x, cons_1(y, z)) -> big_0
   cons_1(x, cons_0(y, z)) -> big_0
   *top*_0(inf_1(x)) -> *top*_0(cons_0(x, inf_1(s_0(x))))
   s_0(inf_1(x)) -> s_0(cons_0(x, inf_1(s_0(x))))
   cons_0(inf_1(x), x0) -> cons_0(cons_0(x, inf_1(s_0(x))), x0)
   cons_0(x0, inf_1(x)) -> cons_1(x0, cons_0(x, inf_1(s_0(x))))

Q is empty.

----------------------------------------

(11) PIsEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R,mu)-chain.
----------------------------------------

(12)
YES
