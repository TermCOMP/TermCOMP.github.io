YES

Problem 1: 

(VAR vu95NonEmpty X Y Z)
(STRATEGY CONTEXTSENSITIVE
(filter 1 2)
(from 1)
(head 1)
(if 1)
(primes)
(sieve 1)
(tail 1)
(num0)
(cons 1)
(divides 1 2)
(fSNonEmpty)
(ffalse)
(s 1)
(ftrue)
)
(RULES
filter(s(s(X)),cons(Y,Z)) -> if(divides(s(s(X)),Y),filter(s(s(X)),Z),cons(Y,filter(X,sieve(Y))))
from(X) -> cons(X,from(s(X)))
head(cons(X,Y)) -> X
if(ffalse,X,Y) -> Y
if(ftrue,X,Y) -> X
primes -> sieve(from(s(s(num0))))
sieve(cons(X,Y)) -> cons(X,filter(X,sieve(Y)))
tail(cons(X,Y)) -> Y
)


Problem 1: 

Innermost Equivalent Processor:
-> Rules:
 filter(s(s(X)),cons(Y,Z)) -> if(divides(s(s(X)),Y),filter(s(s(X)),Z),cons(Y,filter(X,sieve(Y))))
 from(X) -> cons(X,from(s(X)))
 head(cons(X,Y)) -> X
 if(ffalse,X,Y) -> Y
 if(ftrue,X,Y) -> X
 primes -> sieve(from(s(s(num0))))
 sieve(cons(X,Y)) -> cons(X,filter(X,sieve(Y)))
 tail(cons(X,Y)) -> Y
-> The context-sensitive term rewriting system is an orthogonal system. Therefore, innermost cs-termination implies cs-termination.
 

Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 IF(ffalse,X,Y) -> Y
 IF(ftrue,X,Y) -> X
 PRIMES -> FROM(s(s(num0)))
 PRIMES -> SIEVE(from(s(s(num0))))
 TAIL(cons(X,Y)) -> Y
-> Rules:
 filter(s(s(X)),cons(Y,Z)) -> if(divides(s(s(X)),Y),filter(s(s(X)),Z),cons(Y,filter(X,sieve(Y))))
 from(X) -> cons(X,from(s(X)))
 head(cons(X,Y)) -> X
 if(ffalse,X,Y) -> Y
 if(ftrue,X,Y) -> X
 primes -> sieve(from(s(s(num0))))
 sieve(cons(X,Y)) -> cons(X,filter(X,sieve(Y)))
 tail(cons(X,Y)) -> Y
-> Unhiding Rules:
 filter(s(s(X)),Z) -> FILTER(s(s(X)),Z)
 filter(s(s(X)),x4) -> x4
 filter(X,sieve(Y)) -> FILTER(X,sieve(Y))
 filter(X,sieve(Y)) -> SIEVE(Y)
 filter(X,sieve(x4)) -> x4
 from(s(X)) -> FROM(s(X))

Problem 1: 

SCC Processor:
-> Pairs:
 IF(ffalse,X,Y) -> Y
 IF(ftrue,X,Y) -> X
 PRIMES -> FROM(s(s(num0)))
 PRIMES -> SIEVE(from(s(s(num0))))
 TAIL(cons(X,Y)) -> Y
-> Rules:
 filter(s(s(X)),cons(Y,Z)) -> if(divides(s(s(X)),Y),filter(s(s(X)),Z),cons(Y,filter(X,sieve(Y))))
 from(X) -> cons(X,from(s(X)))
 head(cons(X,Y)) -> X
 if(ffalse,X,Y) -> Y
 if(ftrue,X,Y) -> X
 primes -> sieve(from(s(s(num0))))
 sieve(cons(X,Y)) -> cons(X,filter(X,sieve(Y)))
 tail(cons(X,Y)) -> Y
-> Unhiding rules:
 filter(s(s(X)),Z) -> FILTER(s(s(X)),Z)
 filter(s(s(X)),x4) -> x4
 filter(X,sieve(Y)) -> FILTER(X,sieve(Y))
 filter(X,sieve(Y)) -> SIEVE(Y)
 filter(X,sieve(x4)) -> x4
 from(s(X)) -> FROM(s(X))
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
