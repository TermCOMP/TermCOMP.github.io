YES

Problem 1: 

(VAR vu95NonEmpty L N V V1 V2 X)
(STRATEGY CONTEXTSENSITIVE
(U11 1)
(U12 1)
(U21 1)
(U22 1)
(U31 1)
(U32 1)
(U41 1)
(U42 1)
(U43 1)
(U51 1)
(U52 1)
(U53 1)
(U61 1)
(and 1)
(isNat)
(isNatIList)
(isNatIListKind)
(isNatKind)
(isNatList)
(length 1)
(zeros)
(num0)
(cons 1)
(fSNonEmpty)
(nil)
(s 1)
(tt)
)
(RULES
U11(tt,V1) -> U12(isNatList(V1))
U12(tt) -> tt
U21(tt,V1) -> U22(isNat(V1))
U22(tt) -> tt
U31(tt,V) -> U32(isNatList(V))
U32(tt) -> tt
U41(tt,V1,V2) -> U42(isNat(V1),V2)
U42(tt,V2) -> U43(isNatIList(V2))
U43(tt) -> tt
U51(tt,V1,V2) -> U52(isNat(V1),V2)
U52(tt,V2) -> U53(isNatList(V2))
U53(tt) -> tt
U61(tt,L) -> s(length(L))
and(tt,X) -> X
isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
isNat(num0) -> tt
isNat(s(V1)) -> U21(isNatKind(V1),V1)
isNatIList(zeros) -> tt
isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
isNatIList(V) -> U31(isNatIListKind(V),V)
isNatIListKind(zeros) -> tt
isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
isNatIListKind(nil) -> tt
isNatKind(length(V1)) -> isNatIListKind(V1)
isNatKind(num0) -> tt
isNatKind(s(V1)) -> isNatKind(V1)
isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
isNatList(nil) -> tt
length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
length(nil) -> num0
zeros -> cons(num0,zeros)
)


Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 U11Sharp(tt,V1) -> U12Sharp(isNatList(V1))
 U11Sharp(tt,V1) -> ISNATLIST(V1)
 U21Sharp(tt,V1) -> U22Sharp(isNat(V1))
 U21Sharp(tt,V1) -> ISNAT(V1)
 U31Sharp(tt,V) -> U32Sharp(isNatList(V))
 U31Sharp(tt,V) -> ISNATLIST(V)
 U41Sharp(tt,V1,V2) -> U42Sharp(isNat(V1),V2)
 U41Sharp(tt,V1,V2) -> ISNAT(V1)
 U42Sharp(tt,V2) -> U43Sharp(isNatIList(V2))
 U42Sharp(tt,V2) -> ISNATILIST(V2)
 U51Sharp(tt,V1,V2) -> U52Sharp(isNat(V1),V2)
 U51Sharp(tt,V1,V2) -> ISNAT(V1)
 U52Sharp(tt,V2) -> U53Sharp(isNatList(V2))
 U52Sharp(tt,V2) -> ISNATLIST(V2)
 U61Sharp(tt,L) -> LENGTH(L)
 U61Sharp(tt,L) -> L
 AND(tt,X) -> X
 ISNAT(length(V1)) -> U11Sharp(isNatIListKind(V1),V1)
 ISNAT(length(V1)) -> ISNATILISTKIND(V1)
 ISNAT(s(V1)) -> U21Sharp(isNatKind(V1),V1)
 ISNAT(s(V1)) -> ISNATKIND(V1)
 ISNATILIST(cons(V1,V2)) -> U41Sharp(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 ISNATILIST(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
 ISNATILIST(cons(V1,V2)) -> ISNATKIND(V1)
 ISNATILIST(V) -> U31Sharp(isNatIListKind(V),V)
 ISNATILIST(V) -> ISNATILISTKIND(V)
 ISNATILISTKIND(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
 ISNATILISTKIND(cons(V1,V2)) -> ISNATKIND(V1)
 ISNATKIND(length(V1)) -> ISNATILISTKIND(V1)
 ISNATKIND(s(V1)) -> ISNATKIND(V1)
 ISNATLIST(cons(V1,V2)) -> U51Sharp(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 ISNATLIST(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
 ISNATLIST(cons(V1,V2)) -> ISNATKIND(V1)
 LENGTH(cons(N,L)) -> U61Sharp(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 LENGTH(cons(N,L)) -> AND(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N)))
 LENGTH(cons(N,L)) -> AND(isNatList(L),isNatIListKind(L))
 LENGTH(cons(N,L)) -> ISNATLIST(L)
-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding Rules:
 and(isNat(N),isNatKind(N)) -> AND(isNat(N),isNatKind(N))
 and(isNat(N),isNatKind(N)) -> ISNAT(N)
 isNatIListKind(L) -> ISNATILISTKIND(L)
 isNatIListKind(V2) -> ISNATILISTKIND(V2)
 zeros -> ZEROS

Problem 1: 

SCC Processor:
-> Pairs:
 U11Sharp(tt,V1) -> U12Sharp(isNatList(V1))
 U11Sharp(tt,V1) -> ISNATLIST(V1)
 U21Sharp(tt,V1) -> U22Sharp(isNat(V1))
 U21Sharp(tt,V1) -> ISNAT(V1)
 U31Sharp(tt,V) -> U32Sharp(isNatList(V))
 U31Sharp(tt,V) -> ISNATLIST(V)
 U41Sharp(tt,V1,V2) -> U42Sharp(isNat(V1),V2)
 U41Sharp(tt,V1,V2) -> ISNAT(V1)
 U42Sharp(tt,V2) -> U43Sharp(isNatIList(V2))
 U42Sharp(tt,V2) -> ISNATILIST(V2)
 U51Sharp(tt,V1,V2) -> U52Sharp(isNat(V1),V2)
 U51Sharp(tt,V1,V2) -> ISNAT(V1)
 U52Sharp(tt,V2) -> U53Sharp(isNatList(V2))
 U52Sharp(tt,V2) -> ISNATLIST(V2)
 U61Sharp(tt,L) -> LENGTH(L)
 U61Sharp(tt,L) -> L
 AND(tt,X) -> X
 ISNAT(length(V1)) -> U11Sharp(isNatIListKind(V1),V1)
 ISNAT(length(V1)) -> ISNATILISTKIND(V1)
 ISNAT(s(V1)) -> U21Sharp(isNatKind(V1),V1)
 ISNAT(s(V1)) -> ISNATKIND(V1)
 ISNATILIST(cons(V1,V2)) -> U41Sharp(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 ISNATILIST(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
 ISNATILIST(cons(V1,V2)) -> ISNATKIND(V1)
 ISNATILIST(V) -> U31Sharp(isNatIListKind(V),V)
 ISNATILIST(V) -> ISNATILISTKIND(V)
 ISNATILISTKIND(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
 ISNATILISTKIND(cons(V1,V2)) -> ISNATKIND(V1)
 ISNATKIND(length(V1)) -> ISNATILISTKIND(V1)
 ISNATKIND(s(V1)) -> ISNATKIND(V1)
 ISNATLIST(cons(V1,V2)) -> U51Sharp(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 ISNATLIST(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
 ISNATLIST(cons(V1,V2)) -> ISNATKIND(V1)
 LENGTH(cons(N,L)) -> U61Sharp(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 LENGTH(cons(N,L)) -> AND(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N)))
 LENGTH(cons(N,L)) -> AND(isNatList(L),isNatIListKind(L))
 LENGTH(cons(N,L)) -> ISNATLIST(L)
-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 and(isNat(N),isNatKind(N)) -> AND(isNat(N),isNatKind(N))
 and(isNat(N),isNatKind(N)) -> ISNAT(N)
 isNatIListKind(L) -> ISNATILISTKIND(L)
 isNatIListKind(V2) -> ISNATILISTKIND(V2)
 zeros -> ZEROS
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 U11Sharp(tt,V1) -> ISNATLIST(V1)
 U21Sharp(tt,V1) -> ISNAT(V1)
 U51Sharp(tt,V1,V2) -> U52Sharp(isNat(V1),V2)
 U51Sharp(tt,V1,V2) -> ISNAT(V1)
 U52Sharp(tt,V2) -> ISNATLIST(V2)
 AND(tt,X) -> X
 ISNAT(length(V1)) -> U11Sharp(isNatIListKind(V1),V1)
 ISNAT(length(V1)) -> ISNATILISTKIND(V1)
 ISNAT(s(V1)) -> U21Sharp(isNatKind(V1),V1)
 ISNAT(s(V1)) -> ISNATKIND(V1)
 ISNATILISTKIND(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
 ISNATILISTKIND(cons(V1,V2)) -> ISNATKIND(V1)
 ISNATKIND(length(V1)) -> ISNATILISTKIND(V1)
 ISNATKIND(s(V1)) -> ISNATKIND(V1)
 ISNATLIST(cons(V1,V2)) -> U51Sharp(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 ISNATLIST(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
 ISNATLIST(cons(V1,V2)) -> ISNATKIND(V1)
->->-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->->-> Unhiding rules:
 and(isNat(N),isNatKind(N)) -> AND(isNat(N),isNatKind(N))
 and(isNat(N),isNatKind(N)) -> ISNAT(N)
 isNatIListKind(L) -> ISNATILISTKIND(L)
 isNatIListKind(V2) -> ISNATILISTKIND(V2)
->->Cycle:
->->-> Pairs:
 U41Sharp(tt,V1,V2) -> U42Sharp(isNat(V1),V2)
 U42Sharp(tt,V2) -> ISNATILIST(V2)
 ISNATILIST(cons(V1,V2)) -> U41Sharp(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
->->-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->->-> Unhiding rules:
 Empty
->->Cycle:
->->-> Pairs:
 U61Sharp(tt,L) -> LENGTH(L)
 LENGTH(cons(N,L)) -> U61Sharp(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
->->-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->->-> Unhiding rules:
 Empty


The problem is decomposed in 3 subproblems.

Problem 1.1: 

Reduction Triple Processor:
-> Pairs:
 U11Sharp(tt,V1) -> ISNATLIST(V1)
 U21Sharp(tt,V1) -> ISNAT(V1)
 U51Sharp(tt,V1,V2) -> U52Sharp(isNat(V1),V2)
 U51Sharp(tt,V1,V2) -> ISNAT(V1)
 U52Sharp(tt,V2) -> ISNATLIST(V2)
 AND(tt,X) -> X
 ISNAT(length(V1)) -> U11Sharp(isNatIListKind(V1),V1)
 ISNAT(length(V1)) -> ISNATILISTKIND(V1)
 ISNAT(s(V1)) -> U21Sharp(isNatKind(V1),V1)
 ISNAT(s(V1)) -> ISNATKIND(V1)
 ISNATILISTKIND(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
 ISNATILISTKIND(cons(V1,V2)) -> ISNATKIND(V1)
 ISNATKIND(length(V1)) -> ISNATILISTKIND(V1)
 ISNATKIND(s(V1)) -> ISNATKIND(V1)
 ISNATLIST(cons(V1,V2)) -> U51Sharp(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 ISNATLIST(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
 ISNATLIST(cons(V1,V2)) -> ISNATKIND(V1)
-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 and(isNat(N),isNatKind(N)) -> AND(isNat(N),isNatKind(N))
 and(isNat(N),isNatKind(N)) -> ISNAT(N)
 isNatIListKind(L) -> ISNATILISTKIND(L)
 isNatIListKind(V2) -> ISNATILISTKIND(V2)
-> Usable rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[U11](X1,X2) = 2.X1 + 2
[U12](X) = 2
[U21](X1,X2) = X1 + 2
[U22](X) = 2
[U31](X1,X2) = 0
[U32](X) = 0
[U41](X1,X2,X3) = 0
[U42](X1,X2) = 0
[U43](X) = 0
[U51](X1,X2,X3) = 2.X1 + 2.X2 + 2
[U52](X1,X2) = 2
[U53](X) = 2
[U61](X1,X2) = 2
[and](X1,X2) = 2.X2
[isNat](X) = 2.X
[isNatIList](X) = 0
[isNatIListKind](X) = 0
[isNatKind](X) = 2
[isNatList](X) = 2.X + 2
[length](X) = 2
[zeros] = 2
[num0] = 1
[cons](X1,X2) = X1 + 1
[fSNonEmpty] = 0
[nil] = 0
[s](X) = 2
[tt] = 0
[U11Sharp](X1,X2) = 2
[U12Sharp](X) = 0
[U21Sharp](X1,X2) = 2
[U22Sharp](X) = 0
[U31Sharp](X1,X2) = 0
[U32Sharp](X) = 0
[U41Sharp](X1,X2,X3) = 0
[U42Sharp](X1,X2) = 0
[U43Sharp](X) = 0
[U51Sharp](X1,X2,X3) = 2.X1 + 2
[U52Sharp](X1,X2) = 2
[U53Sharp](X) = 0
[U61Sharp](X1,X2) = 0
[AND](X1,X2) = X2
[ISNAT](X) = 2
[ISNATILIST](X) = 0
[ISNATILISTKIND](X) = 0
[ISNATKIND](X) = 0
[ISNATLIST](X) = 2
[LENGTH](X) = 0
[ZEROS] = 0

Problem 1.1: 

SCC Processor:
-> Pairs:
 U11Sharp(tt,V1) -> ISNATLIST(V1)
 U21Sharp(tt,V1) -> ISNAT(V1)
 U51Sharp(tt,V1,V2) -> U52Sharp(isNat(V1),V2)
 U51Sharp(tt,V1,V2) -> ISNAT(V1)
 U52Sharp(tt,V2) -> ISNATLIST(V2)
 AND(tt,X) -> X
 ISNAT(length(V1)) -> U11Sharp(isNatIListKind(V1),V1)
 ISNAT(length(V1)) -> ISNATILISTKIND(V1)
 ISNAT(s(V1)) -> U21Sharp(isNatKind(V1),V1)
 ISNAT(s(V1)) -> ISNATKIND(V1)
 ISNATILISTKIND(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
 ISNATILISTKIND(cons(V1,V2)) -> ISNATKIND(V1)
 ISNATKIND(length(V1)) -> ISNATILISTKIND(V1)
 ISNATKIND(s(V1)) -> ISNATKIND(V1)
 ISNATLIST(cons(V1,V2)) -> U51Sharp(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 ISNATLIST(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
 ISNATLIST(cons(V1,V2)) -> ISNATKIND(V1)
-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 and(isNat(N),isNatKind(N)) -> ISNAT(N)
 isNatIListKind(L) -> ISNATILISTKIND(L)
 isNatIListKind(V2) -> ISNATILISTKIND(V2)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 U11Sharp(tt,V1) -> ISNATLIST(V1)
 U21Sharp(tt,V1) -> ISNAT(V1)
 U51Sharp(tt,V1,V2) -> U52Sharp(isNat(V1),V2)
 U51Sharp(tt,V1,V2) -> ISNAT(V1)
 U52Sharp(tt,V2) -> ISNATLIST(V2)
 AND(tt,X) -> X
 ISNAT(length(V1)) -> U11Sharp(isNatIListKind(V1),V1)
 ISNAT(length(V1)) -> ISNATILISTKIND(V1)
 ISNAT(s(V1)) -> U21Sharp(isNatKind(V1),V1)
 ISNAT(s(V1)) -> ISNATKIND(V1)
 ISNATILISTKIND(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
 ISNATILISTKIND(cons(V1,V2)) -> ISNATKIND(V1)
 ISNATKIND(length(V1)) -> ISNATILISTKIND(V1)
 ISNATKIND(s(V1)) -> ISNATKIND(V1)
 ISNATLIST(cons(V1,V2)) -> U51Sharp(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 ISNATLIST(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
 ISNATLIST(cons(V1,V2)) -> ISNATKIND(V1)
->->-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->->-> Unhiding rules:
 and(isNat(N),isNatKind(N)) -> ISNAT(N)
 isNatIListKind(L) -> ISNATILISTKIND(L)
 isNatIListKind(V2) -> ISNATILISTKIND(V2)

Problem 1.1: 

Reduction Triple Processor:
-> Pairs:
 U11Sharp(tt,V1) -> ISNATLIST(V1)
 U21Sharp(tt,V1) -> ISNAT(V1)
 U51Sharp(tt,V1,V2) -> U52Sharp(isNat(V1),V2)
 U51Sharp(tt,V1,V2) -> ISNAT(V1)
 U52Sharp(tt,V2) -> ISNATLIST(V2)
 AND(tt,X) -> X
 ISNAT(length(V1)) -> U11Sharp(isNatIListKind(V1),V1)
 ISNAT(length(V1)) -> ISNATILISTKIND(V1)
 ISNAT(s(V1)) -> U21Sharp(isNatKind(V1),V1)
 ISNAT(s(V1)) -> ISNATKIND(V1)
 ISNATILISTKIND(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
 ISNATILISTKIND(cons(V1,V2)) -> ISNATKIND(V1)
 ISNATKIND(length(V1)) -> ISNATILISTKIND(V1)
 ISNATKIND(s(V1)) -> ISNATKIND(V1)
 ISNATLIST(cons(V1,V2)) -> U51Sharp(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 ISNATLIST(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
 ISNATLIST(cons(V1,V2)) -> ISNATKIND(V1)
-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 and(isNat(N),isNatKind(N)) -> ISNAT(N)
 isNatIListKind(L) -> ISNATILISTKIND(L)
 isNatIListKind(V2) -> ISNATILISTKIND(V2)
-> Usable rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[U11](X1,X2) = 2.X1 + X2 + 2
[U12](X) = 2
[U21](X1,X2) = 2.X1 + 2.X2 + 1
[U22](X) = 1
[U31](X1,X2) = 0
[U32](X) = 0
[U41](X1,X2,X3) = 0
[U42](X1,X2) = 0
[U43](X) = 0
[U51](X1,X2,X3) = 2.X1 + X2 + 2.X3 + 2
[U52](X1,X2) = 2.X2 + 2
[U53](X) = 2
[U61](X1,X2) = 2.X2
[and](X1,X2) = 2.X1 + 2.X2
[isNat](X) = 2.X + 2
[isNatIList](X) = 0
[isNatIListKind](X) = 0
[isNatKind](X) = 0
[isNatList](X) = X + 2
[length](X) = 2.X
[zeros] = 0
[num0] = 0
[cons](X1,X2) = 2.X1 + 2.X2
[fSNonEmpty] = 0
[nil] = 1
[s](X) = X
[tt] = 0
[U11Sharp](X1,X2) = 2.X2 + 2
[U12Sharp](X) = 0
[U21Sharp](X1,X2) = 2.X2 + 2
[U22Sharp](X) = 0
[U31Sharp](X1,X2) = 0
[U32Sharp](X) = 0
[U41Sharp](X1,X2,X3) = 0
[U42Sharp](X1,X2) = 0
[U43Sharp](X) = 0
[U51Sharp](X1,X2,X3) = 2.X1 + 2.X2 + 2.X3 + 2
[U52Sharp](X1,X2) = 2.X2 + 2
[U53Sharp](X) = 0
[U61Sharp](X1,X2) = 0
[AND](X1,X2) = X2
[ISNAT](X) = 2.X + 2
[ISNATILIST](X) = 0
[ISNATILISTKIND](X) = 0
[ISNATKIND](X) = 0
[ISNATLIST](X) = 2.X + 2
[LENGTH](X) = 0
[ZEROS] = 0

Problem 1.1: 

SCC Processor:
-> Pairs:
 U11Sharp(tt,V1) -> ISNATLIST(V1)
 U21Sharp(tt,V1) -> ISNAT(V1)
 U51Sharp(tt,V1,V2) -> U52Sharp(isNat(V1),V2)
 U51Sharp(tt,V1,V2) -> ISNAT(V1)
 U52Sharp(tt,V2) -> ISNATLIST(V2)
 AND(tt,X) -> X
 ISNAT(length(V1)) -> U11Sharp(isNatIListKind(V1),V1)
 ISNAT(length(V1)) -> ISNATILISTKIND(V1)
 ISNAT(s(V1)) -> U21Sharp(isNatKind(V1),V1)
 ISNAT(s(V1)) -> ISNATKIND(V1)
 ISNATILISTKIND(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
 ISNATILISTKIND(cons(V1,V2)) -> ISNATKIND(V1)
 ISNATKIND(length(V1)) -> ISNATILISTKIND(V1)
 ISNATKIND(s(V1)) -> ISNATKIND(V1)
 ISNATLIST(cons(V1,V2)) -> U51Sharp(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 ISNATLIST(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
 ISNATLIST(cons(V1,V2)) -> ISNATKIND(V1)
-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 isNatIListKind(L) -> ISNATILISTKIND(L)
 isNatIListKind(V2) -> ISNATILISTKIND(V2)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 AND(tt,X) -> X
 ISNATILISTKIND(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
 ISNATILISTKIND(cons(V1,V2)) -> ISNATKIND(V1)
 ISNATKIND(length(V1)) -> ISNATILISTKIND(V1)
 ISNATKIND(s(V1)) -> ISNATKIND(V1)
->->-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->->-> Unhiding rules:
 isNatIListKind(L) -> ISNATILISTKIND(L)
 isNatIListKind(V2) -> ISNATILISTKIND(V2)
->->Cycle:
->->-> Pairs:
 U11Sharp(tt,V1) -> ISNATLIST(V1)
 U21Sharp(tt,V1) -> ISNAT(V1)
 U51Sharp(tt,V1,V2) -> U52Sharp(isNat(V1),V2)
 U51Sharp(tt,V1,V2) -> ISNAT(V1)
 U52Sharp(tt,V2) -> ISNATLIST(V2)
 ISNAT(length(V1)) -> U11Sharp(isNatIListKind(V1),V1)
 ISNAT(s(V1)) -> U21Sharp(isNatKind(V1),V1)
 ISNATLIST(cons(V1,V2)) -> U51Sharp(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
->->-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->->-> Unhiding rules:
 Empty


The problem is decomposed in 2 subproblems.

Problem 1.1.1: 

Reduction Triple Processor:
-> Pairs:
 AND(tt,X) -> X
 ISNATILISTKIND(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
 ISNATILISTKIND(cons(V1,V2)) -> ISNATKIND(V1)
 ISNATKIND(length(V1)) -> ISNATILISTKIND(V1)
 ISNATKIND(s(V1)) -> ISNATKIND(V1)
-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 isNatIListKind(L) -> ISNATILISTKIND(L)
 isNatIListKind(V2) -> ISNATILISTKIND(V2)
-> Usable rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[U11](X1,X2) = 2.X2 + 2
[U12](X) = 2
[U21](X1,X2) = 2
[U22](X) = 2
[U31](X1,X2) = 0
[U32](X) = 0
[U41](X1,X2,X3) = 0
[U42](X1,X2) = 0
[U43](X) = 0
[U51](X1,X2,X3) = 2.X1 + 2.X2
[U52](X1,X2) = 2.X1
[U53](X) = 2
[U61](X1,X2) = 2.X2 + 2
[and](X1,X2) = X2
[isNat](X) = X + 2
[isNatIList](X) = 0
[isNatIListKind](X) = X + 1
[isNatKind](X) = 2.X + 2
[isNatList](X) = 2.X + 2
[length](X) = 2.X + 2
[zeros] = 2
[num0] = 0
[cons](X1,X2) = 2.X1 + X2
[fSNonEmpty] = 0
[nil] = 2
[s](X) = X
[tt] = 2
[U11Sharp](X1,X2) = 0
[U12Sharp](X) = 0
[U21Sharp](X1,X2) = 0
[U22Sharp](X) = 0
[U31Sharp](X1,X2) = 0
[U32Sharp](X) = 0
[U41Sharp](X1,X2,X3) = 0
[U42Sharp](X1,X2) = 0
[U43Sharp](X) = 0
[U51Sharp](X1,X2,X3) = 0
[U52Sharp](X1,X2) = 0
[U53Sharp](X) = 0
[U61Sharp](X1,X2) = 0
[AND](X1,X2) = X2
[ISNAT](X) = 0
[ISNATILIST](X) = 0
[ISNATILISTKIND](X) = X + 1
[ISNATKIND](X) = X
[ISNATLIST](X) = 0
[LENGTH](X) = 0
[ZEROS] = 0

Problem 1.1.1: 

SCC Processor:
-> Pairs:
 AND(tt,X) -> X
 ISNATILISTKIND(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
 ISNATKIND(length(V1)) -> ISNATILISTKIND(V1)
 ISNATKIND(s(V1)) -> ISNATKIND(V1)
-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 isNatIListKind(L) -> ISNATILISTKIND(L)
 isNatIListKind(V2) -> ISNATILISTKIND(V2)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 AND(tt,X) -> X
 ISNATILISTKIND(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
->->-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->->-> Unhiding rules:
 isNatIListKind(L) -> ISNATILISTKIND(L)
 isNatIListKind(V2) -> ISNATILISTKIND(V2)
->->Cycle:
->->-> Pairs:
 ISNATKIND(s(V1)) -> ISNATKIND(V1)
->->-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->->-> Unhiding rules:
 Empty


The problem is decomposed in 2 subproblems.

Problem 1.1.1.1: 

Non-Replacing Projection Processor:
-> Pairs:
 AND(tt,X) -> X
 ISNATILISTKIND(cons(V1,V2)) -> AND(isNatKind(V1),isNatIListKind(V2))
-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 isNatIListKind(L) -> ISNATILISTKIND(L)
 isNatIListKind(V2) -> ISNATILISTKIND(V2)
->Projection:
 pi(AND) = 2
 pi(ISNATILISTKIND) = 1
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[U11](X1,X2) = 0
[U12](X) = 0
[U21](X1,X2) = 0
[U22](X) = 0
[U31](X1,X2) = 0
[U32](X) = 0
[U41](X1,X2,X3) = 0
[U42](X1,X2) = 0
[U43](X) = 0
[U51](X1,X2,X3) = 0
[U52](X1,X2) = 0
[U53](X) = 0
[U61](X1,X2) = 0
[and](X1,X2) = 0
[isNat](X) = 0
[isNatIList](X) = 0
[isNatIListKind](X) = 2.X
[isNatKind](X) = 0
[isNatList](X) = 0
[length](X) = 0
[zeros] = 0
[num0] = 0
[cons](X1,X2) = 2.X2 + 1
[fSNonEmpty] = 0
[nil] = 0
[s](X) = 0
[tt] = 0
[U11Sharp](X1,X2) = 0
[U12Sharp](X) = 0
[U21Sharp](X1,X2) = 0
[U22Sharp](X) = 0
[U31Sharp](X1,X2) = 0
[U32Sharp](X) = 0
[U41Sharp](X1,X2,X3) = 0
[U42Sharp](X1,X2) = 0
[U43Sharp](X) = 0
[U51Sharp](X1,X2,X3) = 0
[U52Sharp](X1,X2) = 0
[U53Sharp](X) = 0
[U61Sharp](X1,X2) = 0
[AND](X1,X2) = 0
[ISNAT](X) = 0
[ISNATILIST](X) = 0
[ISNATILISTKIND](X) = 0
[ISNATKIND](X) = 0
[ISNATLIST](X) = 0
[LENGTH](X) = 0
[ZEROS] = 0

Problem 1.1.1.1: 

Basic Processor:
-> Pairs:
 AND(tt,X) -> X
-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 isNatIListKind(L) -> ISNATILISTKIND(L)
 isNatIListKind(V2) -> ISNATILISTKIND(V2)
-> Result:
 All pairs P are from Px1

The problem is finite.

Problem 1.1.1.2: 

SubNColl Processor:
-> Pairs:
 ISNATKIND(s(V1)) -> ISNATKIND(V1)
-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 Empty
->Projection:
 pi(ISNATKIND) = 1

Problem 1.1.1.2: 

Basic Processor:
-> Pairs:
 Empty
-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 Empty
-> Result:
 Set P is empty

The problem is finite.

Problem 1.1.2: 

Reduction Triple Processor:
-> Pairs:
 U11Sharp(tt,V1) -> ISNATLIST(V1)
 U21Sharp(tt,V1) -> ISNAT(V1)
 U51Sharp(tt,V1,V2) -> U52Sharp(isNat(V1),V2)
 U51Sharp(tt,V1,V2) -> ISNAT(V1)
 U52Sharp(tt,V2) -> ISNATLIST(V2)
 ISNAT(length(V1)) -> U11Sharp(isNatIListKind(V1),V1)
 ISNAT(s(V1)) -> U21Sharp(isNatKind(V1),V1)
 ISNATLIST(cons(V1,V2)) -> U51Sharp(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 Empty
-> Usable rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[U11](X1,X2) = X1
[U12](X) = 2.X
[U21](X1,X2) = 0
[U22](X) = 2.X
[U31](X1,X2) = 0
[U32](X) = 0
[U41](X1,X2,X3) = 0
[U42](X1,X2) = 0
[U43](X) = 0
[U51](X1,X2,X3) = 2.X1
[U52](X1,X2) = 0
[U53](X) = X
[U61](X1,X2) = 2.X2 + 2
[and](X1,X2) = 2.X2
[isNat](X) = 0
[isNatIList](X) = 0
[isNatIListKind](X) = 0
[isNatKind](X) = 2
[isNatList](X) = 0
[length](X) = 2.X + 2
[zeros] = 0
[num0] = 0
[cons](X1,X2) = 2.X1 + 2.X2
[fSNonEmpty] = 0
[nil] = 0
[s](X) = X
[tt] = 0
[U11Sharp](X1,X2) = 2.X1 + 2.X2 + 2
[U12Sharp](X) = 0
[U21Sharp](X1,X2) = 2.X2
[U22Sharp](X) = 0
[U31Sharp](X1,X2) = 0
[U32Sharp](X) = 0
[U41Sharp](X1,X2,X3) = 0
[U42Sharp](X1,X2) = 0
[U43Sharp](X) = 0
[U51Sharp](X1,X2,X3) = 2.X2 + X3 + 1
[U52Sharp](X1,X2) = 2.X1 + X2 + 1
[U53Sharp](X) = 0
[U61Sharp](X1,X2) = 0
[AND](X1,X2) = 0
[ISNAT](X) = 2.X
[ISNATILIST](X) = 0
[ISNATILISTKIND](X) = 0
[ISNATKIND](X) = 0
[ISNATLIST](X) = X + 1
[LENGTH](X) = 0
[ZEROS] = 0

Problem 1.1.2: 

SCC Processor:
-> Pairs:
 U21Sharp(tt,V1) -> ISNAT(V1)
 U51Sharp(tt,V1,V2) -> U52Sharp(isNat(V1),V2)
 U51Sharp(tt,V1,V2) -> ISNAT(V1)
 U52Sharp(tt,V2) -> ISNATLIST(V2)
 ISNAT(length(V1)) -> U11Sharp(isNatIListKind(V1),V1)
 ISNAT(s(V1)) -> U21Sharp(isNatKind(V1),V1)
 ISNATLIST(cons(V1,V2)) -> U51Sharp(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 Empty
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 U21Sharp(tt,V1) -> ISNAT(V1)
 ISNAT(s(V1)) -> U21Sharp(isNatKind(V1),V1)
->->-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->->-> Unhiding rules:
 Empty
->->Cycle:
->->-> Pairs:
 U51Sharp(tt,V1,V2) -> U52Sharp(isNat(V1),V2)
 U52Sharp(tt,V2) -> ISNATLIST(V2)
 ISNATLIST(cons(V1,V2)) -> U51Sharp(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
->->-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->->-> Unhiding rules:
 Empty


The problem is decomposed in 2 subproblems.

Problem 1.1.2.1: 

SubNColl Processor:
-> Pairs:
 U21Sharp(tt,V1) -> ISNAT(V1)
 ISNAT(s(V1)) -> U21Sharp(isNatKind(V1),V1)
-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 Empty
->Projection:
 pi(U21Sharp) = 2
 pi(ISNAT) = 1

Problem 1.1.2.1: 

SCC Processor:
-> Pairs:
 U21Sharp(tt,V1) -> ISNAT(V1)
-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 Empty
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.1.2.2: 

Non-Replacing Projection Processor:
-> Pairs:
 U51Sharp(tt,V1,V2) -> U52Sharp(isNat(V1),V2)
 U52Sharp(tt,V2) -> ISNATLIST(V2)
 ISNATLIST(cons(V1,V2)) -> U51Sharp(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 Empty
->Projection:
 pi(U51Sharp) = 3
 pi(U52Sharp) = 2
 pi(ISNATLIST) = 1
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[U11](X1,X2) = 0
[U12](X) = 0
[U21](X1,X2) = 0
[U22](X) = 0
[U31](X1,X2) = 0
[U32](X) = 0
[U41](X1,X2,X3) = 0
[U42](X1,X2) = 0
[U43](X) = 0
[U51](X1,X2,X3) = 0
[U52](X1,X2) = 0
[U53](X) = 0
[U61](X1,X2) = 0
[and](X1,X2) = 0
[isNat](X) = 0
[isNatIList](X) = 0
[isNatIListKind](X) = 0
[isNatKind](X) = 0
[isNatList](X) = 0
[length](X) = 0
[zeros] = 0
[num0] = 0
[cons](X1,X2) = 2.X2 + 2
[fSNonEmpty] = 0
[nil] = 0
[s](X) = 0
[tt] = 0
[U11Sharp](X1,X2) = 0
[U12Sharp](X) = 0
[U21Sharp](X1,X2) = 0
[U22Sharp](X) = 0
[U31Sharp](X1,X2) = 0
[U32Sharp](X) = 0
[U41Sharp](X1,X2,X3) = 0
[U42Sharp](X1,X2) = 0
[U43Sharp](X) = 0
[U51Sharp](X1,X2,X3) = 0
[U52Sharp](X1,X2) = 0
[U53Sharp](X) = 0
[U61Sharp](X1,X2) = 0
[AND](X1,X2) = 0
[ISNAT](X) = 0
[ISNATILIST](X) = 0
[ISNATILISTKIND](X) = 0
[ISNATKIND](X) = 0
[ISNATLIST](X) = 0
[LENGTH](X) = 0
[ZEROS] = 0

Problem 1.1.2.2: 

SCC Processor:
-> Pairs:
 U51Sharp(tt,V1,V2) -> U52Sharp(isNat(V1),V2)
 U52Sharp(tt,V2) -> ISNATLIST(V2)
-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 Empty
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2: 

Non-Replacing Projection Processor:
-> Pairs:
 U41Sharp(tt,V1,V2) -> U42Sharp(isNat(V1),V2)
 U42Sharp(tt,V2) -> ISNATILIST(V2)
 ISNATILIST(cons(V1,V2)) -> U41Sharp(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 Empty
->Projection:
 pi(U41Sharp) = 3
 pi(U42Sharp) = 2
 pi(ISNATILIST) = 1
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[U11](X1,X2) = 0
[U12](X) = 0
[U21](X1,X2) = 0
[U22](X) = 0
[U31](X1,X2) = 0
[U32](X) = 0
[U41](X1,X2,X3) = 0
[U42](X1,X2) = 0
[U43](X) = 0
[U51](X1,X2,X3) = 0
[U52](X1,X2) = 0
[U53](X) = 0
[U61](X1,X2) = 0
[and](X1,X2) = 0
[isNat](X) = 0
[isNatIList](X) = 0
[isNatIListKind](X) = 0
[isNatKind](X) = 0
[isNatList](X) = 0
[length](X) = 0
[zeros] = 0
[num0] = 0
[cons](X1,X2) = 2.X2 + 2
[fSNonEmpty] = 0
[nil] = 0
[s](X) = 0
[tt] = 0
[U11Sharp](X1,X2) = 0
[U12Sharp](X) = 0
[U21Sharp](X1,X2) = 0
[U22Sharp](X) = 0
[U31Sharp](X1,X2) = 0
[U32Sharp](X) = 0
[U41Sharp](X1,X2,X3) = 0
[U42Sharp](X1,X2) = 0
[U43Sharp](X) = 0
[U51Sharp](X1,X2,X3) = 0
[U52Sharp](X1,X2) = 0
[U53Sharp](X) = 0
[U61Sharp](X1,X2) = 0
[AND](X1,X2) = 0
[ISNAT](X) = 0
[ISNATILIST](X) = 0
[ISNATILISTKIND](X) = 0
[ISNATKIND](X) = 0
[ISNATLIST](X) = 0
[LENGTH](X) = 0
[ZEROS] = 0

Problem 1.2: 

SCC Processor:
-> Pairs:
 U41Sharp(tt,V1,V2) -> U42Sharp(isNat(V1),V2)
 U42Sharp(tt,V2) -> ISNATILIST(V2)
-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 Empty
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.3: 

Reduction Triple Processor:
-> Pairs:
 U61Sharp(tt,L) -> LENGTH(L)
 LENGTH(cons(N,L)) -> U61Sharp(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 Empty
-> Usable rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
->Interpretation type:
 Simple mixed
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[U11](X1,X2) = 2.X2
[U12](X) = X
[U21](X1,X2) = 2.X1 + X2
[U22](X) = X + 2
[U31](X1,X2) = 0
[U32](X) = 0
[U41](X1,X2,X3) = 0
[U42](X1,X2) = 0
[U43](X) = 0
[U51](X1,X2,X3) = 2.X2.X3 + 2.X3
[U52](X1,X2) = 2.X1.X2 + 2.X2
[U53](X) = X
[U61](X1,X2) = 2.X1 + 2.X2 + 1
[and](X1,X2) = X1.X2
[isNat](X) = X
[isNatIList](X) = 0
[isNatIListKind](X) = 1
[isNatKind](X) = 1
[isNatList](X) = 2.X
[length](X) = 2.X + 1
[zeros] = 0
[num0] = 2
[cons](X1,X2) = 2.X1.X2 + 2.X2
[fSNonEmpty] = 0
[nil] = 1
[s](X) = X + 2
[tt] = 1
[U11Sharp](X1,X2) = 0
[U12Sharp](X) = 0
[U21Sharp](X1,X2) = 0
[U22Sharp](X) = 0
[U31Sharp](X1,X2) = 0
[U32Sharp](X) = 0
[U41Sharp](X1,X2,X3) = 0
[U42Sharp](X1,X2) = 0
[U43Sharp](X) = 0
[U51Sharp](X1,X2,X3) = 0
[U52Sharp](X1,X2) = 0
[U53Sharp](X) = 0
[U61Sharp](X1,X2) = 2.X1 + 2.X2 + 2
[AND](X1,X2) = 0
[ISNAT](X) = 0
[ISNATILIST](X) = 0
[ISNATILISTKIND](X) = 0
[ISNATKIND](X) = 0
[ISNATLIST](X) = 0
[LENGTH](X) = 2.X + 2
[ZEROS] = 0

Problem 1.3: 

SCC Processor:
-> Pairs:
 LENGTH(cons(N,L)) -> U61Sharp(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
-> Rules:
 U11(tt,V1) -> U12(isNatList(V1))
 U12(tt) -> tt
 U21(tt,V1) -> U22(isNat(V1))
 U22(tt) -> tt
 U31(tt,V) -> U32(isNatList(V))
 U32(tt) -> tt
 U41(tt,V1,V2) -> U42(isNat(V1),V2)
 U42(tt,V2) -> U43(isNatIList(V2))
 U43(tt) -> tt
 U51(tt,V1,V2) -> U52(isNat(V1),V2)
 U52(tt,V2) -> U53(isNatList(V2))
 U53(tt) -> tt
 U61(tt,L) -> s(length(L))
 and(tt,X) -> X
 isNat(length(V1)) -> U11(isNatIListKind(V1),V1)
 isNat(num0) -> tt
 isNat(s(V1)) -> U21(isNatKind(V1),V1)
 isNatIList(zeros) -> tt
 isNatIList(cons(V1,V2)) -> U41(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatIList(V) -> U31(isNatIListKind(V),V)
 isNatIListKind(zeros) -> tt
 isNatIListKind(cons(V1,V2)) -> and(isNatKind(V1),isNatIListKind(V2))
 isNatIListKind(nil) -> tt
 isNatKind(length(V1)) -> isNatIListKind(V1)
 isNatKind(num0) -> tt
 isNatKind(s(V1)) -> isNatKind(V1)
 isNatList(cons(V1,V2)) -> U51(and(isNatKind(V1),isNatIListKind(V2)),V1,V2)
 isNatList(nil) -> tt
 length(cons(N,L)) -> U61(and(and(isNatList(L),isNatIListKind(L)),and(isNat(N),isNatKind(N))),L)
 length(nil) -> num0
 zeros -> cons(num0,zeros)
-> Unhiding rules:
 Empty
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
