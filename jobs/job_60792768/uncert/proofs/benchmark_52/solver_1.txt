YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/DdUpE.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given CSR could be proven:

(0) CSR
(1) CSDependencyPairsProof [EQUIVALENT, 0 ms]
(2) QCSDP
(3) QCSDependencyGraphProof [EQUIVALENT, 0 ms]
(4) AND
    (5) QCSDP
        (6) QCSDPSubtermProof [EQUIVALENT, 0 ms]
        (7) QCSDP
        (8) PIsEmptyProof [EQUIVALENT, 0 ms]
        (9) YES
    (10) QCSDP
        (11) QCSDPSubtermProof [EQUIVALENT, 0 ms]
        (12) QCSDP
        (13) PIsEmptyProof [EQUIVALENT, 0 ms]
        (14) YES
    (15) QCSDP
        (16) QCSDPSubtermProof [EQUIVALENT, 0 ms]
        (17) QCSDP
        (18) PIsEmptyProof [EQUIVALENT, 0 ms]
        (19) YES
    (20) QCSDP
        (21) QCSDPSubtermProof [EQUIVALENT, 0 ms]
        (22) QCSDP
        (23) PIsEmptyProof [EQUIVALENT, 0 ms]
        (24) YES


----------------------------------------

(0)
Obligation:
Context-sensitive rewrite system:
The TRS R consists of the following rules:

   terms(N) -> cons(recip(sqr(N)), terms(s(N)))
   sqr(0) -> 0
   sqr(s(X)) -> s(add(sqr(X), dbl(X)))
   dbl(0) -> 0
   dbl(s(X)) -> s(s(dbl(X)))
   add(0, X) -> X
   add(s(X), Y) -> s(add(X, Y))
   first(0, X) -> nil
   first(s(X), cons(Y, Z)) -> cons(Y, first(X, Z))
   half(0) -> 0
   half(s(0)) -> 0
   half(s(s(X))) -> s(half(X))
   half(dbl(X)) -> X

The replacement map contains the following entries:

terms: {1}
cons: {1}
recip: {1}
sqr: {1}
s: {1}
0: empty set
add: {1, 2}
dbl: {1}
first: {1, 2}
nil: empty set
half: {1}

----------------------------------------

(1) CSDependencyPairsProof (EQUIVALENT)
Using Improved CS-DPs [LPAR08] we result in the following initial Q-CSDP problem.
----------------------------------------

(2)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {terms_1, recip_1, sqr_1, s_1, add_2, dbl_1, first_2, half_1, SQR_1, TERMS_1, ADD_2, DBL_1, HALF_1} are replacing on all positions.
For all symbols f in {cons_2} we have mu(f) = {1}.

The ordinary context-sensitive dependency pairs DP_o are:
   TERMS(N) -> SQR(N)
   SQR(s(X)) -> ADD(sqr(X), dbl(X))
   SQR(s(X)) -> SQR(X)
   SQR(s(X)) -> DBL(X)
   DBL(s(X)) -> DBL(X)
   ADD(s(X), Y) -> ADD(X, Y)
   HALF(s(s(X))) -> HALF(X)

The TRS R consists of the following rules:

   terms(N) -> cons(recip(sqr(N)), terms(s(N)))
   sqr(0) -> 0
   sqr(s(X)) -> s(add(sqr(X), dbl(X)))
   dbl(0) -> 0
   dbl(s(X)) -> s(s(dbl(X)))
   add(0, X) -> X
   add(s(X), Y) -> s(add(X, Y))
   first(0, X) -> nil
   first(s(X), cons(Y, Z)) -> cons(Y, first(X, Z))
   half(0) -> 0
   half(s(0)) -> 0
   half(s(s(X))) -> s(half(X))
   half(dbl(X)) -> X

Q is empty.

----------------------------------------

(3) QCSDependencyGraphProof (EQUIVALENT)
The approximation of the Context-Sensitive Dependency Graph [LPAR08] contains 4 SCCs with 3 less nodes.

----------------------------------------

(4)
Complex Obligation (AND)

----------------------------------------

(5)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {terms_1, recip_1, sqr_1, s_1, add_2, dbl_1, first_2, half_1, HALF_1} are replacing on all positions.
For all symbols f in {cons_2} we have mu(f) = {1}.

The TRS P consists of the following rules:

   HALF(s(s(X))) -> HALF(X)

The TRS R consists of the following rules:

   terms(N) -> cons(recip(sqr(N)), terms(s(N)))
   sqr(0) -> 0
   sqr(s(X)) -> s(add(sqr(X), dbl(X)))
   dbl(0) -> 0
   dbl(s(X)) -> s(s(dbl(X)))
   add(0, X) -> X
   add(s(X), Y) -> s(add(X, Y))
   first(0, X) -> nil
   first(s(X), cons(Y, Z)) -> cons(Y, first(X, Z))
   half(0) -> 0
   half(s(0)) -> 0
   half(s(s(X))) -> s(half(X))
   half(dbl(X)) -> X

Q is empty.

----------------------------------------

(6) QCSDPSubtermProof (EQUIVALENT)
We use the subterm processor [DA_EMMES].


The following pairs can be oriented strictly and are deleted.

   HALF(s(s(X))) -> HALF(X)
The remaining pairs can at least be oriented weakly.
none
Used ordering:  Combined order from the following AFS and order.
HALF(x1)  =  x1


Subterm Order

----------------------------------------

(7)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {terms_1, recip_1, sqr_1, s_1, add_2, dbl_1, first_2, half_1} are replacing on all positions.
For all symbols f in {cons_2} we have mu(f) = {1}.

The TRS P consists of the following rules:
none

The TRS R consists of the following rules:

   terms(N) -> cons(recip(sqr(N)), terms(s(N)))
   sqr(0) -> 0
   sqr(s(X)) -> s(add(sqr(X), dbl(X)))
   dbl(0) -> 0
   dbl(s(X)) -> s(s(dbl(X)))
   add(0, X) -> X
   add(s(X), Y) -> s(add(X, Y))
   first(0, X) -> nil
   first(s(X), cons(Y, Z)) -> cons(Y, first(X, Z))
   half(0) -> 0
   half(s(0)) -> 0
   half(s(s(X))) -> s(half(X))
   half(dbl(X)) -> X

Q is empty.

----------------------------------------

(8) PIsEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R,mu)-chain.
----------------------------------------

(9)
YES

----------------------------------------

(10)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {terms_1, recip_1, sqr_1, s_1, add_2, dbl_1, first_2, half_1, DBL_1} are replacing on all positions.
For all symbols f in {cons_2} we have mu(f) = {1}.

The TRS P consists of the following rules:

   DBL(s(X)) -> DBL(X)

The TRS R consists of the following rules:

   terms(N) -> cons(recip(sqr(N)), terms(s(N)))
   sqr(0) -> 0
   sqr(s(X)) -> s(add(sqr(X), dbl(X)))
   dbl(0) -> 0
   dbl(s(X)) -> s(s(dbl(X)))
   add(0, X) -> X
   add(s(X), Y) -> s(add(X, Y))
   first(0, X) -> nil
   first(s(X), cons(Y, Z)) -> cons(Y, first(X, Z))
   half(0) -> 0
   half(s(0)) -> 0
   half(s(s(X))) -> s(half(X))
   half(dbl(X)) -> X

Q is empty.

----------------------------------------

(11) QCSDPSubtermProof (EQUIVALENT)
We use the subterm processor [DA_EMMES].


The following pairs can be oriented strictly and are deleted.

   DBL(s(X)) -> DBL(X)
The remaining pairs can at least be oriented weakly.
none
Used ordering:  Combined order from the following AFS and order.
DBL(x1)  =  x1


Subterm Order

----------------------------------------

(12)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {terms_1, recip_1, sqr_1, s_1, add_2, dbl_1, first_2, half_1} are replacing on all positions.
For all symbols f in {cons_2} we have mu(f) = {1}.

The TRS P consists of the following rules:
none

The TRS R consists of the following rules:

   terms(N) -> cons(recip(sqr(N)), terms(s(N)))
   sqr(0) -> 0
   sqr(s(X)) -> s(add(sqr(X), dbl(X)))
   dbl(0) -> 0
   dbl(s(X)) -> s(s(dbl(X)))
   add(0, X) -> X
   add(s(X), Y) -> s(add(X, Y))
   first(0, X) -> nil
   first(s(X), cons(Y, Z)) -> cons(Y, first(X, Z))
   half(0) -> 0
   half(s(0)) -> 0
   half(s(s(X))) -> s(half(X))
   half(dbl(X)) -> X

Q is empty.

----------------------------------------

(13) PIsEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R,mu)-chain.
----------------------------------------

(14)
YES

----------------------------------------

(15)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {terms_1, recip_1, sqr_1, s_1, add_2, dbl_1, first_2, half_1, ADD_2} are replacing on all positions.
For all symbols f in {cons_2} we have mu(f) = {1}.

The TRS P consists of the following rules:

   ADD(s(X), Y) -> ADD(X, Y)

The TRS R consists of the following rules:

   terms(N) -> cons(recip(sqr(N)), terms(s(N)))
   sqr(0) -> 0
   sqr(s(X)) -> s(add(sqr(X), dbl(X)))
   dbl(0) -> 0
   dbl(s(X)) -> s(s(dbl(X)))
   add(0, X) -> X
   add(s(X), Y) -> s(add(X, Y))
   first(0, X) -> nil
   first(s(X), cons(Y, Z)) -> cons(Y, first(X, Z))
   half(0) -> 0
   half(s(0)) -> 0
   half(s(s(X))) -> s(half(X))
   half(dbl(X)) -> X

Q is empty.

----------------------------------------

(16) QCSDPSubtermProof (EQUIVALENT)
We use the subterm processor [DA_EMMES].


The following pairs can be oriented strictly and are deleted.

   ADD(s(X), Y) -> ADD(X, Y)
The remaining pairs can at least be oriented weakly.
none
Used ordering:  Combined order from the following AFS and order.
ADD(x1, x2)  =  x1


Subterm Order

----------------------------------------

(17)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {terms_1, recip_1, sqr_1, s_1, add_2, dbl_1, first_2, half_1} are replacing on all positions.
For all symbols f in {cons_2} we have mu(f) = {1}.

The TRS P consists of the following rules:
none

The TRS R consists of the following rules:

   terms(N) -> cons(recip(sqr(N)), terms(s(N)))
   sqr(0) -> 0
   sqr(s(X)) -> s(add(sqr(X), dbl(X)))
   dbl(0) -> 0
   dbl(s(X)) -> s(s(dbl(X)))
   add(0, X) -> X
   add(s(X), Y) -> s(add(X, Y))
   first(0, X) -> nil
   first(s(X), cons(Y, Z)) -> cons(Y, first(X, Z))
   half(0) -> 0
   half(s(0)) -> 0
   half(s(s(X))) -> s(half(X))
   half(dbl(X)) -> X

Q is empty.

----------------------------------------

(18) PIsEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R,mu)-chain.
----------------------------------------

(19)
YES

----------------------------------------

(20)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {terms_1, recip_1, sqr_1, s_1, add_2, dbl_1, first_2, half_1, SQR_1} are replacing on all positions.
For all symbols f in {cons_2} we have mu(f) = {1}.

The TRS P consists of the following rules:

   SQR(s(X)) -> SQR(X)

The TRS R consists of the following rules:

   terms(N) -> cons(recip(sqr(N)), terms(s(N)))
   sqr(0) -> 0
   sqr(s(X)) -> s(add(sqr(X), dbl(X)))
   dbl(0) -> 0
   dbl(s(X)) -> s(s(dbl(X)))
   add(0, X) -> X
   add(s(X), Y) -> s(add(X, Y))
   first(0, X) -> nil
   first(s(X), cons(Y, Z)) -> cons(Y, first(X, Z))
   half(0) -> 0
   half(s(0)) -> 0
   half(s(s(X))) -> s(half(X))
   half(dbl(X)) -> X

Q is empty.

----------------------------------------

(21) QCSDPSubtermProof (EQUIVALENT)
We use the subterm processor [DA_EMMES].


The following pairs can be oriented strictly and are deleted.

   SQR(s(X)) -> SQR(X)
The remaining pairs can at least be oriented weakly.
none
Used ordering:  Combined order from the following AFS and order.
SQR(x1)  =  x1


Subterm Order

----------------------------------------

(22)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {terms_1, recip_1, sqr_1, s_1, add_2, dbl_1, first_2, half_1} are replacing on all positions.
For all symbols f in {cons_2} we have mu(f) = {1}.

The TRS P consists of the following rules:
none

The TRS R consists of the following rules:

   terms(N) -> cons(recip(sqr(N)), terms(s(N)))
   sqr(0) -> 0
   sqr(s(X)) -> s(add(sqr(X), dbl(X)))
   dbl(0) -> 0
   dbl(s(X)) -> s(s(dbl(X)))
   add(0, X) -> X
   add(s(X), Y) -> s(add(X, Y))
   first(0, X) -> nil
   first(s(X), cons(Y, Z)) -> cons(Y, first(X, Z))
   half(0) -> 0
   half(s(0)) -> 0
   half(s(s(X))) -> s(half(X))
   half(dbl(X)) -> X

Q is empty.

----------------------------------------

(23) PIsEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R,mu)-chain.
----------------------------------------

(24)
YES
