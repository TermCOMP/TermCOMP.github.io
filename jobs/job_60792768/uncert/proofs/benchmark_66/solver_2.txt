YES

Problem 1: 

(VAR vu95NonEmpty N X XS Y YS ZS)
(STRATEGY CONTEXTSENSITIVE
(U11 1)
(U12 1)
(afterNth 1 2)
(and 1)
(fst 1)
(head 1)
(natsFrom 1)
(sel 1 2)
(snd 1)
(splitAt 1 2)
(tail 1)
(take 1 2)
(num0)
(cons 1)
(fSNonEmpty)
(nil)
(pair 1 2)
(s 1)
(tt)
)
(RULES
U11(tt,N,X,XS) -> U12(splitAt(N,XS),X)
U12(pair(YS,ZS),X) -> pair(cons(X,YS),ZS)
afterNth(N,XS) -> snd(splitAt(N,XS))
and(tt,X) -> X
fst(pair(X,Y)) -> X
head(cons(N,XS)) -> N
natsFrom(N) -> cons(N,natsFrom(s(N)))
sel(N,XS) -> head(afterNth(N,XS))
snd(pair(X,Y)) -> Y
splitAt(num0,XS) -> pair(nil,XS)
splitAt(s(N),cons(X,XS)) -> U11(tt,N,X,XS)
tail(cons(N,XS)) -> XS
take(N,XS) -> fst(splitAt(N,XS))
)


Problem 1: 

Innermost Equivalent Processor:
-> Rules:
 U11(tt,N,X,XS) -> U12(splitAt(N,XS),X)
 U12(pair(YS,ZS),X) -> pair(cons(X,YS),ZS)
 afterNth(N,XS) -> snd(splitAt(N,XS))
 and(tt,X) -> X
 fst(pair(X,Y)) -> X
 head(cons(N,XS)) -> N
 natsFrom(N) -> cons(N,natsFrom(s(N)))
 sel(N,XS) -> head(afterNth(N,XS))
 snd(pair(X,Y)) -> Y
 splitAt(num0,XS) -> pair(nil,XS)
 splitAt(s(N),cons(X,XS)) -> U11(tt,N,X,XS)
 tail(cons(N,XS)) -> XS
 take(N,XS) -> fst(splitAt(N,XS))
-> The context-sensitive term rewriting system is an orthogonal system. Therefore, innermost cs-termination implies cs-termination.
 

Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 U11Sharp(tt,N,X,XS) -> U12Sharp(splitAt(N,XS),X)
 U11Sharp(tt,N,X,XS) -> SPLITAT(N,XS)
 U11Sharp(tt,N,X,XS) -> N
 U11Sharp(tt,N,X,XS) -> XS
 U12Sharp(pair(YS,ZS),X) -> X
 AFTERNTH(N,XS) -> SND(splitAt(N,XS))
 AFTERNTH(N,XS) -> SPLITAT(N,XS)
 AND(tt,X) -> X
 SEL(N,XS) -> AFTERNTH(N,XS)
 SEL(N,XS) -> HEAD(afterNth(N,XS))
 SPLITAT(s(N),cons(X,XS)) -> U11Sharp(tt,N,X,XS)
 TAIL(cons(N,XS)) -> XS
 TAKE(N,XS) -> FST(splitAt(N,XS))
 TAKE(N,XS) -> SPLITAT(N,XS)
-> Rules:
 U11(tt,N,X,XS) -> U12(splitAt(N,XS),X)
 U12(pair(YS,ZS),X) -> pair(cons(X,YS),ZS)
 afterNth(N,XS) -> snd(splitAt(N,XS))
 and(tt,X) -> X
 fst(pair(X,Y)) -> X
 head(cons(N,XS)) -> N
 natsFrom(N) -> cons(N,natsFrom(s(N)))
 sel(N,XS) -> head(afterNth(N,XS))
 snd(pair(X,Y)) -> Y
 splitAt(num0,XS) -> pair(nil,XS)
 splitAt(s(N),cons(X,XS)) -> U11(tt,N,X,XS)
 tail(cons(N,XS)) -> XS
 take(N,XS) -> fst(splitAt(N,XS))
-> Unhiding Rules:
 natsFrom(s(N)) -> NATSFROM(s(N))

Problem 1: 

SCC Processor:
-> Pairs:
 U11Sharp(tt,N,X,XS) -> U12Sharp(splitAt(N,XS),X)
 U11Sharp(tt,N,X,XS) -> SPLITAT(N,XS)
 U11Sharp(tt,N,X,XS) -> N
 U11Sharp(tt,N,X,XS) -> XS
 U12Sharp(pair(YS,ZS),X) -> X
 AFTERNTH(N,XS) -> SND(splitAt(N,XS))
 AFTERNTH(N,XS) -> SPLITAT(N,XS)
 AND(tt,X) -> X
 SEL(N,XS) -> AFTERNTH(N,XS)
 SEL(N,XS) -> HEAD(afterNth(N,XS))
 SPLITAT(s(N),cons(X,XS)) -> U11Sharp(tt,N,X,XS)
 TAIL(cons(N,XS)) -> XS
 TAKE(N,XS) -> FST(splitAt(N,XS))
 TAKE(N,XS) -> SPLITAT(N,XS)
-> Rules:
 U11(tt,N,X,XS) -> U12(splitAt(N,XS),X)
 U12(pair(YS,ZS),X) -> pair(cons(X,YS),ZS)
 afterNth(N,XS) -> snd(splitAt(N,XS))
 and(tt,X) -> X
 fst(pair(X,Y)) -> X
 head(cons(N,XS)) -> N
 natsFrom(N) -> cons(N,natsFrom(s(N)))
 sel(N,XS) -> head(afterNth(N,XS))
 snd(pair(X,Y)) -> Y
 splitAt(num0,XS) -> pair(nil,XS)
 splitAt(s(N),cons(X,XS)) -> U11(tt,N,X,XS)
 tail(cons(N,XS)) -> XS
 take(N,XS) -> fst(splitAt(N,XS))
-> Unhiding rules:
 natsFrom(s(N)) -> NATSFROM(s(N))
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 U11Sharp(tt,N,X,XS) -> SPLITAT(N,XS)
 SPLITAT(s(N),cons(X,XS)) -> U11Sharp(tt,N,X,XS)
->->-> Rules:
 U11(tt,N,X,XS) -> U12(splitAt(N,XS),X)
 U12(pair(YS,ZS),X) -> pair(cons(X,YS),ZS)
 afterNth(N,XS) -> snd(splitAt(N,XS))
 and(tt,X) -> X
 fst(pair(X,Y)) -> X
 head(cons(N,XS)) -> N
 natsFrom(N) -> cons(N,natsFrom(s(N)))
 sel(N,XS) -> head(afterNth(N,XS))
 snd(pair(X,Y)) -> Y
 splitAt(num0,XS) -> pair(nil,XS)
 splitAt(s(N),cons(X,XS)) -> U11(tt,N,X,XS)
 tail(cons(N,XS)) -> XS
 take(N,XS) -> fst(splitAt(N,XS))
->->-> Unhiding rules:
 Empty

Problem 1: 

SubNColl Processor:
-> Pairs:
 U11Sharp(tt,N,X,XS) -> SPLITAT(N,XS)
 SPLITAT(s(N),cons(X,XS)) -> U11Sharp(tt,N,X,XS)
-> Rules:
 U11(tt,N,X,XS) -> U12(splitAt(N,XS),X)
 U12(pair(YS,ZS),X) -> pair(cons(X,YS),ZS)
 afterNth(N,XS) -> snd(splitAt(N,XS))
 and(tt,X) -> X
 fst(pair(X,Y)) -> X
 head(cons(N,XS)) -> N
 natsFrom(N) -> cons(N,natsFrom(s(N)))
 sel(N,XS) -> head(afterNth(N,XS))
 snd(pair(X,Y)) -> Y
 splitAt(num0,XS) -> pair(nil,XS)
 splitAt(s(N),cons(X,XS)) -> U11(tt,N,X,XS)
 tail(cons(N,XS)) -> XS
 take(N,XS) -> fst(splitAt(N,XS))
-> Unhiding rules:
 Empty
->Projection:
 pi(U11Sharp) = 2
 pi(SPLITAT) = 1

Problem 1: 

SCC Processor:
-> Pairs:
 U11Sharp(tt,N,X,XS) -> SPLITAT(N,XS)
-> Rules:
 U11(tt,N,X,XS) -> U12(splitAt(N,XS),X)
 U12(pair(YS,ZS),X) -> pair(cons(X,YS),ZS)
 afterNth(N,XS) -> snd(splitAt(N,XS))
 and(tt,X) -> X
 fst(pair(X,Y)) -> X
 head(cons(N,XS)) -> N
 natsFrom(N) -> cons(N,natsFrom(s(N)))
 sel(N,XS) -> head(afterNth(N,XS))
 snd(pair(X,Y)) -> Y
 splitAt(num0,XS) -> pair(nil,XS)
 splitAt(s(N),cons(X,XS)) -> U11(tt,N,X,XS)
 tail(cons(N,XS)) -> XS
 take(N,XS) -> fst(splitAt(N,XS))
-> Unhiding rules:
 Empty
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
