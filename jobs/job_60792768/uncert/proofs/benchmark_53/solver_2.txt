YES

Problem 1: 

(VAR vu95NonEmpty N X XS YS ZS)
(STRATEGY CONTEXTSENSITIVE
(afterNth 1 2)
(fst 1)
(head 1)
(natsFrom 1)
(sel 1 2)
(snd 1)
(splitAt 1 2)
(tail 1)
(take 1 2)
(u 1)
(num0)
(cons 1)
(fSNonEmpty)
(nil)
(pair 1 2)
(s 1)
)
(RULES
afterNth(N,XS) -> snd(splitAt(N,XS))
fst(pair(XS,YS)) -> XS
head(cons(N,XS)) -> N
natsFrom(N) -> cons(N,natsFrom(s(N)))
sel(N,XS) -> head(afterNth(N,XS))
snd(pair(XS,YS)) -> YS
splitAt(num0,XS) -> pair(nil,XS)
splitAt(s(N),cons(X,XS)) -> u(splitAt(N,XS),N,X,XS)
tail(cons(N,XS)) -> XS
take(N,XS) -> fst(splitAt(N,XS))
u(pair(YS,ZS),N,X,XS) -> pair(cons(X,YS),ZS)
)


Problem 1: 

Innermost Equivalent Processor:
-> Rules:
 afterNth(N,XS) -> snd(splitAt(N,XS))
 fst(pair(XS,YS)) -> XS
 head(cons(N,XS)) -> N
 natsFrom(N) -> cons(N,natsFrom(s(N)))
 sel(N,XS) -> head(afterNth(N,XS))
 snd(pair(XS,YS)) -> YS
 splitAt(num0,XS) -> pair(nil,XS)
 splitAt(s(N),cons(X,XS)) -> u(splitAt(N,XS),N,X,XS)
 tail(cons(N,XS)) -> XS
 take(N,XS) -> fst(splitAt(N,XS))
 u(pair(YS,ZS),N,X,XS) -> pair(cons(X,YS),ZS)
-> The context-sensitive term rewriting system is an orthogonal system. Therefore, innermost cs-termination implies cs-termination.
 

Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 AFTERNTH(N,XS) -> SND(splitAt(N,XS))
 AFTERNTH(N,XS) -> SPLITAT(N,XS)
 SEL(N,XS) -> AFTERNTH(N,XS)
 SEL(N,XS) -> HEAD(afterNth(N,XS))
 SPLITAT(s(N),cons(X,XS)) -> SPLITAT(N,XS)
 SPLITAT(s(N),cons(X,XS)) -> U(splitAt(N,XS),N,X,XS)
 SPLITAT(s(N),cons(X,XS)) -> XS
 TAIL(cons(N,XS)) -> XS
 TAKE(N,XS) -> FST(splitAt(N,XS))
 TAKE(N,XS) -> SPLITAT(N,XS)
 U(pair(YS,ZS),N,X,XS) -> X
-> Rules:
 afterNth(N,XS) -> snd(splitAt(N,XS))
 fst(pair(XS,YS)) -> XS
 head(cons(N,XS)) -> N
 natsFrom(N) -> cons(N,natsFrom(s(N)))
 sel(N,XS) -> head(afterNth(N,XS))
 snd(pair(XS,YS)) -> YS
 splitAt(num0,XS) -> pair(nil,XS)
 splitAt(s(N),cons(X,XS)) -> u(splitAt(N,XS),N,X,XS)
 tail(cons(N,XS)) -> XS
 take(N,XS) -> fst(splitAt(N,XS))
 u(pair(YS,ZS),N,X,XS) -> pair(cons(X,YS),ZS)
-> Unhiding Rules:
 natsFrom(s(N)) -> NATSFROM(s(N))

Problem 1: 

SCC Processor:
-> Pairs:
 AFTERNTH(N,XS) -> SND(splitAt(N,XS))
 AFTERNTH(N,XS) -> SPLITAT(N,XS)
 SEL(N,XS) -> AFTERNTH(N,XS)
 SEL(N,XS) -> HEAD(afterNth(N,XS))
 SPLITAT(s(N),cons(X,XS)) -> SPLITAT(N,XS)
 SPLITAT(s(N),cons(X,XS)) -> U(splitAt(N,XS),N,X,XS)
 SPLITAT(s(N),cons(X,XS)) -> XS
 TAIL(cons(N,XS)) -> XS
 TAKE(N,XS) -> FST(splitAt(N,XS))
 TAKE(N,XS) -> SPLITAT(N,XS)
 U(pair(YS,ZS),N,X,XS) -> X
-> Rules:
 afterNth(N,XS) -> snd(splitAt(N,XS))
 fst(pair(XS,YS)) -> XS
 head(cons(N,XS)) -> N
 natsFrom(N) -> cons(N,natsFrom(s(N)))
 sel(N,XS) -> head(afterNth(N,XS))
 snd(pair(XS,YS)) -> YS
 splitAt(num0,XS) -> pair(nil,XS)
 splitAt(s(N),cons(X,XS)) -> u(splitAt(N,XS),N,X,XS)
 tail(cons(N,XS)) -> XS
 take(N,XS) -> fst(splitAt(N,XS))
 u(pair(YS,ZS),N,X,XS) -> pair(cons(X,YS),ZS)
-> Unhiding rules:
 natsFrom(s(N)) -> NATSFROM(s(N))
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 SPLITAT(s(N),cons(X,XS)) -> SPLITAT(N,XS)
->->-> Rules:
 afterNth(N,XS) -> snd(splitAt(N,XS))
 fst(pair(XS,YS)) -> XS
 head(cons(N,XS)) -> N
 natsFrom(N) -> cons(N,natsFrom(s(N)))
 sel(N,XS) -> head(afterNth(N,XS))
 snd(pair(XS,YS)) -> YS
 splitAt(num0,XS) -> pair(nil,XS)
 splitAt(s(N),cons(X,XS)) -> u(splitAt(N,XS),N,X,XS)
 tail(cons(N,XS)) -> XS
 take(N,XS) -> fst(splitAt(N,XS))
 u(pair(YS,ZS),N,X,XS) -> pair(cons(X,YS),ZS)
->->-> Unhiding rules:
 Empty

Problem 1: 

SubNColl Processor:
-> Pairs:
 SPLITAT(s(N),cons(X,XS)) -> SPLITAT(N,XS)
-> Rules:
 afterNth(N,XS) -> snd(splitAt(N,XS))
 fst(pair(XS,YS)) -> XS
 head(cons(N,XS)) -> N
 natsFrom(N) -> cons(N,natsFrom(s(N)))
 sel(N,XS) -> head(afterNth(N,XS))
 snd(pair(XS,YS)) -> YS
 splitAt(num0,XS) -> pair(nil,XS)
 splitAt(s(N),cons(X,XS)) -> u(splitAt(N,XS),N,X,XS)
 tail(cons(N,XS)) -> XS
 take(N,XS) -> fst(splitAt(N,XS))
 u(pair(YS,ZS),N,X,XS) -> pair(cons(X,YS),ZS)
-> Unhiding rules:
 Empty
->Projection:
 pi(SPLITAT) = 1

Problem 1: 

Basic Processor:
-> Pairs:
 Empty
-> Rules:
 afterNth(N,XS) -> snd(splitAt(N,XS))
 fst(pair(XS,YS)) -> XS
 head(cons(N,XS)) -> N
 natsFrom(N) -> cons(N,natsFrom(s(N)))
 sel(N,XS) -> head(afterNth(N,XS))
 snd(pair(XS,YS)) -> YS
 splitAt(num0,XS) -> pair(nil,XS)
 splitAt(s(N),cons(X,XS)) -> u(splitAt(N,XS),N,X,XS)
 tail(cons(N,XS)) -> XS
 take(N,XS) -> fst(splitAt(N,XS))
 u(pair(YS,ZS),N,X,XS) -> pair(cons(X,YS),ZS)
-> Unhiding rules:
 Empty
-> Result:
 Set P is empty

The problem is finite.
