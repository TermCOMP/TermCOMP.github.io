MAYBE
proof of /hpcwork/ff862203/termcomp25/benchmarks/cLsyi.pl
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Left Termination of the query pattern

fl(a,a,g)

w.r.t. the given Prolog program could not be shown:

(0) Prolog
(1) PrologToPiTRSProof [SOUND, 0 ms]
(2) PiTRS
    (3) DependencyPairsProof [EQUIVALENT, 0 ms]
    (4) PiDP
    (5) DependencyGraphProof [EQUIVALENT, 0 ms]
    (6) AND
        (7) PiDP
            (8) UsableRulesProof [EQUIVALENT, 0 ms]
            (9) PiDP
            (10) PiDPToQDPProof [SOUND, 0 ms]
            (11) QDP
            (12) NonTerminationLoopProof [COMPLETE, 0 ms]
            (13) NO
        (14) PiDP
            (15) UsableRulesProof [EQUIVALENT, 0 ms]
            (16) PiDP
            (17) PiDPToQDPProof [SOUND, 0 ms]
            (18) QDP
            (19) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (20) YES
(21) PrologToPiTRSProof [SOUND, 0 ms]
(22) PiTRS
    (23) DependencyPairsProof [EQUIVALENT, 0 ms]
    (24) PiDP
    (25) DependencyGraphProof [EQUIVALENT, 0 ms]
    (26) AND
        (27) PiDP
            (28) UsableRulesProof [EQUIVALENT, 0 ms]
            (29) PiDP
            (30) PiDPToQDPProof [SOUND, 0 ms]
            (31) QDP
            (32) NonTerminationLoopProof [COMPLETE, 0 ms]
            (33) NO
        (34) PiDP
            (35) UsableRulesProof [EQUIVALENT, 0 ms]
            (36) PiDP
            (37) PiDPToQDPProof [SOUND, 0 ms]
            (38) QDP
            (39) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (40) YES
(41) PrologToTRSTransformerProof [SOUND, 0 ms]
(42) QTRS
    (43) QTRSRRRProof [EQUIVALENT, 28 ms]
    (44) QTRS
    (45) QTRSRRRProof [EQUIVALENT, 0 ms]
    (46) QTRS
    (47) QTRSRRRProof [EQUIVALENT, 0 ms]
    (48) QTRS
    (49) Overlay + Local Confluence [EQUIVALENT, 0 ms]
    (50) QTRS
    (51) DependencyPairsProof [EQUIVALENT, 0 ms]
    (52) QDP
    (53) UsableRulesProof [EQUIVALENT, 0 ms]
    (54) QDP
    (55) QReductionProof [EQUIVALENT, 0 ms]
    (56) QDP
(57) PrologToDTProblemTransformerProof [SOUND, 0 ms]
(58) TRIPLES
    (59) TriplesToPiDPProof [SOUND, 0 ms]
    (60) PiDP
    (61) DependencyGraphProof [EQUIVALENT, 0 ms]
    (62) PiDP
    (63) PiDPToQDPProof [SOUND, 0 ms]
    (64) QDP
    (65) UsableRulesReductionPairsProof [EQUIVALENT, 12 ms]
    (66) QDP
    (67) DependencyGraphProof [EQUIVALENT, 0 ms]
    (68) QDP
    (69) NonTerminationLoopProof [COMPLETE, 0 ms]
    (70) NO
(71) PrologToIRSwTTransformerProof [SOUND, 0 ms]
(72) AND
    (73) IRSwT
        (74) IRSwTSimpleDependencyGraphProof [EQUIVALENT, 0 ms]
        (75) IRSwT
        (76) IntTRSCompressionProof [EQUIVALENT, 8 ms]
        (77) IRSwT
        (78) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
        (79) IRSwT
        (80) IRSwTTerminationDigraphProof [EQUIVALENT, 3 ms]
        (81) IRSwT
        (82) FilterProof [EQUIVALENT, 0 ms]
        (83) IntTRS
        (84) IntTRSNonPeriodicNontermProof [COMPLETE, 2 ms]
        (85) NO
    (86) IRSwT
        (87) IRSwTSimpleDependencyGraphProof [EQUIVALENT, 0 ms]
        (88) IRSwT
        (89) IntTRSCompressionProof [EQUIVALENT, 3 ms]
        (90) IRSwT
        (91) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
        (92) IRSwT
        (93) IRSwTTerminationDigraphProof [EQUIVALENT, 1 ms]
        (94) IRSwT
        (95) FilterProof [EQUIVALENT, 0 ms]
        (96) IntTRS
        (97) IntTRSPeriodicNontermProof [COMPLETE, 0 ms]
        (98) NO


----------------------------------------

(0)
Obligation:
Clauses:

fl([], [], 0).
fl(.(E, X), R, s(Z)) :- ','(append(E, Y, R), fl(X, Y, Z)).
append([], X, X).
append(.(X, Xs), Ys, .(X, Zs)) :- append(Xs, Ys, Zs).


Query: fl(a,a,g)
----------------------------------------

(1) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

fl_in_3: (f,f,b)

append_in_3: (f,f,f)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   fl_in_aag([], [], 0) -> fl_out_aag([], [], 0)
   fl_in_aag(.(E, X), R, s(Z)) -> U1_aag(E, X, R, Z, append_in_aaa(E, Y, R))
   append_in_aaa([], X, X) -> append_out_aaa([], X, X)
   append_in_aaa(.(X, Xs), Ys, .(X, Zs)) -> U3_aaa(X, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U3_aaa(X, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(X, Xs), Ys, .(X, Zs))
   U1_aag(E, X, R, Z, append_out_aaa(E, Y, R)) -> U2_aag(E, X, R, Z, fl_in_aag(X, Y, Z))
   U2_aag(E, X, R, Z, fl_out_aag(X, Y, Z)) -> fl_out_aag(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aag(x1, x2, x3)  =  fl_in_aag(x3)

0  =  0

fl_out_aag(x1, x2, x3)  =  fl_out_aag(x3)

s(x1)  =  s(x1)

U1_aag(x1, x2, x3, x4, x5)  =  U1_aag(x4, x5)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa

U3_aaa(x1, x2, x3, x4, x5)  =  U3_aaa(x5)

U2_aag(x1, x2, x3, x4, x5)  =  U2_aag(x4, x5)





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(2)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   fl_in_aag([], [], 0) -> fl_out_aag([], [], 0)
   fl_in_aag(.(E, X), R, s(Z)) -> U1_aag(E, X, R, Z, append_in_aaa(E, Y, R))
   append_in_aaa([], X, X) -> append_out_aaa([], X, X)
   append_in_aaa(.(X, Xs), Ys, .(X, Zs)) -> U3_aaa(X, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U3_aaa(X, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(X, Xs), Ys, .(X, Zs))
   U1_aag(E, X, R, Z, append_out_aaa(E, Y, R)) -> U2_aag(E, X, R, Z, fl_in_aag(X, Y, Z))
   U2_aag(E, X, R, Z, fl_out_aag(X, Y, Z)) -> fl_out_aag(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aag(x1, x2, x3)  =  fl_in_aag(x3)

0  =  0

fl_out_aag(x1, x2, x3)  =  fl_out_aag(x3)

s(x1)  =  s(x1)

U1_aag(x1, x2, x3, x4, x5)  =  U1_aag(x4, x5)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa

U3_aaa(x1, x2, x3, x4, x5)  =  U3_aaa(x5)

U2_aag(x1, x2, x3, x4, x5)  =  U2_aag(x4, x5)



----------------------------------------

(3) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   FL_IN_AAG(.(E, X), R, s(Z)) -> U1_AAG(E, X, R, Z, append_in_aaa(E, Y, R))
   FL_IN_AAG(.(E, X), R, s(Z)) -> APPEND_IN_AAA(E, Y, R)
   APPEND_IN_AAA(.(X, Xs), Ys, .(X, Zs)) -> U3_AAA(X, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   APPEND_IN_AAA(.(X, Xs), Ys, .(X, Zs)) -> APPEND_IN_AAA(Xs, Ys, Zs)
   U1_AAG(E, X, R, Z, append_out_aaa(E, Y, R)) -> U2_AAG(E, X, R, Z, fl_in_aag(X, Y, Z))
   U1_AAG(E, X, R, Z, append_out_aaa(E, Y, R)) -> FL_IN_AAG(X, Y, Z)

The TRS R consists of the following rules:

   fl_in_aag([], [], 0) -> fl_out_aag([], [], 0)
   fl_in_aag(.(E, X), R, s(Z)) -> U1_aag(E, X, R, Z, append_in_aaa(E, Y, R))
   append_in_aaa([], X, X) -> append_out_aaa([], X, X)
   append_in_aaa(.(X, Xs), Ys, .(X, Zs)) -> U3_aaa(X, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U3_aaa(X, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(X, Xs), Ys, .(X, Zs))
   U1_aag(E, X, R, Z, append_out_aaa(E, Y, R)) -> U2_aag(E, X, R, Z, fl_in_aag(X, Y, Z))
   U2_aag(E, X, R, Z, fl_out_aag(X, Y, Z)) -> fl_out_aag(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aag(x1, x2, x3)  =  fl_in_aag(x3)

0  =  0

fl_out_aag(x1, x2, x3)  =  fl_out_aag(x3)

s(x1)  =  s(x1)

U1_aag(x1, x2, x3, x4, x5)  =  U1_aag(x4, x5)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa

U3_aaa(x1, x2, x3, x4, x5)  =  U3_aaa(x5)

U2_aag(x1, x2, x3, x4, x5)  =  U2_aag(x4, x5)

FL_IN_AAG(x1, x2, x3)  =  FL_IN_AAG(x3)

U1_AAG(x1, x2, x3, x4, x5)  =  U1_AAG(x4, x5)

APPEND_IN_AAA(x1, x2, x3)  =  APPEND_IN_AAA

U3_AAA(x1, x2, x3, x4, x5)  =  U3_AAA(x5)

U2_AAG(x1, x2, x3, x4, x5)  =  U2_AAG(x4, x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(4)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   FL_IN_AAG(.(E, X), R, s(Z)) -> U1_AAG(E, X, R, Z, append_in_aaa(E, Y, R))
   FL_IN_AAG(.(E, X), R, s(Z)) -> APPEND_IN_AAA(E, Y, R)
   APPEND_IN_AAA(.(X, Xs), Ys, .(X, Zs)) -> U3_AAA(X, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   APPEND_IN_AAA(.(X, Xs), Ys, .(X, Zs)) -> APPEND_IN_AAA(Xs, Ys, Zs)
   U1_AAG(E, X, R, Z, append_out_aaa(E, Y, R)) -> U2_AAG(E, X, R, Z, fl_in_aag(X, Y, Z))
   U1_AAG(E, X, R, Z, append_out_aaa(E, Y, R)) -> FL_IN_AAG(X, Y, Z)

The TRS R consists of the following rules:

   fl_in_aag([], [], 0) -> fl_out_aag([], [], 0)
   fl_in_aag(.(E, X), R, s(Z)) -> U1_aag(E, X, R, Z, append_in_aaa(E, Y, R))
   append_in_aaa([], X, X) -> append_out_aaa([], X, X)
   append_in_aaa(.(X, Xs), Ys, .(X, Zs)) -> U3_aaa(X, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U3_aaa(X, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(X, Xs), Ys, .(X, Zs))
   U1_aag(E, X, R, Z, append_out_aaa(E, Y, R)) -> U2_aag(E, X, R, Z, fl_in_aag(X, Y, Z))
   U2_aag(E, X, R, Z, fl_out_aag(X, Y, Z)) -> fl_out_aag(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aag(x1, x2, x3)  =  fl_in_aag(x3)

0  =  0

fl_out_aag(x1, x2, x3)  =  fl_out_aag(x3)

s(x1)  =  s(x1)

U1_aag(x1, x2, x3, x4, x5)  =  U1_aag(x4, x5)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa

U3_aaa(x1, x2, x3, x4, x5)  =  U3_aaa(x5)

U2_aag(x1, x2, x3, x4, x5)  =  U2_aag(x4, x5)

FL_IN_AAG(x1, x2, x3)  =  FL_IN_AAG(x3)

U1_AAG(x1, x2, x3, x4, x5)  =  U1_AAG(x4, x5)

APPEND_IN_AAA(x1, x2, x3)  =  APPEND_IN_AAA

U3_AAA(x1, x2, x3, x4, x5)  =  U3_AAA(x5)

U2_AAG(x1, x2, x3, x4, x5)  =  U2_AAG(x4, x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(5) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 2 SCCs with 3 less nodes.
----------------------------------------

(6)
Complex Obligation (AND)

----------------------------------------

(7)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   APPEND_IN_AAA(.(X, Xs), Ys, .(X, Zs)) -> APPEND_IN_AAA(Xs, Ys, Zs)

The TRS R consists of the following rules:

   fl_in_aag([], [], 0) -> fl_out_aag([], [], 0)
   fl_in_aag(.(E, X), R, s(Z)) -> U1_aag(E, X, R, Z, append_in_aaa(E, Y, R))
   append_in_aaa([], X, X) -> append_out_aaa([], X, X)
   append_in_aaa(.(X, Xs), Ys, .(X, Zs)) -> U3_aaa(X, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U3_aaa(X, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(X, Xs), Ys, .(X, Zs))
   U1_aag(E, X, R, Z, append_out_aaa(E, Y, R)) -> U2_aag(E, X, R, Z, fl_in_aag(X, Y, Z))
   U2_aag(E, X, R, Z, fl_out_aag(X, Y, Z)) -> fl_out_aag(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aag(x1, x2, x3)  =  fl_in_aag(x3)

0  =  0

fl_out_aag(x1, x2, x3)  =  fl_out_aag(x3)

s(x1)  =  s(x1)

U1_aag(x1, x2, x3, x4, x5)  =  U1_aag(x4, x5)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa

U3_aaa(x1, x2, x3, x4, x5)  =  U3_aaa(x5)

U2_aag(x1, x2, x3, x4, x5)  =  U2_aag(x4, x5)

APPEND_IN_AAA(x1, x2, x3)  =  APPEND_IN_AAA


We have to consider all (P,R,Pi)-chains
----------------------------------------

(8) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(9)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   APPEND_IN_AAA(.(X, Xs), Ys, .(X, Zs)) -> APPEND_IN_AAA(Xs, Ys, Zs)

R is empty.
The argument filtering Pi contains the following mapping:
APPEND_IN_AAA(x1, x2, x3)  =  APPEND_IN_AAA


We have to consider all (P,R,Pi)-chains
----------------------------------------

(10) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(11)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   APPEND_IN_AAA -> APPEND_IN_AAA

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(12) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by semiunifying a rule from P directly.

s = APPEND_IN_AAA evaluates to  t =APPEND_IN_AAA

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

The DP semiunifies directly so there is only one rewrite step from APPEND_IN_AAA to APPEND_IN_AAA.




----------------------------------------

(13)
NO

----------------------------------------

(14)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_AAG(E, X, R, Z, append_out_aaa(E, Y, R)) -> FL_IN_AAG(X, Y, Z)
   FL_IN_AAG(.(E, X), R, s(Z)) -> U1_AAG(E, X, R, Z, append_in_aaa(E, Y, R))

The TRS R consists of the following rules:

   fl_in_aag([], [], 0) -> fl_out_aag([], [], 0)
   fl_in_aag(.(E, X), R, s(Z)) -> U1_aag(E, X, R, Z, append_in_aaa(E, Y, R))
   append_in_aaa([], X, X) -> append_out_aaa([], X, X)
   append_in_aaa(.(X, Xs), Ys, .(X, Zs)) -> U3_aaa(X, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U3_aaa(X, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(X, Xs), Ys, .(X, Zs))
   U1_aag(E, X, R, Z, append_out_aaa(E, Y, R)) -> U2_aag(E, X, R, Z, fl_in_aag(X, Y, Z))
   U2_aag(E, X, R, Z, fl_out_aag(X, Y, Z)) -> fl_out_aag(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aag(x1, x2, x3)  =  fl_in_aag(x3)

0  =  0

fl_out_aag(x1, x2, x3)  =  fl_out_aag(x3)

s(x1)  =  s(x1)

U1_aag(x1, x2, x3, x4, x5)  =  U1_aag(x4, x5)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa

U3_aaa(x1, x2, x3, x4, x5)  =  U3_aaa(x5)

U2_aag(x1, x2, x3, x4, x5)  =  U2_aag(x4, x5)

FL_IN_AAG(x1, x2, x3)  =  FL_IN_AAG(x3)

U1_AAG(x1, x2, x3, x4, x5)  =  U1_AAG(x4, x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(15) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(16)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_AAG(E, X, R, Z, append_out_aaa(E, Y, R)) -> FL_IN_AAG(X, Y, Z)
   FL_IN_AAG(.(E, X), R, s(Z)) -> U1_AAG(E, X, R, Z, append_in_aaa(E, Y, R))

The TRS R consists of the following rules:

   append_in_aaa([], X, X) -> append_out_aaa([], X, X)
   append_in_aaa(.(X, Xs), Ys, .(X, Zs)) -> U3_aaa(X, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U3_aaa(X, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(X, Xs), Ys, .(X, Zs))

The argument filtering Pi contains the following mapping:
s(x1)  =  s(x1)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa

U3_aaa(x1, x2, x3, x4, x5)  =  U3_aaa(x5)

FL_IN_AAG(x1, x2, x3)  =  FL_IN_AAG(x3)

U1_AAG(x1, x2, x3, x4, x5)  =  U1_AAG(x4, x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(17) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(18)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AAG(Z, append_out_aaa) -> FL_IN_AAG(Z)
   FL_IN_AAG(s(Z)) -> U1_AAG(Z, append_in_aaa)

The TRS R consists of the following rules:

   append_in_aaa -> append_out_aaa
   append_in_aaa -> U3_aaa(append_in_aaa)
   U3_aaa(append_out_aaa) -> append_out_aaa

The set Q consists of the following terms:

   append_in_aaa
   U3_aaa(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(19) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*FL_IN_AAG(s(Z)) -> U1_AAG(Z, append_in_aaa)
The graph contains the following edges 1 > 1


*U1_AAG(Z, append_out_aaa) -> FL_IN_AAG(Z)
The graph contains the following edges 1 >= 1


----------------------------------------

(20)
YES

----------------------------------------

(21) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

fl_in_3: (f,f,b)

append_in_3: (f,f,f)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   fl_in_aag([], [], 0) -> fl_out_aag([], [], 0)
   fl_in_aag(.(E, X), R, s(Z)) -> U1_aag(E, X, R, Z, append_in_aaa(E, Y, R))
   append_in_aaa([], X, X) -> append_out_aaa([], X, X)
   append_in_aaa(.(X, Xs), Ys, .(X, Zs)) -> U3_aaa(X, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U3_aaa(X, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(X, Xs), Ys, .(X, Zs))
   U1_aag(E, X, R, Z, append_out_aaa(E, Y, R)) -> U2_aag(E, X, R, Z, fl_in_aag(X, Y, Z))
   U2_aag(E, X, R, Z, fl_out_aag(X, Y, Z)) -> fl_out_aag(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aag(x1, x2, x3)  =  fl_in_aag(x3)

0  =  0

fl_out_aag(x1, x2, x3)  =  fl_out_aag

s(x1)  =  s(x1)

U1_aag(x1, x2, x3, x4, x5)  =  U1_aag(x4, x5)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa

U3_aaa(x1, x2, x3, x4, x5)  =  U3_aaa(x5)

U2_aag(x1, x2, x3, x4, x5)  =  U2_aag(x5)





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(22)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   fl_in_aag([], [], 0) -> fl_out_aag([], [], 0)
   fl_in_aag(.(E, X), R, s(Z)) -> U1_aag(E, X, R, Z, append_in_aaa(E, Y, R))
   append_in_aaa([], X, X) -> append_out_aaa([], X, X)
   append_in_aaa(.(X, Xs), Ys, .(X, Zs)) -> U3_aaa(X, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U3_aaa(X, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(X, Xs), Ys, .(X, Zs))
   U1_aag(E, X, R, Z, append_out_aaa(E, Y, R)) -> U2_aag(E, X, R, Z, fl_in_aag(X, Y, Z))
   U2_aag(E, X, R, Z, fl_out_aag(X, Y, Z)) -> fl_out_aag(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aag(x1, x2, x3)  =  fl_in_aag(x3)

0  =  0

fl_out_aag(x1, x2, x3)  =  fl_out_aag

s(x1)  =  s(x1)

U1_aag(x1, x2, x3, x4, x5)  =  U1_aag(x4, x5)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa

U3_aaa(x1, x2, x3, x4, x5)  =  U3_aaa(x5)

U2_aag(x1, x2, x3, x4, x5)  =  U2_aag(x5)



----------------------------------------

(23) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   FL_IN_AAG(.(E, X), R, s(Z)) -> U1_AAG(E, X, R, Z, append_in_aaa(E, Y, R))
   FL_IN_AAG(.(E, X), R, s(Z)) -> APPEND_IN_AAA(E, Y, R)
   APPEND_IN_AAA(.(X, Xs), Ys, .(X, Zs)) -> U3_AAA(X, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   APPEND_IN_AAA(.(X, Xs), Ys, .(X, Zs)) -> APPEND_IN_AAA(Xs, Ys, Zs)
   U1_AAG(E, X, R, Z, append_out_aaa(E, Y, R)) -> U2_AAG(E, X, R, Z, fl_in_aag(X, Y, Z))
   U1_AAG(E, X, R, Z, append_out_aaa(E, Y, R)) -> FL_IN_AAG(X, Y, Z)

The TRS R consists of the following rules:

   fl_in_aag([], [], 0) -> fl_out_aag([], [], 0)
   fl_in_aag(.(E, X), R, s(Z)) -> U1_aag(E, X, R, Z, append_in_aaa(E, Y, R))
   append_in_aaa([], X, X) -> append_out_aaa([], X, X)
   append_in_aaa(.(X, Xs), Ys, .(X, Zs)) -> U3_aaa(X, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U3_aaa(X, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(X, Xs), Ys, .(X, Zs))
   U1_aag(E, X, R, Z, append_out_aaa(E, Y, R)) -> U2_aag(E, X, R, Z, fl_in_aag(X, Y, Z))
   U2_aag(E, X, R, Z, fl_out_aag(X, Y, Z)) -> fl_out_aag(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aag(x1, x2, x3)  =  fl_in_aag(x3)

0  =  0

fl_out_aag(x1, x2, x3)  =  fl_out_aag

s(x1)  =  s(x1)

U1_aag(x1, x2, x3, x4, x5)  =  U1_aag(x4, x5)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa

U3_aaa(x1, x2, x3, x4, x5)  =  U3_aaa(x5)

U2_aag(x1, x2, x3, x4, x5)  =  U2_aag(x5)

FL_IN_AAG(x1, x2, x3)  =  FL_IN_AAG(x3)

U1_AAG(x1, x2, x3, x4, x5)  =  U1_AAG(x4, x5)

APPEND_IN_AAA(x1, x2, x3)  =  APPEND_IN_AAA

U3_AAA(x1, x2, x3, x4, x5)  =  U3_AAA(x5)

U2_AAG(x1, x2, x3, x4, x5)  =  U2_AAG(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(24)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   FL_IN_AAG(.(E, X), R, s(Z)) -> U1_AAG(E, X, R, Z, append_in_aaa(E, Y, R))
   FL_IN_AAG(.(E, X), R, s(Z)) -> APPEND_IN_AAA(E, Y, R)
   APPEND_IN_AAA(.(X, Xs), Ys, .(X, Zs)) -> U3_AAA(X, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   APPEND_IN_AAA(.(X, Xs), Ys, .(X, Zs)) -> APPEND_IN_AAA(Xs, Ys, Zs)
   U1_AAG(E, X, R, Z, append_out_aaa(E, Y, R)) -> U2_AAG(E, X, R, Z, fl_in_aag(X, Y, Z))
   U1_AAG(E, X, R, Z, append_out_aaa(E, Y, R)) -> FL_IN_AAG(X, Y, Z)

The TRS R consists of the following rules:

   fl_in_aag([], [], 0) -> fl_out_aag([], [], 0)
   fl_in_aag(.(E, X), R, s(Z)) -> U1_aag(E, X, R, Z, append_in_aaa(E, Y, R))
   append_in_aaa([], X, X) -> append_out_aaa([], X, X)
   append_in_aaa(.(X, Xs), Ys, .(X, Zs)) -> U3_aaa(X, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U3_aaa(X, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(X, Xs), Ys, .(X, Zs))
   U1_aag(E, X, R, Z, append_out_aaa(E, Y, R)) -> U2_aag(E, X, R, Z, fl_in_aag(X, Y, Z))
   U2_aag(E, X, R, Z, fl_out_aag(X, Y, Z)) -> fl_out_aag(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aag(x1, x2, x3)  =  fl_in_aag(x3)

0  =  0

fl_out_aag(x1, x2, x3)  =  fl_out_aag

s(x1)  =  s(x1)

U1_aag(x1, x2, x3, x4, x5)  =  U1_aag(x4, x5)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa

U3_aaa(x1, x2, x3, x4, x5)  =  U3_aaa(x5)

U2_aag(x1, x2, x3, x4, x5)  =  U2_aag(x5)

FL_IN_AAG(x1, x2, x3)  =  FL_IN_AAG(x3)

U1_AAG(x1, x2, x3, x4, x5)  =  U1_AAG(x4, x5)

APPEND_IN_AAA(x1, x2, x3)  =  APPEND_IN_AAA

U3_AAA(x1, x2, x3, x4, x5)  =  U3_AAA(x5)

U2_AAG(x1, x2, x3, x4, x5)  =  U2_AAG(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(25) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 2 SCCs with 3 less nodes.
----------------------------------------

(26)
Complex Obligation (AND)

----------------------------------------

(27)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   APPEND_IN_AAA(.(X, Xs), Ys, .(X, Zs)) -> APPEND_IN_AAA(Xs, Ys, Zs)

The TRS R consists of the following rules:

   fl_in_aag([], [], 0) -> fl_out_aag([], [], 0)
   fl_in_aag(.(E, X), R, s(Z)) -> U1_aag(E, X, R, Z, append_in_aaa(E, Y, R))
   append_in_aaa([], X, X) -> append_out_aaa([], X, X)
   append_in_aaa(.(X, Xs), Ys, .(X, Zs)) -> U3_aaa(X, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U3_aaa(X, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(X, Xs), Ys, .(X, Zs))
   U1_aag(E, X, R, Z, append_out_aaa(E, Y, R)) -> U2_aag(E, X, R, Z, fl_in_aag(X, Y, Z))
   U2_aag(E, X, R, Z, fl_out_aag(X, Y, Z)) -> fl_out_aag(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aag(x1, x2, x3)  =  fl_in_aag(x3)

0  =  0

fl_out_aag(x1, x2, x3)  =  fl_out_aag

s(x1)  =  s(x1)

U1_aag(x1, x2, x3, x4, x5)  =  U1_aag(x4, x5)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa

U3_aaa(x1, x2, x3, x4, x5)  =  U3_aaa(x5)

U2_aag(x1, x2, x3, x4, x5)  =  U2_aag(x5)

APPEND_IN_AAA(x1, x2, x3)  =  APPEND_IN_AAA


We have to consider all (P,R,Pi)-chains
----------------------------------------

(28) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(29)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   APPEND_IN_AAA(.(X, Xs), Ys, .(X, Zs)) -> APPEND_IN_AAA(Xs, Ys, Zs)

R is empty.
The argument filtering Pi contains the following mapping:
APPEND_IN_AAA(x1, x2, x3)  =  APPEND_IN_AAA


We have to consider all (P,R,Pi)-chains
----------------------------------------

(30) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(31)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   APPEND_IN_AAA -> APPEND_IN_AAA

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(32) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by semiunifying a rule from P directly.

s = APPEND_IN_AAA evaluates to  t =APPEND_IN_AAA

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

The DP semiunifies directly so there is only one rewrite step from APPEND_IN_AAA to APPEND_IN_AAA.




----------------------------------------

(33)
NO

----------------------------------------

(34)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_AAG(E, X, R, Z, append_out_aaa(E, Y, R)) -> FL_IN_AAG(X, Y, Z)
   FL_IN_AAG(.(E, X), R, s(Z)) -> U1_AAG(E, X, R, Z, append_in_aaa(E, Y, R))

The TRS R consists of the following rules:

   fl_in_aag([], [], 0) -> fl_out_aag([], [], 0)
   fl_in_aag(.(E, X), R, s(Z)) -> U1_aag(E, X, R, Z, append_in_aaa(E, Y, R))
   append_in_aaa([], X, X) -> append_out_aaa([], X, X)
   append_in_aaa(.(X, Xs), Ys, .(X, Zs)) -> U3_aaa(X, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U3_aaa(X, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(X, Xs), Ys, .(X, Zs))
   U1_aag(E, X, R, Z, append_out_aaa(E, Y, R)) -> U2_aag(E, X, R, Z, fl_in_aag(X, Y, Z))
   U2_aag(E, X, R, Z, fl_out_aag(X, Y, Z)) -> fl_out_aag(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aag(x1, x2, x3)  =  fl_in_aag(x3)

0  =  0

fl_out_aag(x1, x2, x3)  =  fl_out_aag

s(x1)  =  s(x1)

U1_aag(x1, x2, x3, x4, x5)  =  U1_aag(x4, x5)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa

U3_aaa(x1, x2, x3, x4, x5)  =  U3_aaa(x5)

U2_aag(x1, x2, x3, x4, x5)  =  U2_aag(x5)

FL_IN_AAG(x1, x2, x3)  =  FL_IN_AAG(x3)

U1_AAG(x1, x2, x3, x4, x5)  =  U1_AAG(x4, x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(35) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(36)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_AAG(E, X, R, Z, append_out_aaa(E, Y, R)) -> FL_IN_AAG(X, Y, Z)
   FL_IN_AAG(.(E, X), R, s(Z)) -> U1_AAG(E, X, R, Z, append_in_aaa(E, Y, R))

The TRS R consists of the following rules:

   append_in_aaa([], X, X) -> append_out_aaa([], X, X)
   append_in_aaa(.(X, Xs), Ys, .(X, Zs)) -> U3_aaa(X, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U3_aaa(X, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(X, Xs), Ys, .(X, Zs))

The argument filtering Pi contains the following mapping:
s(x1)  =  s(x1)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa

U3_aaa(x1, x2, x3, x4, x5)  =  U3_aaa(x5)

FL_IN_AAG(x1, x2, x3)  =  FL_IN_AAG(x3)

U1_AAG(x1, x2, x3, x4, x5)  =  U1_AAG(x4, x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(37) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(38)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AAG(Z, append_out_aaa) -> FL_IN_AAG(Z)
   FL_IN_AAG(s(Z)) -> U1_AAG(Z, append_in_aaa)

The TRS R consists of the following rules:

   append_in_aaa -> append_out_aaa
   append_in_aaa -> U3_aaa(append_in_aaa)
   U3_aaa(append_out_aaa) -> append_out_aaa

The set Q consists of the following terms:

   append_in_aaa
   U3_aaa(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(39) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*FL_IN_AAG(s(Z)) -> U1_AAG(Z, append_in_aaa)
The graph contains the following edges 1 > 1


*U1_AAG(Z, append_out_aaa) -> FL_IN_AAG(Z)
The graph contains the following edges 1 >= 1


----------------------------------------

(40)
YES

----------------------------------------

(41) PrologToTRSTransformerProof (SOUND)
Transformed Prolog program to TRS.

{
    "root": 5,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(fl ([]) ([]) (0))",
                null
            ],
            [
                "(fl (. E X) R (s Z))",
                "(',' (append E Y R) (fl X Y Z))"
            ],
            [
                "(append ([]) X X)",
                null
            ],
            [
                "(append (. X Xs) Ys (. X Zs))",
                "(append Xs Ys Zs)"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "19": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "250": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "240": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(append T16 X14 T17)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": ["X14"],
                    "exprvars": []
                }
            },
            "120": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "241": {
                "goal": [{
                    "clause": 3,
                    "scope": 2,
                    "term": "(append T16 X14 T17)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": ["X14"],
                    "exprvars": []
                }
            },
            "242": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "245": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "246": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "5": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(fl T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T3"],
                    "free": [],
                    "exprvars": []
                }
            },
            "6": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 1,
                        "term": "(fl T1 T2 T3)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(fl T1 T2 T3)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T3"],
                    "free": [],
                    "exprvars": []
                }
            },
            "237": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(append T16 X14 T17)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": ["X14"],
                    "exprvars": []
                }
            },
            "7": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(fl T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T3"],
                    "free": [],
                    "exprvars": []
                }
            },
            "238": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(fl T22 T21 T15)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T15"],
                    "free": [],
                    "exprvars": []
                }
            },
            "249": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(append T39 X47 T40)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": ["X47"],
                    "exprvars": []
                }
            },
            "239": {
                "goal": [
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(append T16 X14 T17)"
                    },
                    {
                        "clause": 3,
                        "scope": 2,
                        "term": "(append T16 X14 T17)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": ["X14"],
                    "exprvars": []
                }
            },
            "9": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(fl T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T3"],
                    "free": [],
                    "exprvars": []
                }
            },
            "119": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (append T16 X14 T17) (fl T18 X14 T15))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T15"],
                    "free": ["X14"],
                    "exprvars": []
                }
            },
            "20": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "21": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 5,
                "to": 6,
                "label": "CASE"
            },
            {
                "from": 6,
                "to": 7,
                "label": "PARALLEL"
            },
            {
                "from": 6,
                "to": 9,
                "label": "PARALLEL"
            },
            {
                "from": 7,
                "to": 19,
                "label": "EVAL with clause\nfl([], [], 0).\nand substitutionT1 -> [],\nT2 -> [],\nT3 -> 0"
            },
            {
                "from": 7,
                "to": 20,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 9,
                "to": 119,
                "label": "EVAL with clause\nfl(.(X10, X11), X12, s(X13)) :- ','(append(X10, X14, X12), fl(X11, X14, X13)).\nand substitutionX10 -> T16,\nX11 -> T18,\nT1 -> .(T16, T18),\nT2 -> T17,\nX12 -> T17,\nX13 -> T15,\nT3 -> s(T15),\nT12 -> T16,\nT14 -> T17,\nT13 -> T18"
            },
            {
                "from": 9,
                "to": 120,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 19,
                "to": 21,
                "label": "SUCCESS"
            },
            {
                "from": 119,
                "to": 237,
                "label": "SPLIT 1"
            },
            {
                "from": 119,
                "to": 238,
                "label": "SPLIT 2\nreplacements:X14 -> T21,\nT18 -> T22"
            },
            {
                "from": 237,
                "to": 239,
                "label": "CASE"
            },
            {
                "from": 238,
                "to": 5,
                "label": "INSTANCE with matching:\nT1 -> T22\nT2 -> T21\nT3 -> T15"
            },
            {
                "from": 239,
                "to": 240,
                "label": "PARALLEL"
            },
            {
                "from": 239,
                "to": 241,
                "label": "PARALLEL"
            },
            {
                "from": 240,
                "to": 242,
                "label": "EVAL with clause\nappend([], X31, X31).\nand substitutionT16 -> [],\nX14 -> T29,\nX31 -> T29,\nT17 -> T29,\nX32 -> T29"
            },
            {
                "from": 240,
                "to": 245,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 241,
                "to": 249,
                "label": "EVAL with clause\nappend(.(X43, X44), X45, .(X43, X46)) :- append(X44, X45, X46).\nand substitutionX43 -> T36,\nX44 -> T39,\nT16 -> .(T36, T39),\nX14 -> X47,\nX45 -> X47,\nX46 -> T40,\nT17 -> .(T36, T40),\nT37 -> T39,\nT38 -> T40"
            },
            {
                "from": 241,
                "to": 250,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 242,
                "to": 246,
                "label": "SUCCESS"
            },
            {
                "from": 249,
                "to": 237,
                "label": "INSTANCE with matching:\nT16 -> T39\nX14 -> X47\nT17 -> T40"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(42)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f5_in(0) -> f5_out1
   f5_in(s(T15)) -> U1(f119_in(T15), s(T15))
   U1(f119_out1, s(T15)) -> f5_out1
   f237_in -> f237_out1
   f237_in -> U2(f237_in)
   U2(f237_out1) -> f237_out1
   f119_in(T15) -> U3(f237_in, T15)
   U3(f237_out1, T15) -> U4(f5_in(T15), T15)
   U4(f5_out1, T15) -> f119_out1

Q is empty.

----------------------------------------

(43) QTRSRRRProof (EQUIVALENT)
Used ordering:
f5_in/1(YES)
0/0)
f5_out1/0)
s/1(YES)
U1/2(YES,YES)
f119_in/1(YES)
f119_out1/0)
f237_in/0)
f237_out1/0)
U2/1)YES(
U3/2(YES,YES)
U4/2(YES,YES)

Quasi precedence:
0 > f5_out1 > f119_out1 > [U1_2, U4_2]
s_1 > f5_out1 > f119_out1 > [U1_2, U4_2]
s_1 > f119_in_1 > [f237_in, f237_out1] > [f5_in_1, U3_2] > [U1_2, U4_2]


Status:
f5_in_1: multiset status
0: multiset status
f5_out1: multiset status
s_1: [1]
U1_2: multiset status
f119_in_1: multiset status
f119_out1: multiset status
f237_in: multiset status
f237_out1: multiset status
U3_2: multiset status
U4_2: [2,1]

With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   f5_in(0) -> f5_out1
   f5_in(s(T15)) -> U1(f119_in(T15), s(T15))
   U1(f119_out1, s(T15)) -> f5_out1
   f119_in(T15) -> U3(f237_in, T15)
   U3(f237_out1, T15) -> U4(f5_in(T15), T15)
   U4(f5_out1, T15) -> f119_out1




----------------------------------------

(44)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f237_in -> f237_out1
   f237_in -> U2(f237_in)
   U2(f237_out1) -> f237_out1

Q is empty.

----------------------------------------

(45) QTRSRRRProof (EQUIVALENT)
Used ordering:
f237_in/0)
f237_out1/0)
U2/1)YES(

Quasi precedence:
f237_in > f237_out1


Status:
f237_in: multiset status
f237_out1: multiset status

With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   f237_in -> f237_out1




----------------------------------------

(46)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f237_in -> U2(f237_in)
   U2(f237_out1) -> f237_out1

Q is empty.

----------------------------------------

(47) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(U2(x_1)) = 2*x_1
   POL(f237_in) = 0
   POL(f237_out1) = 1
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   U2(f237_out1) -> f237_out1




----------------------------------------

(48)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f237_in -> U2(f237_in)

Q is empty.

----------------------------------------

(49) Overlay + Local Confluence (EQUIVALENT)
The TRS is overlay and locally confluent. By [NOC] we can switch to innermost.
----------------------------------------

(50)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f237_in -> U2(f237_in)

The set Q consists of the following terms:

   f237_in


----------------------------------------

(51) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(52)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F237_IN -> F237_IN

The TRS R consists of the following rules:

   f237_in -> U2(f237_in)

The set Q consists of the following terms:

   f237_in

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(53) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(54)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F237_IN -> F237_IN

R is empty.
The set Q consists of the following terms:

   f237_in

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(55) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   f237_in


----------------------------------------

(56)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F237_IN -> F237_IN

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(57) PrologToDTProblemTransformerProof (SOUND)
Built DT problem from termination graph DT10.

{
    "root": 1,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(fl ([]) ([]) (0))",
                null
            ],
            [
                "(fl (. E X) R (s Z))",
                "(',' (append E Y R) (fl X Y Z))"
            ],
            [
                "(append ([]) X X)",
                null
            ],
            [
                "(append (. X Xs) Ys (. X Zs))",
                "(append Xs Ys Zs)"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "type": "Nodes",
            "1": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(fl T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T3"],
                    "free": [],
                    "exprvars": []
                }
            },
            "2": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 1,
                        "term": "(fl T1 T2 T3)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(fl T1 T2 T3)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T3"],
                    "free": [],
                    "exprvars": []
                }
            },
            "112": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (append T15 X13 T16) (fl T17 X13 T14))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": ["X13"],
                    "exprvars": []
                }
            },
            "113": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "114": {
                "goal": [
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(',' (append T15 X13 T16) (fl T17 X13 T14))"
                    },
                    {
                        "clause": 3,
                        "scope": 2,
                        "term": "(',' (append T15 X13 T16) (fl T17 X13 T14))"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": ["X13"],
                    "exprvars": []
                }
            },
            "115": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(',' (append T15 X13 T16) (fl T17 X13 T14))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": ["X13"],
                    "exprvars": []
                }
            },
            "247": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (append T34 X38 T35) (fl T36 X38 T14))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": ["X38"],
                    "exprvars": []
                }
            },
            "116": {
                "goal": [{
                    "clause": 3,
                    "scope": 2,
                    "term": "(',' (append T15 X13 T16) (fl T17 X13 T14))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": ["X13"],
                    "exprvars": []
                }
            },
            "248": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "117": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(fl T23 T24 T14)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": [],
                    "exprvars": []
                }
            },
            "91": {
                "goal": [
                    {
                        "clause": -1,
                        "scope": -1,
                        "term": "(true)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(fl T1 T2 (0))"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "118": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "94": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(fl T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [[
                        "(fl T1 T2 T3)",
                        "(fl ([]) ([]) (0))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T3"],
                    "free": [],
                    "exprvars": []
                }
            },
            "96": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(fl T1 T2 (0))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "97": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 1,
                "to": 2,
                "label": "CASE"
            },
            {
                "from": 2,
                "to": 91,
                "label": "EVAL with clause\nfl([], [], 0).\nand substitutionT1 -> [],\nT2 -> [],\nT3 -> 0"
            },
            {
                "from": 2,
                "to": 94,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 91,
                "to": 96,
                "label": "SUCCESS"
            },
            {
                "from": 94,
                "to": 112,
                "label": "EVAL with clause\nfl(.(X9, X10), X11, s(X12)) :- ','(append(X9, X13, X11), fl(X10, X13, X12)).\nand substitutionX9 -> T15,\nX10 -> T17,\nT1 -> .(T15, T17),\nT2 -> T16,\nX11 -> T16,\nX12 -> T14,\nT3 -> s(T14),\nT11 -> T15,\nT13 -> T16,\nT12 -> T17"
            },
            {
                "from": 94,
                "to": 113,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 96,
                "to": 97,
                "label": "BACKTRACK\nfor clause: fl(.(E, X), R, s(Z)) :- ','(append(E, Y, R), fl(X, Y, Z))because of non-unification"
            },
            {
                "from": 112,
                "to": 114,
                "label": "CASE"
            },
            {
                "from": 114,
                "to": 115,
                "label": "PARALLEL"
            },
            {
                "from": 114,
                "to": 116,
                "label": "PARALLEL"
            },
            {
                "from": 115,
                "to": 117,
                "label": "EVAL with clause\nappend([], X22, X22).\nand substitutionT15 -> [],\nX13 -> T24,\nX22 -> T24,\nT16 -> T24,\nX23 -> T24,\nT17 -> T23,\nT22 -> T24"
            },
            {
                "from": 115,
                "to": 118,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 116,
                "to": 247,
                "label": "EVAL with clause\nappend(.(X34, X35), X36, .(X34, X37)) :- append(X35, X36, X37).\nand substitutionX34 -> T31,\nX35 -> T34,\nT15 -> .(T31, T34),\nX13 -> X38,\nX36 -> X38,\nX37 -> T35,\nT16 -> .(T31, T35),\nT32 -> T34,\nT33 -> T35,\nT17 -> T36"
            },
            {
                "from": 116,
                "to": 248,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 117,
                "to": 1,
                "label": "INSTANCE with matching:\nT1 -> T23\nT2 -> T24\nT3 -> T14"
            },
            {
                "from": 247,
                "to": 112,
                "label": "INSTANCE with matching:\nT15 -> T34\nX13 -> X38\nT16 -> T35\nT17 -> T36"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(58)
Obligation:
Triples:

pB([], X1, X1, X2, X3) :- flA(X2, X1, X3).
pB(.(X1, X2), X3, .(X1, X4), X5, X6) :- pB(X2, X3, X4, X5, X6).
flA(.(X1, X2), X3, s(X4)) :- pB(X1, X5, X3, X2, X4).

Clauses:

flcA([], [], 0).
flcA(.(X1, X2), X3, s(X4)) :- qcB(X1, X5, X3, X2, X4).
qcB([], X1, X1, X2, X3) :- flcA(X2, X1, X3).
qcB(.(X1, X2), X3, .(X1, X4), X5, X6) :- qcB(X2, X3, X4, X5, X6).

Afs:

flA(x1, x2, x3)  =  flA(x3)


----------------------------------------

(59) TriplesToPiDPProof (SOUND)
We use the technique of [DT09]. With regard to the inferred argument filtering the predicates were used in the following modes:

flA_in_3: (f,f,b)

pB_in_5: (f,f,f,f,b)

Transforming TRIPLES into the following Term Rewriting System:

Pi DP problem:
The TRS P consists of the following rules:

   FLA_IN_AAG(.(X1, X2), X3, s(X4)) -> U3_AAG(X1, X2, X3, X4, pB_in_aaaag(X1, X5, X3, X2, X4))
   FLA_IN_AAG(.(X1, X2), X3, s(X4)) -> PB_IN_AAAAG(X1, X5, X3, X2, X4)
   PB_IN_AAAAG([], X1, X1, X2, X3) -> U1_AAAAG(X1, X2, X3, flA_in_aag(X2, X1, X3))
   PB_IN_AAAAG([], X1, X1, X2, X3) -> FLA_IN_AAG(X2, X1, X3)
   PB_IN_AAAAG(.(X1, X2), X3, .(X1, X4), X5, X6) -> U2_AAAAG(X1, X2, X3, X4, X5, X6, pB_in_aaaag(X2, X3, X4, X5, X6))
   PB_IN_AAAAG(.(X1, X2), X3, .(X1, X4), X5, X6) -> PB_IN_AAAAG(X2, X3, X4, X5, X6)

R is empty.
The argument filtering Pi contains the following mapping:
flA_in_aag(x1, x2, x3)  =  flA_in_aag(x3)

s(x1)  =  s(x1)

pB_in_aaaag(x1, x2, x3, x4, x5)  =  pB_in_aaaag(x5)

FLA_IN_AAG(x1, x2, x3)  =  FLA_IN_AAG(x3)

U3_AAG(x1, x2, x3, x4, x5)  =  U3_AAG(x4, x5)

PB_IN_AAAAG(x1, x2, x3, x4, x5)  =  PB_IN_AAAAG(x5)

U1_AAAAG(x1, x2, x3, x4)  =  U1_AAAAG(x3, x4)

U2_AAAAG(x1, x2, x3, x4, x5, x6, x7)  =  U2_AAAAG(x6, x7)


We have to consider all (P,R,Pi)-chains


Infinitary Constructor Rewriting Termination of PiDP implies Termination of TRIPLES



----------------------------------------

(60)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   FLA_IN_AAG(.(X1, X2), X3, s(X4)) -> U3_AAG(X1, X2, X3, X4, pB_in_aaaag(X1, X5, X3, X2, X4))
   FLA_IN_AAG(.(X1, X2), X3, s(X4)) -> PB_IN_AAAAG(X1, X5, X3, X2, X4)
   PB_IN_AAAAG([], X1, X1, X2, X3) -> U1_AAAAG(X1, X2, X3, flA_in_aag(X2, X1, X3))
   PB_IN_AAAAG([], X1, X1, X2, X3) -> FLA_IN_AAG(X2, X1, X3)
   PB_IN_AAAAG(.(X1, X2), X3, .(X1, X4), X5, X6) -> U2_AAAAG(X1, X2, X3, X4, X5, X6, pB_in_aaaag(X2, X3, X4, X5, X6))
   PB_IN_AAAAG(.(X1, X2), X3, .(X1, X4), X5, X6) -> PB_IN_AAAAG(X2, X3, X4, X5, X6)

R is empty.
The argument filtering Pi contains the following mapping:
flA_in_aag(x1, x2, x3)  =  flA_in_aag(x3)

s(x1)  =  s(x1)

pB_in_aaaag(x1, x2, x3, x4, x5)  =  pB_in_aaaag(x5)

FLA_IN_AAG(x1, x2, x3)  =  FLA_IN_AAG(x3)

U3_AAG(x1, x2, x3, x4, x5)  =  U3_AAG(x4, x5)

PB_IN_AAAAG(x1, x2, x3, x4, x5)  =  PB_IN_AAAAG(x5)

U1_AAAAG(x1, x2, x3, x4)  =  U1_AAAAG(x3, x4)

U2_AAAAG(x1, x2, x3, x4, x5, x6, x7)  =  U2_AAAAG(x6, x7)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(61) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 3 less nodes.
----------------------------------------

(62)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   FLA_IN_AAG(.(X1, X2), X3, s(X4)) -> PB_IN_AAAAG(X1, X5, X3, X2, X4)
   PB_IN_AAAAG([], X1, X1, X2, X3) -> FLA_IN_AAG(X2, X1, X3)
   PB_IN_AAAAG(.(X1, X2), X3, .(X1, X4), X5, X6) -> PB_IN_AAAAG(X2, X3, X4, X5, X6)

R is empty.
The argument filtering Pi contains the following mapping:
s(x1)  =  s(x1)

FLA_IN_AAG(x1, x2, x3)  =  FLA_IN_AAG(x3)

PB_IN_AAAAG(x1, x2, x3, x4, x5)  =  PB_IN_AAAAG(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(63) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(64)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   FLA_IN_AAG(s(X4)) -> PB_IN_AAAAG(X4)
   PB_IN_AAAAG(X3) -> FLA_IN_AAG(X3)
   PB_IN_AAAAG(X6) -> PB_IN_AAAAG(X6)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(65) UsableRulesReductionPairsProof (EQUIVALENT)
By using the usable rules with reduction pair processor [LPAR04] with a polynomial ordering [POLO], all dependency pairs and the corresponding usable rules [FROCOS05] can be oriented non-strictly. All non-usable rules are removed, and those dependency pairs and usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

The following dependency pairs can be deleted:

   FLA_IN_AAG(s(X4)) -> PB_IN_AAAAG(X4)
No rules are removed from R.

Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(FLA_IN_AAG(x_1)) = 2 + x_1
   POL(PB_IN_AAAAG(x_1)) = 2 + x_1
   POL(s(x_1)) = 2 + 2*x_1


----------------------------------------

(66)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PB_IN_AAAAG(X3) -> FLA_IN_AAG(X3)
   PB_IN_AAAAG(X6) -> PB_IN_AAAAG(X6)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(67) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(68)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PB_IN_AAAAG(X6) -> PB_IN_AAAAG(X6)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(69) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by semiunifying a rule from P directly.

s = PB_IN_AAAAG(X6) evaluates to  t =PB_IN_AAAAG(X6)

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

The DP semiunifies directly so there is only one rewrite step from PB_IN_AAAAG(X6) to PB_IN_AAAAG(X6).




----------------------------------------

(70)
NO

----------------------------------------

(71) PrologToIRSwTTransformerProof (SOUND)
Transformed Prolog program to IRSwT according to method in Master Thesis of A. Weinert

{
    "root": 3,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(fl ([]) ([]) (0))",
                null
            ],
            [
                "(fl (. E X) R (s Z))",
                "(',' (append E Y R) (fl X Y Z))"
            ],
            [
                "(append ([]) X X)",
                null
            ],
            [
                "(append (. X Xs) Ys (. X Zs))",
                "(append Xs Ys Zs)"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "33": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "88": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "121": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(append T16 X14 T17)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": ["X14"],
                    "exprvars": []
                }
            },
            "132": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "122": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(fl T22 T21 T15)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T15"],
                    "free": [],
                    "exprvars": []
                }
            },
            "133": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "243": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(append T39 X47 T40)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": ["X47"],
                    "exprvars": []
                }
            },
            "123": {
                "goal": [
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(append T16 X14 T17)"
                    },
                    {
                        "clause": 3,
                        "scope": 2,
                        "term": "(append T16 X14 T17)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": ["X14"],
                    "exprvars": []
                }
            },
            "134": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "244": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "3": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(fl T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T3"],
                    "free": [],
                    "exprvars": []
                }
            },
            "124": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(append T16 X14 T17)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": ["X14"],
                    "exprvars": []
                }
            },
            "4": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 1,
                        "term": "(fl T1 T2 T3)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(fl T1 T2 T3)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T3"],
                    "free": [],
                    "exprvars": []
                }
            },
            "125": {
                "goal": [{
                    "clause": 3,
                    "scope": 2,
                    "term": "(append T16 X14 T17)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": ["X14"],
                    "exprvars": []
                }
            },
            "8": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(fl T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T3"],
                    "free": [],
                    "exprvars": []
                }
            },
            "31": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "10": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(fl T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T3"],
                    "free": [],
                    "exprvars": []
                }
            },
            "32": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "87": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (append T16 X14 T17) (fl T18 X14 T15))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T15"],
                    "free": ["X14"],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 3,
                "to": 4,
                "label": "CASE"
            },
            {
                "from": 4,
                "to": 8,
                "label": "PARALLEL"
            },
            {
                "from": 4,
                "to": 10,
                "label": "PARALLEL"
            },
            {
                "from": 8,
                "to": 31,
                "label": "EVAL with clause\nfl([], [], 0).\nand substitutionT1 -> [],\nT2 -> [],\nT3 -> 0"
            },
            {
                "from": 8,
                "to": 32,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 10,
                "to": 87,
                "label": "EVAL with clause\nfl(.(X10, X11), X12, s(X13)) :- ','(append(X10, X14, X12), fl(X11, X14, X13)).\nand substitutionX10 -> T16,\nX11 -> T18,\nT1 -> .(T16, T18),\nT2 -> T17,\nX12 -> T17,\nX13 -> T15,\nT3 -> s(T15),\nT12 -> T16,\nT14 -> T17,\nT13 -> T18"
            },
            {
                "from": 10,
                "to": 88,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 31,
                "to": 33,
                "label": "SUCCESS"
            },
            {
                "from": 87,
                "to": 121,
                "label": "SPLIT 1"
            },
            {
                "from": 87,
                "to": 122,
                "label": "SPLIT 2\nreplacements:X14 -> T21,\nT18 -> T22"
            },
            {
                "from": 121,
                "to": 123,
                "label": "CASE"
            },
            {
                "from": 122,
                "to": 3,
                "label": "INSTANCE with matching:\nT1 -> T22\nT2 -> T21\nT3 -> T15"
            },
            {
                "from": 123,
                "to": 124,
                "label": "PARALLEL"
            },
            {
                "from": 123,
                "to": 125,
                "label": "PARALLEL"
            },
            {
                "from": 124,
                "to": 132,
                "label": "EVAL with clause\nappend([], X31, X31).\nand substitutionT16 -> [],\nX14 -> T29,\nX31 -> T29,\nT17 -> T29,\nX32 -> T29"
            },
            {
                "from": 124,
                "to": 133,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 125,
                "to": 243,
                "label": "EVAL with clause\nappend(.(X43, X44), X45, .(X43, X46)) :- append(X44, X45, X46).\nand substitutionX43 -> T36,\nX44 -> T39,\nT16 -> .(T36, T39),\nX14 -> X47,\nX45 -> X47,\nX46 -> T40,\nT17 -> .(T36, T40),\nT37 -> T39,\nT38 -> T40"
            },
            {
                "from": 125,
                "to": 244,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 132,
                "to": 134,
                "label": "SUCCESS"
            },
            {
                "from": 243,
                "to": 121,
                "label": "INSTANCE with matching:\nT16 -> T39\nX14 -> X47\nT17 -> T40"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(72)
Complex Obligation (AND)

----------------------------------------

(73)
Obligation:
Rules:
f123_out -> f121_out :|: TRUE
f121_in -> f123_in :|: TRUE
f243_in -> f121_in :|: TRUE
f121_out -> f243_out :|: TRUE
f123_in -> f124_in :|: TRUE
f124_out -> f123_out :|: TRUE
f123_in -> f125_in :|: TRUE
f125_out -> f123_out :|: TRUE
f125_in -> f244_in :|: TRUE
f243_out -> f125_out :|: TRUE
f244_out -> f125_out :|: TRUE
f125_in -> f243_in :|: TRUE
f4_out(T3) -> f3_out(T3) :|: TRUE
f3_in(x) -> f4_in(x) :|: TRUE
f4_in(x1) -> f10_in(x1) :|: TRUE
f10_out(x2) -> f4_out(x2) :|: TRUE
f4_in(x3) -> f8_in(x3) :|: TRUE
f8_out(x4) -> f4_out(x4) :|: TRUE
f10_in(x5) -> f88_in :|: TRUE
f10_in(s(T15)) -> f87_in(T15) :|: TRUE
f87_out(x6) -> f10_out(s(x6)) :|: TRUE
f88_out -> f10_out(x7) :|: TRUE
f87_in(x8) -> f121_in :|: TRUE
f121_out -> f122_in(x9) :|: TRUE
f122_out(x10) -> f87_out(x10) :|: TRUE
Start term: f3_in(T3)

----------------------------------------

(74) IRSwTSimpleDependencyGraphProof (EQUIVALENT)
Constructed simple dependency graph.

Simplified to the following IRSwTs:

intTRSProblem:
f121_in -> f123_in :|: TRUE
f243_in -> f121_in :|: TRUE
f123_in -> f125_in :|: TRUE
f125_in -> f243_in :|: TRUE


----------------------------------------

(75)
Obligation:
Rules:
f121_in -> f123_in :|: TRUE
f243_in -> f121_in :|: TRUE
f123_in -> f125_in :|: TRUE
f125_in -> f243_in :|: TRUE

----------------------------------------

(76) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(77)
Obligation:
Rules:
f243_in -> f243_in :|: TRUE

----------------------------------------

(78) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(79)
Obligation:
Rules:
f243_in -> f243_in :|: TRUE

----------------------------------------

(80) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f243_in -> f243_in :|: TRUE

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(81)
Obligation:

Termination digraph:
Nodes:
(1) f243_in -> f243_in :|: TRUE

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(82) FilterProof (EQUIVALENT)
Used the following sort dictionary for filtering: 
f243_in()
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(83)
Obligation:
Rules:
f243_in -> f243_in :|: TRUE

----------------------------------------

(84) IntTRSNonPeriodicNontermProof (COMPLETE)
Normalized system to the following form:
f(pc) -> f(1) :|: pc = 1 && TRUE
Proved unsatisfiability of the following formula, indicating that the system is never left after entering:
((run2_0 = ((1 * 1)) and (((run1_0 * 1)) = ((1 * 1)) and T)) and !(((run2_0 * 1)) = ((1 * 1)) and T))
Proved satisfiability of the following formula, indicating that the system is entered at least once:
(run2_0 = ((1 * 1)) and (((run1_0 * 1)) = ((1 * 1)) and T))

----------------------------------------

(85)
NO

----------------------------------------

(86)
Obligation:
Rules:
f124_in -> f133_in :|: TRUE
f124_in -> f132_in :|: TRUE
f132_out -> f124_out :|: TRUE
f133_out -> f124_out :|: TRUE
f123_out -> f121_out :|: TRUE
f121_in -> f123_in :|: TRUE
f243_in -> f121_in :|: TRUE
f121_out -> f243_out :|: TRUE
f123_in -> f124_in :|: TRUE
f124_out -> f123_out :|: TRUE
f123_in -> f125_in :|: TRUE
f125_out -> f123_out :|: TRUE
f10_in(T3) -> f88_in :|: TRUE
f10_in(s(T15)) -> f87_in(T15) :|: TRUE
f87_out(x) -> f10_out(s(x)) :|: TRUE
f88_out -> f10_out(x1) :|: TRUE
f3_out(x2) -> f122_out(x2) :|: TRUE
f122_in(x3) -> f3_in(x3) :|: TRUE
f132_in -> f132_out :|: TRUE
f4_out(x4) -> f3_out(x4) :|: TRUE
f3_in(x5) -> f4_in(x5) :|: TRUE
f4_in(x6) -> f10_in(x6) :|: TRUE
f10_out(x7) -> f4_out(x7) :|: TRUE
f4_in(x8) -> f8_in(x8) :|: TRUE
f8_out(x9) -> f4_out(x9) :|: TRUE
f87_in(x10) -> f121_in :|: TRUE
f121_out -> f122_in(x11) :|: TRUE
f122_out(x12) -> f87_out(x12) :|: TRUE
f125_in -> f244_in :|: TRUE
f243_out -> f125_out :|: TRUE
f244_out -> f125_out :|: TRUE
f125_in -> f243_in :|: TRUE
Start term: f3_in(T3)

----------------------------------------

(87) IRSwTSimpleDependencyGraphProof (EQUIVALENT)
Constructed simple dependency graph.

Simplified to the following IRSwTs:

intTRSProblem:
f124_in -> f132_in :|: TRUE
f132_out -> f124_out :|: TRUE
f123_out -> f121_out :|: TRUE
f121_in -> f123_in :|: TRUE
f243_in -> f121_in :|: TRUE
f121_out -> f243_out :|: TRUE
f123_in -> f124_in :|: TRUE
f124_out -> f123_out :|: TRUE
f123_in -> f125_in :|: TRUE
f125_out -> f123_out :|: TRUE
f10_in(s(T15)) -> f87_in(T15) :|: TRUE
f122_in(x3) -> f3_in(x3) :|: TRUE
f132_in -> f132_out :|: TRUE
f3_in(x5) -> f4_in(x5) :|: TRUE
f4_in(x6) -> f10_in(x6) :|: TRUE
f87_in(x10) -> f121_in :|: TRUE
f121_out -> f122_in(x11) :|: TRUE
f243_out -> f125_out :|: TRUE
f125_in -> f243_in :|: TRUE


----------------------------------------

(88)
Obligation:
Rules:
f124_in -> f132_in :|: TRUE
f132_out -> f124_out :|: TRUE
f123_out -> f121_out :|: TRUE
f121_in -> f123_in :|: TRUE
f243_in -> f121_in :|: TRUE
f121_out -> f243_out :|: TRUE
f123_in -> f124_in :|: TRUE
f124_out -> f123_out :|: TRUE
f123_in -> f125_in :|: TRUE
f125_out -> f123_out :|: TRUE
f10_in(s(T15)) -> f87_in(T15) :|: TRUE
f122_in(x3) -> f3_in(x3) :|: TRUE
f132_in -> f132_out :|: TRUE
f3_in(x5) -> f4_in(x5) :|: TRUE
f4_in(x6) -> f10_in(x6) :|: TRUE
f87_in(x10) -> f121_in :|: TRUE
f121_out -> f122_in(x11) :|: TRUE
f243_out -> f125_out :|: TRUE
f125_in -> f243_in :|: TRUE

----------------------------------------

(89) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(90)
Obligation:
Rules:
f123_out -> f123_out :|: TRUE
f121_in -> f123_out :|: TRUE
f121_in -> f121_in :|: TRUE
f123_out -> f121_in :|: TRUE

----------------------------------------

(91) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(92)
Obligation:
Rules:
f123_out -> f123_out :|: TRUE
f121_in -> f123_out :|: TRUE
f121_in -> f121_in :|: TRUE
f123_out -> f121_in :|: TRUE

----------------------------------------

(93) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f123_out -> f123_out :|: TRUE
(2) f121_in -> f123_out :|: TRUE
(3) f121_in -> f121_in :|: TRUE
(4) f123_out -> f121_in :|: TRUE

Arcs:
(1) -> (1), (4)
(2) -> (1), (4)
(3) -> (2), (3)
(4) -> (2), (3)

This digraph is fully evaluated!
----------------------------------------

(94)
Obligation:

Termination digraph:
Nodes:
(1) f123_out -> f123_out :|: TRUE
(2) f121_in -> f123_out :|: TRUE
(3) f121_in -> f121_in :|: TRUE
(4) f123_out -> f121_in :|: TRUE

Arcs:
(1) -> (1), (4)
(2) -> (1), (4)
(3) -> (2), (3)
(4) -> (2), (3)

This digraph is fully evaluated!

----------------------------------------

(95) FilterProof (EQUIVALENT)
Used the following sort dictionary for filtering: 
f123_out()
f121_in()
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(96)
Obligation:
Rules:
f123_out -> f123_out :|: TRUE
f121_in -> f123_out :|: TRUE
f121_in -> f121_in :|: TRUE
f123_out -> f121_in :|: TRUE

----------------------------------------

(97) IntTRSPeriodicNontermProof (COMPLETE)
Normalized system to the following form:
f(pc) -> f(1) :|: pc = 1 && TRUE
f(pc) -> f(1) :|: pc = 2 && TRUE
f(pc) -> f(2) :|: pc = 2 && TRUE
f(pc) -> f(2) :|: pc = 1 && TRUE
Witness term starting non-terminating reduction: f(2)
----------------------------------------

(98)
NO
