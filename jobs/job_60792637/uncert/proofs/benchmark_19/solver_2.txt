MAYBE
proof of /hpcwork/ff862203/termcomp25/benchmarks/senVh.pl
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Left Termination of the query pattern

fl(a,g,a)

w.r.t. the given Prolog program could not be shown:

(0) Prolog
(1) PrologToPiTRSProof [SOUND, 0 ms]
(2) PiTRS
    (3) DependencyPairsProof [EQUIVALENT, 0 ms]
    (4) PiDP
    (5) DependencyGraphProof [EQUIVALENT, 0 ms]
    (6) AND
        (7) PiDP
            (8) UsableRulesProof [EQUIVALENT, 0 ms]
            (9) PiDP
            (10) PiDPToQDPProof [SOUND, 0 ms]
            (11) QDP
            (12) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (13) YES
        (14) PiDP
            (15) UsableRulesProof [EQUIVALENT, 0 ms]
            (16) PiDP
            (17) PiDPToQDPProof [SOUND, 0 ms]
            (18) QDP
            (19) MRRProof [EQUIVALENT, 17 ms]
            (20) QDP
            (21) UsableRulesProof [EQUIVALENT, 0 ms]
            (22) QDP
            (23) QReductionProof [EQUIVALENT, 0 ms]
            (24) QDP
            (25) TransformationProof [EQUIVALENT, 0 ms]
            (26) QDP
            (27) UsableRulesProof [EQUIVALENT, 0 ms]
            (28) QDP
            (29) QReductionProof [EQUIVALENT, 0 ms]
            (30) QDP
            (31) TransformationProof [EQUIVALENT, 0 ms]
            (32) QDP
(33) PrologToPiTRSProof [SOUND, 0 ms]
(34) PiTRS
    (35) DependencyPairsProof [EQUIVALENT, 0 ms]
    (36) PiDP
    (37) DependencyGraphProof [EQUIVALENT, 0 ms]
    (38) AND
        (39) PiDP
            (40) UsableRulesProof [EQUIVALENT, 0 ms]
            (41) PiDP
            (42) PiDPToQDPProof [SOUND, 0 ms]
            (43) QDP
            (44) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (45) YES
        (46) PiDP
            (47) UsableRulesProof [EQUIVALENT, 0 ms]
            (48) PiDP
            (49) PiDPToQDPProof [SOUND, 0 ms]
            (50) QDP
            (51) QDPQMonotonicMRRProof [EQUIVALENT, 10 ms]
            (52) QDP
            (53) UsableRulesProof [EQUIVALENT, 0 ms]
            (54) QDP
            (55) QReductionProof [EQUIVALENT, 0 ms]
            (56) QDP
            (57) TransformationProof [EQUIVALENT, 0 ms]
            (58) QDP
            (59) UsableRulesProof [EQUIVALENT, 0 ms]
            (60) QDP
            (61) QReductionProof [EQUIVALENT, 0 ms]
            (62) QDP
            (63) TransformationProof [EQUIVALENT, 0 ms]
            (64) QDP
(65) PrologToDTProblemTransformerProof [SOUND, 0 ms]
(66) TRIPLES
    (67) TriplesToPiDPProof [SOUND, 0 ms]
    (68) PiDP
    (69) DependencyGraphProof [EQUIVALENT, 0 ms]
    (70) AND
        (71) PiDP
            (72) UsableRulesProof [EQUIVALENT, 0 ms]
            (73) PiDP
            (74) PiDPToQDPProof [SOUND, 0 ms]
            (75) QDP
            (76) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (77) YES
        (78) PiDP
            (79) PiDPToQDPProof [SOUND, 0 ms]
            (80) QDP
            (81) QDPOrderProof [EQUIVALENT, 11 ms]
            (82) QDP
            (83) QDPOrderProof [EQUIVALENT, 38 ms]
            (84) QDP
            (85) QDPQMonotonicMRRProof [EQUIVALENT, 7 ms]
            (86) QDP
                (87) UsableRulesProof [EQUIVALENT, 0 ms]
                (88) QDP
                (89) QReductionProof [EQUIVALENT, 0 ms]
                (90) QDP
(91) PrologToTRSTransformerProof [SOUND, 0 ms]
(92) QTRS
    (93) DependencyPairsProof [EQUIVALENT, 0 ms]
    (94) QDP
    (95) DependencyGraphProof [EQUIVALENT, 0 ms]
    (96) AND
        (97) QDP
            (98) UsableRulesProof [EQUIVALENT, 0 ms]
            (99) QDP
            (100) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (101) YES
        (102) QDP
            (103) NonTerminationLoopProof [COMPLETE, 0 ms]
            (104) NO
(105) PrologToIRSwTTransformerProof [SOUND, 0 ms]
(106) AND
    (107) IRSwT
        (108) IRSwTSimpleDependencyGraphProof [EQUIVALENT, 0 ms]
        (109) IRSwT
        (110) IntTRSCompressionProof [EQUIVALENT, 8 ms]
        (111) IRSwT
        (112) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
        (113) IRSwT
        (114) IRSwTTerminationDigraphProof [EQUIVALENT, 0 ms]
        (115) IRSwT
        (116) IntTRSUnneededArgumentFilterProof [EQUIVALENT, 0 ms]
        (117) IRSwT
        (118) TempFilterProof [SOUND, 1 ms]
        (119) IRSwT
        (120) IRSwTToQDPProof [SOUND, 0 ms]
        (121) QDP
        (122) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (123) YES
    (124) IRSwT
        (125) IRSwTSimpleDependencyGraphProof [EQUIVALENT, 0 ms]
        (126) IRSwT


----------------------------------------

(0)
Obligation:
Clauses:

fl([], [], 0).
fl(.(E, X), R, s(Z)) :- ','(append(E, Y, R), fl(X, Y, Z)).
append([], X, X).
append(.(X, Xs), Ys, .(X, Zs)) :- append(Xs, Ys, Zs).


Query: fl(a,g,a)
----------------------------------------

(1) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

fl_in_3: (f,b,f)

append_in_3: (f,f,b)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   fl_in_aga([], [], 0) -> fl_out_aga([], [], 0)
   fl_in_aga(.(E, X), R, s(Z)) -> U1_aga(E, X, R, Z, append_in_aag(E, Y, R))
   append_in_aag([], X, X) -> append_out_aag([], X, X)
   append_in_aag(.(X, Xs), Ys, .(X, Zs)) -> U3_aag(X, Xs, Ys, Zs, append_in_aag(Xs, Ys, Zs))
   U3_aag(X, Xs, Ys, Zs, append_out_aag(Xs, Ys, Zs)) -> append_out_aag(.(X, Xs), Ys, .(X, Zs))
   U1_aga(E, X, R, Z, append_out_aag(E, Y, R)) -> U2_aga(E, X, R, Z, fl_in_aga(X, Y, Z))
   U2_aga(E, X, R, Z, fl_out_aga(X, Y, Z)) -> fl_out_aga(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aga(x1, x2, x3)  =  fl_in_aga(x2)

[]  =  []

fl_out_aga(x1, x2, x3)  =  fl_out_aga(x1, x3)

U1_aga(x1, x2, x3, x4, x5)  =  U1_aga(x5)

append_in_aag(x1, x2, x3)  =  append_in_aag(x3)

append_out_aag(x1, x2, x3)  =  append_out_aag(x1, x2)

.(x1, x2)  =  .(x1, x2)

U3_aag(x1, x2, x3, x4, x5)  =  U3_aag(x1, x5)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x1, x5)

s(x1)  =  s(x1)





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(2)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   fl_in_aga([], [], 0) -> fl_out_aga([], [], 0)
   fl_in_aga(.(E, X), R, s(Z)) -> U1_aga(E, X, R, Z, append_in_aag(E, Y, R))
   append_in_aag([], X, X) -> append_out_aag([], X, X)
   append_in_aag(.(X, Xs), Ys, .(X, Zs)) -> U3_aag(X, Xs, Ys, Zs, append_in_aag(Xs, Ys, Zs))
   U3_aag(X, Xs, Ys, Zs, append_out_aag(Xs, Ys, Zs)) -> append_out_aag(.(X, Xs), Ys, .(X, Zs))
   U1_aga(E, X, R, Z, append_out_aag(E, Y, R)) -> U2_aga(E, X, R, Z, fl_in_aga(X, Y, Z))
   U2_aga(E, X, R, Z, fl_out_aga(X, Y, Z)) -> fl_out_aga(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aga(x1, x2, x3)  =  fl_in_aga(x2)

[]  =  []

fl_out_aga(x1, x2, x3)  =  fl_out_aga(x1, x3)

U1_aga(x1, x2, x3, x4, x5)  =  U1_aga(x5)

append_in_aag(x1, x2, x3)  =  append_in_aag(x3)

append_out_aag(x1, x2, x3)  =  append_out_aag(x1, x2)

.(x1, x2)  =  .(x1, x2)

U3_aag(x1, x2, x3, x4, x5)  =  U3_aag(x1, x5)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x1, x5)

s(x1)  =  s(x1)



----------------------------------------

(3) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   FL_IN_AGA(.(E, X), R, s(Z)) -> U1_AGA(E, X, R, Z, append_in_aag(E, Y, R))
   FL_IN_AGA(.(E, X), R, s(Z)) -> APPEND_IN_AAG(E, Y, R)
   APPEND_IN_AAG(.(X, Xs), Ys, .(X, Zs)) -> U3_AAG(X, Xs, Ys, Zs, append_in_aag(Xs, Ys, Zs))
   APPEND_IN_AAG(.(X, Xs), Ys, .(X, Zs)) -> APPEND_IN_AAG(Xs, Ys, Zs)
   U1_AGA(E, X, R, Z, append_out_aag(E, Y, R)) -> U2_AGA(E, X, R, Z, fl_in_aga(X, Y, Z))
   U1_AGA(E, X, R, Z, append_out_aag(E, Y, R)) -> FL_IN_AGA(X, Y, Z)

The TRS R consists of the following rules:

   fl_in_aga([], [], 0) -> fl_out_aga([], [], 0)
   fl_in_aga(.(E, X), R, s(Z)) -> U1_aga(E, X, R, Z, append_in_aag(E, Y, R))
   append_in_aag([], X, X) -> append_out_aag([], X, X)
   append_in_aag(.(X, Xs), Ys, .(X, Zs)) -> U3_aag(X, Xs, Ys, Zs, append_in_aag(Xs, Ys, Zs))
   U3_aag(X, Xs, Ys, Zs, append_out_aag(Xs, Ys, Zs)) -> append_out_aag(.(X, Xs), Ys, .(X, Zs))
   U1_aga(E, X, R, Z, append_out_aag(E, Y, R)) -> U2_aga(E, X, R, Z, fl_in_aga(X, Y, Z))
   U2_aga(E, X, R, Z, fl_out_aga(X, Y, Z)) -> fl_out_aga(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aga(x1, x2, x3)  =  fl_in_aga(x2)

[]  =  []

fl_out_aga(x1, x2, x3)  =  fl_out_aga(x1, x3)

U1_aga(x1, x2, x3, x4, x5)  =  U1_aga(x5)

append_in_aag(x1, x2, x3)  =  append_in_aag(x3)

append_out_aag(x1, x2, x3)  =  append_out_aag(x1, x2)

.(x1, x2)  =  .(x1, x2)

U3_aag(x1, x2, x3, x4, x5)  =  U3_aag(x1, x5)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x1, x5)

s(x1)  =  s(x1)

FL_IN_AGA(x1, x2, x3)  =  FL_IN_AGA(x2)

U1_AGA(x1, x2, x3, x4, x5)  =  U1_AGA(x5)

APPEND_IN_AAG(x1, x2, x3)  =  APPEND_IN_AAG(x3)

U3_AAG(x1, x2, x3, x4, x5)  =  U3_AAG(x1, x5)

U2_AGA(x1, x2, x3, x4, x5)  =  U2_AGA(x1, x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(4)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   FL_IN_AGA(.(E, X), R, s(Z)) -> U1_AGA(E, X, R, Z, append_in_aag(E, Y, R))
   FL_IN_AGA(.(E, X), R, s(Z)) -> APPEND_IN_AAG(E, Y, R)
   APPEND_IN_AAG(.(X, Xs), Ys, .(X, Zs)) -> U3_AAG(X, Xs, Ys, Zs, append_in_aag(Xs, Ys, Zs))
   APPEND_IN_AAG(.(X, Xs), Ys, .(X, Zs)) -> APPEND_IN_AAG(Xs, Ys, Zs)
   U1_AGA(E, X, R, Z, append_out_aag(E, Y, R)) -> U2_AGA(E, X, R, Z, fl_in_aga(X, Y, Z))
   U1_AGA(E, X, R, Z, append_out_aag(E, Y, R)) -> FL_IN_AGA(X, Y, Z)

The TRS R consists of the following rules:

   fl_in_aga([], [], 0) -> fl_out_aga([], [], 0)
   fl_in_aga(.(E, X), R, s(Z)) -> U1_aga(E, X, R, Z, append_in_aag(E, Y, R))
   append_in_aag([], X, X) -> append_out_aag([], X, X)
   append_in_aag(.(X, Xs), Ys, .(X, Zs)) -> U3_aag(X, Xs, Ys, Zs, append_in_aag(Xs, Ys, Zs))
   U3_aag(X, Xs, Ys, Zs, append_out_aag(Xs, Ys, Zs)) -> append_out_aag(.(X, Xs), Ys, .(X, Zs))
   U1_aga(E, X, R, Z, append_out_aag(E, Y, R)) -> U2_aga(E, X, R, Z, fl_in_aga(X, Y, Z))
   U2_aga(E, X, R, Z, fl_out_aga(X, Y, Z)) -> fl_out_aga(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aga(x1, x2, x3)  =  fl_in_aga(x2)

[]  =  []

fl_out_aga(x1, x2, x3)  =  fl_out_aga(x1, x3)

U1_aga(x1, x2, x3, x4, x5)  =  U1_aga(x5)

append_in_aag(x1, x2, x3)  =  append_in_aag(x3)

append_out_aag(x1, x2, x3)  =  append_out_aag(x1, x2)

.(x1, x2)  =  .(x1, x2)

U3_aag(x1, x2, x3, x4, x5)  =  U3_aag(x1, x5)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x1, x5)

s(x1)  =  s(x1)

FL_IN_AGA(x1, x2, x3)  =  FL_IN_AGA(x2)

U1_AGA(x1, x2, x3, x4, x5)  =  U1_AGA(x5)

APPEND_IN_AAG(x1, x2, x3)  =  APPEND_IN_AAG(x3)

U3_AAG(x1, x2, x3, x4, x5)  =  U3_AAG(x1, x5)

U2_AGA(x1, x2, x3, x4, x5)  =  U2_AGA(x1, x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(5) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 2 SCCs with 3 less nodes.
----------------------------------------

(6)
Complex Obligation (AND)

----------------------------------------

(7)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   APPEND_IN_AAG(.(X, Xs), Ys, .(X, Zs)) -> APPEND_IN_AAG(Xs, Ys, Zs)

The TRS R consists of the following rules:

   fl_in_aga([], [], 0) -> fl_out_aga([], [], 0)
   fl_in_aga(.(E, X), R, s(Z)) -> U1_aga(E, X, R, Z, append_in_aag(E, Y, R))
   append_in_aag([], X, X) -> append_out_aag([], X, X)
   append_in_aag(.(X, Xs), Ys, .(X, Zs)) -> U3_aag(X, Xs, Ys, Zs, append_in_aag(Xs, Ys, Zs))
   U3_aag(X, Xs, Ys, Zs, append_out_aag(Xs, Ys, Zs)) -> append_out_aag(.(X, Xs), Ys, .(X, Zs))
   U1_aga(E, X, R, Z, append_out_aag(E, Y, R)) -> U2_aga(E, X, R, Z, fl_in_aga(X, Y, Z))
   U2_aga(E, X, R, Z, fl_out_aga(X, Y, Z)) -> fl_out_aga(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aga(x1, x2, x3)  =  fl_in_aga(x2)

[]  =  []

fl_out_aga(x1, x2, x3)  =  fl_out_aga(x1, x3)

U1_aga(x1, x2, x3, x4, x5)  =  U1_aga(x5)

append_in_aag(x1, x2, x3)  =  append_in_aag(x3)

append_out_aag(x1, x2, x3)  =  append_out_aag(x1, x2)

.(x1, x2)  =  .(x1, x2)

U3_aag(x1, x2, x3, x4, x5)  =  U3_aag(x1, x5)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x1, x5)

s(x1)  =  s(x1)

APPEND_IN_AAG(x1, x2, x3)  =  APPEND_IN_AAG(x3)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(8) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(9)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   APPEND_IN_AAG(.(X, Xs), Ys, .(X, Zs)) -> APPEND_IN_AAG(Xs, Ys, Zs)

R is empty.
The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x1, x2)

APPEND_IN_AAG(x1, x2, x3)  =  APPEND_IN_AAG(x3)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(10) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(11)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   APPEND_IN_AAG(.(X, Zs)) -> APPEND_IN_AAG(Zs)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(12) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*APPEND_IN_AAG(.(X, Zs)) -> APPEND_IN_AAG(Zs)
The graph contains the following edges 1 > 1


----------------------------------------

(13)
YES

----------------------------------------

(14)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_AGA(E, X, R, Z, append_out_aag(E, Y, R)) -> FL_IN_AGA(X, Y, Z)
   FL_IN_AGA(.(E, X), R, s(Z)) -> U1_AGA(E, X, R, Z, append_in_aag(E, Y, R))

The TRS R consists of the following rules:

   fl_in_aga([], [], 0) -> fl_out_aga([], [], 0)
   fl_in_aga(.(E, X), R, s(Z)) -> U1_aga(E, X, R, Z, append_in_aag(E, Y, R))
   append_in_aag([], X, X) -> append_out_aag([], X, X)
   append_in_aag(.(X, Xs), Ys, .(X, Zs)) -> U3_aag(X, Xs, Ys, Zs, append_in_aag(Xs, Ys, Zs))
   U3_aag(X, Xs, Ys, Zs, append_out_aag(Xs, Ys, Zs)) -> append_out_aag(.(X, Xs), Ys, .(X, Zs))
   U1_aga(E, X, R, Z, append_out_aag(E, Y, R)) -> U2_aga(E, X, R, Z, fl_in_aga(X, Y, Z))
   U2_aga(E, X, R, Z, fl_out_aga(X, Y, Z)) -> fl_out_aga(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aga(x1, x2, x3)  =  fl_in_aga(x2)

[]  =  []

fl_out_aga(x1, x2, x3)  =  fl_out_aga(x1, x3)

U1_aga(x1, x2, x3, x4, x5)  =  U1_aga(x5)

append_in_aag(x1, x2, x3)  =  append_in_aag(x3)

append_out_aag(x1, x2, x3)  =  append_out_aag(x1, x2)

.(x1, x2)  =  .(x1, x2)

U3_aag(x1, x2, x3, x4, x5)  =  U3_aag(x1, x5)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x1, x5)

s(x1)  =  s(x1)

FL_IN_AGA(x1, x2, x3)  =  FL_IN_AGA(x2)

U1_AGA(x1, x2, x3, x4, x5)  =  U1_AGA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(15) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(16)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_AGA(E, X, R, Z, append_out_aag(E, Y, R)) -> FL_IN_AGA(X, Y, Z)
   FL_IN_AGA(.(E, X), R, s(Z)) -> U1_AGA(E, X, R, Z, append_in_aag(E, Y, R))

The TRS R consists of the following rules:

   append_in_aag([], X, X) -> append_out_aag([], X, X)
   append_in_aag(.(X, Xs), Ys, .(X, Zs)) -> U3_aag(X, Xs, Ys, Zs, append_in_aag(Xs, Ys, Zs))
   U3_aag(X, Xs, Ys, Zs, append_out_aag(Xs, Ys, Zs)) -> append_out_aag(.(X, Xs), Ys, .(X, Zs))

The argument filtering Pi contains the following mapping:
[]  =  []

append_in_aag(x1, x2, x3)  =  append_in_aag(x3)

append_out_aag(x1, x2, x3)  =  append_out_aag(x1, x2)

.(x1, x2)  =  .(x1, x2)

U3_aag(x1, x2, x3, x4, x5)  =  U3_aag(x1, x5)

s(x1)  =  s(x1)

FL_IN_AGA(x1, x2, x3)  =  FL_IN_AGA(x2)

U1_AGA(x1, x2, x3, x4, x5)  =  U1_AGA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(17) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(18)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AGA(append_out_aag(E, Y)) -> FL_IN_AGA(Y)
   FL_IN_AGA(R) -> U1_AGA(append_in_aag(R))

The TRS R consists of the following rules:

   append_in_aag(X) -> append_out_aag([], X)
   append_in_aag(.(X, Zs)) -> U3_aag(X, append_in_aag(Zs))
   U3_aag(X, append_out_aag(Xs, Ys)) -> append_out_aag(.(X, Xs), Ys)

The set Q consists of the following terms:

   append_in_aag(x0)
   U3_aag(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(19) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.


Strictly oriented rules of the TRS R:

   append_in_aag(.(X, Zs)) -> U3_aag(X, append_in_aag(Zs))

Used ordering: Polynomial interpretation [POLO]:

   POL(.(x_1, x_2)) = 1 + 2*x_1 + 2*x_2
   POL(FL_IN_AGA(x_1)) = 2*x_1
   POL(U1_AGA(x_1)) = x_1
   POL(U3_aag(x_1, x_2)) = 1 + 2*x_1 + 2*x_2
   POL([]) = 0
   POL(append_in_aag(x_1)) = 2*x_1
   POL(append_out_aag(x_1, x_2)) = x_1 + 2*x_2


----------------------------------------

(20)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AGA(append_out_aag(E, Y)) -> FL_IN_AGA(Y)
   FL_IN_AGA(R) -> U1_AGA(append_in_aag(R))

The TRS R consists of the following rules:

   append_in_aag(X) -> append_out_aag([], X)
   U3_aag(X, append_out_aag(Xs, Ys)) -> append_out_aag(.(X, Xs), Ys)

The set Q consists of the following terms:

   append_in_aag(x0)
   U3_aag(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(21) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(22)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AGA(append_out_aag(E, Y)) -> FL_IN_AGA(Y)
   FL_IN_AGA(R) -> U1_AGA(append_in_aag(R))

The TRS R consists of the following rules:

   append_in_aag(X) -> append_out_aag([], X)

The set Q consists of the following terms:

   append_in_aag(x0)
   U3_aag(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(23) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   U3_aag(x0, x1)


----------------------------------------

(24)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AGA(append_out_aag(E, Y)) -> FL_IN_AGA(Y)
   FL_IN_AGA(R) -> U1_AGA(append_in_aag(R))

The TRS R consists of the following rules:

   append_in_aag(X) -> append_out_aag([], X)

The set Q consists of the following terms:

   append_in_aag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(25) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule FL_IN_AGA(R) -> U1_AGA(append_in_aag(R)) at position [0] we obtained the following new rules [LPAR04]:

   (FL_IN_AGA(R) -> U1_AGA(append_out_aag([], R)),FL_IN_AGA(R) -> U1_AGA(append_out_aag([], R)))


----------------------------------------

(26)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AGA(append_out_aag(E, Y)) -> FL_IN_AGA(Y)
   FL_IN_AGA(R) -> U1_AGA(append_out_aag([], R))

The TRS R consists of the following rules:

   append_in_aag(X) -> append_out_aag([], X)

The set Q consists of the following terms:

   append_in_aag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(27) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(28)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AGA(append_out_aag(E, Y)) -> FL_IN_AGA(Y)
   FL_IN_AGA(R) -> U1_AGA(append_out_aag([], R))

R is empty.
The set Q consists of the following terms:

   append_in_aag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(29) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   append_in_aag(x0)


----------------------------------------

(30)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AGA(append_out_aag(E, Y)) -> FL_IN_AGA(Y)
   FL_IN_AGA(R) -> U1_AGA(append_out_aag([], R))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(31) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U1_AGA(append_out_aag(E, Y)) -> FL_IN_AGA(Y) we obtained the following new rules [LPAR04]:

   (U1_AGA(append_out_aag([], z0)) -> FL_IN_AGA(z0),U1_AGA(append_out_aag([], z0)) -> FL_IN_AGA(z0))


----------------------------------------

(32)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   FL_IN_AGA(R) -> U1_AGA(append_out_aag([], R))
   U1_AGA(append_out_aag([], z0)) -> FL_IN_AGA(z0)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(33) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

fl_in_3: (f,b,f)

append_in_3: (f,f,b)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   fl_in_aga([], [], 0) -> fl_out_aga([], [], 0)
   fl_in_aga(.(E, X), R, s(Z)) -> U1_aga(E, X, R, Z, append_in_aag(E, Y, R))
   append_in_aag([], X, X) -> append_out_aag([], X, X)
   append_in_aag(.(X, Xs), Ys, .(X, Zs)) -> U3_aag(X, Xs, Ys, Zs, append_in_aag(Xs, Ys, Zs))
   U3_aag(X, Xs, Ys, Zs, append_out_aag(Xs, Ys, Zs)) -> append_out_aag(.(X, Xs), Ys, .(X, Zs))
   U1_aga(E, X, R, Z, append_out_aag(E, Y, R)) -> U2_aga(E, X, R, Z, fl_in_aga(X, Y, Z))
   U2_aga(E, X, R, Z, fl_out_aga(X, Y, Z)) -> fl_out_aga(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aga(x1, x2, x3)  =  fl_in_aga(x2)

[]  =  []

fl_out_aga(x1, x2, x3)  =  fl_out_aga(x1, x2, x3)

U1_aga(x1, x2, x3, x4, x5)  =  U1_aga(x3, x5)

append_in_aag(x1, x2, x3)  =  append_in_aag(x3)

append_out_aag(x1, x2, x3)  =  append_out_aag(x1, x2, x3)

.(x1, x2)  =  .(x1, x2)

U3_aag(x1, x2, x3, x4, x5)  =  U3_aag(x1, x4, x5)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x1, x3, x5)

s(x1)  =  s(x1)





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(34)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   fl_in_aga([], [], 0) -> fl_out_aga([], [], 0)
   fl_in_aga(.(E, X), R, s(Z)) -> U1_aga(E, X, R, Z, append_in_aag(E, Y, R))
   append_in_aag([], X, X) -> append_out_aag([], X, X)
   append_in_aag(.(X, Xs), Ys, .(X, Zs)) -> U3_aag(X, Xs, Ys, Zs, append_in_aag(Xs, Ys, Zs))
   U3_aag(X, Xs, Ys, Zs, append_out_aag(Xs, Ys, Zs)) -> append_out_aag(.(X, Xs), Ys, .(X, Zs))
   U1_aga(E, X, R, Z, append_out_aag(E, Y, R)) -> U2_aga(E, X, R, Z, fl_in_aga(X, Y, Z))
   U2_aga(E, X, R, Z, fl_out_aga(X, Y, Z)) -> fl_out_aga(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aga(x1, x2, x3)  =  fl_in_aga(x2)

[]  =  []

fl_out_aga(x1, x2, x3)  =  fl_out_aga(x1, x2, x3)

U1_aga(x1, x2, x3, x4, x5)  =  U1_aga(x3, x5)

append_in_aag(x1, x2, x3)  =  append_in_aag(x3)

append_out_aag(x1, x2, x3)  =  append_out_aag(x1, x2, x3)

.(x1, x2)  =  .(x1, x2)

U3_aag(x1, x2, x3, x4, x5)  =  U3_aag(x1, x4, x5)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x1, x3, x5)

s(x1)  =  s(x1)



----------------------------------------

(35) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   FL_IN_AGA(.(E, X), R, s(Z)) -> U1_AGA(E, X, R, Z, append_in_aag(E, Y, R))
   FL_IN_AGA(.(E, X), R, s(Z)) -> APPEND_IN_AAG(E, Y, R)
   APPEND_IN_AAG(.(X, Xs), Ys, .(X, Zs)) -> U3_AAG(X, Xs, Ys, Zs, append_in_aag(Xs, Ys, Zs))
   APPEND_IN_AAG(.(X, Xs), Ys, .(X, Zs)) -> APPEND_IN_AAG(Xs, Ys, Zs)
   U1_AGA(E, X, R, Z, append_out_aag(E, Y, R)) -> U2_AGA(E, X, R, Z, fl_in_aga(X, Y, Z))
   U1_AGA(E, X, R, Z, append_out_aag(E, Y, R)) -> FL_IN_AGA(X, Y, Z)

The TRS R consists of the following rules:

   fl_in_aga([], [], 0) -> fl_out_aga([], [], 0)
   fl_in_aga(.(E, X), R, s(Z)) -> U1_aga(E, X, R, Z, append_in_aag(E, Y, R))
   append_in_aag([], X, X) -> append_out_aag([], X, X)
   append_in_aag(.(X, Xs), Ys, .(X, Zs)) -> U3_aag(X, Xs, Ys, Zs, append_in_aag(Xs, Ys, Zs))
   U3_aag(X, Xs, Ys, Zs, append_out_aag(Xs, Ys, Zs)) -> append_out_aag(.(X, Xs), Ys, .(X, Zs))
   U1_aga(E, X, R, Z, append_out_aag(E, Y, R)) -> U2_aga(E, X, R, Z, fl_in_aga(X, Y, Z))
   U2_aga(E, X, R, Z, fl_out_aga(X, Y, Z)) -> fl_out_aga(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aga(x1, x2, x3)  =  fl_in_aga(x2)

[]  =  []

fl_out_aga(x1, x2, x3)  =  fl_out_aga(x1, x2, x3)

U1_aga(x1, x2, x3, x4, x5)  =  U1_aga(x3, x5)

append_in_aag(x1, x2, x3)  =  append_in_aag(x3)

append_out_aag(x1, x2, x3)  =  append_out_aag(x1, x2, x3)

.(x1, x2)  =  .(x1, x2)

U3_aag(x1, x2, x3, x4, x5)  =  U3_aag(x1, x4, x5)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x1, x3, x5)

s(x1)  =  s(x1)

FL_IN_AGA(x1, x2, x3)  =  FL_IN_AGA(x2)

U1_AGA(x1, x2, x3, x4, x5)  =  U1_AGA(x3, x5)

APPEND_IN_AAG(x1, x2, x3)  =  APPEND_IN_AAG(x3)

U3_AAG(x1, x2, x3, x4, x5)  =  U3_AAG(x1, x4, x5)

U2_AGA(x1, x2, x3, x4, x5)  =  U2_AGA(x1, x3, x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(36)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   FL_IN_AGA(.(E, X), R, s(Z)) -> U1_AGA(E, X, R, Z, append_in_aag(E, Y, R))
   FL_IN_AGA(.(E, X), R, s(Z)) -> APPEND_IN_AAG(E, Y, R)
   APPEND_IN_AAG(.(X, Xs), Ys, .(X, Zs)) -> U3_AAG(X, Xs, Ys, Zs, append_in_aag(Xs, Ys, Zs))
   APPEND_IN_AAG(.(X, Xs), Ys, .(X, Zs)) -> APPEND_IN_AAG(Xs, Ys, Zs)
   U1_AGA(E, X, R, Z, append_out_aag(E, Y, R)) -> U2_AGA(E, X, R, Z, fl_in_aga(X, Y, Z))
   U1_AGA(E, X, R, Z, append_out_aag(E, Y, R)) -> FL_IN_AGA(X, Y, Z)

The TRS R consists of the following rules:

   fl_in_aga([], [], 0) -> fl_out_aga([], [], 0)
   fl_in_aga(.(E, X), R, s(Z)) -> U1_aga(E, X, R, Z, append_in_aag(E, Y, R))
   append_in_aag([], X, X) -> append_out_aag([], X, X)
   append_in_aag(.(X, Xs), Ys, .(X, Zs)) -> U3_aag(X, Xs, Ys, Zs, append_in_aag(Xs, Ys, Zs))
   U3_aag(X, Xs, Ys, Zs, append_out_aag(Xs, Ys, Zs)) -> append_out_aag(.(X, Xs), Ys, .(X, Zs))
   U1_aga(E, X, R, Z, append_out_aag(E, Y, R)) -> U2_aga(E, X, R, Z, fl_in_aga(X, Y, Z))
   U2_aga(E, X, R, Z, fl_out_aga(X, Y, Z)) -> fl_out_aga(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aga(x1, x2, x3)  =  fl_in_aga(x2)

[]  =  []

fl_out_aga(x1, x2, x3)  =  fl_out_aga(x1, x2, x3)

U1_aga(x1, x2, x3, x4, x5)  =  U1_aga(x3, x5)

append_in_aag(x1, x2, x3)  =  append_in_aag(x3)

append_out_aag(x1, x2, x3)  =  append_out_aag(x1, x2, x3)

.(x1, x2)  =  .(x1, x2)

U3_aag(x1, x2, x3, x4, x5)  =  U3_aag(x1, x4, x5)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x1, x3, x5)

s(x1)  =  s(x1)

FL_IN_AGA(x1, x2, x3)  =  FL_IN_AGA(x2)

U1_AGA(x1, x2, x3, x4, x5)  =  U1_AGA(x3, x5)

APPEND_IN_AAG(x1, x2, x3)  =  APPEND_IN_AAG(x3)

U3_AAG(x1, x2, x3, x4, x5)  =  U3_AAG(x1, x4, x5)

U2_AGA(x1, x2, x3, x4, x5)  =  U2_AGA(x1, x3, x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(37) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 2 SCCs with 3 less nodes.
----------------------------------------

(38)
Complex Obligation (AND)

----------------------------------------

(39)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   APPEND_IN_AAG(.(X, Xs), Ys, .(X, Zs)) -> APPEND_IN_AAG(Xs, Ys, Zs)

The TRS R consists of the following rules:

   fl_in_aga([], [], 0) -> fl_out_aga([], [], 0)
   fl_in_aga(.(E, X), R, s(Z)) -> U1_aga(E, X, R, Z, append_in_aag(E, Y, R))
   append_in_aag([], X, X) -> append_out_aag([], X, X)
   append_in_aag(.(X, Xs), Ys, .(X, Zs)) -> U3_aag(X, Xs, Ys, Zs, append_in_aag(Xs, Ys, Zs))
   U3_aag(X, Xs, Ys, Zs, append_out_aag(Xs, Ys, Zs)) -> append_out_aag(.(X, Xs), Ys, .(X, Zs))
   U1_aga(E, X, R, Z, append_out_aag(E, Y, R)) -> U2_aga(E, X, R, Z, fl_in_aga(X, Y, Z))
   U2_aga(E, X, R, Z, fl_out_aga(X, Y, Z)) -> fl_out_aga(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aga(x1, x2, x3)  =  fl_in_aga(x2)

[]  =  []

fl_out_aga(x1, x2, x3)  =  fl_out_aga(x1, x2, x3)

U1_aga(x1, x2, x3, x4, x5)  =  U1_aga(x3, x5)

append_in_aag(x1, x2, x3)  =  append_in_aag(x3)

append_out_aag(x1, x2, x3)  =  append_out_aag(x1, x2, x3)

.(x1, x2)  =  .(x1, x2)

U3_aag(x1, x2, x3, x4, x5)  =  U3_aag(x1, x4, x5)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x1, x3, x5)

s(x1)  =  s(x1)

APPEND_IN_AAG(x1, x2, x3)  =  APPEND_IN_AAG(x3)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(40) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(41)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   APPEND_IN_AAG(.(X, Xs), Ys, .(X, Zs)) -> APPEND_IN_AAG(Xs, Ys, Zs)

R is empty.
The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x1, x2)

APPEND_IN_AAG(x1, x2, x3)  =  APPEND_IN_AAG(x3)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(42) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(43)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   APPEND_IN_AAG(.(X, Zs)) -> APPEND_IN_AAG(Zs)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(44) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*APPEND_IN_AAG(.(X, Zs)) -> APPEND_IN_AAG(Zs)
The graph contains the following edges 1 > 1


----------------------------------------

(45)
YES

----------------------------------------

(46)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_AGA(E, X, R, Z, append_out_aag(E, Y, R)) -> FL_IN_AGA(X, Y, Z)
   FL_IN_AGA(.(E, X), R, s(Z)) -> U1_AGA(E, X, R, Z, append_in_aag(E, Y, R))

The TRS R consists of the following rules:

   fl_in_aga([], [], 0) -> fl_out_aga([], [], 0)
   fl_in_aga(.(E, X), R, s(Z)) -> U1_aga(E, X, R, Z, append_in_aag(E, Y, R))
   append_in_aag([], X, X) -> append_out_aag([], X, X)
   append_in_aag(.(X, Xs), Ys, .(X, Zs)) -> U3_aag(X, Xs, Ys, Zs, append_in_aag(Xs, Ys, Zs))
   U3_aag(X, Xs, Ys, Zs, append_out_aag(Xs, Ys, Zs)) -> append_out_aag(.(X, Xs), Ys, .(X, Zs))
   U1_aga(E, X, R, Z, append_out_aag(E, Y, R)) -> U2_aga(E, X, R, Z, fl_in_aga(X, Y, Z))
   U2_aga(E, X, R, Z, fl_out_aga(X, Y, Z)) -> fl_out_aga(.(E, X), R, s(Z))

The argument filtering Pi contains the following mapping:
fl_in_aga(x1, x2, x3)  =  fl_in_aga(x2)

[]  =  []

fl_out_aga(x1, x2, x3)  =  fl_out_aga(x1, x2, x3)

U1_aga(x1, x2, x3, x4, x5)  =  U1_aga(x3, x5)

append_in_aag(x1, x2, x3)  =  append_in_aag(x3)

append_out_aag(x1, x2, x3)  =  append_out_aag(x1, x2, x3)

.(x1, x2)  =  .(x1, x2)

U3_aag(x1, x2, x3, x4, x5)  =  U3_aag(x1, x4, x5)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x1, x3, x5)

s(x1)  =  s(x1)

FL_IN_AGA(x1, x2, x3)  =  FL_IN_AGA(x2)

U1_AGA(x1, x2, x3, x4, x5)  =  U1_AGA(x3, x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(47) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(48)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_AGA(E, X, R, Z, append_out_aag(E, Y, R)) -> FL_IN_AGA(X, Y, Z)
   FL_IN_AGA(.(E, X), R, s(Z)) -> U1_AGA(E, X, R, Z, append_in_aag(E, Y, R))

The TRS R consists of the following rules:

   append_in_aag([], X, X) -> append_out_aag([], X, X)
   append_in_aag(.(X, Xs), Ys, .(X, Zs)) -> U3_aag(X, Xs, Ys, Zs, append_in_aag(Xs, Ys, Zs))
   U3_aag(X, Xs, Ys, Zs, append_out_aag(Xs, Ys, Zs)) -> append_out_aag(.(X, Xs), Ys, .(X, Zs))

The argument filtering Pi contains the following mapping:
[]  =  []

append_in_aag(x1, x2, x3)  =  append_in_aag(x3)

append_out_aag(x1, x2, x3)  =  append_out_aag(x1, x2, x3)

.(x1, x2)  =  .(x1, x2)

U3_aag(x1, x2, x3, x4, x5)  =  U3_aag(x1, x4, x5)

s(x1)  =  s(x1)

FL_IN_AGA(x1, x2, x3)  =  FL_IN_AGA(x2)

U1_AGA(x1, x2, x3, x4, x5)  =  U1_AGA(x3, x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(49) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(50)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AGA(R, append_out_aag(E, Y, R)) -> FL_IN_AGA(Y)
   FL_IN_AGA(R) -> U1_AGA(R, append_in_aag(R))

The TRS R consists of the following rules:

   append_in_aag(X) -> append_out_aag([], X, X)
   append_in_aag(.(X, Zs)) -> U3_aag(X, Zs, append_in_aag(Zs))
   U3_aag(X, Zs, append_out_aag(Xs, Ys, Zs)) -> append_out_aag(.(X, Xs), Ys, .(X, Zs))

The set Q consists of the following terms:

   append_in_aag(x0)
   U3_aag(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(51) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.


Strictly oriented rules of the TRS R:

   append_in_aag(.(X, Zs)) -> U3_aag(X, Zs, append_in_aag(Zs))

Used ordering: Polynomial interpretation [POLO]:

   POL(.(x_1, x_2)) = 1 + 2*x_2
   POL(FL_IN_AGA(x_1)) = 2*x_1
   POL(U1_AGA(x_1, x_2)) = x_2
   POL(U3_aag(x_1, x_2, x_3)) = x_3
   POL([]) = 2
   POL(append_in_aag(x_1)) = 2*x_1
   POL(append_out_aag(x_1, x_2, x_3)) = 2*x_2


----------------------------------------

(52)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AGA(R, append_out_aag(E, Y, R)) -> FL_IN_AGA(Y)
   FL_IN_AGA(R) -> U1_AGA(R, append_in_aag(R))

The TRS R consists of the following rules:

   append_in_aag(X) -> append_out_aag([], X, X)
   U3_aag(X, Zs, append_out_aag(Xs, Ys, Zs)) -> append_out_aag(.(X, Xs), Ys, .(X, Zs))

The set Q consists of the following terms:

   append_in_aag(x0)
   U3_aag(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(53) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(54)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AGA(R, append_out_aag(E, Y, R)) -> FL_IN_AGA(Y)
   FL_IN_AGA(R) -> U1_AGA(R, append_in_aag(R))

The TRS R consists of the following rules:

   append_in_aag(X) -> append_out_aag([], X, X)

The set Q consists of the following terms:

   append_in_aag(x0)
   U3_aag(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(55) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   U3_aag(x0, x1, x2)


----------------------------------------

(56)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AGA(R, append_out_aag(E, Y, R)) -> FL_IN_AGA(Y)
   FL_IN_AGA(R) -> U1_AGA(R, append_in_aag(R))

The TRS R consists of the following rules:

   append_in_aag(X) -> append_out_aag([], X, X)

The set Q consists of the following terms:

   append_in_aag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(57) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule FL_IN_AGA(R) -> U1_AGA(R, append_in_aag(R)) at position [1] we obtained the following new rules [LPAR04]:

   (FL_IN_AGA(R) -> U1_AGA(R, append_out_aag([], R, R)),FL_IN_AGA(R) -> U1_AGA(R, append_out_aag([], R, R)))


----------------------------------------

(58)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AGA(R, append_out_aag(E, Y, R)) -> FL_IN_AGA(Y)
   FL_IN_AGA(R) -> U1_AGA(R, append_out_aag([], R, R))

The TRS R consists of the following rules:

   append_in_aag(X) -> append_out_aag([], X, X)

The set Q consists of the following terms:

   append_in_aag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(59) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(60)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AGA(R, append_out_aag(E, Y, R)) -> FL_IN_AGA(Y)
   FL_IN_AGA(R) -> U1_AGA(R, append_out_aag([], R, R))

R is empty.
The set Q consists of the following terms:

   append_in_aag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(61) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   append_in_aag(x0)


----------------------------------------

(62)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AGA(R, append_out_aag(E, Y, R)) -> FL_IN_AGA(Y)
   FL_IN_AGA(R) -> U1_AGA(R, append_out_aag([], R, R))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(63) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U1_AGA(R, append_out_aag(E, Y, R)) -> FL_IN_AGA(Y) we obtained the following new rules [LPAR04]:

   (U1_AGA(z0, append_out_aag([], z0, z0)) -> FL_IN_AGA(z0),U1_AGA(z0, append_out_aag([], z0, z0)) -> FL_IN_AGA(z0))


----------------------------------------

(64)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   FL_IN_AGA(R) -> U1_AGA(R, append_out_aag([], R, R))
   U1_AGA(z0, append_out_aag([], z0, z0)) -> FL_IN_AGA(z0)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(65) PrologToDTProblemTransformerProof (SOUND)
Built DT problem from termination graph DT10.

{
    "root": 184,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(fl ([]) ([]) (0))",
                null
            ],
            [
                "(fl (. E X) R (s Z))",
                "(',' (append E Y R) (fl X Y Z))"
            ],
            [
                "(append ([]) X X)",
                null
            ],
            [
                "(append (. X Xs) Ys (. X Zs))",
                "(append Xs Ys Zs)"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "type": "Nodes",
            "230": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(fl T33 T32 T34)"
                }],
                "kb": {
                    "nonunifying": [[
                        "(fl T1 T32 T3)",
                        "(fl ([]) ([]) (0))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T32"],
                    "free": [],
                    "exprvars": []
                }
            },
            "198": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (append T10 X9 ([])) (fl T11 X9 T12))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": ["X9"],
                    "exprvars": []
                }
            },
            "231": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "199": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "232": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (append T44 X58 T43) (fl T45 X58 T46))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T43"],
                    "free": ["X58"],
                    "exprvars": []
                }
            },
            "233": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "212": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "234": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(append T44 X58 T43)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T43"],
                    "free": ["X58"],
                    "exprvars": []
                }
            },
            "235": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(fl T50 T49 T51)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T49"],
                    "free": [],
                    "exprvars": []
                }
            },
            "236": {
                "goal": [
                    {
                        "clause": 2,
                        "scope": 4,
                        "term": "(append T44 X58 T43)"
                    },
                    {
                        "clause": 3,
                        "scope": 4,
                        "term": "(append T44 X58 T43)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T43"],
                    "free": ["X58"],
                    "exprvars": []
                }
            },
            "237": {
                "goal": [{
                    "clause": 2,
                    "scope": 4,
                    "term": "(append T44 X58 T43)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T43"],
                    "free": ["X58"],
                    "exprvars": []
                }
            },
            "238": {
                "goal": [{
                    "clause": 3,
                    "scope": 4,
                    "term": "(append T44 X58 T43)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T43"],
                    "free": ["X58"],
                    "exprvars": []
                }
            },
            "239": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "219": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (append T25 X33 T23) (fl T26 X33 T27))"
                }],
                "kb": {
                    "nonunifying": [[
                        "(fl T1 T23 T3)",
                        "(fl ([]) ([]) (0))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T23"],
                    "free": ["X33"],
                    "exprvars": []
                }
            },
            "184": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(fl T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T2"],
                    "free": [],
                    "exprvars": []
                }
            },
            "185": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 1,
                        "term": "(fl T1 T2 T3)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(fl T1 T2 T3)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T2"],
                    "free": [],
                    "exprvars": []
                }
            },
            "240": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "186": {
                "goal": [
                    {
                        "clause": -1,
                        "scope": -1,
                        "term": "(true)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(fl T1 ([]) T3)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "241": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "187": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(fl T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [[
                        "(fl T1 T2 T3)",
                        "(fl ([]) ([]) (0))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T2"],
                    "free": [],
                    "exprvars": []
                }
            },
            "242": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(append T68 X91 T67)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T67"],
                    "free": ["X91"],
                    "exprvars": []
                }
            },
            "188": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(fl T1 ([]) T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "243": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "200": {
                "goal": [
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(',' (append T10 X9 ([])) (fl T11 X9 T12))"
                    },
                    {
                        "clause": 3,
                        "scope": 2,
                        "term": "(',' (append T10 X9 ([])) (fl T11 X9 T12))"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": ["X9"],
                    "exprvars": []
                }
            },
            "204": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(',' (append T10 X9 ([])) (fl T11 X9 T12))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": ["X9"],
                    "exprvars": []
                }
            },
            "226": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "205": {
                "goal": [{
                    "clause": 3,
                    "scope": 2,
                    "term": "(',' (append T10 X9 ([])) (fl T11 X9 T12))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": ["X9"],
                    "exprvars": []
                }
            },
            "227": {
                "goal": [
                    {
                        "clause": 2,
                        "scope": 3,
                        "term": "(',' (append T25 X33 T23) (fl T26 X33 T27))"
                    },
                    {
                        "clause": 3,
                        "scope": 3,
                        "term": "(',' (append T25 X33 T23) (fl T26 X33 T27))"
                    }
                ],
                "kb": {
                    "nonunifying": [[
                        "(fl T1 T23 T3)",
                        "(fl ([]) ([]) (0))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T23"],
                    "free": ["X33"],
                    "exprvars": []
                }
            },
            "206": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(fl T13 ([]) T14)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "228": {
                "goal": [{
                    "clause": 2,
                    "scope": 3,
                    "term": "(',' (append T25 X33 T23) (fl T26 X33 T27))"
                }],
                "kb": {
                    "nonunifying": [[
                        "(fl T1 T23 T3)",
                        "(fl ([]) ([]) (0))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T23"],
                    "free": ["X33"],
                    "exprvars": []
                }
            },
            "207": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "229": {
                "goal": [{
                    "clause": 3,
                    "scope": 3,
                    "term": "(',' (append T25 X33 T23) (fl T26 X33 T27))"
                }],
                "kb": {
                    "nonunifying": [[
                        "(fl T1 T23 T3)",
                        "(fl ([]) ([]) (0))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T23"],
                    "free": ["X33"],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 184,
                "to": 185,
                "label": "CASE"
            },
            {
                "from": 185,
                "to": 186,
                "label": "EVAL with clause\nfl([], [], 0).\nand substitutionT1 -> [],\nT2 -> [],\nT3 -> 0"
            },
            {
                "from": 185,
                "to": 187,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 186,
                "to": 188,
                "label": "SUCCESS"
            },
            {
                "from": 187,
                "to": 219,
                "label": "EVAL with clause\nfl(.(X29, X30), X31, s(X32)) :- ','(append(X29, X33, X31), fl(X30, X33, X32)).\nand substitutionX29 -> T25,\nX30 -> T26,\nT1 -> .(T25, T26),\nT2 -> T23,\nX31 -> T23,\nX32 -> T27,\nT3 -> s(T27),\nT21 -> T25,\nT22 -> T26,\nT24 -> T27"
            },
            {
                "from": 187,
                "to": 226,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 188,
                "to": 198,
                "label": "EVAL with clause\nfl(.(X5, X6), X7, s(X8)) :- ','(append(X5, X9, X7), fl(X6, X9, X8)).\nand substitutionX5 -> T10,\nX6 -> T11,\nT1 -> .(T10, T11),\nX7 -> [],\nX8 -> T12,\nT3 -> s(T12),\nT7 -> T10,\nT8 -> T11,\nT9 -> T12"
            },
            {
                "from": 188,
                "to": 199,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 198,
                "to": 200,
                "label": "CASE"
            },
            {
                "from": 200,
                "to": 204,
                "label": "PARALLEL"
            },
            {
                "from": 200,
                "to": 205,
                "label": "PARALLEL"
            },
            {
                "from": 204,
                "to": 206,
                "label": "EVAL with clause\nappend([], X18, X18).\nand substitutionT10 -> [],\nX9 -> [],\nX18 -> [],\nX19 -> [],\nT11 -> T13,\nT12 -> T14"
            },
            {
                "from": 204,
                "to": 207,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 205,
                "to": 212,
                "label": "BACKTRACK\nfor clause: append(.(X, Xs), Ys, .(X, Zs)) :- append(Xs, Ys, Zs)because of non-unification"
            },
            {
                "from": 206,
                "to": 184,
                "label": "INSTANCE with matching:\nT1 -> T13\nT2 -> []\nT3 -> T14"
            },
            {
                "from": 219,
                "to": 227,
                "label": "CASE"
            },
            {
                "from": 227,
                "to": 228,
                "label": "PARALLEL"
            },
            {
                "from": 227,
                "to": 229,
                "label": "PARALLEL"
            },
            {
                "from": 228,
                "to": 230,
                "label": "EVAL with clause\nappend([], X42, X42).\nand substitutionT25 -> [],\nX33 -> T32,\nX42 -> T32,\nT23 -> T32,\nX43 -> T32,\nT26 -> T33,\nT27 -> T34"
            },
            {
                "from": 228,
                "to": 231,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 229,
                "to": 232,
                "label": "EVAL with clause\nappend(.(X54, X55), X56, .(X54, X57)) :- append(X55, X56, X57).\nand substitutionX54 -> T41,\nX55 -> T44,\nT25 -> .(T41, T44),\nX33 -> X58,\nX56 -> X58,\nX57 -> T43,\nT23 -> .(T41, T43),\nT42 -> T44,\nT26 -> T45,\nT27 -> T46"
            },
            {
                "from": 229,
                "to": 233,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 230,
                "to": 184,
                "label": "INSTANCE with matching:\nT1 -> T33\nT2 -> T32\nT3 -> T34"
            },
            {
                "from": 232,
                "to": 234,
                "label": "SPLIT 1"
            },
            {
                "from": 232,
                "to": 235,
                "label": "SPLIT 2\nnew knowledge:\nT44 is ground\nT49 is ground\nT43 is ground\nreplacements:X58 -> T49,\nT45 -> T50,\nT46 -> T51"
            },
            {
                "from": 234,
                "to": 236,
                "label": "CASE"
            },
            {
                "from": 235,
                "to": 184,
                "label": "INSTANCE with matching:\nT1 -> T50\nT2 -> T49\nT3 -> T51"
            },
            {
                "from": 236,
                "to": 237,
                "label": "PARALLEL"
            },
            {
                "from": 236,
                "to": 238,
                "label": "PARALLEL"
            },
            {
                "from": 237,
                "to": 239,
                "label": "EVAL with clause\nappend([], X75, X75).\nand substitutionT44 -> [],\nX58 -> T58,\nX75 -> T58,\nT43 -> T58,\nX76 -> T58"
            },
            {
                "from": 237,
                "to": 240,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 238,
                "to": 242,
                "label": "EVAL with clause\nappend(.(X87, X88), X89, .(X87, X90)) :- append(X88, X89, X90).\nand substitutionX87 -> T65,\nX88 -> T68,\nT44 -> .(T65, T68),\nX58 -> X91,\nX89 -> X91,\nX90 -> T67,\nT43 -> .(T65, T67),\nT66 -> T68"
            },
            {
                "from": 238,
                "to": 243,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 239,
                "to": 241,
                "label": "SUCCESS"
            },
            {
                "from": 242,
                "to": 234,
                "label": "INSTANCE with matching:\nT44 -> T68\nX58 -> X91\nT43 -> T67"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(66)
Obligation:
Triples:

appendB(.(X1, X2), X3, .(X1, X4)) :- appendB(X2, X3, X4).
flA(.([], X1), [], s(X2)) :- flA(X1, [], X2).
flA(.([], X1), X2, s(X3)) :- flA(X1, X2, X3).
flA(.(.(X1, X2), X3), .(X1, X4), s(X5)) :- appendB(X2, X6, X4).
flA(.(.(X1, X2), X3), .(X1, X4), s(X5)) :- ','(appendcB(X2, X6, X4), flA(X3, X6, X5)).

Clauses:

flcA([], [], 0).
flcA(.([], X1), [], s(X2)) :- flcA(X1, [], X2).
flcA(.([], X1), X2, s(X3)) :- flcA(X1, X2, X3).
flcA(.(.(X1, X2), X3), .(X1, X4), s(X5)) :- ','(appendcB(X2, X6, X4), flcA(X3, X6, X5)).
appendcB([], X1, X1).
appendcB(.(X1, X2), X3, .(X1, X4)) :- appendcB(X2, X3, X4).

Afs:

flA(x1, x2, x3)  =  flA(x2)


----------------------------------------

(67) TriplesToPiDPProof (SOUND)
We use the technique of [DT09]. With regard to the inferred argument filtering the predicates were used in the following modes:

flA_in_3: (f,b,f)

appendB_in_3: (f,f,b)

appendcB_in_3: (f,f,b)

Transforming TRIPLES into the following Term Rewriting System:

Pi DP problem:
The TRS P consists of the following rules:

   FLA_IN_AGA(.([], X1), [], s(X2)) -> U2_AGA(X1, X2, flA_in_aga(X1, [], X2))
   FLA_IN_AGA(.([], X1), [], s(X2)) -> FLA_IN_AGA(X1, [], X2)
   FLA_IN_AGA(.([], X1), X2, s(X3)) -> U3_AGA(X1, X2, X3, flA_in_aga(X1, X2, X3))
   FLA_IN_AGA(.([], X1), X2, s(X3)) -> FLA_IN_AGA(X1, X2, X3)
   FLA_IN_AGA(.(.(X1, X2), X3), .(X1, X4), s(X5)) -> U4_AGA(X1, X2, X3, X4, X5, appendB_in_aag(X2, X6, X4))
   FLA_IN_AGA(.(.(X1, X2), X3), .(X1, X4), s(X5)) -> APPENDB_IN_AAG(X2, X6, X4)
   APPENDB_IN_AAG(.(X1, X2), X3, .(X1, X4)) -> U1_AAG(X1, X2, X3, X4, appendB_in_aag(X2, X3, X4))
   APPENDB_IN_AAG(.(X1, X2), X3, .(X1, X4)) -> APPENDB_IN_AAG(X2, X3, X4)
   FLA_IN_AGA(.(.(X1, X2), X3), .(X1, X4), s(X5)) -> U5_AGA(X1, X2, X3, X4, X5, appendcB_in_aag(X2, X6, X4))
   U5_AGA(X1, X2, X3, X4, X5, appendcB_out_aag(X2, X6, X4)) -> U6_AGA(X1, X2, X3, X4, X5, flA_in_aga(X3, X6, X5))
   U5_AGA(X1, X2, X3, X4, X5, appendcB_out_aag(X2, X6, X4)) -> FLA_IN_AGA(X3, X6, X5)

The TRS R consists of the following rules:

   appendcB_in_aag([], X1, X1) -> appendcB_out_aag([], X1, X1)
   appendcB_in_aag(.(X1, X2), X3, .(X1, X4)) -> U12_aag(X1, X2, X3, X4, appendcB_in_aag(X2, X3, X4))
   U12_aag(X1, X2, X3, X4, appendcB_out_aag(X2, X3, X4)) -> appendcB_out_aag(.(X1, X2), X3, .(X1, X4))

The argument filtering Pi contains the following mapping:
flA_in_aga(x1, x2, x3)  =  flA_in_aga(x2)

[]  =  []

.(x1, x2)  =  .(x1, x2)

appendB_in_aag(x1, x2, x3)  =  appendB_in_aag(x3)

appendcB_in_aag(x1, x2, x3)  =  appendcB_in_aag(x3)

appendcB_out_aag(x1, x2, x3)  =  appendcB_out_aag(x1, x2, x3)

U12_aag(x1, x2, x3, x4, x5)  =  U12_aag(x1, x4, x5)

FLA_IN_AGA(x1, x2, x3)  =  FLA_IN_AGA(x2)

U2_AGA(x1, x2, x3)  =  U2_AGA(x3)

U3_AGA(x1, x2, x3, x4)  =  U3_AGA(x2, x4)

U4_AGA(x1, x2, x3, x4, x5, x6)  =  U4_AGA(x1, x4, x6)

APPENDB_IN_AAG(x1, x2, x3)  =  APPENDB_IN_AAG(x3)

U1_AAG(x1, x2, x3, x4, x5)  =  U1_AAG(x1, x4, x5)

U5_AGA(x1, x2, x3, x4, x5, x6)  =  U5_AGA(x1, x4, x6)

U6_AGA(x1, x2, x3, x4, x5, x6)  =  U6_AGA(x1, x4, x6)


We have to consider all (P,R,Pi)-chains


Infinitary Constructor Rewriting Termination of PiDP implies Termination of TRIPLES



----------------------------------------

(68)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   FLA_IN_AGA(.([], X1), [], s(X2)) -> U2_AGA(X1, X2, flA_in_aga(X1, [], X2))
   FLA_IN_AGA(.([], X1), [], s(X2)) -> FLA_IN_AGA(X1, [], X2)
   FLA_IN_AGA(.([], X1), X2, s(X3)) -> U3_AGA(X1, X2, X3, flA_in_aga(X1, X2, X3))
   FLA_IN_AGA(.([], X1), X2, s(X3)) -> FLA_IN_AGA(X1, X2, X3)
   FLA_IN_AGA(.(.(X1, X2), X3), .(X1, X4), s(X5)) -> U4_AGA(X1, X2, X3, X4, X5, appendB_in_aag(X2, X6, X4))
   FLA_IN_AGA(.(.(X1, X2), X3), .(X1, X4), s(X5)) -> APPENDB_IN_AAG(X2, X6, X4)
   APPENDB_IN_AAG(.(X1, X2), X3, .(X1, X4)) -> U1_AAG(X1, X2, X3, X4, appendB_in_aag(X2, X3, X4))
   APPENDB_IN_AAG(.(X1, X2), X3, .(X1, X4)) -> APPENDB_IN_AAG(X2, X3, X4)
   FLA_IN_AGA(.(.(X1, X2), X3), .(X1, X4), s(X5)) -> U5_AGA(X1, X2, X3, X4, X5, appendcB_in_aag(X2, X6, X4))
   U5_AGA(X1, X2, X3, X4, X5, appendcB_out_aag(X2, X6, X4)) -> U6_AGA(X1, X2, X3, X4, X5, flA_in_aga(X3, X6, X5))
   U5_AGA(X1, X2, X3, X4, X5, appendcB_out_aag(X2, X6, X4)) -> FLA_IN_AGA(X3, X6, X5)

The TRS R consists of the following rules:

   appendcB_in_aag([], X1, X1) -> appendcB_out_aag([], X1, X1)
   appendcB_in_aag(.(X1, X2), X3, .(X1, X4)) -> U12_aag(X1, X2, X3, X4, appendcB_in_aag(X2, X3, X4))
   U12_aag(X1, X2, X3, X4, appendcB_out_aag(X2, X3, X4)) -> appendcB_out_aag(.(X1, X2), X3, .(X1, X4))

The argument filtering Pi contains the following mapping:
flA_in_aga(x1, x2, x3)  =  flA_in_aga(x2)

[]  =  []

.(x1, x2)  =  .(x1, x2)

appendB_in_aag(x1, x2, x3)  =  appendB_in_aag(x3)

appendcB_in_aag(x1, x2, x3)  =  appendcB_in_aag(x3)

appendcB_out_aag(x1, x2, x3)  =  appendcB_out_aag(x1, x2, x3)

U12_aag(x1, x2, x3, x4, x5)  =  U12_aag(x1, x4, x5)

FLA_IN_AGA(x1, x2, x3)  =  FLA_IN_AGA(x2)

U2_AGA(x1, x2, x3)  =  U2_AGA(x3)

U3_AGA(x1, x2, x3, x4)  =  U3_AGA(x2, x4)

U4_AGA(x1, x2, x3, x4, x5, x6)  =  U4_AGA(x1, x4, x6)

APPENDB_IN_AAG(x1, x2, x3)  =  APPENDB_IN_AAG(x3)

U1_AAG(x1, x2, x3, x4, x5)  =  U1_AAG(x1, x4, x5)

U5_AGA(x1, x2, x3, x4, x5, x6)  =  U5_AGA(x1, x4, x6)

U6_AGA(x1, x2, x3, x4, x5, x6)  =  U6_AGA(x1, x4, x6)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(69) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 2 SCCs with 6 less nodes.
----------------------------------------

(70)
Complex Obligation (AND)

----------------------------------------

(71)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   APPENDB_IN_AAG(.(X1, X2), X3, .(X1, X4)) -> APPENDB_IN_AAG(X2, X3, X4)

The TRS R consists of the following rules:

   appendcB_in_aag([], X1, X1) -> appendcB_out_aag([], X1, X1)
   appendcB_in_aag(.(X1, X2), X3, .(X1, X4)) -> U12_aag(X1, X2, X3, X4, appendcB_in_aag(X2, X3, X4))
   U12_aag(X1, X2, X3, X4, appendcB_out_aag(X2, X3, X4)) -> appendcB_out_aag(.(X1, X2), X3, .(X1, X4))

The argument filtering Pi contains the following mapping:
[]  =  []

.(x1, x2)  =  .(x1, x2)

appendcB_in_aag(x1, x2, x3)  =  appendcB_in_aag(x3)

appendcB_out_aag(x1, x2, x3)  =  appendcB_out_aag(x1, x2, x3)

U12_aag(x1, x2, x3, x4, x5)  =  U12_aag(x1, x4, x5)

APPENDB_IN_AAG(x1, x2, x3)  =  APPENDB_IN_AAG(x3)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(72) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(73)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   APPENDB_IN_AAG(.(X1, X2), X3, .(X1, X4)) -> APPENDB_IN_AAG(X2, X3, X4)

R is empty.
The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x1, x2)

APPENDB_IN_AAG(x1, x2, x3)  =  APPENDB_IN_AAG(x3)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(74) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(75)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   APPENDB_IN_AAG(.(X1, X4)) -> APPENDB_IN_AAG(X4)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(76) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*APPENDB_IN_AAG(.(X1, X4)) -> APPENDB_IN_AAG(X4)
The graph contains the following edges 1 > 1


----------------------------------------

(77)
YES

----------------------------------------

(78)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   FLA_IN_AGA(.([], X1), X2, s(X3)) -> FLA_IN_AGA(X1, X2, X3)
   FLA_IN_AGA(.([], X1), [], s(X2)) -> FLA_IN_AGA(X1, [], X2)
   FLA_IN_AGA(.(.(X1, X2), X3), .(X1, X4), s(X5)) -> U5_AGA(X1, X2, X3, X4, X5, appendcB_in_aag(X2, X6, X4))
   U5_AGA(X1, X2, X3, X4, X5, appendcB_out_aag(X2, X6, X4)) -> FLA_IN_AGA(X3, X6, X5)

The TRS R consists of the following rules:

   appendcB_in_aag([], X1, X1) -> appendcB_out_aag([], X1, X1)
   appendcB_in_aag(.(X1, X2), X3, .(X1, X4)) -> U12_aag(X1, X2, X3, X4, appendcB_in_aag(X2, X3, X4))
   U12_aag(X1, X2, X3, X4, appendcB_out_aag(X2, X3, X4)) -> appendcB_out_aag(.(X1, X2), X3, .(X1, X4))

The argument filtering Pi contains the following mapping:
[]  =  []

.(x1, x2)  =  .(x1, x2)

appendcB_in_aag(x1, x2, x3)  =  appendcB_in_aag(x3)

appendcB_out_aag(x1, x2, x3)  =  appendcB_out_aag(x1, x2, x3)

U12_aag(x1, x2, x3, x4, x5)  =  U12_aag(x1, x4, x5)

FLA_IN_AGA(x1, x2, x3)  =  FLA_IN_AGA(x2)

U5_AGA(x1, x2, x3, x4, x5, x6)  =  U5_AGA(x1, x4, x6)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(79) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(80)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   FLA_IN_AGA(X2) -> FLA_IN_AGA(X2)
   FLA_IN_AGA([]) -> FLA_IN_AGA([])
   FLA_IN_AGA(.(X1, X4)) -> U5_AGA(X1, X4, appendcB_in_aag(X4))
   U5_AGA(X1, X4, appendcB_out_aag(X2, X6, X4)) -> FLA_IN_AGA(X6)

The TRS R consists of the following rules:

   appendcB_in_aag(X1) -> appendcB_out_aag([], X1, X1)
   appendcB_in_aag(.(X1, X4)) -> U12_aag(X1, X4, appendcB_in_aag(X4))
   U12_aag(X1, X4, appendcB_out_aag(X2, X3, X4)) -> appendcB_out_aag(.(X1, X2), X3, .(X1, X4))

The set Q consists of the following terms:

   appendcB_in_aag(x0)
   U12_aag(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(81) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   FLA_IN_AGA(.(X1, X4)) -> U5_AGA(X1, X4, appendcB_in_aag(X4))
   U5_AGA(X1, X4, appendcB_out_aag(X2, X6, X4)) -> FLA_IN_AGA(X6)
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( U5_AGA_3(x_1, ..., x_3) ) = max{0, 2x_3 - 2}
POL( appendcB_in_aag_1(x_1) ) = x_1 + 2
POL( appendcB_out_aag_3(x_1, ..., x_3) ) = x_2 + 2
POL( [] ) = 0
POL( ._2(x_1, x_2) ) = x_2 + 2
POL( U12_aag_3(x_1, ..., x_3) ) = x_3 + 2
POL( FLA_IN_AGA_1(x_1) ) = 2x_1 + 1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   appendcB_in_aag(X1) -> appendcB_out_aag([], X1, X1)
   appendcB_in_aag(.(X1, X4)) -> U12_aag(X1, X4, appendcB_in_aag(X4))
   U12_aag(X1, X4, appendcB_out_aag(X2, X3, X4)) -> appendcB_out_aag(.(X1, X2), X3, .(X1, X4))


----------------------------------------

(82)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   FLA_IN_AGA(X2) -> FLA_IN_AGA(X2)
   FLA_IN_AGA([]) -> FLA_IN_AGA([])

The TRS R consists of the following rules:

   appendcB_in_aag(X1) -> appendcB_out_aag([], X1, X1)
   appendcB_in_aag(.(X1, X4)) -> U12_aag(X1, X4, appendcB_in_aag(X4))
   U12_aag(X1, X4, appendcB_out_aag(X2, X3, X4)) -> appendcB_out_aag(.(X1, X2), X3, .(X1, X4))

The set Q consists of the following terms:

   appendcB_in_aag(x0)
   U12_aag(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(83) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   FLA_IN_AGA(.(X1, X4)) -> U5_AGA(X1, X4, appendcB_in_aag(X4))
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
FLA_IN_AGA(x1)  =  x1

[]  =  []

.(x1, x2)  =  .(x2)

U5_AGA(x1, x2, x3)  =  x3

appendcB_in_aag(x1)  =  x1

appendcB_out_aag(x1, x2, x3)  =  x2

U12_aag(x1, x2, x3)  =  x3


Knuth-Bendix order [KBO] with precedence:trivial

and weight map:

   []=1
   ._1=1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   appendcB_in_aag(X1) -> appendcB_out_aag([], X1, X1)
   appendcB_in_aag(.(X1, X4)) -> U12_aag(X1, X4, appendcB_in_aag(X4))
   U12_aag(X1, X4, appendcB_out_aag(X2, X3, X4)) -> appendcB_out_aag(.(X1, X2), X3, .(X1, X4))


----------------------------------------

(84)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   FLA_IN_AGA(X2) -> FLA_IN_AGA(X2)
   FLA_IN_AGA([]) -> FLA_IN_AGA([])
   U5_AGA(X1, X4, appendcB_out_aag(X2, X6, X4)) -> FLA_IN_AGA(X6)

The TRS R consists of the following rules:

   appendcB_in_aag(X1) -> appendcB_out_aag([], X1, X1)
   appendcB_in_aag(.(X1, X4)) -> U12_aag(X1, X4, appendcB_in_aag(X4))
   U12_aag(X1, X4, appendcB_out_aag(X2, X3, X4)) -> appendcB_out_aag(.(X1, X2), X3, .(X1, X4))

The set Q consists of the following terms:

   appendcB_in_aag(x0)
   U12_aag(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(85) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   FLA_IN_AGA(.(X1, X4)) -> U5_AGA(X1, X4, appendcB_in_aag(X4))
   U5_AGA(X1, X4, appendcB_out_aag(X2, X6, X4)) -> FLA_IN_AGA(X6)

Strictly oriented rules of the TRS R:

   appendcB_in_aag(.(X1, X4)) -> U12_aag(X1, X4, appendcB_in_aag(X4))
   U12_aag(X1, X4, appendcB_out_aag(X2, X3, X4)) -> appendcB_out_aag(.(X1, X2), X3, .(X1, X4))

Used ordering: Polynomial interpretation [POLO]:

   POL(.(x_1, x_2)) = 2 + 2*x_2
   POL(FLA_IN_AGA(x_1)) = 2 + 2*x_1
   POL(U12_aag(x_1, x_2, x_3)) = 2*x_3
   POL(U5_AGA(x_1, x_2, x_3)) = 2*x_3
   POL([]) = 2
   POL(appendcB_in_aag(x_1)) = 2 + 2*x_1
   POL(appendcB_out_aag(x_1, x_2, x_3)) = 2 + 2*x_2


----------------------------------------

(86)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   FLA_IN_AGA(X2) -> FLA_IN_AGA(X2)
   FLA_IN_AGA([]) -> FLA_IN_AGA([])

The TRS R consists of the following rules:

   appendcB_in_aag(X1) -> appendcB_out_aag([], X1, X1)

The set Q consists of the following terms:

   appendcB_in_aag(x0)
   U12_aag(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(87) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(88)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   FLA_IN_AGA(X2) -> FLA_IN_AGA(X2)
   FLA_IN_AGA([]) -> FLA_IN_AGA([])

R is empty.
The set Q consists of the following terms:

   appendcB_in_aag(x0)
   U12_aag(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(89) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   appendcB_in_aag(x0)
   U12_aag(x0, x1, x2)


----------------------------------------

(90)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   FLA_IN_AGA(X2) -> FLA_IN_AGA(X2)
   FLA_IN_AGA([]) -> FLA_IN_AGA([])

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(91) PrologToTRSTransformerProof (SOUND)
Transformed Prolog program to TRS.

{
    "root": 5,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(fl ([]) ([]) (0))",
                null
            ],
            [
                "(fl (. E X) R (s Z))",
                "(',' (append E Y R) (fl X Y Z))"
            ],
            [
                "(append ([]) X X)",
                null
            ],
            [
                "(append (. X Xs) Ys (. X Zs))",
                "(append Xs Ys Zs)"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "12": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 1,
                        "term": "(fl T1 T2 T3)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(fl T1 T2 T3)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T2"],
                    "free": [],
                    "exprvars": []
                }
            },
            "13": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(fl T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T2"],
                    "free": [],
                    "exprvars": []
                }
            },
            "14": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(fl T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T2"],
                    "free": [],
                    "exprvars": []
                }
            },
            "190": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(append T16 X14 T14)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": ["X14"],
                    "exprvars": []
                }
            },
            "180": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(append T16 X14 T14)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": ["X14"],
                    "exprvars": []
                }
            },
            "191": {
                "goal": [{
                    "clause": 3,
                    "scope": 2,
                    "term": "(append T16 X14 T14)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": ["X14"],
                    "exprvars": []
                }
            },
            "181": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(fl T22 T21 T23)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T21"],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "195": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "174": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "196": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "197": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "166": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "167": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "189": {
                "goal": [
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(append T16 X14 T14)"
                    },
                    {
                        "clause": 3,
                        "scope": 2,
                        "term": "(append T16 X14 T14)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": ["X14"],
                    "exprvars": []
                }
            },
            "168": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "169": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (append T16 X14 T14) (fl T17 X14 T18))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": ["X14"],
                    "exprvars": []
                }
            },
            "5": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(fl T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T2"],
                    "free": [],
                    "exprvars": []
                }
            },
            "208": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(append T40 X47 T39)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T39"],
                    "free": ["X47"],
                    "exprvars": []
                }
            },
            "209": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 5,
                "to": 12,
                "label": "CASE"
            },
            {
                "from": 12,
                "to": 13,
                "label": "PARALLEL"
            },
            {
                "from": 12,
                "to": 14,
                "label": "PARALLEL"
            },
            {
                "from": 13,
                "to": 166,
                "label": "EVAL with clause\nfl([], [], 0).\nand substitutionT1 -> [],\nT2 -> [],\nT3 -> 0"
            },
            {
                "from": 13,
                "to": 167,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 14,
                "to": 169,
                "label": "EVAL with clause\nfl(.(X10, X11), X12, s(X13)) :- ','(append(X10, X14, X12), fl(X11, X14, X13)).\nand substitutionX10 -> T16,\nX11 -> T17,\nT1 -> .(T16, T17),\nT2 -> T14,\nX12 -> T14,\nX13 -> T18,\nT3 -> s(T18),\nT12 -> T16,\nT13 -> T17,\nT15 -> T18"
            },
            {
                "from": 14,
                "to": 174,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 166,
                "to": 168,
                "label": "SUCCESS"
            },
            {
                "from": 169,
                "to": 180,
                "label": "SPLIT 1"
            },
            {
                "from": 169,
                "to": 181,
                "label": "SPLIT 2\nnew knowledge:\nT16 is ground\nT21 is ground\nT14 is ground\nreplacements:X14 -> T21,\nT17 -> T22,\nT18 -> T23"
            },
            {
                "from": 180,
                "to": 189,
                "label": "CASE"
            },
            {
                "from": 181,
                "to": 5,
                "label": "INSTANCE with matching:\nT1 -> T22\nT2 -> T21\nT3 -> T23"
            },
            {
                "from": 189,
                "to": 190,
                "label": "PARALLEL"
            },
            {
                "from": 189,
                "to": 191,
                "label": "PARALLEL"
            },
            {
                "from": 190,
                "to": 195,
                "label": "EVAL with clause\nappend([], X31, X31).\nand substitutionT16 -> [],\nX14 -> T30,\nX31 -> T30,\nT14 -> T30,\nX32 -> T30"
            },
            {
                "from": 190,
                "to": 196,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 191,
                "to": 208,
                "label": "EVAL with clause\nappend(.(X43, X44), X45, .(X43, X46)) :- append(X44, X45, X46).\nand substitutionX43 -> T37,\nX44 -> T40,\nT16 -> .(T37, T40),\nX14 -> X47,\nX45 -> X47,\nX46 -> T39,\nT14 -> .(T37, T39),\nT38 -> T40"
            },
            {
                "from": 191,
                "to": 209,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 195,
                "to": 197,
                "label": "SUCCESS"
            },
            {
                "from": 208,
                "to": 180,
                "label": "INSTANCE with matching:\nT16 -> T40\nX14 -> X47\nT14 -> T39"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(92)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f5_in([]) -> f5_out1([], 0)
   f5_in(T14) -> U1(f169_in(T14), T14)
   U1(f169_out1(T16, X14, T17, T18), T14) -> f5_out1(.(T16, T17), s(T18))
   f180_in(T30) -> f180_out1([], T30)
   f180_in(.(T37, T39)) -> U2(f180_in(T39), .(T37, T39))
   U2(f180_out1(T40, X47), .(T37, T39)) -> f180_out1(.(T37, T40), X47)
   f169_in(T14) -> U3(f180_in(T14), T14)
   U3(f180_out1(T16, T21), T14) -> U4(f5_in(T21), T14, T16, T21)
   U4(f5_out1(T22, T23), T14, T16, T21) -> f169_out1(T16, T21, T22, T23)

Q is empty.

----------------------------------------

(93) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(94)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F5_IN(T14) -> U1^1(f169_in(T14), T14)
   F5_IN(T14) -> F169_IN(T14)
   F180_IN(.(T37, T39)) -> U2^1(f180_in(T39), .(T37, T39))
   F180_IN(.(T37, T39)) -> F180_IN(T39)
   F169_IN(T14) -> U3^1(f180_in(T14), T14)
   F169_IN(T14) -> F180_IN(T14)
   U3^1(f180_out1(T16, T21), T14) -> U4^1(f5_in(T21), T14, T16, T21)
   U3^1(f180_out1(T16, T21), T14) -> F5_IN(T21)

The TRS R consists of the following rules:

   f5_in([]) -> f5_out1([], 0)
   f5_in(T14) -> U1(f169_in(T14), T14)
   U1(f169_out1(T16, X14, T17, T18), T14) -> f5_out1(.(T16, T17), s(T18))
   f180_in(T30) -> f180_out1([], T30)
   f180_in(.(T37, T39)) -> U2(f180_in(T39), .(T37, T39))
   U2(f180_out1(T40, X47), .(T37, T39)) -> f180_out1(.(T37, T40), X47)
   f169_in(T14) -> U3(f180_in(T14), T14)
   U3(f180_out1(T16, T21), T14) -> U4(f5_in(T21), T14, T16, T21)
   U4(f5_out1(T22, T23), T14, T16, T21) -> f169_out1(T16, T21, T22, T23)

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(95) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 4 less nodes.
----------------------------------------

(96)
Complex Obligation (AND)

----------------------------------------

(97)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F180_IN(.(T37, T39)) -> F180_IN(T39)

The TRS R consists of the following rules:

   f5_in([]) -> f5_out1([], 0)
   f5_in(T14) -> U1(f169_in(T14), T14)
   U1(f169_out1(T16, X14, T17, T18), T14) -> f5_out1(.(T16, T17), s(T18))
   f180_in(T30) -> f180_out1([], T30)
   f180_in(.(T37, T39)) -> U2(f180_in(T39), .(T37, T39))
   U2(f180_out1(T40, X47), .(T37, T39)) -> f180_out1(.(T37, T40), X47)
   f169_in(T14) -> U3(f180_in(T14), T14)
   U3(f180_out1(T16, T21), T14) -> U4(f5_in(T21), T14, T16, T21)
   U4(f5_out1(T22, T23), T14, T16, T21) -> f169_out1(T16, T21, T22, T23)

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(98) UsableRulesProof (EQUIVALENT)
We can use the usable rules and reduction pair processor [LPAR04] with the Ce-compatible extension of the polynomial order that maps every function symbol to the sum of its arguments. Then, we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(99)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F180_IN(.(T37, T39)) -> F180_IN(T39)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(100) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*F180_IN(.(T37, T39)) -> F180_IN(T39)
The graph contains the following edges 1 > 1


----------------------------------------

(101)
YES

----------------------------------------

(102)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F5_IN(T14) -> F169_IN(T14)
   F169_IN(T14) -> U3^1(f180_in(T14), T14)
   U3^1(f180_out1(T16, T21), T14) -> F5_IN(T21)

The TRS R consists of the following rules:

   f5_in([]) -> f5_out1([], 0)
   f5_in(T14) -> U1(f169_in(T14), T14)
   U1(f169_out1(T16, X14, T17, T18), T14) -> f5_out1(.(T16, T17), s(T18))
   f180_in(T30) -> f180_out1([], T30)
   f180_in(.(T37, T39)) -> U2(f180_in(T39), .(T37, T39))
   U2(f180_out1(T40, X47), .(T37, T39)) -> f180_out1(.(T37, T40), X47)
   f169_in(T14) -> U3(f180_in(T14), T14)
   U3(f180_out1(T16, T21), T14) -> U4(f5_in(T21), T14, T16, T21)
   U4(f5_out1(T22, T23), T14, T16, T21) -> f169_out1(T16, T21, T22, T23)

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(103) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = F169_IN(T14) evaluates to  t =F169_IN(T14)

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

F169_IN(T14) -> U3^1(f180_in(T14), T14)
with rule F169_IN(T14') -> U3^1(f180_in(T14'), T14') at position [] and matcher [T14' / T14]

U3^1(f180_in(T14), T14) -> U3^1(f180_out1([], T14), T14)
with rule f180_in(T30) -> f180_out1([], T30) at position [0] and matcher [T30 / T14]

U3^1(f180_out1([], T14), T14) -> F5_IN(T14)
with rule U3^1(f180_out1(T16, T21), T14') -> F5_IN(T21) at position [] and matcher [T16 / [], T21 / T14, T14' / T14]

F5_IN(T14) -> F169_IN(T14)
with rule F5_IN(T14) -> F169_IN(T14)

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(104)
NO

----------------------------------------

(105) PrologToIRSwTTransformerProof (SOUND)
Transformed Prolog program to IRSwT according to method in Master Thesis of A. Weinert

{
    "root": 152,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(fl ([]) ([]) (0))",
                null
            ],
            [
                "(fl (. E X) R (s Z))",
                "(',' (append E Y R) (fl X Y Z))"
            ],
            [
                "(append ([]) X X)",
                null
            ],
            [
                "(append (. X Xs) Ys (. X Zs))",
                "(append Xs Ys Zs)"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "192": {
                "goal": [
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(append T16 X14 T14)"
                    },
                    {
                        "clause": 3,
                        "scope": 2,
                        "term": "(append T16 X14 T14)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": ["X14"],
                    "exprvars": []
                }
            },
            "182": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(append T16 X14 T14)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": ["X14"],
                    "exprvars": []
                }
            },
            "193": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(append T16 X14 T14)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": ["X14"],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "183": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(fl T22 T21 T23)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T21"],
                    "free": [],
                    "exprvars": []
                }
            },
            "194": {
                "goal": [{
                    "clause": 3,
                    "scope": 2,
                    "term": "(append T16 X14 T14)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": ["X14"],
                    "exprvars": []
                }
            },
            "152": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(fl T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T2"],
                    "free": [],
                    "exprvars": []
                }
            },
            "175": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "176": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "155": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 1,
                        "term": "(fl T1 T2 T3)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(fl T1 T2 T3)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T2"],
                    "free": [],
                    "exprvars": []
                }
            },
            "177": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "210": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(append T40 X47 T39)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T39"],
                    "free": ["X47"],
                    "exprvars": []
                }
            },
            "178": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (append T16 X14 T14) (fl T17 X14 T18))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": ["X14"],
                    "exprvars": []
                }
            },
            "211": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "157": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(fl T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T2"],
                    "free": [],
                    "exprvars": []
                }
            },
            "179": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "201": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "158": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(fl T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T2"],
                    "free": [],
                    "exprvars": []
                }
            },
            "202": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "203": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 152,
                "to": 155,
                "label": "CASE"
            },
            {
                "from": 155,
                "to": 157,
                "label": "PARALLEL"
            },
            {
                "from": 155,
                "to": 158,
                "label": "PARALLEL"
            },
            {
                "from": 157,
                "to": 175,
                "label": "EVAL with clause\nfl([], [], 0).\nand substitutionT1 -> [],\nT2 -> [],\nT3 -> 0"
            },
            {
                "from": 157,
                "to": 176,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 158,
                "to": 178,
                "label": "EVAL with clause\nfl(.(X10, X11), X12, s(X13)) :- ','(append(X10, X14, X12), fl(X11, X14, X13)).\nand substitutionX10 -> T16,\nX11 -> T17,\nT1 -> .(T16, T17),\nT2 -> T14,\nX12 -> T14,\nX13 -> T18,\nT3 -> s(T18),\nT12 -> T16,\nT13 -> T17,\nT15 -> T18"
            },
            {
                "from": 158,
                "to": 179,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 175,
                "to": 177,
                "label": "SUCCESS"
            },
            {
                "from": 178,
                "to": 182,
                "label": "SPLIT 1"
            },
            {
                "from": 178,
                "to": 183,
                "label": "SPLIT 2\nnew knowledge:\nT16 is ground\nT21 is ground\nT14 is ground\nreplacements:X14 -> T21,\nT17 -> T22,\nT18 -> T23"
            },
            {
                "from": 182,
                "to": 192,
                "label": "CASE"
            },
            {
                "from": 183,
                "to": 152,
                "label": "INSTANCE with matching:\nT1 -> T22\nT2 -> T21\nT3 -> T23"
            },
            {
                "from": 192,
                "to": 193,
                "label": "PARALLEL"
            },
            {
                "from": 192,
                "to": 194,
                "label": "PARALLEL"
            },
            {
                "from": 193,
                "to": 201,
                "label": "EVAL with clause\nappend([], X31, X31).\nand substitutionT16 -> [],\nX14 -> T30,\nX31 -> T30,\nT14 -> T30,\nX32 -> T30"
            },
            {
                "from": 193,
                "to": 202,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 194,
                "to": 210,
                "label": "EVAL with clause\nappend(.(X43, X44), X45, .(X43, X46)) :- append(X44, X45, X46).\nand substitutionX43 -> T37,\nX44 -> T40,\nT16 -> .(T37, T40),\nX14 -> X47,\nX45 -> X47,\nX46 -> T39,\nT14 -> .(T37, T39),\nT38 -> T40"
            },
            {
                "from": 194,
                "to": 211,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 201,
                "to": 203,
                "label": "SUCCESS"
            },
            {
                "from": 210,
                "to": 182,
                "label": "INSTANCE with matching:\nT16 -> T40\nX14 -> X47\nT14 -> T39"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(106)
Complex Obligation (AND)

----------------------------------------

(107)
Obligation:
Rules:
f192_in(T14) -> f194_in(T14) :|: TRUE
f192_in(x) -> f193_in(x) :|: TRUE
f193_out(x1) -> f192_out(x1) :|: TRUE
f194_out(x2) -> f192_out(x2) :|: TRUE
f210_in(T39) -> f182_in(T39) :|: TRUE
f182_out(x3) -> f210_out(x3) :|: TRUE
f182_in(x4) -> f192_in(x4) :|: TRUE
f192_out(x5) -> f182_out(x5) :|: TRUE
f194_in(.(x6, x7)) -> f210_in(x7) :|: TRUE
f210_out(x8) -> f194_out(.(x9, x8)) :|: TRUE
f194_in(x10) -> f211_in :|: TRUE
f211_out -> f194_out(x11) :|: TRUE
f155_out(T2) -> f152_out(T2) :|: TRUE
f152_in(x12) -> f155_in(x12) :|: TRUE
f158_out(x13) -> f155_out(x13) :|: TRUE
f157_out(x14) -> f155_out(x14) :|: TRUE
f155_in(x15) -> f157_in(x15) :|: TRUE
f155_in(x16) -> f158_in(x16) :|: TRUE
f179_out -> f158_out(x17) :|: TRUE
f158_in(x18) -> f178_in(x18) :|: TRUE
f158_in(x19) -> f179_in :|: TRUE
f178_out(x20) -> f158_out(x20) :|: TRUE
f182_out(x21) -> f183_in(x22) :|: TRUE
f183_out(x23) -> f178_out(x24) :|: TRUE
f178_in(x25) -> f182_in(x25) :|: TRUE
Start term: f152_in(T2)

----------------------------------------

(108) IRSwTSimpleDependencyGraphProof (EQUIVALENT)
Constructed simple dependency graph.

Simplified to the following IRSwTs:

intTRSProblem:
f192_in(T14) -> f194_in(T14) :|: TRUE
f210_in(T39) -> f182_in(T39) :|: TRUE
f182_in(x4) -> f192_in(x4) :|: TRUE
f194_in(.(x6, x7)) -> f210_in(x7) :|: TRUE


----------------------------------------

(109)
Obligation:
Rules:
f192_in(T14) -> f194_in(T14) :|: TRUE
f210_in(T39) -> f182_in(T39) :|: TRUE
f182_in(x4) -> f192_in(x4) :|: TRUE
f194_in(.(x6, x7)) -> f210_in(x7) :|: TRUE

----------------------------------------

(110) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(111)
Obligation:
Rules:
f210_in(.(x6:0, x7:0)) -> f210_in(x7:0) :|: TRUE

----------------------------------------

(112) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(113)
Obligation:
Rules:
f210_in(.(x6:0, x7:0)) -> f210_in(x7:0) :|: TRUE

----------------------------------------

(114) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f210_in(.(x6:0, x7:0)) -> f210_in(x7:0) :|: TRUE

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(115)
Obligation:

Termination digraph:
Nodes:
(1) f210_in(.(x6:0, x7:0)) -> f210_in(x7:0) :|: TRUE

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(116) IntTRSUnneededArgumentFilterProof (EQUIVALENT)
Some arguments are removed because they cannot influence termination. We removed arguments according to the following replacements:

   .(x1, x2) -> .(x2)

----------------------------------------

(117)
Obligation:
Rules:
f210_in(.(x7:0)) -> f210_in(x7:0) :|: TRUE

----------------------------------------

(118) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f210_in(VARIABLE)
.(VARIABLE)
Removed predefined arithmetic.
----------------------------------------

(119)
Obligation:
Rules:
f210_in(.(x7:0)) -> f210_in(x7:0)

----------------------------------------

(120) IRSwTToQDPProof (SOUND)
Removed the integers and created a QDP-Problem.
----------------------------------------

(121)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   f210_in(.(x7:0)) -> f210_in(x7:0)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(122) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*f210_in(.(x7:0)) -> f210_in(x7:0)
The graph contains the following edges 1 > 1


----------------------------------------

(123)
YES

----------------------------------------

(124)
Obligation:
Rules:
f183_in(T21) -> f152_in(T21) :|: TRUE
f152_out(x) -> f183_out(x) :|: TRUE
f210_in(T39) -> f182_in(T39) :|: TRUE
f182_out(x1) -> f210_out(x1) :|: TRUE
f194_in(.(x2, x3)) -> f210_in(x3) :|: TRUE
f210_out(x4) -> f194_out(.(x5, x4)) :|: TRUE
f194_in(T14) -> f211_in :|: TRUE
f211_out -> f194_out(x6) :|: TRUE
f201_out -> f193_out(T30) :|: TRUE
f193_in(x7) -> f202_in :|: TRUE
f193_in(x8) -> f201_in :|: TRUE
f202_out -> f193_out(x9) :|: TRUE
f179_out -> f158_out(T2) :|: TRUE
f158_in(x10) -> f178_in(x10) :|: TRUE
f158_in(x11) -> f179_in :|: TRUE
f178_out(x12) -> f158_out(x12) :|: TRUE
f182_out(x13) -> f183_in(x14) :|: TRUE
f183_out(x15) -> f178_out(x16) :|: TRUE
f178_in(x17) -> f182_in(x17) :|: TRUE
f155_out(x18) -> f152_out(x18) :|: TRUE
f152_in(x19) -> f155_in(x19) :|: TRUE
f158_out(x20) -> f155_out(x20) :|: TRUE
f157_out(x21) -> f155_out(x21) :|: TRUE
f155_in(x22) -> f157_in(x22) :|: TRUE
f155_in(x23) -> f158_in(x23) :|: TRUE
f192_in(x24) -> f194_in(x24) :|: TRUE
f192_in(x25) -> f193_in(x25) :|: TRUE
f193_out(x26) -> f192_out(x26) :|: TRUE
f194_out(x27) -> f192_out(x27) :|: TRUE
f201_in -> f201_out :|: TRUE
f182_in(x28) -> f192_in(x28) :|: TRUE
f192_out(x29) -> f182_out(x29) :|: TRUE
Start term: f152_in(T2)

----------------------------------------

(125) IRSwTSimpleDependencyGraphProof (EQUIVALENT)
Constructed simple dependency graph.

Simplified to the following IRSwTs:

intTRSProblem:
f183_in(T21) -> f152_in(T21) :|: TRUE
f210_in(T39) -> f182_in(T39) :|: TRUE
f182_out(x1) -> f210_out(x1) :|: TRUE
f194_in(.(x2, x3)) -> f210_in(x3) :|: TRUE
f210_out(x4) -> f194_out(.(x5, x4)) :|: TRUE
f201_out -> f193_out(T30) :|: TRUE
f193_in(x8) -> f201_in :|: TRUE
f158_in(x10) -> f178_in(x10) :|: TRUE
f182_out(x13) -> f183_in(x14) :|: TRUE
f178_in(x17) -> f182_in(x17) :|: TRUE
f152_in(x19) -> f155_in(x19) :|: TRUE
f155_in(x23) -> f158_in(x23) :|: TRUE
f192_in(x24) -> f194_in(x24) :|: TRUE
f192_in(x25) -> f193_in(x25) :|: TRUE
f193_out(x26) -> f192_out(x26) :|: TRUE
f194_out(x27) -> f192_out(x27) :|: TRUE
f201_in -> f201_out :|: TRUE
f182_in(x28) -> f192_in(x28) :|: TRUE
f192_out(x29) -> f182_out(x29) :|: TRUE


----------------------------------------

(126)
Obligation:
Rules:
f183_in(T21) -> f152_in(T21) :|: TRUE
f210_in(T39) -> f182_in(T39) :|: TRUE
f182_out(x1) -> f210_out(x1) :|: TRUE
f194_in(.(x2, x3)) -> f210_in(x3) :|: TRUE
f210_out(x4) -> f194_out(.(x5, x4)) :|: TRUE
f201_out -> f193_out(T30) :|: TRUE
f193_in(x8) -> f201_in :|: TRUE
f158_in(x10) -> f178_in(x10) :|: TRUE
f182_out(x13) -> f183_in(x14) :|: TRUE
f178_in(x17) -> f182_in(x17) :|: TRUE
f152_in(x19) -> f155_in(x19) :|: TRUE
f155_in(x23) -> f158_in(x23) :|: TRUE
f192_in(x24) -> f194_in(x24) :|: TRUE
f192_in(x25) -> f193_in(x25) :|: TRUE
f193_out(x26) -> f192_out(x26) :|: TRUE
f194_out(x27) -> f192_out(x27) :|: TRUE
f201_in -> f201_out :|: TRUE
f182_in(x28) -> f192_in(x28) :|: TRUE
f192_out(x29) -> f182_out(x29) :|: TRUE
