MAYBE
proof of /hpcwork/ff862203/termcomp25/benchmarks/AqIUV.pl
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Left Termination of the query pattern

p(g,g)

w.r.t. the given Prolog program could not be shown:

(0) Prolog
(1) PrologToPiTRSProof [SOUND, 0 ms]
(2) PiTRS
    (3) DependencyPairsProof [EQUIVALENT, 0 ms]
    (4) PiDP
    (5) DependencyGraphProof [EQUIVALENT, 0 ms]
    (6) PiDP
    (7) UsableRulesProof [EQUIVALENT, 0 ms]
    (8) PiDP
    (9) PiDPToQDPProof [EQUIVALENT, 0 ms]
    (10) QDP
    (11) TransformationProof [EQUIVALENT, 0 ms]
    (12) QDP
    (13) TransformationProof [EQUIVALENT, 0 ms]
    (14) QDP
    (15) QDPOrderProof [EQUIVALENT, 0 ms]
    (16) QDP
    (17) QDPOrderProof [EQUIVALENT, 0 ms]
    (18) QDP
    (19) DependencyGraphProof [EQUIVALENT, 0 ms]
    (20) AND
        (21) QDP
            (22) TransformationProof [EQUIVALENT, 0 ms]
            (23) QDP
            (24) NonTerminationLoopProof [COMPLETE, 0 ms]
            (25) NO
        (26) QDP
            (27) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (28) YES
(29) PrologToPiTRSProof [SOUND, 0 ms]
(30) PiTRS
    (31) DependencyPairsProof [EQUIVALENT, 0 ms]
    (32) PiDP
    (33) DependencyGraphProof [EQUIVALENT, 0 ms]
    (34) PiDP
    (35) UsableRulesProof [EQUIVALENT, 0 ms]
    (36) PiDP
    (37) PiDPToQDPProof [EQUIVALENT, 0 ms]
    (38) QDP
    (39) TransformationProof [EQUIVALENT, 0 ms]
    (40) QDP
    (41) TransformationProof [EQUIVALENT, 0 ms]
    (42) QDP
    (43) QDPOrderProof [EQUIVALENT, 0 ms]
    (44) QDP
    (45) QDPOrderProof [EQUIVALENT, 0 ms]
    (46) QDP
    (47) DependencyGraphProof [EQUIVALENT, 0 ms]
    (48) AND
        (49) QDP
            (50) TransformationProof [EQUIVALENT, 0 ms]
            (51) QDP
            (52) NonTerminationLoopProof [COMPLETE, 0 ms]
            (53) NO
        (54) QDP
            (55) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (56) YES
(57) PrologToTRSTransformerProof [SOUND, 0 ms]
(58) QTRS
    (59) Overlay + Local Confluence [EQUIVALENT, 0 ms]
    (60) QTRS
    (61) DependencyPairsProof [EQUIVALENT, 0 ms]
    (62) QDP
    (63) DependencyGraphProof [EQUIVALENT, 0 ms]
    (64) QDP
    (65) UsableRulesProof [EQUIVALENT, 0 ms]
    (66) QDP
    (67) QReductionProof [EQUIVALENT, 0 ms]
    (68) QDP
    (69) TransformationProof [EQUIVALENT, 0 ms]
    (70) QDP
    (71) TransformationProof [EQUIVALENT, 0 ms]
    (72) QDP
    (73) QDPOrderProof [EQUIVALENT, 0 ms]
    (74) QDP
    (75) QDPOrderProof [EQUIVALENT, 0 ms]
    (76) QDP
    (77) DependencyGraphProof [EQUIVALENT, 0 ms]
    (78) AND
        (79) QDP
            (80) TransformationProof [EQUIVALENT, 0 ms]
            (81) QDP
            (82) NonTerminationLoopProof [COMPLETE, 0 ms]
            (83) NO
        (84) QDP
            (85) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (86) YES
(87) PrologToDTProblemTransformerProof [SOUND, 0 ms]
(88) TRIPLES
    (89) TriplesToPiDPProof [SOUND, 12 ms]
    (90) PiDP
    (91) DependencyGraphProof [EQUIVALENT, 0 ms]
    (92) PiDP
    (93) PiDPToQDPProof [EQUIVALENT, 0 ms]
    (94) QDP
    (95) QDPOrderProof [EQUIVALENT, 1 ms]
    (96) QDP
    (97) MRRProof [EQUIVALENT, 5 ms]
    (98) QDP
    (99) TransformationProof [EQUIVALENT, 0 ms]
    (100) QDP
    (101) DependencyGraphProof [EQUIVALENT, 0 ms]
    (102) AND
        (103) QDP
            (104) NonTerminationLoopProof [COMPLETE, 0 ms]
            (105) NO
        (106) QDP
            (107) TransformationProof [EQUIVALENT, 0 ms]
            (108) QDP
            (109) NonTerminationLoopProof [COMPLETE, 0 ms]
            (110) NO
(111) PrologToIRSwTTransformerProof [SOUND, 0 ms]
(112) IRSwT
    (113) IRSwTSimpleDependencyGraphProof [EQUIVALENT, 0 ms]
    (114) IRSwT
    (115) IntTRSCompressionProof [EQUIVALENT, 39 ms]
    (116) IRSwT
    (117) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
    (118) IRSwT
    (119) IRSwTTerminationDigraphProof [EQUIVALENT, 16 ms]
    (120) IRSwT
    (121) IntTRSCompressionProof [EQUIVALENT, 0 ms]
    (122) IRSwT
    (123) IntTRSUnneededArgumentFilterProof [EQUIVALENT, 0 ms]
    (124) IRSwT
    (125) IRSwTToIntTRSProof [SOUND, 0 ms]
    (126) IRSwT
    (127) IntTRSCompressionProof [EQUIVALENT, 1 ms]
    (128) IRSwT


----------------------------------------

(0)
Obligation:
Clauses:

p(X, .(0, [])) :- p(g(.(0, []), .(0, [])), X).
p(X, g(Y, Y)) :- p(X, Y).


Query: p(g,g)
----------------------------------------

(1) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

p_in_2: (b,b)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   p_in_gg(X, .(0, [])) -> U1_gg(X, p_in_gg(g(.(0, []), .(0, [])), X))
   p_in_gg(X, g(Y, Y)) -> U2_gg(X, Y, p_in_gg(X, Y))
   U2_gg(X, Y, p_out_gg(X, Y)) -> p_out_gg(X, g(Y, Y))
   U1_gg(X, p_out_gg(g(.(0, []), .(0, [])), X)) -> p_out_gg(X, .(0, []))

Pi is empty.



Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(2)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   p_in_gg(X, .(0, [])) -> U1_gg(X, p_in_gg(g(.(0, []), .(0, [])), X))
   p_in_gg(X, g(Y, Y)) -> U2_gg(X, Y, p_in_gg(X, Y))
   U2_gg(X, Y, p_out_gg(X, Y)) -> p_out_gg(X, g(Y, Y))
   U1_gg(X, p_out_gg(g(.(0, []), .(0, [])), X)) -> p_out_gg(X, .(0, []))

Pi is empty.

----------------------------------------

(3) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, .(0, [])) -> U1_GG(X, p_in_gg(g(.(0, []), .(0, [])), X))
   P_IN_GG(X, .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), X)
   P_IN_GG(X, g(Y, Y)) -> U2_GG(X, Y, p_in_gg(X, Y))
   P_IN_GG(X, g(Y, Y)) -> P_IN_GG(X, Y)

The TRS R consists of the following rules:

   p_in_gg(X, .(0, [])) -> U1_gg(X, p_in_gg(g(.(0, []), .(0, [])), X))
   p_in_gg(X, g(Y, Y)) -> U2_gg(X, Y, p_in_gg(X, Y))
   U2_gg(X, Y, p_out_gg(X, Y)) -> p_out_gg(X, g(Y, Y))
   U1_gg(X, p_out_gg(g(.(0, []), .(0, [])), X)) -> p_out_gg(X, .(0, []))

Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(4)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, .(0, [])) -> U1_GG(X, p_in_gg(g(.(0, []), .(0, [])), X))
   P_IN_GG(X, .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), X)
   P_IN_GG(X, g(Y, Y)) -> U2_GG(X, Y, p_in_gg(X, Y))
   P_IN_GG(X, g(Y, Y)) -> P_IN_GG(X, Y)

The TRS R consists of the following rules:

   p_in_gg(X, .(0, [])) -> U1_gg(X, p_in_gg(g(.(0, []), .(0, [])), X))
   p_in_gg(X, g(Y, Y)) -> U2_gg(X, Y, p_in_gg(X, Y))
   U2_gg(X, Y, p_out_gg(X, Y)) -> p_out_gg(X, g(Y, Y))
   U1_gg(X, p_out_gg(g(.(0, []), .(0, [])), X)) -> p_out_gg(X, .(0, []))

Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(5) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 2 less nodes.
----------------------------------------

(6)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, g(Y, Y)) -> P_IN_GG(X, Y)
   P_IN_GG(X, .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), X)

The TRS R consists of the following rules:

   p_in_gg(X, .(0, [])) -> U1_gg(X, p_in_gg(g(.(0, []), .(0, [])), X))
   p_in_gg(X, g(Y, Y)) -> U2_gg(X, Y, p_in_gg(X, Y))
   U2_gg(X, Y, p_out_gg(X, Y)) -> p_out_gg(X, g(Y, Y))
   U1_gg(X, p_out_gg(g(.(0, []), .(0, [])), X)) -> p_out_gg(X, .(0, []))

Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(7) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(8)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, g(Y, Y)) -> P_IN_GG(X, Y)
   P_IN_GG(X, .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), X)

R is empty.
Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(9) PiDPToQDPProof (EQUIVALENT)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(10)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, g(Y, Y)) -> P_IN_GG(X, Y)
   P_IN_GG(X, .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), X)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(11) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule P_IN_GG(X, g(Y, Y)) -> P_IN_GG(X, Y) we obtained the following new rules [LPAR04]:

   (P_IN_GG(x0, g(.(0, []), .(0, []))) -> P_IN_GG(x0, .(0, [])),P_IN_GG(x0, g(.(0, []), .(0, []))) -> P_IN_GG(x0, .(0, [])))
   (P_IN_GG(x0, g(g(y_1, y_2), g(y_1, y_2))) -> P_IN_GG(x0, g(y_1, y_2)),P_IN_GG(x0, g(g(y_1, y_2), g(y_1, y_2))) -> P_IN_GG(x0, g(y_1, y_2)))


----------------------------------------

(12)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), X)
   P_IN_GG(x0, g(.(0, []), .(0, []))) -> P_IN_GG(x0, .(0, []))
   P_IN_GG(x0, g(g(y_1, y_2), g(y_1, y_2))) -> P_IN_GG(x0, g(y_1, y_2))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(13) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule P_IN_GG(X, .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), X) we obtained the following new rules [LPAR04]:

   (P_IN_GG(.(0, []), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), .(0, [])),P_IN_GG(.(0, []), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), .(0, [])))
   (P_IN_GG(g(.(0, []), .(0, [])), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))),P_IN_GG(g(.(0, []), .(0, [])), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))))
   (P_IN_GG(g(g(y_1, y_2), g(y_3, y_4)), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(g(y_1, y_2), g(y_3, y_4))),P_IN_GG(g(g(y_1, y_2), g(y_3, y_4)), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(g(y_1, y_2), g(y_3, y_4))))


----------------------------------------

(14)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(x0, g(.(0, []), .(0, []))) -> P_IN_GG(x0, .(0, []))
   P_IN_GG(x0, g(g(y_1, y_2), g(y_1, y_2))) -> P_IN_GG(x0, g(y_1, y_2))
   P_IN_GG(.(0, []), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), .(0, []))
   P_IN_GG(g(.(0, []), .(0, [])), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))
   P_IN_GG(g(g(y_1, y_2), g(y_3, y_4)), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(g(y_1, y_2), g(y_3, y_4)))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(15) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   P_IN_GG(.(0, []), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), .(0, []))
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
P_IN_GG(x1, x2)  =  x1

.(x1, x2)  =  .

0  =  0

[]  =  []

g(x1, x2)  =  g


Knuth-Bendix order [KBO] with precedence:. > g

and weight map:

   .=1
   g=1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:
none


----------------------------------------

(16)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(x0, g(.(0, []), .(0, []))) -> P_IN_GG(x0, .(0, []))
   P_IN_GG(x0, g(g(y_1, y_2), g(y_1, y_2))) -> P_IN_GG(x0, g(y_1, y_2))
   P_IN_GG(g(.(0, []), .(0, [])), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))
   P_IN_GG(g(g(y_1, y_2), g(y_3, y_4)), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(g(y_1, y_2), g(y_3, y_4)))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(17) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   P_IN_GG(g(g(y_1, y_2), g(y_3, y_4)), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(g(y_1, y_2), g(y_3, y_4)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
P_IN_GG(x1, x2)  =  x1

g(x1, x2)  =  g(x2)

.(x1, x2)  =  .

0  =  0

[]  =  []


Knuth-Bendix order [KBO] with precedence:trivial

and weight map:

   .=1
   g_1=1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:
none


----------------------------------------

(18)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(x0, g(.(0, []), .(0, []))) -> P_IN_GG(x0, .(0, []))
   P_IN_GG(x0, g(g(y_1, y_2), g(y_1, y_2))) -> P_IN_GG(x0, g(y_1, y_2))
   P_IN_GG(g(.(0, []), .(0, [])), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(19) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs.
----------------------------------------

(20)
Complex Obligation (AND)

----------------------------------------

(21)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(g(.(0, []), .(0, [])), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))
   P_IN_GG(x0, g(.(0, []), .(0, []))) -> P_IN_GG(x0, .(0, []))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(22) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule P_IN_GG(x0, g(.(0, []), .(0, []))) -> P_IN_GG(x0, .(0, [])) we obtained the following new rules [LPAR04]:

   (P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) -> P_IN_GG(g(.(0, []), .(0, [])), .(0, [])),P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) -> P_IN_GG(g(.(0, []), .(0, [])), .(0, [])))


----------------------------------------

(23)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(g(.(0, []), .(0, [])), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))
   P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) -> P_IN_GG(g(.(0, []), .(0, [])), .(0, []))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(24) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) evaluates to  t =P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) -> P_IN_GG(g(.(0, []), .(0, [])), .(0, []))
with rule P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) -> P_IN_GG(g(.(0, []), .(0, [])), .(0, [])) at position [] and matcher [ ]

P_IN_GG(g(.(0, []), .(0, [])), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))
with rule P_IN_GG(g(.(0, []), .(0, [])), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(25)
NO

----------------------------------------

(26)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(x0, g(g(y_1, y_2), g(y_1, y_2))) -> P_IN_GG(x0, g(y_1, y_2))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(27) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*P_IN_GG(x0, g(g(y_1, y_2), g(y_1, y_2))) -> P_IN_GG(x0, g(y_1, y_2))
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(28)
YES

----------------------------------------

(29) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

p_in_2: (b,b)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   p_in_gg(X, .(0, [])) -> U1_gg(X, p_in_gg(g(.(0, []), .(0, [])), X))
   p_in_gg(X, g(Y, Y)) -> U2_gg(X, Y, p_in_gg(X, Y))
   U2_gg(X, Y, p_out_gg(X, Y)) -> p_out_gg(X, g(Y, Y))
   U1_gg(X, p_out_gg(g(.(0, []), .(0, [])), X)) -> p_out_gg(X, .(0, []))

The argument filtering Pi contains the following mapping:
p_in_gg(x1, x2)  =  p_in_gg(x1, x2)

.(x1, x2)  =  .(x1, x2)

0  =  0

[]  =  []

U1_gg(x1, x2)  =  U1_gg(x2)

g(x1, x2)  =  g(x1, x2)

U2_gg(x1, x2, x3)  =  U2_gg(x3)

p_out_gg(x1, x2)  =  p_out_gg





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(30)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   p_in_gg(X, .(0, [])) -> U1_gg(X, p_in_gg(g(.(0, []), .(0, [])), X))
   p_in_gg(X, g(Y, Y)) -> U2_gg(X, Y, p_in_gg(X, Y))
   U2_gg(X, Y, p_out_gg(X, Y)) -> p_out_gg(X, g(Y, Y))
   U1_gg(X, p_out_gg(g(.(0, []), .(0, [])), X)) -> p_out_gg(X, .(0, []))

The argument filtering Pi contains the following mapping:
p_in_gg(x1, x2)  =  p_in_gg(x1, x2)

.(x1, x2)  =  .(x1, x2)

0  =  0

[]  =  []

U1_gg(x1, x2)  =  U1_gg(x2)

g(x1, x2)  =  g(x1, x2)

U2_gg(x1, x2, x3)  =  U2_gg(x3)

p_out_gg(x1, x2)  =  p_out_gg



----------------------------------------

(31) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, .(0, [])) -> U1_GG(X, p_in_gg(g(.(0, []), .(0, [])), X))
   P_IN_GG(X, .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), X)
   P_IN_GG(X, g(Y, Y)) -> U2_GG(X, Y, p_in_gg(X, Y))
   P_IN_GG(X, g(Y, Y)) -> P_IN_GG(X, Y)

The TRS R consists of the following rules:

   p_in_gg(X, .(0, [])) -> U1_gg(X, p_in_gg(g(.(0, []), .(0, [])), X))
   p_in_gg(X, g(Y, Y)) -> U2_gg(X, Y, p_in_gg(X, Y))
   U2_gg(X, Y, p_out_gg(X, Y)) -> p_out_gg(X, g(Y, Y))
   U1_gg(X, p_out_gg(g(.(0, []), .(0, [])), X)) -> p_out_gg(X, .(0, []))

The argument filtering Pi contains the following mapping:
p_in_gg(x1, x2)  =  p_in_gg(x1, x2)

.(x1, x2)  =  .(x1, x2)

0  =  0

[]  =  []

U1_gg(x1, x2)  =  U1_gg(x2)

g(x1, x2)  =  g(x1, x2)

U2_gg(x1, x2, x3)  =  U2_gg(x3)

p_out_gg(x1, x2)  =  p_out_gg

P_IN_GG(x1, x2)  =  P_IN_GG(x1, x2)

U1_GG(x1, x2)  =  U1_GG(x2)

U2_GG(x1, x2, x3)  =  U2_GG(x3)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(32)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, .(0, [])) -> U1_GG(X, p_in_gg(g(.(0, []), .(0, [])), X))
   P_IN_GG(X, .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), X)
   P_IN_GG(X, g(Y, Y)) -> U2_GG(X, Y, p_in_gg(X, Y))
   P_IN_GG(X, g(Y, Y)) -> P_IN_GG(X, Y)

The TRS R consists of the following rules:

   p_in_gg(X, .(0, [])) -> U1_gg(X, p_in_gg(g(.(0, []), .(0, [])), X))
   p_in_gg(X, g(Y, Y)) -> U2_gg(X, Y, p_in_gg(X, Y))
   U2_gg(X, Y, p_out_gg(X, Y)) -> p_out_gg(X, g(Y, Y))
   U1_gg(X, p_out_gg(g(.(0, []), .(0, [])), X)) -> p_out_gg(X, .(0, []))

The argument filtering Pi contains the following mapping:
p_in_gg(x1, x2)  =  p_in_gg(x1, x2)

.(x1, x2)  =  .(x1, x2)

0  =  0

[]  =  []

U1_gg(x1, x2)  =  U1_gg(x2)

g(x1, x2)  =  g(x1, x2)

U2_gg(x1, x2, x3)  =  U2_gg(x3)

p_out_gg(x1, x2)  =  p_out_gg

P_IN_GG(x1, x2)  =  P_IN_GG(x1, x2)

U1_GG(x1, x2)  =  U1_GG(x2)

U2_GG(x1, x2, x3)  =  U2_GG(x3)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(33) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 2 less nodes.
----------------------------------------

(34)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, g(Y, Y)) -> P_IN_GG(X, Y)
   P_IN_GG(X, .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), X)

The TRS R consists of the following rules:

   p_in_gg(X, .(0, [])) -> U1_gg(X, p_in_gg(g(.(0, []), .(0, [])), X))
   p_in_gg(X, g(Y, Y)) -> U2_gg(X, Y, p_in_gg(X, Y))
   U2_gg(X, Y, p_out_gg(X, Y)) -> p_out_gg(X, g(Y, Y))
   U1_gg(X, p_out_gg(g(.(0, []), .(0, [])), X)) -> p_out_gg(X, .(0, []))

The argument filtering Pi contains the following mapping:
p_in_gg(x1, x2)  =  p_in_gg(x1, x2)

.(x1, x2)  =  .(x1, x2)

0  =  0

[]  =  []

U1_gg(x1, x2)  =  U1_gg(x2)

g(x1, x2)  =  g(x1, x2)

U2_gg(x1, x2, x3)  =  U2_gg(x3)

p_out_gg(x1, x2)  =  p_out_gg

P_IN_GG(x1, x2)  =  P_IN_GG(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(35) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(36)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, g(Y, Y)) -> P_IN_GG(X, Y)
   P_IN_GG(X, .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), X)

R is empty.
Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(37) PiDPToQDPProof (EQUIVALENT)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(38)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, g(Y, Y)) -> P_IN_GG(X, Y)
   P_IN_GG(X, .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), X)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(39) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule P_IN_GG(X, g(Y, Y)) -> P_IN_GG(X, Y) we obtained the following new rules [LPAR04]:

   (P_IN_GG(x0, g(.(0, []), .(0, []))) -> P_IN_GG(x0, .(0, [])),P_IN_GG(x0, g(.(0, []), .(0, []))) -> P_IN_GG(x0, .(0, [])))
   (P_IN_GG(x0, g(g(y_1, y_2), g(y_1, y_2))) -> P_IN_GG(x0, g(y_1, y_2)),P_IN_GG(x0, g(g(y_1, y_2), g(y_1, y_2))) -> P_IN_GG(x0, g(y_1, y_2)))


----------------------------------------

(40)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), X)
   P_IN_GG(x0, g(.(0, []), .(0, []))) -> P_IN_GG(x0, .(0, []))
   P_IN_GG(x0, g(g(y_1, y_2), g(y_1, y_2))) -> P_IN_GG(x0, g(y_1, y_2))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(41) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule P_IN_GG(X, .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), X) we obtained the following new rules [LPAR04]:

   (P_IN_GG(.(0, []), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), .(0, [])),P_IN_GG(.(0, []), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), .(0, [])))
   (P_IN_GG(g(.(0, []), .(0, [])), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))),P_IN_GG(g(.(0, []), .(0, [])), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))))
   (P_IN_GG(g(g(y_1, y_2), g(y_3, y_4)), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(g(y_1, y_2), g(y_3, y_4))),P_IN_GG(g(g(y_1, y_2), g(y_3, y_4)), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(g(y_1, y_2), g(y_3, y_4))))


----------------------------------------

(42)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(x0, g(.(0, []), .(0, []))) -> P_IN_GG(x0, .(0, []))
   P_IN_GG(x0, g(g(y_1, y_2), g(y_1, y_2))) -> P_IN_GG(x0, g(y_1, y_2))
   P_IN_GG(.(0, []), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), .(0, []))
   P_IN_GG(g(.(0, []), .(0, [])), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))
   P_IN_GG(g(g(y_1, y_2), g(y_3, y_4)), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(g(y_1, y_2), g(y_3, y_4)))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(43) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   P_IN_GG(.(0, []), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), .(0, []))
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
P_IN_GG(x1, x2)  =  x1

.(x1, x2)  =  .

0  =  0

[]  =  []

g(x1, x2)  =  g


Knuth-Bendix order [KBO] with precedence:. > g

and weight map:

   .=1
   g=1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:
none


----------------------------------------

(44)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(x0, g(.(0, []), .(0, []))) -> P_IN_GG(x0, .(0, []))
   P_IN_GG(x0, g(g(y_1, y_2), g(y_1, y_2))) -> P_IN_GG(x0, g(y_1, y_2))
   P_IN_GG(g(.(0, []), .(0, [])), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))
   P_IN_GG(g(g(y_1, y_2), g(y_3, y_4)), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(g(y_1, y_2), g(y_3, y_4)))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(45) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   P_IN_GG(g(g(y_1, y_2), g(y_3, y_4)), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(g(y_1, y_2), g(y_3, y_4)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
P_IN_GG(x1, x2)  =  x1

g(x1, x2)  =  g(x2)

.(x1, x2)  =  .

0  =  0

[]  =  []


Knuth-Bendix order [KBO] with precedence:trivial

and weight map:

   .=1
   g_1=1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:
none


----------------------------------------

(46)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(x0, g(.(0, []), .(0, []))) -> P_IN_GG(x0, .(0, []))
   P_IN_GG(x0, g(g(y_1, y_2), g(y_1, y_2))) -> P_IN_GG(x0, g(y_1, y_2))
   P_IN_GG(g(.(0, []), .(0, [])), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(47) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs.
----------------------------------------

(48)
Complex Obligation (AND)

----------------------------------------

(49)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(g(.(0, []), .(0, [])), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))
   P_IN_GG(x0, g(.(0, []), .(0, []))) -> P_IN_GG(x0, .(0, []))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(50) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule P_IN_GG(x0, g(.(0, []), .(0, []))) -> P_IN_GG(x0, .(0, [])) we obtained the following new rules [LPAR04]:

   (P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) -> P_IN_GG(g(.(0, []), .(0, [])), .(0, [])),P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) -> P_IN_GG(g(.(0, []), .(0, [])), .(0, [])))


----------------------------------------

(51)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(g(.(0, []), .(0, [])), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))
   P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) -> P_IN_GG(g(.(0, []), .(0, [])), .(0, []))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(52) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) evaluates to  t =P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) -> P_IN_GG(g(.(0, []), .(0, [])), .(0, []))
with rule P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) -> P_IN_GG(g(.(0, []), .(0, [])), .(0, [])) at position [] and matcher [ ]

P_IN_GG(g(.(0, []), .(0, [])), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))
with rule P_IN_GG(g(.(0, []), .(0, [])), .(0, [])) -> P_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(53)
NO

----------------------------------------

(54)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(x0, g(g(y_1, y_2), g(y_1, y_2))) -> P_IN_GG(x0, g(y_1, y_2))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(55) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*P_IN_GG(x0, g(g(y_1, y_2), g(y_1, y_2))) -> P_IN_GG(x0, g(y_1, y_2))
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(56)
YES

----------------------------------------

(57) PrologToTRSTransformerProof (SOUND)
Transformed Prolog program to TRS.

{
    "root": 1,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(p X (. (0) ([])))",
                "(p (g (. (0) ([])) (. (0) ([]))) X)"
            ],
            [
                "(p X (g Y Y))",
                "(p X Y)"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "1": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "12": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(p T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "13": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(p T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "101": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p T12 T13)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T12",
                        "T13"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "102": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "4": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 1,
                        "term": "(p T1 T2)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(p T1 T2)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "62": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p (g (. (0) ([])) (. (0) ([]))) T7)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T7"],
                    "free": [],
                    "exprvars": []
                }
            },
            "63": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 1,
                "to": 4,
                "label": "CASE"
            },
            {
                "from": 4,
                "to": 12,
                "label": "PARALLEL"
            },
            {
                "from": 4,
                "to": 13,
                "label": "PARALLEL"
            },
            {
                "from": 12,
                "to": 62,
                "label": "EVAL with clause\np(X5, .(0, [])) :- p(g(.(0, []), .(0, [])), X5).\nand substitutionT1 -> T7,\nX5 -> T7,\nT2 -> .(0, [])"
            },
            {
                "from": 12,
                "to": 63,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 13,
                "to": 101,
                "label": "EVAL with clause\np(X11, g(X12, X12)) :- p(X11, X12).\nand substitutionT1 -> T12,\nX11 -> T12,\nX12 -> T13,\nT2 -> g(T13, T13)"
            },
            {
                "from": 13,
                "to": 102,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 62,
                "to": 1,
                "label": "INSTANCE with matching:\nT1 -> g(.(0, []), .(0, []))\nT2 -> T7"
            },
            {
                "from": 101,
                "to": 1,
                "label": "INSTANCE with matching:\nT1 -> T12\nT2 -> T13"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(58)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f1_in(T7, .(0, [])) -> U1(f1_in(g(.(0, []), .(0, [])), T7), T7, .(0, []))
   U1(f1_out1, T7, .(0, [])) -> f1_out1
   f1_in(T12, g(T13, T13)) -> U2(f1_in(T12, T13), T12, g(T13, T13))
   U2(f1_out1, T12, g(T13, T13)) -> f1_out1

Q is empty.

----------------------------------------

(59) Overlay + Local Confluence (EQUIVALENT)
The TRS is overlay and locally confluent. By [NOC] we can switch to innermost.
----------------------------------------

(60)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f1_in(T7, .(0, [])) -> U1(f1_in(g(.(0, []), .(0, [])), T7), T7, .(0, []))
   U1(f1_out1, T7, .(0, [])) -> f1_out1
   f1_in(T12, g(T13, T13)) -> U2(f1_in(T12, T13), T12, g(T13, T13))
   U2(f1_out1, T12, g(T13, T13)) -> f1_out1

The set Q consists of the following terms:

   f1_in(x0, .(0, []))
   U1(f1_out1, x0, .(0, []))
   f1_in(x0, g(x1, x1))
   U2(f1_out1, x0, g(x1, x1))


----------------------------------------

(61) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(62)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(T7, .(0, [])) -> U1^1(f1_in(g(.(0, []), .(0, [])), T7), T7, .(0, []))
   F1_IN(T7, .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), T7)
   F1_IN(T12, g(T13, T13)) -> U2^1(f1_in(T12, T13), T12, g(T13, T13))
   F1_IN(T12, g(T13, T13)) -> F1_IN(T12, T13)

The TRS R consists of the following rules:

   f1_in(T7, .(0, [])) -> U1(f1_in(g(.(0, []), .(0, [])), T7), T7, .(0, []))
   U1(f1_out1, T7, .(0, [])) -> f1_out1
   f1_in(T12, g(T13, T13)) -> U2(f1_in(T12, T13), T12, g(T13, T13))
   U2(f1_out1, T12, g(T13, T13)) -> f1_out1

The set Q consists of the following terms:

   f1_in(x0, .(0, []))
   U1(f1_out1, x0, .(0, []))
   f1_in(x0, g(x1, x1))
   U2(f1_out1, x0, g(x1, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(63) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(64)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(T12, g(T13, T13)) -> F1_IN(T12, T13)
   F1_IN(T7, .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), T7)

The TRS R consists of the following rules:

   f1_in(T7, .(0, [])) -> U1(f1_in(g(.(0, []), .(0, [])), T7), T7, .(0, []))
   U1(f1_out1, T7, .(0, [])) -> f1_out1
   f1_in(T12, g(T13, T13)) -> U2(f1_in(T12, T13), T12, g(T13, T13))
   U2(f1_out1, T12, g(T13, T13)) -> f1_out1

The set Q consists of the following terms:

   f1_in(x0, .(0, []))
   U1(f1_out1, x0, .(0, []))
   f1_in(x0, g(x1, x1))
   U2(f1_out1, x0, g(x1, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(65) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(66)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(T12, g(T13, T13)) -> F1_IN(T12, T13)
   F1_IN(T7, .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), T7)

R is empty.
The set Q consists of the following terms:

   f1_in(x0, .(0, []))
   U1(f1_out1, x0, .(0, []))
   f1_in(x0, g(x1, x1))
   U2(f1_out1, x0, g(x1, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(67) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   f1_in(x0, .(0, []))
   U1(f1_out1, x0, .(0, []))
   f1_in(x0, g(x1, x1))
   U2(f1_out1, x0, g(x1, x1))


----------------------------------------

(68)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(T12, g(T13, T13)) -> F1_IN(T12, T13)
   F1_IN(T7, .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), T7)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(69) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule F1_IN(T12, g(T13, T13)) -> F1_IN(T12, T13) we obtained the following new rules [LPAR04]:

   (F1_IN(x0, g(.(0, []), .(0, []))) -> F1_IN(x0, .(0, [])),F1_IN(x0, g(.(0, []), .(0, []))) -> F1_IN(x0, .(0, [])))
   (F1_IN(x0, g(g(y_1, y_2), g(y_1, y_2))) -> F1_IN(x0, g(y_1, y_2)),F1_IN(x0, g(g(y_1, y_2), g(y_1, y_2))) -> F1_IN(x0, g(y_1, y_2)))


----------------------------------------

(70)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(T7, .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), T7)
   F1_IN(x0, g(.(0, []), .(0, []))) -> F1_IN(x0, .(0, []))
   F1_IN(x0, g(g(y_1, y_2), g(y_1, y_2))) -> F1_IN(x0, g(y_1, y_2))

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(71) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule F1_IN(T7, .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), T7) we obtained the following new rules [LPAR04]:

   (F1_IN(.(0, []), .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), .(0, [])),F1_IN(.(0, []), .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), .(0, [])))
   (F1_IN(g(.(0, []), .(0, [])), .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))),F1_IN(g(.(0, []), .(0, [])), .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))))
   (F1_IN(g(g(y_1, y_2), g(y_3, y_4)), .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), g(g(y_1, y_2), g(y_3, y_4))),F1_IN(g(g(y_1, y_2), g(y_3, y_4)), .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), g(g(y_1, y_2), g(y_3, y_4))))


----------------------------------------

(72)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(x0, g(.(0, []), .(0, []))) -> F1_IN(x0, .(0, []))
   F1_IN(x0, g(g(y_1, y_2), g(y_1, y_2))) -> F1_IN(x0, g(y_1, y_2))
   F1_IN(.(0, []), .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), .(0, []))
   F1_IN(g(.(0, []), .(0, [])), .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))
   F1_IN(g(g(y_1, y_2), g(y_3, y_4)), .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), g(g(y_1, y_2), g(y_3, y_4)))

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(73) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   F1_IN(.(0, []), .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), .(0, []))
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
F1_IN(x1, x2)  =  x1

.(x1, x2)  =  .

0  =  0

[]  =  []

g(x1, x2)  =  g


Knuth-Bendix order [KBO] with precedence:. > g

and weight map:

   .=1
   g=1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:
none


----------------------------------------

(74)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(x0, g(.(0, []), .(0, []))) -> F1_IN(x0, .(0, []))
   F1_IN(x0, g(g(y_1, y_2), g(y_1, y_2))) -> F1_IN(x0, g(y_1, y_2))
   F1_IN(g(.(0, []), .(0, [])), .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))
   F1_IN(g(g(y_1, y_2), g(y_3, y_4)), .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), g(g(y_1, y_2), g(y_3, y_4)))

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(75) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   F1_IN(g(g(y_1, y_2), g(y_3, y_4)), .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), g(g(y_1, y_2), g(y_3, y_4)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
F1_IN(x1, x2)  =  x1

g(x1, x2)  =  g(x2)

.(x1, x2)  =  .

0  =  0

[]  =  []


Knuth-Bendix order [KBO] with precedence:trivial

and weight map:

   .=1
   g_1=1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:
none


----------------------------------------

(76)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(x0, g(.(0, []), .(0, []))) -> F1_IN(x0, .(0, []))
   F1_IN(x0, g(g(y_1, y_2), g(y_1, y_2))) -> F1_IN(x0, g(y_1, y_2))
   F1_IN(g(.(0, []), .(0, [])), .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(77) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs.
----------------------------------------

(78)
Complex Obligation (AND)

----------------------------------------

(79)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(g(.(0, []), .(0, [])), .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))
   F1_IN(x0, g(.(0, []), .(0, []))) -> F1_IN(x0, .(0, []))

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(80) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule F1_IN(x0, g(.(0, []), .(0, []))) -> F1_IN(x0, .(0, [])) we obtained the following new rules [LPAR04]:

   (F1_IN(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) -> F1_IN(g(.(0, []), .(0, [])), .(0, [])),F1_IN(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) -> F1_IN(g(.(0, []), .(0, [])), .(0, [])))


----------------------------------------

(81)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(g(.(0, []), .(0, [])), .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))
   F1_IN(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) -> F1_IN(g(.(0, []), .(0, [])), .(0, []))

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(82) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = F1_IN(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) evaluates to  t =F1_IN(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

F1_IN(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) -> F1_IN(g(.(0, []), .(0, [])), .(0, []))
with rule F1_IN(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) -> F1_IN(g(.(0, []), .(0, [])), .(0, [])) at position [] and matcher [ ]

F1_IN(g(.(0, []), .(0, [])), .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))
with rule F1_IN(g(.(0, []), .(0, [])), .(0, [])) -> F1_IN(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(83)
NO

----------------------------------------

(84)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(x0, g(g(y_1, y_2), g(y_1, y_2))) -> F1_IN(x0, g(y_1, y_2))

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(85) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*F1_IN(x0, g(g(y_1, y_2), g(y_1, y_2))) -> F1_IN(x0, g(y_1, y_2))
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(86)
YES

----------------------------------------

(87) PrologToDTProblemTransformerProof (SOUND)
Built DT problem from termination graph DT10.

{
    "root": 3,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(p X (. (0) ([])))",
                "(p (g (. (0) ([])) (. (0) ([]))) X)"
            ],
            [
                "(p X (g Y Y))",
                "(p X Y)"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "22": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(p T1 T2)"
                }],
                "kb": {
                    "nonunifying": [[
                        "(p T1 T2)",
                        "(p X2 (. (0) ([])))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": ["X2"],
                    "exprvars": []
                }
            },
            "23": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 2,
                        "term": "(p (g (. (0) ([])) (. (0) ([]))) T4)"
                    },
                    {
                        "clause": 1,
                        "scope": 2,
                        "term": "(p (g (. (0) ([])) (. (0) ([]))) T4)"
                    },
                    {
                        "clause": -1,
                        "scope": 2,
                        "term": null
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(p T4 (. (0) ([])))"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [],
                    "exprvars": []
                }
            },
            "24": {
                "goal": [{
                    "clause": 0,
                    "scope": 2,
                    "term": "(p (g (. (0) ([])) (. (0) ([]))) T4)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [],
                    "exprvars": []
                }
            },
            "25": {
                "goal": [
                    {
                        "clause": 1,
                        "scope": 2,
                        "term": "(p (g (. (0) ([])) (. (0) ([]))) T4)"
                    },
                    {
                        "clause": -1,
                        "scope": 2,
                        "term": null
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(p T4 (. (0) ([])))"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [],
                    "exprvars": []
                }
            },
            "26": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p (g (. (0) ([])) (. (0) ([]))) (g (. (0) ([])) (. (0) ([]))))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "27": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "110": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "119": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p T24 T25)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T24",
                        "T25"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "98": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(p T4 (. (0) ([])))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [],
                    "exprvars": []
                }
            },
            "55": {
                "goal": [{
                    "clause": 1,
                    "scope": 2,
                    "term": "(p (g (. (0) ([])) (. (0) ([]))) T4)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [],
                    "exprvars": []
                }
            },
            "56": {
                "goal": [
                    {
                        "clause": -1,
                        "scope": 2,
                        "term": null
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(p T4 (. (0) ([])))"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [],
                    "exprvars": []
                }
            },
            "57": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p (g (. (0) ([])) (. (0) ([]))) T9)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T9"],
                    "free": [],
                    "exprvars": []
                }
            },
            "59": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "120": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "3": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "103": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "104": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p T13 T14)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T13",
                        "T14"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "6": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 1,
                        "term": "(p T1 T2)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(p T1 T2)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "105": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "106": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 3,
                        "term": "(p T13 T14)"
                    },
                    {
                        "clause": 1,
                        "scope": 3,
                        "term": "(p T13 T14)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T13",
                        "T14"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "107": {
                "goal": [{
                    "clause": 0,
                    "scope": 3,
                    "term": "(p T13 T14)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T13",
                        "T14"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "108": {
                "goal": [{
                    "clause": 1,
                    "scope": 3,
                    "term": "(p T13 T14)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T13",
                        "T14"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "109": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p (g (. (0) ([])) (. (0) ([]))) T19)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T19"],
                    "free": [],
                    "exprvars": []
                }
            },
            "21": {
                "goal": [
                    {
                        "clause": -1,
                        "scope": -1,
                        "term": "(p (g (. (0) ([])) (. (0) ([]))) T4)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(p T4 (. (0) ([])))"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 3,
                "to": 6,
                "label": "CASE"
            },
            {
                "from": 6,
                "to": 21,
                "label": "EVAL with clause\np(X2, .(0, [])) :- p(g(.(0, []), .(0, [])), X2).\nand substitutionT1 -> T4,\nX2 -> T4,\nT2 -> .(0, [])"
            },
            {
                "from": 6,
                "to": 22,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 21,
                "to": 23,
                "label": "CASE"
            },
            {
                "from": 22,
                "to": 104,
                "label": "EVAL with clause\np(X24, g(X25, X25)) :- p(X24, X25).\nand substitutionT1 -> T13,\nX24 -> T13,\nX25 -> T14,\nT2 -> g(T14, T14)"
            },
            {
                "from": 22,
                "to": 105,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 23,
                "to": 24,
                "label": "PARALLEL"
            },
            {
                "from": 23,
                "to": 25,
                "label": "PARALLEL"
            },
            {
                "from": 24,
                "to": 26,
                "label": "EVAL with clause\np(X7, .(0, [])) :- p(g(.(0, []), .(0, [])), X7).\nand substitutionX7 -> g(.(0, []), .(0, [])),\nT4 -> .(0, [])"
            },
            {
                "from": 24,
                "to": 27,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 25,
                "to": 55,
                "label": "PARALLEL"
            },
            {
                "from": 25,
                "to": 56,
                "label": "PARALLEL"
            },
            {
                "from": 26,
                "to": 3,
                "label": "INSTANCE with matching:\nT1 -> g(.(0, []), .(0, []))\nT2 -> g(.(0, []), .(0, []))"
            },
            {
                "from": 55,
                "to": 57,
                "label": "EVAL with clause\np(X17, g(X18, X18)) :- p(X17, X18).\nand substitutionX17 -> g(.(0, []), .(0, [])),\nX18 -> T9,\nT4 -> g(T9, T9)"
            },
            {
                "from": 55,
                "to": 59,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 56,
                "to": 98,
                "label": "FAILURE"
            },
            {
                "from": 57,
                "to": 3,
                "label": "INSTANCE with matching:\nT1 -> g(.(0, []), .(0, []))\nT2 -> T9"
            },
            {
                "from": 98,
                "to": 103,
                "label": "BACKTRACK\nfor clause: p(X, g(Y, Y)) :- p(X, Y)because of non-unification"
            },
            {
                "from": 104,
                "to": 106,
                "label": "CASE"
            },
            {
                "from": 106,
                "to": 107,
                "label": "PARALLEL"
            },
            {
                "from": 106,
                "to": 108,
                "label": "PARALLEL"
            },
            {
                "from": 107,
                "to": 109,
                "label": "EVAL with clause\np(X30, .(0, [])) :- p(g(.(0, []), .(0, [])), X30).\nand substitutionT13 -> T19,\nX30 -> T19,\nT14 -> .(0, [])"
            },
            {
                "from": 107,
                "to": 110,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 108,
                "to": 119,
                "label": "EVAL with clause\np(X36, g(X37, X37)) :- p(X36, X37).\nand substitutionT13 -> T24,\nX36 -> T24,\nX37 -> T25,\nT14 -> g(T25, T25)"
            },
            {
                "from": 108,
                "to": 120,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 109,
                "to": 3,
                "label": "INSTANCE with matching:\nT1 -> g(.(0, []), .(0, []))\nT2 -> T19"
            },
            {
                "from": 119,
                "to": 3,
                "label": "INSTANCE with matching:\nT1 -> T24\nT2 -> T25"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(88)
Obligation:
Triples:

pA(.(0, []), .(0, [])) :- pA(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))).
pA(g(X1, X1), .(0, [])) :- pA(g(.(0, []), .(0, [])), X1).
pA(X1, g(.(0, []), .(0, []))) :- pA(g(.(0, []), .(0, [])), X1).
pA(X1, g(g(X2, X2), g(X2, X2))) :- pA(X1, X2).

Clauses:

pcA(.(0, []), .(0, [])) :- pcA(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))).
pcA(g(X1, X1), .(0, [])) :- pcA(g(.(0, []), .(0, [])), X1).
pcA(X1, g(.(0, []), .(0, []))) :- pcA(g(.(0, []), .(0, [])), X1).
pcA(X1, g(g(X2, X2), g(X2, X2))) :- pcA(X1, X2).

Afs:

pA(x1, x2)  =  pA(x1, x2)


----------------------------------------

(89) TriplesToPiDPProof (SOUND)
We use the technique of [DT09]. With regard to the inferred argument filtering the predicates were used in the following modes:

pA_in_2: (b,b)

Transforming TRIPLES into the following Term Rewriting System:

Pi DP problem:
The TRS P consists of the following rules:

   PA_IN_GG(.(0, []), .(0, [])) -> U1_GG(pA_in_gg(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))))
   PA_IN_GG(.(0, []), .(0, [])) -> PA_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))
   PA_IN_GG(g(X1, X1), .(0, [])) -> U2_GG(X1, pA_in_gg(g(.(0, []), .(0, [])), X1))
   PA_IN_GG(g(X1, X1), .(0, [])) -> PA_IN_GG(g(.(0, []), .(0, [])), X1)
   PA_IN_GG(X1, g(.(0, []), .(0, []))) -> U3_GG(X1, pA_in_gg(g(.(0, []), .(0, [])), X1))
   PA_IN_GG(X1, g(.(0, []), .(0, []))) -> PA_IN_GG(g(.(0, []), .(0, [])), X1)
   PA_IN_GG(X1, g(g(X2, X2), g(X2, X2))) -> U4_GG(X1, X2, pA_in_gg(X1, X2))
   PA_IN_GG(X1, g(g(X2, X2), g(X2, X2))) -> PA_IN_GG(X1, X2)

R is empty.
Pi is empty.
We have to consider all (P,R,Pi)-chains


Infinitary Constructor Rewriting Termination of PiDP implies Termination of TRIPLES



----------------------------------------

(90)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   PA_IN_GG(.(0, []), .(0, [])) -> U1_GG(pA_in_gg(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))))
   PA_IN_GG(.(0, []), .(0, [])) -> PA_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))
   PA_IN_GG(g(X1, X1), .(0, [])) -> U2_GG(X1, pA_in_gg(g(.(0, []), .(0, [])), X1))
   PA_IN_GG(g(X1, X1), .(0, [])) -> PA_IN_GG(g(.(0, []), .(0, [])), X1)
   PA_IN_GG(X1, g(.(0, []), .(0, []))) -> U3_GG(X1, pA_in_gg(g(.(0, []), .(0, [])), X1))
   PA_IN_GG(X1, g(.(0, []), .(0, []))) -> PA_IN_GG(g(.(0, []), .(0, [])), X1)
   PA_IN_GG(X1, g(g(X2, X2), g(X2, X2))) -> U4_GG(X1, X2, pA_in_gg(X1, X2))
   PA_IN_GG(X1, g(g(X2, X2), g(X2, X2))) -> PA_IN_GG(X1, X2)

R is empty.
Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(91) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 4 less nodes.
----------------------------------------

(92)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   PA_IN_GG(.(0, []), .(0, [])) -> PA_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))
   PA_IN_GG(X1, g(.(0, []), .(0, []))) -> PA_IN_GG(g(.(0, []), .(0, [])), X1)
   PA_IN_GG(g(X1, X1), .(0, [])) -> PA_IN_GG(g(.(0, []), .(0, [])), X1)
   PA_IN_GG(X1, g(g(X2, X2), g(X2, X2))) -> PA_IN_GG(X1, X2)

R is empty.
Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(93) PiDPToQDPProof (EQUIVALENT)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(94)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PA_IN_GG(.(0, []), .(0, [])) -> PA_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))
   PA_IN_GG(X1, g(.(0, []), .(0, []))) -> PA_IN_GG(g(.(0, []), .(0, [])), X1)
   PA_IN_GG(g(X1, X1), .(0, [])) -> PA_IN_GG(g(.(0, []), .(0, [])), X1)
   PA_IN_GG(X1, g(g(X2, X2), g(X2, X2))) -> PA_IN_GG(X1, X2)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(95) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   PA_IN_GG(.(0, []), .(0, [])) -> PA_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
PA_IN_GG(x1, x2)  =  x1

.(x1, x2)  =  .

0  =  0

[]  =  []

g(x1, x2)  =  g


Knuth-Bendix order [KBO] with precedence:trivial

and weight map:

   .=2
   g=1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:
none


----------------------------------------

(96)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PA_IN_GG(X1, g(.(0, []), .(0, []))) -> PA_IN_GG(g(.(0, []), .(0, [])), X1)
   PA_IN_GG(g(X1, X1), .(0, [])) -> PA_IN_GG(g(.(0, []), .(0, [])), X1)
   PA_IN_GG(X1, g(g(X2, X2), g(X2, X2))) -> PA_IN_GG(X1, X2)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(97) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   PA_IN_GG(X1, g(g(X2, X2), g(X2, X2))) -> PA_IN_GG(X1, X2)


Used ordering: Polynomial interpretation [POLO]:

   POL(.(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(0) = 0
   POL(PA_IN_GG(x_1, x_2)) = x_1 + x_2
   POL([]) = 0
   POL(g(x_1, x_2)) = 1 + 2*x_1 + 2*x_2


----------------------------------------

(98)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PA_IN_GG(X1, g(.(0, []), .(0, []))) -> PA_IN_GG(g(.(0, []), .(0, [])), X1)
   PA_IN_GG(g(X1, X1), .(0, [])) -> PA_IN_GG(g(.(0, []), .(0, [])), X1)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(99) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule PA_IN_GG(X1, g(.(0, []), .(0, []))) -> PA_IN_GG(g(.(0, []), .(0, [])), X1) we obtained the following new rules [LPAR04]:

   (PA_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) -> PA_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))),PA_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) -> PA_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))))


----------------------------------------

(100)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PA_IN_GG(g(X1, X1), .(0, [])) -> PA_IN_GG(g(.(0, []), .(0, [])), X1)
   PA_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) -> PA_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(101) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs.
----------------------------------------

(102)
Complex Obligation (AND)

----------------------------------------

(103)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PA_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) -> PA_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(104) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by semiunifying a rule from P directly.

s = PA_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) evaluates to  t =PA_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, [])))

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

The DP semiunifies directly so there is only one rewrite step from PA_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))) to PA_IN_GG(g(.(0, []), .(0, [])), g(.(0, []), .(0, []))).




----------------------------------------

(105)
NO

----------------------------------------

(106)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PA_IN_GG(g(X1, X1), .(0, [])) -> PA_IN_GG(g(.(0, []), .(0, [])), X1)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(107) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule PA_IN_GG(g(X1, X1), .(0, [])) -> PA_IN_GG(g(.(0, []), .(0, [])), X1) we obtained the following new rules [LPAR04]:

   (PA_IN_GG(g(.(0, []), .(0, [])), .(0, [])) -> PA_IN_GG(g(.(0, []), .(0, [])), .(0, [])),PA_IN_GG(g(.(0, []), .(0, [])), .(0, [])) -> PA_IN_GG(g(.(0, []), .(0, [])), .(0, [])))


----------------------------------------

(108)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PA_IN_GG(g(.(0, []), .(0, [])), .(0, [])) -> PA_IN_GG(g(.(0, []), .(0, [])), .(0, []))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(109) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by semiunifying a rule from P directly.

s = PA_IN_GG(g(.(0, []), .(0, [])), .(0, [])) evaluates to  t =PA_IN_GG(g(.(0, []), .(0, [])), .(0, []))

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

The DP semiunifies directly so there is only one rewrite step from PA_IN_GG(g(.(0, []), .(0, [])), .(0, [])) to PA_IN_GG(g(.(0, []), .(0, [])), .(0, [])).




----------------------------------------

(110)
NO

----------------------------------------

(111) PrologToIRSwTTransformerProof (SOUND)
Transformed Prolog program to IRSwT according to method in Master Thesis of A. Weinert

{
    "root": 2,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(p X (. (0) ([])))",
                "(p (g (. (0) ([])) (. (0) ([]))) X)"
            ],
            [
                "(p X (g Y Y))",
                "(p X Y)"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "99": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p T12 T13)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T12",
                        "T13"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "100": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "2": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "5": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 1,
                        "term": "(p T1 T2)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(p T1 T2)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "28": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p (g (. (0) ([])) (. (0) ([]))) T7)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T7"],
                    "free": [],
                    "exprvars": []
                }
            },
            "29": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "19": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(p T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "20": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(p T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 2,
                "to": 5,
                "label": "CASE"
            },
            {
                "from": 5,
                "to": 19,
                "label": "PARALLEL"
            },
            {
                "from": 5,
                "to": 20,
                "label": "PARALLEL"
            },
            {
                "from": 19,
                "to": 28,
                "label": "EVAL with clause\np(X5, .(0, [])) :- p(g(.(0, []), .(0, [])), X5).\nand substitutionT1 -> T7,\nX5 -> T7,\nT2 -> .(0, [])"
            },
            {
                "from": 19,
                "to": 29,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 20,
                "to": 99,
                "label": "EVAL with clause\np(X11, g(X12, X12)) :- p(X11, X12).\nand substitutionT1 -> T12,\nX11 -> T12,\nX12 -> T13,\nT2 -> g(T13, T13)"
            },
            {
                "from": 20,
                "to": 100,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 28,
                "to": 2,
                "label": "INSTANCE with matching:\nT1 -> g(.(0, []), .(0, []))\nT2 -> T7"
            },
            {
                "from": 99,
                "to": 2,
                "label": "INSTANCE with matching:\nT1 -> T12\nT2 -> T13"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(112)
Obligation:
Rules:
f19_in(T7, .(0, [])) -> f28_in(T7) :|: TRUE
f29_out -> f19_out(T1, T2) :|: TRUE
f19_in(x, x1) -> f29_in :|: TRUE
f28_out(x2) -> f19_out(x2, .(0, [])) :|: TRUE
f5_out(x3, x4) -> f2_out(x3, x4) :|: TRUE
f2_in(x5, x6) -> f5_in(x5, x6) :|: TRUE
f20_in(T12, g(T13, T13)) -> f99_in(T12, T13) :|: TRUE
f100_out -> f20_out(x7, x8) :|: TRUE
f20_in(x9, x10) -> f100_in :|: TRUE
f99_out(x11, x12) -> f20_out(x11, g(x12, x12)) :|: TRUE
f28_in(x13) -> f2_in(g(.(0, []), .(0, [])), x13) :|: TRUE
f2_out(g(.(0, []), .(0, [])), x14) -> f28_out(x14) :|: TRUE
f99_in(x15, x16) -> f2_in(x15, x16) :|: TRUE
f2_out(x17, x18) -> f99_out(x17, x18) :|: TRUE
f5_in(x19, x20) -> f19_in(x19, x20) :|: TRUE
f19_out(x21, x22) -> f5_out(x21, x22) :|: TRUE
f20_out(x23, x24) -> f5_out(x23, x24) :|: TRUE
f5_in(x25, x26) -> f20_in(x25, x26) :|: TRUE
Start term: f2_in(T1, T2)

----------------------------------------

(113) IRSwTSimpleDependencyGraphProof (EQUIVALENT)
Constructed simple dependency graph.

Simplified to the following IRSwTs:

intTRSProblem:
f19_in(T7, .(0, [])) -> f28_in(T7) :|: TRUE
f2_in(x5, x6) -> f5_in(x5, x6) :|: TRUE
f20_in(T12, g(T13, T13)) -> f99_in(T12, T13) :|: TRUE
f28_in(x13) -> f2_in(g(.(0, []), .(0, [])), x13) :|: TRUE
f99_in(x15, x16) -> f2_in(x15, x16) :|: TRUE
f5_in(x19, x20) -> f19_in(x19, x20) :|: TRUE
f5_in(x25, x26) -> f20_in(x25, x26) :|: TRUE


----------------------------------------

(114)
Obligation:
Rules:
f19_in(T7, .(0, [])) -> f28_in(T7) :|: TRUE
f2_in(x5, x6) -> f5_in(x5, x6) :|: TRUE
f20_in(T12, g(T13, T13)) -> f99_in(T12, T13) :|: TRUE
f28_in(x13) -> f2_in(g(.(0, []), .(0, [])), x13) :|: TRUE
f99_in(x15, x16) -> f2_in(x15, x16) :|: TRUE
f5_in(x19, x20) -> f19_in(x19, x20) :|: TRUE
f5_in(x25, x26) -> f20_in(x25, x26) :|: TRUE

----------------------------------------

(115) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(116)
Obligation:
Rules:
f2_in(x5:0, .(cons_0, [])) -> f2_in(g(.(0, []), .(0, [])), x5:0) :|: TRUE && cons_0 = 0
f2_in(x, g(x1, x1)) -> f2_in(x, x1) :|: TRUE

----------------------------------------

(117) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(118)
Obligation:
Rules:
f2_in(x5:0, .(cons_0, [])) -> f2_in(g(.(0, []), .(0, [])), x5:0) :|: TRUE && cons_0 = 0
f2_in(x, g(x1, x1)) -> f2_in(x, x1) :|: TRUE

----------------------------------------

(119) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f2_in(x5:0, .(cons_0, [])) -> f2_in(g(.(0, []), .(0, [])), x5:0) :|: TRUE && cons_0 = 0
(2) f2_in(x, g(x1, x1)) -> f2_in(x, x1) :|: TRUE

Arcs:
(1) -> (1), (2)
(2) -> (1), (2)

This digraph is fully evaluated!
----------------------------------------

(120)
Obligation:

Termination digraph:
Nodes:
(1) f2_in(x5:0, .(cons_0, [])) -> f2_in(g(.(0, []), .(0, [])), x5:0) :|: TRUE && cons_0 = 0
(2) f2_in(x, g(x1, x1)) -> f2_in(x, x1) :|: TRUE

Arcs:
(1) -> (1), (2)
(2) -> (1), (2)

This digraph is fully evaluated!

----------------------------------------

(121) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(122)
Obligation:
Rules:
f2_in(x5:0:0, .(cons_0, [])) -> f2_in(g(.(0, []), .(0, [])), x5:0:0) :|: TRUE && cons_0 = 0
f2_in(x:0, g(x1:0, x1:0)) -> f2_in(x:0, x1:0) :|: TRUE

----------------------------------------

(123) IntTRSUnneededArgumentFilterProof (EQUIVALENT)
Some arguments are removed because they cannot influence termination. We removed arguments according to the following replacements:

   .(x1, x2) -> .(x1)

----------------------------------------

(124)
Obligation:
Rules:
f2_in(x5:0:0, .(cons_0)) -> f2_in(g(.(0), .(0)), x5:0:0) :|: TRUE && cons_0 = 0
f2_in(x:0, g(x1:0, x1:0)) -> f2_in(x:0, x1:0) :|: TRUE

----------------------------------------

(125) IRSwTToIntTRSProof (SOUND)
Applied path-length measure to transform intTRS with terms to intTRS.
----------------------------------------

(126)
Obligation:
Rules:
f2_in(x, .(cons_0)) -> f2_in(g(.(0), .(0)), x) :|: TRUE && cons_0 = 0
f2_in(x2, g(x3, x3)) -> f2_in(x2, x3) :|: TRUE

----------------------------------------

(127) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(128)
Obligation:
Rules:
f2_in(x:0, .(cons_0)) -> f2_in(g(.(0), .(0)), x:0) :|: TRUE && cons_0 = 0
f2_in(x2:0, g(x3:0, x3:0)) -> f2_in(x2:0, x3:0) :|: TRUE
