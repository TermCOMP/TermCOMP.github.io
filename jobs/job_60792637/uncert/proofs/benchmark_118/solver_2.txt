MAYBE
proof of /hpcwork/ff862203/termcomp25/benchmarks/Qrn7M.pl
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Left Termination of the query pattern

p(g,g)

w.r.t. the given Prolog program could not be shown:

(0) Prolog
(1) PrologToPiTRSProof [SOUND, 0 ms]
(2) PiTRS
    (3) DependencyPairsProof [EQUIVALENT, 0 ms]
    (4) PiDP
    (5) DependencyGraphProof [EQUIVALENT, 0 ms]
    (6) PiDP
    (7) UsableRulesProof [EQUIVALENT, 0 ms]
    (8) PiDP
    (9) PiDPToQDPProof [EQUIVALENT, 0 ms]
    (10) QDP
    (11) TransformationProof [EQUIVALENT, 0 ms]
    (12) QDP
    (13) TransformationProof [EQUIVALENT, 0 ms]
    (14) QDP
    (15) QDPOrderProof [EQUIVALENT, 59 ms]
    (16) QDP
    (17) NonTerminationLoopProof [COMPLETE, 0 ms]
    (18) NO
(19) PrologToTRSTransformerProof [SOUND, 0 ms]
(20) QTRS
    (21) Overlay + Local Confluence [EQUIVALENT, 0 ms]
    (22) QTRS
    (23) DependencyPairsProof [EQUIVALENT, 0 ms]
    (24) QDP
    (25) DependencyGraphProof [EQUIVALENT, 0 ms]
    (26) QDP
    (27) UsableRulesProof [EQUIVALENT, 0 ms]
    (28) QDP
    (29) QReductionProof [EQUIVALENT, 0 ms]
    (30) QDP
    (31) TransformationProof [EQUIVALENT, 0 ms]
    (32) QDP
    (33) TransformationProof [EQUIVALENT, 0 ms]
    (34) QDP
    (35) QDPOrderProof [EQUIVALENT, 62 ms]
    (36) QDP
    (37) NonTerminationLoopProof [COMPLETE, 0 ms]
    (38) NO
(39) PrologToPiTRSProof [SOUND, 0 ms]
(40) PiTRS
    (41) DependencyPairsProof [EQUIVALENT, 0 ms]
    (42) PiDP
    (43) DependencyGraphProof [EQUIVALENT, 0 ms]
    (44) PiDP
    (45) UsableRulesProof [EQUIVALENT, 0 ms]
    (46) PiDP
    (47) PiDPToQDPProof [EQUIVALENT, 0 ms]
    (48) QDP
    (49) TransformationProof [EQUIVALENT, 0 ms]
    (50) QDP
    (51) TransformationProof [EQUIVALENT, 0 ms]
    (52) QDP
    (53) QDPOrderProof [EQUIVALENT, 51 ms]
    (54) QDP
    (55) NonTerminationLoopProof [COMPLETE, 0 ms]
    (56) NO
(57) PrologToDTProblemTransformerProof [SOUND, 0 ms]
(58) TRIPLES
    (59) TriplesToPiDPProof [SOUND, 6 ms]
    (60) PiDP
    (61) DependencyGraphProof [EQUIVALENT, 0 ms]
    (62) PiDP
    (63) PiDPToQDPProof [EQUIVALENT, 0 ms]
    (64) QDP
    (65) TransformationProof [EQUIVALENT, 0 ms]
    (66) QDP
    (67) TransformationProof [EQUIVALENT, 0 ms]
    (68) QDP
    (69) TransformationProof [EQUIVALENT, 0 ms]
    (70) QDP
(71) PrologToIRSwTTransformerProof [SOUND, 0 ms]
(72) IRSwT
    (73) IRSwTSimpleDependencyGraphProof [EQUIVALENT, 0 ms]
    (74) IRSwT
    (75) IntTRSCompressionProof [EQUIVALENT, 22 ms]
    (76) IRSwT
    (77) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
    (78) IRSwT
    (79) IRSwTTerminationDigraphProof [EQUIVALENT, 8 ms]
    (80) IRSwT
    (81) IntTRSCompressionProof [EQUIVALENT, 0 ms]
    (82) IRSwT


----------------------------------------

(0)
Obligation:
Clauses:

p(X, s(s(s(s(s(s(s(Y)))))))) :- p(X, s(s(Y))).
p(X, s(s(s(s(s(s(0))))))) :- p(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X))))))))).


Query: p(g,g)
----------------------------------------

(1) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

p_in_2: (b,b)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   p_in_gg(X, s(s(s(s(s(s(s(Y)))))))) -> U1_gg(X, Y, p_in_gg(X, s(s(Y))))
   p_in_gg(X, s(s(s(s(s(s(0))))))) -> U2_gg(X, p_in_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X))))))))))
   U2_gg(X, p_out_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))) -> p_out_gg(X, s(s(s(s(s(s(0)))))))
   U1_gg(X, Y, p_out_gg(X, s(s(Y)))) -> p_out_gg(X, s(s(s(s(s(s(s(Y))))))))

The argument filtering Pi contains the following mapping:
p_in_gg(x1, x2)  =  p_in_gg(x1, x2)

s(x1)  =  s(x1)

U1_gg(x1, x2, x3)  =  U1_gg(x3)

0  =  0

U2_gg(x1, x2)  =  U2_gg(x2)

p_out_gg(x1, x2)  =  p_out_gg





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(2)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   p_in_gg(X, s(s(s(s(s(s(s(Y)))))))) -> U1_gg(X, Y, p_in_gg(X, s(s(Y))))
   p_in_gg(X, s(s(s(s(s(s(0))))))) -> U2_gg(X, p_in_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X))))))))))
   U2_gg(X, p_out_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))) -> p_out_gg(X, s(s(s(s(s(s(0)))))))
   U1_gg(X, Y, p_out_gg(X, s(s(Y)))) -> p_out_gg(X, s(s(s(s(s(s(s(Y))))))))

The argument filtering Pi contains the following mapping:
p_in_gg(x1, x2)  =  p_in_gg(x1, x2)

s(x1)  =  s(x1)

U1_gg(x1, x2, x3)  =  U1_gg(x3)

0  =  0

U2_gg(x1, x2)  =  U2_gg(x2)

p_out_gg(x1, x2)  =  p_out_gg



----------------------------------------

(3) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, s(s(s(s(s(s(s(Y)))))))) -> U1_GG(X, Y, p_in_gg(X, s(s(Y))))
   P_IN_GG(X, s(s(s(s(s(s(s(Y)))))))) -> P_IN_GG(X, s(s(Y)))
   P_IN_GG(X, s(s(s(s(s(s(0))))))) -> U2_GG(X, p_in_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X))))))))))
   P_IN_GG(X, s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))

The TRS R consists of the following rules:

   p_in_gg(X, s(s(s(s(s(s(s(Y)))))))) -> U1_gg(X, Y, p_in_gg(X, s(s(Y))))
   p_in_gg(X, s(s(s(s(s(s(0))))))) -> U2_gg(X, p_in_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X))))))))))
   U2_gg(X, p_out_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))) -> p_out_gg(X, s(s(s(s(s(s(0)))))))
   U1_gg(X, Y, p_out_gg(X, s(s(Y)))) -> p_out_gg(X, s(s(s(s(s(s(s(Y))))))))

The argument filtering Pi contains the following mapping:
p_in_gg(x1, x2)  =  p_in_gg(x1, x2)

s(x1)  =  s(x1)

U1_gg(x1, x2, x3)  =  U1_gg(x3)

0  =  0

U2_gg(x1, x2)  =  U2_gg(x2)

p_out_gg(x1, x2)  =  p_out_gg

P_IN_GG(x1, x2)  =  P_IN_GG(x1, x2)

U1_GG(x1, x2, x3)  =  U1_GG(x3)

U2_GG(x1, x2)  =  U2_GG(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(4)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, s(s(s(s(s(s(s(Y)))))))) -> U1_GG(X, Y, p_in_gg(X, s(s(Y))))
   P_IN_GG(X, s(s(s(s(s(s(s(Y)))))))) -> P_IN_GG(X, s(s(Y)))
   P_IN_GG(X, s(s(s(s(s(s(0))))))) -> U2_GG(X, p_in_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X))))))))))
   P_IN_GG(X, s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))

The TRS R consists of the following rules:

   p_in_gg(X, s(s(s(s(s(s(s(Y)))))))) -> U1_gg(X, Y, p_in_gg(X, s(s(Y))))
   p_in_gg(X, s(s(s(s(s(s(0))))))) -> U2_gg(X, p_in_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X))))))))))
   U2_gg(X, p_out_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))) -> p_out_gg(X, s(s(s(s(s(s(0)))))))
   U1_gg(X, Y, p_out_gg(X, s(s(Y)))) -> p_out_gg(X, s(s(s(s(s(s(s(Y))))))))

The argument filtering Pi contains the following mapping:
p_in_gg(x1, x2)  =  p_in_gg(x1, x2)

s(x1)  =  s(x1)

U1_gg(x1, x2, x3)  =  U1_gg(x3)

0  =  0

U2_gg(x1, x2)  =  U2_gg(x2)

p_out_gg(x1, x2)  =  p_out_gg

P_IN_GG(x1, x2)  =  P_IN_GG(x1, x2)

U1_GG(x1, x2, x3)  =  U1_GG(x3)

U2_GG(x1, x2)  =  U2_GG(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(5) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 2 less nodes.
----------------------------------------

(6)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))
   P_IN_GG(X, s(s(s(s(s(s(s(Y)))))))) -> P_IN_GG(X, s(s(Y)))

The TRS R consists of the following rules:

   p_in_gg(X, s(s(s(s(s(s(s(Y)))))))) -> U1_gg(X, Y, p_in_gg(X, s(s(Y))))
   p_in_gg(X, s(s(s(s(s(s(0))))))) -> U2_gg(X, p_in_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X))))))))))
   U2_gg(X, p_out_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))) -> p_out_gg(X, s(s(s(s(s(s(0)))))))
   U1_gg(X, Y, p_out_gg(X, s(s(Y)))) -> p_out_gg(X, s(s(s(s(s(s(s(Y))))))))

The argument filtering Pi contains the following mapping:
p_in_gg(x1, x2)  =  p_in_gg(x1, x2)

s(x1)  =  s(x1)

U1_gg(x1, x2, x3)  =  U1_gg(x3)

0  =  0

U2_gg(x1, x2)  =  U2_gg(x2)

p_out_gg(x1, x2)  =  p_out_gg

P_IN_GG(x1, x2)  =  P_IN_GG(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(7) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(8)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))
   P_IN_GG(X, s(s(s(s(s(s(s(Y)))))))) -> P_IN_GG(X, s(s(Y)))

R is empty.
Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(9) PiDPToQDPProof (EQUIVALENT)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(10)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))
   P_IN_GG(X, s(s(s(s(s(s(s(Y)))))))) -> P_IN_GG(X, s(s(Y)))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(11) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule P_IN_GG(X, s(s(s(s(s(s(s(Y)))))))) -> P_IN_GG(X, s(s(Y))) we obtained the following new rules [LPAR04]:

   (P_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> P_IN_GG(x0, s(s(s(s(s(s(0))))))),P_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> P_IN_GG(x0, s(s(s(s(s(s(0))))))))
   (P_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))) -> P_IN_GG(x0, s(s(s(s(s(s(s(y_1)))))))),P_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))) -> P_IN_GG(x0, s(s(s(s(s(s(s(y_1)))))))))


----------------------------------------

(12)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))
   P_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> P_IN_GG(x0, s(s(s(s(s(s(0)))))))
   P_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))) -> P_IN_GG(x0, s(s(s(s(s(s(s(y_1))))))))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(13) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule P_IN_GG(X, s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X))))))))) we obtained the following new rules [LPAR04]:

   (P_IN_GG(s(s(s(0))), s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))),P_IN_GG(s(s(s(0))), s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))
   (P_IN_GG(s(s(s(s(y_1)))), s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))),P_IN_GG(s(s(s(s(y_1)))), s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))))


----------------------------------------

(14)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> P_IN_GG(x0, s(s(s(s(s(s(0)))))))
   P_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))) -> P_IN_GG(x0, s(s(s(s(s(s(s(y_1))))))))
   P_IN_GG(s(s(s(0))), s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0))))))))))))
   P_IN_GG(s(s(s(s(y_1)))), s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(y_1)))))))))))))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(15) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   P_IN_GG(s(s(s(0))), s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0))))))))))))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(P_IN_GG(x_1, x_2)) =  	[[0]] 	 +  	[[1, 0]] 	* 	x_1 	 +  	[[0, 0]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[0], [0]] 	 +  	[[0, 1], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[0], [1]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:
none


----------------------------------------

(16)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> P_IN_GG(x0, s(s(s(s(s(s(0)))))))
   P_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))) -> P_IN_GG(x0, s(s(s(s(s(s(s(y_1))))))))
   P_IN_GG(s(s(s(s(y_1)))), s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(y_1)))))))))))))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(17) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(0))))))) evaluates to  t =P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(0)))))))

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))
with rule P_IN_GG(s(s(s(s(y_1)))), s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))) at position [] and matcher [y_1 / s(s(s(s(0))))]

P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0))))))))))))
with rule P_IN_GG(x0', s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))) -> P_IN_GG(x0', s(s(s(s(s(s(s(y_1)))))))) at position [] and matcher [x0' / s(s(s(s(s(s(s(s(0)))))))), y_1 / s(s(s(s(0))))]

P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(0)))))))
with rule P_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> P_IN_GG(x0, s(s(s(s(s(s(0)))))))

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(18)
NO

----------------------------------------

(19) PrologToTRSTransformerProof (SOUND)
Transformed Prolog program to TRS.

{
    "root": 1,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(p X (s (s (s (s (s (s (s Y))))))))",
                "(p X (s (s Y)))"
            ],
            [
                "(p X (s (s (s (s (s (s (0))))))))",
                "(p (s (s (s (s (s (s (s (s (0))))))))) (s (s (s (s (s (s (s (s X)))))))))"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "11": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(p T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "1": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "12": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(p T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "4": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 1,
                        "term": "(p T1 T2)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(p T1 T2)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "73": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p T11 (s (s T12)))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T11",
                        "T12"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "84": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p (s (s (s (s (s (s (s (s (0))))))))) (s (s (s (s (s (s (s (s T17)))))))))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T17"],
                    "free": [],
                    "exprvars": []
                }
            },
            "74": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "85": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 1,
                "to": 4,
                "label": "CASE"
            },
            {
                "from": 4,
                "to": 11,
                "label": "PARALLEL"
            },
            {
                "from": 4,
                "to": 12,
                "label": "PARALLEL"
            },
            {
                "from": 11,
                "to": 73,
                "label": "EVAL with clause\np(X9, s(s(s(s(s(s(s(X10)))))))) :- p(X9, s(s(X10))).\nand substitutionT1 -> T11,\nX9 -> T11,\nX10 -> T12,\nT2 -> s(s(s(s(s(s(s(T12)))))))"
            },
            {
                "from": 11,
                "to": 74,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 12,
                "to": 84,
                "label": "EVAL with clause\np(X15, s(s(s(s(s(s(0))))))) :- p(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X15))))))))).\nand substitutionT1 -> T17,\nX15 -> T17,\nT2 -> s(s(s(s(s(s(0))))))"
            },
            {
                "from": 12,
                "to": 85,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 73,
                "to": 1,
                "label": "INSTANCE with matching:\nT1 -> T11\nT2 -> s(s(T12))"
            },
            {
                "from": 84,
                "to": 1,
                "label": "INSTANCE with matching:\nT1 -> s(s(s(s(s(s(s(s(0))))))))\nT2 -> s(s(s(s(s(s(s(s(T17))))))))"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(20)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f1_in(T11, s(s(s(s(s(s(s(T12)))))))) -> U1(f1_in(T11, s(s(T12))), T11, s(s(s(s(s(s(s(T12))))))))
   U1(f1_out1, T11, s(s(s(s(s(s(s(T12)))))))) -> f1_out1
   f1_in(T17, s(s(s(s(s(s(0))))))) -> U2(f1_in(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(T17))))))))), T17, s(s(s(s(s(s(0)))))))
   U2(f1_out1, T17, s(s(s(s(s(s(0))))))) -> f1_out1

Q is empty.

----------------------------------------

(21) Overlay + Local Confluence (EQUIVALENT)
The TRS is overlay and locally confluent. By [NOC] we can switch to innermost.
----------------------------------------

(22)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f1_in(T11, s(s(s(s(s(s(s(T12)))))))) -> U1(f1_in(T11, s(s(T12))), T11, s(s(s(s(s(s(s(T12))))))))
   U1(f1_out1, T11, s(s(s(s(s(s(s(T12)))))))) -> f1_out1
   f1_in(T17, s(s(s(s(s(s(0))))))) -> U2(f1_in(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(T17))))))))), T17, s(s(s(s(s(s(0)))))))
   U2(f1_out1, T17, s(s(s(s(s(s(0))))))) -> f1_out1

The set Q consists of the following terms:

   f1_in(x0, s(s(s(s(s(s(s(x1))))))))
   U1(f1_out1, x0, s(s(s(s(s(s(s(x1))))))))
   f1_in(x0, s(s(s(s(s(s(0)))))))
   U2(f1_out1, x0, s(s(s(s(s(s(0)))))))


----------------------------------------

(23) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(24)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(T11, s(s(s(s(s(s(s(T12)))))))) -> U1^1(f1_in(T11, s(s(T12))), T11, s(s(s(s(s(s(s(T12))))))))
   F1_IN(T11, s(s(s(s(s(s(s(T12)))))))) -> F1_IN(T11, s(s(T12)))
   F1_IN(T17, s(s(s(s(s(s(0))))))) -> U2^1(f1_in(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(T17))))))))), T17, s(s(s(s(s(s(0)))))))
   F1_IN(T17, s(s(s(s(s(s(0))))))) -> F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(T17)))))))))

The TRS R consists of the following rules:

   f1_in(T11, s(s(s(s(s(s(s(T12)))))))) -> U1(f1_in(T11, s(s(T12))), T11, s(s(s(s(s(s(s(T12))))))))
   U1(f1_out1, T11, s(s(s(s(s(s(s(T12)))))))) -> f1_out1
   f1_in(T17, s(s(s(s(s(s(0))))))) -> U2(f1_in(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(T17))))))))), T17, s(s(s(s(s(s(0)))))))
   U2(f1_out1, T17, s(s(s(s(s(s(0))))))) -> f1_out1

The set Q consists of the following terms:

   f1_in(x0, s(s(s(s(s(s(s(x1))))))))
   U1(f1_out1, x0, s(s(s(s(s(s(s(x1))))))))
   f1_in(x0, s(s(s(s(s(s(0)))))))
   U2(f1_out1, x0, s(s(s(s(s(s(0)))))))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(25) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(26)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(T17, s(s(s(s(s(s(0))))))) -> F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(T17)))))))))
   F1_IN(T11, s(s(s(s(s(s(s(T12)))))))) -> F1_IN(T11, s(s(T12)))

The TRS R consists of the following rules:

   f1_in(T11, s(s(s(s(s(s(s(T12)))))))) -> U1(f1_in(T11, s(s(T12))), T11, s(s(s(s(s(s(s(T12))))))))
   U1(f1_out1, T11, s(s(s(s(s(s(s(T12)))))))) -> f1_out1
   f1_in(T17, s(s(s(s(s(s(0))))))) -> U2(f1_in(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(T17))))))))), T17, s(s(s(s(s(s(0)))))))
   U2(f1_out1, T17, s(s(s(s(s(s(0))))))) -> f1_out1

The set Q consists of the following terms:

   f1_in(x0, s(s(s(s(s(s(s(x1))))))))
   U1(f1_out1, x0, s(s(s(s(s(s(s(x1))))))))
   f1_in(x0, s(s(s(s(s(s(0)))))))
   U2(f1_out1, x0, s(s(s(s(s(s(0)))))))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(27) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(28)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(T17, s(s(s(s(s(s(0))))))) -> F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(T17)))))))))
   F1_IN(T11, s(s(s(s(s(s(s(T12)))))))) -> F1_IN(T11, s(s(T12)))

R is empty.
The set Q consists of the following terms:

   f1_in(x0, s(s(s(s(s(s(s(x1))))))))
   U1(f1_out1, x0, s(s(s(s(s(s(s(x1))))))))
   f1_in(x0, s(s(s(s(s(s(0)))))))
   U2(f1_out1, x0, s(s(s(s(s(s(0)))))))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(29) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   f1_in(x0, s(s(s(s(s(s(s(x1))))))))
   U1(f1_out1, x0, s(s(s(s(s(s(s(x1))))))))
   f1_in(x0, s(s(s(s(s(s(0)))))))
   U2(f1_out1, x0, s(s(s(s(s(s(0)))))))


----------------------------------------

(30)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(T17, s(s(s(s(s(s(0))))))) -> F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(T17)))))))))
   F1_IN(T11, s(s(s(s(s(s(s(T12)))))))) -> F1_IN(T11, s(s(T12)))

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(31) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule F1_IN(T11, s(s(s(s(s(s(s(T12)))))))) -> F1_IN(T11, s(s(T12))) we obtained the following new rules [LPAR04]:

   (F1_IN(x0, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> F1_IN(x0, s(s(s(s(s(s(0))))))),F1_IN(x0, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> F1_IN(x0, s(s(s(s(s(s(0))))))))
   (F1_IN(x0, s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))) -> F1_IN(x0, s(s(s(s(s(s(s(y_1)))))))),F1_IN(x0, s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))) -> F1_IN(x0, s(s(s(s(s(s(s(y_1)))))))))


----------------------------------------

(32)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(T17, s(s(s(s(s(s(0))))))) -> F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(T17)))))))))
   F1_IN(x0, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> F1_IN(x0, s(s(s(s(s(s(0)))))))
   F1_IN(x0, s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))) -> F1_IN(x0, s(s(s(s(s(s(s(y_1))))))))

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(33) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule F1_IN(T17, s(s(s(s(s(s(0))))))) -> F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(T17))))))))) we obtained the following new rules [LPAR04]:

   (F1_IN(s(s(s(0))), s(s(s(s(s(s(0))))))) -> F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))),F1_IN(s(s(s(0))), s(s(s(s(s(s(0))))))) -> F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))
   (F1_IN(s(s(s(s(y_1)))), s(s(s(s(s(s(0))))))) -> F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))),F1_IN(s(s(s(s(y_1)))), s(s(s(s(s(s(0))))))) -> F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))))


----------------------------------------

(34)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(x0, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> F1_IN(x0, s(s(s(s(s(s(0)))))))
   F1_IN(x0, s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))) -> F1_IN(x0, s(s(s(s(s(s(s(y_1))))))))
   F1_IN(s(s(s(0))), s(s(s(s(s(s(0))))))) -> F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0))))))))))))
   F1_IN(s(s(s(s(y_1)))), s(s(s(s(s(s(0))))))) -> F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(y_1)))))))))))))

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(35) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   F1_IN(s(s(s(0))), s(s(s(s(s(s(0))))))) -> F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0))))))))))))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(F1_IN(x_1, x_2)) =  	[[0]] 	 +  	[[1, 0]] 	* 	x_1 	 +  	[[0, 0]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[0], [0]] 	 +  	[[0, 1], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[0], [1]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:
none


----------------------------------------

(36)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(x0, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> F1_IN(x0, s(s(s(s(s(s(0)))))))
   F1_IN(x0, s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))) -> F1_IN(x0, s(s(s(s(s(s(s(y_1))))))))
   F1_IN(s(s(s(s(y_1)))), s(s(s(s(s(s(0))))))) -> F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(y_1)))))))))))))

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(37) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(0))))))) evaluates to  t =F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(0)))))))

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(0))))))) -> F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))
with rule F1_IN(s(s(s(s(y_1)))), s(s(s(s(s(s(0))))))) -> F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))) at position [] and matcher [y_1 / s(s(s(s(0))))]

F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))))) -> F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0))))))))))))
with rule F1_IN(x0', s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))) -> F1_IN(x0', s(s(s(s(s(s(s(y_1)))))))) at position [] and matcher [x0' / s(s(s(s(s(s(s(s(0)))))))), y_1 / s(s(s(s(0))))]

F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> F1_IN(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(0)))))))
with rule F1_IN(x0, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> F1_IN(x0, s(s(s(s(s(s(0)))))))

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(38)
NO

----------------------------------------

(39) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

p_in_2: (b,b)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   p_in_gg(X, s(s(s(s(s(s(s(Y)))))))) -> U1_gg(X, Y, p_in_gg(X, s(s(Y))))
   p_in_gg(X, s(s(s(s(s(s(0))))))) -> U2_gg(X, p_in_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X))))))))))
   U2_gg(X, p_out_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))) -> p_out_gg(X, s(s(s(s(s(s(0)))))))
   U1_gg(X, Y, p_out_gg(X, s(s(Y)))) -> p_out_gg(X, s(s(s(s(s(s(s(Y))))))))

Pi is empty.



Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(40)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   p_in_gg(X, s(s(s(s(s(s(s(Y)))))))) -> U1_gg(X, Y, p_in_gg(X, s(s(Y))))
   p_in_gg(X, s(s(s(s(s(s(0))))))) -> U2_gg(X, p_in_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X))))))))))
   U2_gg(X, p_out_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))) -> p_out_gg(X, s(s(s(s(s(s(0)))))))
   U1_gg(X, Y, p_out_gg(X, s(s(Y)))) -> p_out_gg(X, s(s(s(s(s(s(s(Y))))))))

Pi is empty.

----------------------------------------

(41) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, s(s(s(s(s(s(s(Y)))))))) -> U1_GG(X, Y, p_in_gg(X, s(s(Y))))
   P_IN_GG(X, s(s(s(s(s(s(s(Y)))))))) -> P_IN_GG(X, s(s(Y)))
   P_IN_GG(X, s(s(s(s(s(s(0))))))) -> U2_GG(X, p_in_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X))))))))))
   P_IN_GG(X, s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))

The TRS R consists of the following rules:

   p_in_gg(X, s(s(s(s(s(s(s(Y)))))))) -> U1_gg(X, Y, p_in_gg(X, s(s(Y))))
   p_in_gg(X, s(s(s(s(s(s(0))))))) -> U2_gg(X, p_in_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X))))))))))
   U2_gg(X, p_out_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))) -> p_out_gg(X, s(s(s(s(s(s(0)))))))
   U1_gg(X, Y, p_out_gg(X, s(s(Y)))) -> p_out_gg(X, s(s(s(s(s(s(s(Y))))))))

Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(42)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, s(s(s(s(s(s(s(Y)))))))) -> U1_GG(X, Y, p_in_gg(X, s(s(Y))))
   P_IN_GG(X, s(s(s(s(s(s(s(Y)))))))) -> P_IN_GG(X, s(s(Y)))
   P_IN_GG(X, s(s(s(s(s(s(0))))))) -> U2_GG(X, p_in_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X))))))))))
   P_IN_GG(X, s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))

The TRS R consists of the following rules:

   p_in_gg(X, s(s(s(s(s(s(s(Y)))))))) -> U1_gg(X, Y, p_in_gg(X, s(s(Y))))
   p_in_gg(X, s(s(s(s(s(s(0))))))) -> U2_gg(X, p_in_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X))))))))))
   U2_gg(X, p_out_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))) -> p_out_gg(X, s(s(s(s(s(s(0)))))))
   U1_gg(X, Y, p_out_gg(X, s(s(Y)))) -> p_out_gg(X, s(s(s(s(s(s(s(Y))))))))

Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(43) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 2 less nodes.
----------------------------------------

(44)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))
   P_IN_GG(X, s(s(s(s(s(s(s(Y)))))))) -> P_IN_GG(X, s(s(Y)))

The TRS R consists of the following rules:

   p_in_gg(X, s(s(s(s(s(s(s(Y)))))))) -> U1_gg(X, Y, p_in_gg(X, s(s(Y))))
   p_in_gg(X, s(s(s(s(s(s(0))))))) -> U2_gg(X, p_in_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X))))))))))
   U2_gg(X, p_out_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))) -> p_out_gg(X, s(s(s(s(s(s(0)))))))
   U1_gg(X, Y, p_out_gg(X, s(s(Y)))) -> p_out_gg(X, s(s(s(s(s(s(s(Y))))))))

Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(45) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(46)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))
   P_IN_GG(X, s(s(s(s(s(s(s(Y)))))))) -> P_IN_GG(X, s(s(Y)))

R is empty.
Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(47) PiDPToQDPProof (EQUIVALENT)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(48)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))
   P_IN_GG(X, s(s(s(s(s(s(s(Y)))))))) -> P_IN_GG(X, s(s(Y)))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(49) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule P_IN_GG(X, s(s(s(s(s(s(s(Y)))))))) -> P_IN_GG(X, s(s(Y))) we obtained the following new rules [LPAR04]:

   (P_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> P_IN_GG(x0, s(s(s(s(s(s(0))))))),P_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> P_IN_GG(x0, s(s(s(s(s(s(0))))))))
   (P_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))) -> P_IN_GG(x0, s(s(s(s(s(s(s(y_1)))))))),P_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))) -> P_IN_GG(x0, s(s(s(s(s(s(s(y_1)))))))))


----------------------------------------

(50)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(X, s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))
   P_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> P_IN_GG(x0, s(s(s(s(s(s(0)))))))
   P_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))) -> P_IN_GG(x0, s(s(s(s(s(s(s(y_1))))))))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(51) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule P_IN_GG(X, s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X))))))))) we obtained the following new rules [LPAR04]:

   (P_IN_GG(s(s(s(0))), s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))),P_IN_GG(s(s(s(0))), s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))
   (P_IN_GG(s(s(s(s(y_1)))), s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))),P_IN_GG(s(s(s(s(y_1)))), s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))))


----------------------------------------

(52)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> P_IN_GG(x0, s(s(s(s(s(s(0)))))))
   P_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))) -> P_IN_GG(x0, s(s(s(s(s(s(s(y_1))))))))
   P_IN_GG(s(s(s(0))), s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0))))))))))))
   P_IN_GG(s(s(s(s(y_1)))), s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(y_1)))))))))))))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(53) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   P_IN_GG(s(s(s(0))), s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0))))))))))))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(P_IN_GG(x_1, x_2)) =  	[[0]] 	 +  	[[1, 0]] 	* 	x_1 	 +  	[[0, 0]] 	* 	x_2
>>>

   <<<
 POL(s(x_1)) =  	[[0], [0]] 	 +  	[[0, 1], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[0], [1]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:
none


----------------------------------------

(54)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   P_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> P_IN_GG(x0, s(s(s(s(s(s(0)))))))
   P_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))) -> P_IN_GG(x0, s(s(s(s(s(s(s(y_1))))))))
   P_IN_GG(s(s(s(s(y_1)))), s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(y_1)))))))))))))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(55) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(0))))))) evaluates to  t =P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(0)))))))

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))
with rule P_IN_GG(s(s(s(s(y_1)))), s(s(s(s(s(s(0))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))) at position [] and matcher [y_1 / s(s(s(s(0))))]

P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0))))))))))))
with rule P_IN_GG(x0', s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))) -> P_IN_GG(x0', s(s(s(s(s(s(s(y_1)))))))) at position [] and matcher [x0' / s(s(s(s(s(s(s(s(0)))))))), y_1 / s(s(s(s(0))))]

P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> P_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(0)))))))
with rule P_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> P_IN_GG(x0, s(s(s(s(s(s(0)))))))

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(56)
NO

----------------------------------------

(57) PrologToDTProblemTransformerProof (SOUND)
Built DT problem from termination graph DT10.

{
    "root": 2,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(p X (s (s (s (s (s (s (s Y))))))))",
                "(p X (s (s Y)))"
            ],
            [
                "(p X (s (s (s (s (s (s (0))))))))",
                "(p (s (s (s (s (s (s (s (s (0))))))))) (s (s (s (s (s (s (s (s X)))))))))"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "67": {
                "goal": [
                    {
                        "clause": -1,
                        "scope": -1,
                        "term": "(p T5 (s (s T6)))"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(p T5 (s (s (s (s (s (s (s T6))))))))"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T5",
                        "T6"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "78": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(p T1 T2)"
                }],
                "kb": {
                    "nonunifying": [[
                        "(p T1 T2)",
                        "(p X3 (s (s (s (s (s (s (s X4))))))))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [
                        "X3",
                        "X4"
                    ],
                    "exprvars": []
                }
            },
            "79": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 2,
                        "term": "(p T5 (s (s T6)))"
                    },
                    {
                        "clause": 1,
                        "scope": 2,
                        "term": "(p T5 (s (s T6)))"
                    },
                    {
                        "clause": -1,
                        "scope": 2,
                        "term": null
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(p T5 (s (s (s (s (s (s (s T6))))))))"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T5",
                        "T6"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "2": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "101": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "102": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p (s (s (s (s (s (s (s (s (0))))))))) (s (s (s (s (s (s (s (s T27)))))))))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T27"],
                    "free": [],
                    "exprvars": []
                }
            },
            "103": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "104": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 3,
                        "term": "(p (s (s (s (s (s (s (s (s (0))))))))) (s (s (s (s (s (s (s (s T27)))))))))"
                    },
                    {
                        "clause": 1,
                        "scope": 3,
                        "term": "(p (s (s (s (s (s (s (s (s (0))))))))) (s (s (s (s (s (s (s (s T27)))))))))"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T27"],
                    "free": [],
                    "exprvars": []
                }
            },
            "105": {
                "goal": [{
                    "clause": 0,
                    "scope": 3,
                    "term": "(p (s (s (s (s (s (s (s (s (0))))))))) (s (s (s (s (s (s (s (s T27)))))))))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T27"],
                    "free": [],
                    "exprvars": []
                }
            },
            "90": {
                "goal": [{
                    "clause": 1,
                    "scope": 2,
                    "term": "(p T5 (s (s T6)))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T5",
                        "T6"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "106": {
                "goal": [{
                    "clause": 1,
                    "scope": 3,
                    "term": "(p (s (s (s (s (s (s (s (s (0))))))))) (s (s (s (s (s (s (s (s T27)))))))))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T27"],
                    "free": [],
                    "exprvars": []
                }
            },
            "8": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 1,
                        "term": "(p T1 T2)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(p T1 T2)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "80": {
                "goal": [{
                    "clause": 0,
                    "scope": 2,
                    "term": "(p T5 (s (s T6)))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T5",
                        "T6"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "91": {
                "goal": [
                    {
                        "clause": -1,
                        "scope": 2,
                        "term": null
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(p T5 (s (s (s (s (s (s (s T6))))))))"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T5",
                        "T6"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "107": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p (s (s (s (s (s (s (s (s (0))))))))) (s (s (s T34))))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T34"],
                    "free": [],
                    "exprvars": []
                }
            },
            "81": {
                "goal": [
                    {
                        "clause": 1,
                        "scope": 2,
                        "term": "(p T5 (s (s T6)))"
                    },
                    {
                        "clause": -1,
                        "scope": 2,
                        "term": null
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(p T5 (s (s (s (s (s (s (s T6))))))))"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T5",
                        "T6"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "92": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p (s (s (s (s (s (s (s (s (0))))))))) (s (s (s (s (s (s (s (s T23)))))))))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T23"],
                    "free": [],
                    "exprvars": []
                }
            },
            "108": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "82": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p T15 (s (s T16)))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T15",
                        "T16"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "93": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "83": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "95": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(p T5 (s (s (s (s (s (s (s T6))))))))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T5",
                        "T6"
                    ],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 2,
                "to": 8,
                "label": "CASE"
            },
            {
                "from": 8,
                "to": 67,
                "label": "EVAL with clause\np(X3, s(s(s(s(s(s(s(X4)))))))) :- p(X3, s(s(X4))).\nand substitutionT1 -> T5,\nX3 -> T5,\nX4 -> T6,\nT2 -> s(s(s(s(s(s(s(T6)))))))"
            },
            {
                "from": 8,
                "to": 78,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 67,
                "to": 79,
                "label": "CASE"
            },
            {
                "from": 78,
                "to": 102,
                "label": "EVAL with clause\np(X26, s(s(s(s(s(s(0))))))) :- p(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X26))))))))).\nand substitutionT1 -> T27,\nX26 -> T27,\nT2 -> s(s(s(s(s(s(0))))))"
            },
            {
                "from": 78,
                "to": 103,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 79,
                "to": 80,
                "label": "PARALLEL"
            },
            {
                "from": 79,
                "to": 81,
                "label": "PARALLEL"
            },
            {
                "from": 80,
                "to": 82,
                "label": "EVAL with clause\np(X13, s(s(s(s(s(s(s(X14)))))))) :- p(X13, s(s(X14))).\nand substitutionT5 -> T15,\nX13 -> T15,\nX14 -> T16,\nT6 -> s(s(s(s(s(T16)))))"
            },
            {
                "from": 80,
                "to": 83,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 81,
                "to": 90,
                "label": "PARALLEL"
            },
            {
                "from": 81,
                "to": 91,
                "label": "PARALLEL"
            },
            {
                "from": 82,
                "to": 2,
                "label": "INSTANCE with matching:\nT1 -> T15\nT2 -> s(s(T16))"
            },
            {
                "from": 90,
                "to": 92,
                "label": "EVAL with clause\np(X21, s(s(s(s(s(s(0))))))) :- p(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X21))))))))).\nand substitutionT5 -> T23,\nX21 -> T23,\nT6 -> s(s(s(s(0))))"
            },
            {
                "from": 90,
                "to": 93,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 91,
                "to": 95,
                "label": "FAILURE"
            },
            {
                "from": 92,
                "to": 2,
                "label": "INSTANCE with matching:\nT1 -> s(s(s(s(s(s(s(s(0))))))))\nT2 -> s(s(s(s(s(s(s(s(T23))))))))"
            },
            {
                "from": 95,
                "to": 101,
                "label": "BACKTRACK\nfor clause: p(X, s(s(s(s(s(s(0))))))) :- p(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))because of non-unification"
            },
            {
                "from": 102,
                "to": 104,
                "label": "CASE"
            },
            {
                "from": 104,
                "to": 105,
                "label": "PARALLEL"
            },
            {
                "from": 104,
                "to": 106,
                "label": "PARALLEL"
            },
            {
                "from": 105,
                "to": 107,
                "label": "ONLY EVAL with clause\np(X39, s(s(s(s(s(s(s(X40)))))))) :- p(X39, s(s(X40))).\nand substitutionX39 -> s(s(s(s(s(s(s(s(0)))))))),\nT27 -> T34,\nX40 -> s(T34)"
            },
            {
                "from": 106,
                "to": 108,
                "label": "BACKTRACK\nfor clause: p(X, s(s(s(s(s(s(0))))))) :- p(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X)))))))))because of non-unification"
            },
            {
                "from": 107,
                "to": 2,
                "label": "INSTANCE with matching:\nT1 -> s(s(s(s(s(s(s(s(0))))))))\nT2 -> s(s(s(T34)))"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(58)
Obligation:
Triples:

pA(X1, s(s(s(s(s(s(s(s(s(s(s(s(X2))))))))))))) :- pA(X1, s(s(X2))).
pA(X1, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) :- pA(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X1))))))))).
pA(X1, s(s(s(s(s(s(0))))))) :- pA(s(s(s(s(s(s(s(s(0)))))))), s(s(s(X1)))).

Clauses:

pcA(X1, s(s(s(s(s(s(s(s(s(s(s(s(X2))))))))))))) :- pcA(X1, s(s(X2))).
pcA(X1, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) :- pcA(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X1))))))))).
pcA(X1, s(s(s(s(s(s(0))))))) :- pcA(s(s(s(s(s(s(s(s(0)))))))), s(s(s(X1)))).

Afs:

pA(x1, x2)  =  pA(x1, x2)


----------------------------------------

(59) TriplesToPiDPProof (SOUND)
We use the technique of [DT09]. With regard to the inferred argument filtering the predicates were used in the following modes:

pA_in_2: (b,b)

Transforming TRIPLES into the following Term Rewriting System:

Pi DP problem:
The TRS P consists of the following rules:

   PA_IN_GG(X1, s(s(s(s(s(s(s(s(s(s(s(s(X2))))))))))))) -> U1_GG(X1, X2, pA_in_gg(X1, s(s(X2))))
   PA_IN_GG(X1, s(s(s(s(s(s(s(s(s(s(s(s(X2))))))))))))) -> PA_IN_GG(X1, s(s(X2)))
   PA_IN_GG(X1, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> U2_GG(X1, pA_in_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X1))))))))))
   PA_IN_GG(X1, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X1)))))))))
   PA_IN_GG(X1, s(s(s(s(s(s(0))))))) -> U3_GG(X1, pA_in_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(X1)))))
   PA_IN_GG(X1, s(s(s(s(s(s(0))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(X1))))

R is empty.
Pi is empty.
We have to consider all (P,R,Pi)-chains


Infinitary Constructor Rewriting Termination of PiDP implies Termination of TRIPLES



----------------------------------------

(60)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   PA_IN_GG(X1, s(s(s(s(s(s(s(s(s(s(s(s(X2))))))))))))) -> U1_GG(X1, X2, pA_in_gg(X1, s(s(X2))))
   PA_IN_GG(X1, s(s(s(s(s(s(s(s(s(s(s(s(X2))))))))))))) -> PA_IN_GG(X1, s(s(X2)))
   PA_IN_GG(X1, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> U2_GG(X1, pA_in_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X1))))))))))
   PA_IN_GG(X1, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X1)))))))))
   PA_IN_GG(X1, s(s(s(s(s(s(0))))))) -> U3_GG(X1, pA_in_gg(s(s(s(s(s(s(s(s(0)))))))), s(s(s(X1)))))
   PA_IN_GG(X1, s(s(s(s(s(s(0))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(X1))))

R is empty.
Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(61) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 3 less nodes.
----------------------------------------

(62)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   PA_IN_GG(X1, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X1)))))))))
   PA_IN_GG(X1, s(s(s(s(s(s(s(s(s(s(s(s(X2))))))))))))) -> PA_IN_GG(X1, s(s(X2)))
   PA_IN_GG(X1, s(s(s(s(s(s(0))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(X1))))

R is empty.
Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(63) PiDPToQDPProof (EQUIVALENT)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(64)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PA_IN_GG(X1, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X1)))))))))
   PA_IN_GG(X1, s(s(s(s(s(s(s(s(s(s(s(s(X2))))))))))))) -> PA_IN_GG(X1, s(s(X2)))
   PA_IN_GG(X1, s(s(s(s(s(s(0))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(X1))))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(65) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule PA_IN_GG(X1, s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X1))))))))) we obtained the following new rules [LPAR04]:

   (PA_IN_GG(s(s(s(s(y_1)))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))),PA_IN_GG(s(s(s(s(y_1)))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))))
   (PA_IN_GG(s(s(s(0))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))),PA_IN_GG(s(s(s(0))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))


----------------------------------------

(66)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PA_IN_GG(X1, s(s(s(s(s(s(s(s(s(s(s(s(X2))))))))))))) -> PA_IN_GG(X1, s(s(X2)))
   PA_IN_GG(X1, s(s(s(s(s(s(0))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(X1))))
   PA_IN_GG(s(s(s(s(y_1)))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(y_1)))))))))))))
   PA_IN_GG(s(s(s(0))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0))))))))))))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(67) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule PA_IN_GG(X1, s(s(s(s(s(s(s(s(s(s(s(s(X2))))))))))))) -> PA_IN_GG(X1, s(s(X2))) we obtained the following new rules [LPAR04]:

   (PA_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))))) -> PA_IN_GG(x0, s(s(s(s(s(s(0))))))),PA_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))))) -> PA_IN_GG(x0, s(s(s(s(s(s(0))))))))
   (PA_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))))))))))))) -> PA_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))),PA_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))))))))))))) -> PA_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))))
   (PA_IN_GG(s(s(s(s(y_0)))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))))))) -> PA_IN_GG(s(s(s(s(y_0)))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))),PA_IN_GG(s(s(s(s(y_0)))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))))))) -> PA_IN_GG(s(s(s(s(y_0)))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))
   (PA_IN_GG(s(s(s(0))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))))))) -> PA_IN_GG(s(s(s(0))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))),PA_IN_GG(s(s(s(0))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))))))) -> PA_IN_GG(s(s(s(0))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))


----------------------------------------

(68)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PA_IN_GG(X1, s(s(s(s(s(s(0))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(X1))))
   PA_IN_GG(s(s(s(s(y_1)))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(y_1)))))))))))))
   PA_IN_GG(s(s(s(0))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0))))))))))))
   PA_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))))) -> PA_IN_GG(x0, s(s(s(s(s(s(0)))))))
   PA_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))))))))))))) -> PA_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(s(y_1)))))))))))))
   PA_IN_GG(s(s(s(s(y_0)))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))))))) -> PA_IN_GG(s(s(s(s(y_0)))), s(s(s(s(s(s(s(s(s(s(s(0))))))))))))
   PA_IN_GG(s(s(s(0))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))))))) -> PA_IN_GG(s(s(s(0))), s(s(s(s(s(s(s(s(s(s(s(0))))))))))))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(69) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule PA_IN_GG(X1, s(s(s(s(s(s(0))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(X1)))) we obtained the following new rules [LPAR04]:

   (PA_IN_GG(s(s(s(0))), s(s(s(s(s(s(0))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(0))))))),PA_IN_GG(s(s(s(0))), s(s(s(s(s(s(0))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(0))))))))
   (PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(0))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))),PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(0))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))
   (PA_IN_GG(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))), s(s(s(s(s(s(0))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))))),PA_IN_GG(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))), s(s(s(s(s(s(0))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))))))
   (PA_IN_GG(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))))))))), s(s(s(s(s(s(0))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))))))))))))),PA_IN_GG(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))))))))), s(s(s(s(s(s(0))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))))))))))))))
   (PA_IN_GG(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))), s(s(s(s(s(s(0))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))))))),PA_IN_GG(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))), s(s(s(s(s(s(0))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))))))))


----------------------------------------

(70)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PA_IN_GG(s(s(s(s(y_1)))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(y_1)))))))))))))
   PA_IN_GG(s(s(s(0))), s(s(s(s(s(s(s(s(s(s(s(0)))))))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0))))))))))))
   PA_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))))) -> PA_IN_GG(x0, s(s(s(s(s(s(0)))))))
   PA_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))))))))))))) -> PA_IN_GG(x0, s(s(s(s(s(s(s(s(s(s(s(s(y_1)))))))))))))
   PA_IN_GG(s(s(s(s(y_0)))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))))))) -> PA_IN_GG(s(s(s(s(y_0)))), s(s(s(s(s(s(s(s(s(s(s(0))))))))))))
   PA_IN_GG(s(s(s(0))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))))))) -> PA_IN_GG(s(s(s(0))), s(s(s(s(s(s(s(s(s(s(s(0))))))))))))
   PA_IN_GG(s(s(s(0))), s(s(s(s(s(s(0))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(0)))))))
   PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(0))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(0))))))))))))
   PA_IN_GG(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))), s(s(s(s(s(s(0))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))
   PA_IN_GG(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(y_1))))))))))))))))))), s(s(s(s(s(s(0))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(y_1)))))))))))))))))))))))
   PA_IN_GG(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))))), s(s(s(s(s(s(0))))))) -> PA_IN_GG(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))))))))))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(71) PrologToIRSwTTransformerProof (SOUND)
Transformed Prolog program to IRSwT according to method in Master Thesis of A. Weinert

{
    "root": 3,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(p X (s (s (s (s (s (s (s Y))))))))",
                "(p X (s (s Y)))"
            ],
            [
                "(p X (s (s (s (s (s (s (0))))))))",
                "(p (s (s (s (s (s (s (s (s (0))))))))) (s (s (s (s (s (s (s (s X)))))))))"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "77": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "3": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "18": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 1,
                        "term": "(p T1 T2)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(p T1 T2)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "19": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(p T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "94": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p (s (s (s (s (s (s (s (s (0))))))))) (s (s (s (s (s (s (s (s T17)))))))))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T17"],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "96": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "20": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(p T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "76": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p T11 (s (s T12)))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T11",
                        "T12"
                    ],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 3,
                "to": 18,
                "label": "CASE"
            },
            {
                "from": 18,
                "to": 19,
                "label": "PARALLEL"
            },
            {
                "from": 18,
                "to": 20,
                "label": "PARALLEL"
            },
            {
                "from": 19,
                "to": 76,
                "label": "EVAL with clause\np(X9, s(s(s(s(s(s(s(X10)))))))) :- p(X9, s(s(X10))).\nand substitutionT1 -> T11,\nX9 -> T11,\nX10 -> T12,\nT2 -> s(s(s(s(s(s(s(T12)))))))"
            },
            {
                "from": 19,
                "to": 77,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 20,
                "to": 94,
                "label": "EVAL with clause\np(X15, s(s(s(s(s(s(0))))))) :- p(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(X15))))))))).\nand substitutionT1 -> T17,\nX15 -> T17,\nT2 -> s(s(s(s(s(s(0))))))"
            },
            {
                "from": 20,
                "to": 96,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 76,
                "to": 3,
                "label": "INSTANCE with matching:\nT1 -> T11\nT2 -> s(s(T12))"
            },
            {
                "from": 94,
                "to": 3,
                "label": "INSTANCE with matching:\nT1 -> s(s(s(s(s(s(s(s(0))))))))\nT2 -> s(s(s(s(s(s(s(s(T17))))))))"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(72)
Obligation:
Rules:
f76_out(T11, T12) -> f19_out(T11, s(s(s(s(s(s(s(T12)))))))) :|: TRUE
f19_in(x, s(s(s(s(s(s(s(x1)))))))) -> f76_in(x, x1) :|: TRUE
f77_out -> f19_out(T1, T2) :|: TRUE
f19_in(x2, x3) -> f77_in :|: TRUE
f94_out(T17) -> f20_out(T17, s(s(s(s(s(s(0))))))) :|: TRUE
f96_out -> f20_out(x4, x5) :|: TRUE
f20_in(x6, s(s(s(s(s(s(0))))))) -> f94_in(x6) :|: TRUE
f20_in(x7, x8) -> f96_in :|: TRUE
f3_out(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(x9))))))))) -> f94_out(x9) :|: TRUE
f94_in(x10) -> f3_in(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(x10))))))))) :|: TRUE
f18_in(x11, x12) -> f19_in(x11, x12) :|: TRUE
f18_in(x13, x14) -> f20_in(x13, x14) :|: TRUE
f20_out(x15, x16) -> f18_out(x15, x16) :|: TRUE
f19_out(x17, x18) -> f18_out(x17, x18) :|: TRUE
f3_in(x19, x20) -> f18_in(x19, x20) :|: TRUE
f18_out(x21, x22) -> f3_out(x21, x22) :|: TRUE
f76_in(x23, x24) -> f3_in(x23, s(s(x24))) :|: TRUE
f3_out(x25, s(s(x26))) -> f76_out(x25, x26) :|: TRUE
Start term: f3_in(T1, T2)

----------------------------------------

(73) IRSwTSimpleDependencyGraphProof (EQUIVALENT)
Constructed simple dependency graph.

Simplified to the following IRSwTs:

intTRSProblem:
f19_in(x, s(s(s(s(s(s(s(x1)))))))) -> f76_in(x, x1) :|: TRUE
f20_in(x6, s(s(s(s(s(s(0))))))) -> f94_in(x6) :|: TRUE
f94_in(x10) -> f3_in(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(x10))))))))) :|: TRUE
f18_in(x11, x12) -> f19_in(x11, x12) :|: TRUE
f18_in(x13, x14) -> f20_in(x13, x14) :|: TRUE
f3_in(x19, x20) -> f18_in(x19, x20) :|: TRUE
f76_in(x23, x24) -> f3_in(x23, s(s(x24))) :|: TRUE


----------------------------------------

(74)
Obligation:
Rules:
f19_in(x, s(s(s(s(s(s(s(x1)))))))) -> f76_in(x, x1) :|: TRUE
f20_in(x6, s(s(s(s(s(s(0))))))) -> f94_in(x6) :|: TRUE
f94_in(x10) -> f3_in(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(x10))))))))) :|: TRUE
f18_in(x11, x12) -> f19_in(x11, x12) :|: TRUE
f18_in(x13, x14) -> f20_in(x13, x14) :|: TRUE
f3_in(x19, x20) -> f18_in(x19, x20) :|: TRUE
f76_in(x23, x24) -> f3_in(x23, s(s(x24))) :|: TRUE

----------------------------------------

(75) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(76)
Obligation:
Rules:
f18_in(x11:0, s(s(s(s(s(s(s(x1:0)))))))) -> f18_in(x11:0, s(s(x1:0))) :|: TRUE
f18_in(x13:0, s(s(s(s(s(s(cons_0))))))) -> f18_in(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(x13:0))))))))) :|: TRUE && cons_0 = 0

----------------------------------------

(77) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(78)
Obligation:
Rules:
f18_in(x11:0, s(s(s(s(s(s(s(x1:0)))))))) -> f18_in(x11:0, s(s(x1:0))) :|: TRUE
f18_in(x13:0, s(s(s(s(s(s(cons_0))))))) -> f18_in(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(x13:0))))))))) :|: TRUE && cons_0 = 0

----------------------------------------

(79) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f18_in(x11:0, s(s(s(s(s(s(s(x1:0)))))))) -> f18_in(x11:0, s(s(x1:0))) :|: TRUE
(2) f18_in(x13:0, s(s(s(s(s(s(cons_0))))))) -> f18_in(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(x13:0))))))))) :|: TRUE && cons_0 = 0

Arcs:
(1) -> (1), (2)
(2) -> (1)

This digraph is fully evaluated!
----------------------------------------

(80)
Obligation:

Termination digraph:
Nodes:
(1) f18_in(x11:0, s(s(s(s(s(s(s(x1:0)))))))) -> f18_in(x11:0, s(s(x1:0))) :|: TRUE
(2) f18_in(x13:0, s(s(s(s(s(s(cons_0))))))) -> f18_in(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(x13:0))))))))) :|: TRUE && cons_0 = 0

Arcs:
(1) -> (1), (2)
(2) -> (1)

This digraph is fully evaluated!

----------------------------------------

(81) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(82)
Obligation:
Rules:
f18_in(x11:0:0, s(s(s(s(s(s(s(x1:0:0)))))))) -> f18_in(x11:0:0, s(s(x1:0:0))) :|: TRUE
f18_in(x13:0:0, s(s(s(s(s(s(cons_0))))))) -> f18_in(s(s(s(s(s(s(s(s(0)))))))), s(s(s(s(s(s(s(s(x13:0:0))))))))) :|: TRUE && cons_0 = 0
