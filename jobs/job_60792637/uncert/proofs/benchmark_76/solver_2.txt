MAYBE
proof of /hpcwork/ff862203/termcomp25/benchmarks/5FflH.pl
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Left Termination of the query pattern

suffix(g,a)

w.r.t. the given Prolog program could not be shown:

(0) Prolog
(1) PrologToPiTRSProof [SOUND, 0 ms]
(2) PiTRS
    (3) DependencyPairsProof [EQUIVALENT, 0 ms]
    (4) PiDP
    (5) DependencyGraphProof [EQUIVALENT, 0 ms]
    (6) PiDP
    (7) UsableRulesProof [EQUIVALENT, 0 ms]
    (8) PiDP
    (9) PiDPToQDPProof [SOUND, 0 ms]
    (10) QDP
(11) PrologToPiTRSProof [SOUND, 0 ms]
(12) PiTRS
    (13) DependencyPairsProof [EQUIVALENT, 0 ms]
    (14) PiDP
    (15) DependencyGraphProof [EQUIVALENT, 0 ms]
    (16) PiDP
    (17) UsableRulesProof [EQUIVALENT, 0 ms]
    (18) PiDP
    (19) PiDPToQDPProof [SOUND, 0 ms]
    (20) QDP
(21) PrologToTRSTransformerProof [SOUND, 0 ms]
(22) QTRS
    (23) DependencyPairsProof [EQUIVALENT, 0 ms]
    (24) QDP
    (25) DependencyGraphProof [EQUIVALENT, 0 ms]
    (26) QDP
    (27) MNOCProof [EQUIVALENT, 0 ms]
    (28) QDP
    (29) UsableRulesProof [EQUIVALENT, 0 ms]
    (30) QDP
    (31) QReductionProof [EQUIVALENT, 0 ms]
    (32) QDP
(33) PrologToIRSwTTransformerProof [SOUND, 0 ms]
(34) IRSwT
    (35) IRSwTSimpleDependencyGraphProof [EQUIVALENT, 0 ms]
    (36) IRSwT
    (37) IntTRSCompressionProof [EQUIVALENT, 12 ms]
    (38) IRSwT
    (39) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
    (40) IRSwT
    (41) IRSwTTerminationDigraphProof [EQUIVALENT, 0 ms]
    (42) IRSwT
    (43) FilterProof [EQUIVALENT, 0 ms]
    (44) IntTRS
    (45) IntTRSPeriodicNontermProof [COMPLETE, 0 ms]
    (46) NO
(47) PrologToDTProblemTransformerProof [SOUND, 0 ms]
(48) TRIPLES
    (49) TriplesToPiDPProof [SOUND, 0 ms]
    (50) PiDP
    (51) DependencyGraphProof [EQUIVALENT, 0 ms]
    (52) PiDP
    (53) PiDPToQDPProof [SOUND, 0 ms]
    (54) QDP


----------------------------------------

(0)
Obligation:
Clauses:

suffix(Xs, Ys) :- app(X1, Xs, Ys).
app([], X, X).
app(.(X, Xs), Ys, .(X, Zs)) :- app(Xs, Ys, Zs).


Query: suffix(g,a)
----------------------------------------

(1) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

suffix_in_2: (b,f)

app_in_3: (f,b,f)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   suffix_in_ga(Xs, Ys) -> U1_ga(Xs, Ys, app_in_aga(X1, Xs, Ys))
   app_in_aga([], X, X) -> app_out_aga([], X, X)
   app_in_aga(.(X, Xs), Ys, .(X, Zs)) -> U2_aga(X, Xs, Ys, Zs, app_in_aga(Xs, Ys, Zs))
   U2_aga(X, Xs, Ys, Zs, app_out_aga(Xs, Ys, Zs)) -> app_out_aga(.(X, Xs), Ys, .(X, Zs))
   U1_ga(Xs, Ys, app_out_aga(X1, Xs, Ys)) -> suffix_out_ga(Xs, Ys)

The argument filtering Pi contains the following mapping:
suffix_in_ga(x1, x2)  =  suffix_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

app_in_aga(x1, x2, x3)  =  app_in_aga(x2)

app_out_aga(x1, x2, x3)  =  app_out_aga(x1, x2, x3)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x3, x5)

.(x1, x2)  =  .(x2)

suffix_out_ga(x1, x2)  =  suffix_out_ga(x1, x2)





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(2)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   suffix_in_ga(Xs, Ys) -> U1_ga(Xs, Ys, app_in_aga(X1, Xs, Ys))
   app_in_aga([], X, X) -> app_out_aga([], X, X)
   app_in_aga(.(X, Xs), Ys, .(X, Zs)) -> U2_aga(X, Xs, Ys, Zs, app_in_aga(Xs, Ys, Zs))
   U2_aga(X, Xs, Ys, Zs, app_out_aga(Xs, Ys, Zs)) -> app_out_aga(.(X, Xs), Ys, .(X, Zs))
   U1_ga(Xs, Ys, app_out_aga(X1, Xs, Ys)) -> suffix_out_ga(Xs, Ys)

The argument filtering Pi contains the following mapping:
suffix_in_ga(x1, x2)  =  suffix_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

app_in_aga(x1, x2, x3)  =  app_in_aga(x2)

app_out_aga(x1, x2, x3)  =  app_out_aga(x1, x2, x3)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x3, x5)

.(x1, x2)  =  .(x2)

suffix_out_ga(x1, x2)  =  suffix_out_ga(x1, x2)



----------------------------------------

(3) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   SUFFIX_IN_GA(Xs, Ys) -> U1_GA(Xs, Ys, app_in_aga(X1, Xs, Ys))
   SUFFIX_IN_GA(Xs, Ys) -> APP_IN_AGA(X1, Xs, Ys)
   APP_IN_AGA(.(X, Xs), Ys, .(X, Zs)) -> U2_AGA(X, Xs, Ys, Zs, app_in_aga(Xs, Ys, Zs))
   APP_IN_AGA(.(X, Xs), Ys, .(X, Zs)) -> APP_IN_AGA(Xs, Ys, Zs)

The TRS R consists of the following rules:

   suffix_in_ga(Xs, Ys) -> U1_ga(Xs, Ys, app_in_aga(X1, Xs, Ys))
   app_in_aga([], X, X) -> app_out_aga([], X, X)
   app_in_aga(.(X, Xs), Ys, .(X, Zs)) -> U2_aga(X, Xs, Ys, Zs, app_in_aga(Xs, Ys, Zs))
   U2_aga(X, Xs, Ys, Zs, app_out_aga(Xs, Ys, Zs)) -> app_out_aga(.(X, Xs), Ys, .(X, Zs))
   U1_ga(Xs, Ys, app_out_aga(X1, Xs, Ys)) -> suffix_out_ga(Xs, Ys)

The argument filtering Pi contains the following mapping:
suffix_in_ga(x1, x2)  =  suffix_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

app_in_aga(x1, x2, x3)  =  app_in_aga(x2)

app_out_aga(x1, x2, x3)  =  app_out_aga(x1, x2, x3)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x3, x5)

.(x1, x2)  =  .(x2)

suffix_out_ga(x1, x2)  =  suffix_out_ga(x1, x2)

SUFFIX_IN_GA(x1, x2)  =  SUFFIX_IN_GA(x1)

U1_GA(x1, x2, x3)  =  U1_GA(x1, x3)

APP_IN_AGA(x1, x2, x3)  =  APP_IN_AGA(x2)

U2_AGA(x1, x2, x3, x4, x5)  =  U2_AGA(x3, x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(4)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   SUFFIX_IN_GA(Xs, Ys) -> U1_GA(Xs, Ys, app_in_aga(X1, Xs, Ys))
   SUFFIX_IN_GA(Xs, Ys) -> APP_IN_AGA(X1, Xs, Ys)
   APP_IN_AGA(.(X, Xs), Ys, .(X, Zs)) -> U2_AGA(X, Xs, Ys, Zs, app_in_aga(Xs, Ys, Zs))
   APP_IN_AGA(.(X, Xs), Ys, .(X, Zs)) -> APP_IN_AGA(Xs, Ys, Zs)

The TRS R consists of the following rules:

   suffix_in_ga(Xs, Ys) -> U1_ga(Xs, Ys, app_in_aga(X1, Xs, Ys))
   app_in_aga([], X, X) -> app_out_aga([], X, X)
   app_in_aga(.(X, Xs), Ys, .(X, Zs)) -> U2_aga(X, Xs, Ys, Zs, app_in_aga(Xs, Ys, Zs))
   U2_aga(X, Xs, Ys, Zs, app_out_aga(Xs, Ys, Zs)) -> app_out_aga(.(X, Xs), Ys, .(X, Zs))
   U1_ga(Xs, Ys, app_out_aga(X1, Xs, Ys)) -> suffix_out_ga(Xs, Ys)

The argument filtering Pi contains the following mapping:
suffix_in_ga(x1, x2)  =  suffix_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

app_in_aga(x1, x2, x3)  =  app_in_aga(x2)

app_out_aga(x1, x2, x3)  =  app_out_aga(x1, x2, x3)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x3, x5)

.(x1, x2)  =  .(x2)

suffix_out_ga(x1, x2)  =  suffix_out_ga(x1, x2)

SUFFIX_IN_GA(x1, x2)  =  SUFFIX_IN_GA(x1)

U1_GA(x1, x2, x3)  =  U1_GA(x1, x3)

APP_IN_AGA(x1, x2, x3)  =  APP_IN_AGA(x2)

U2_AGA(x1, x2, x3, x4, x5)  =  U2_AGA(x3, x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(5) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 3 less nodes.
----------------------------------------

(6)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   APP_IN_AGA(.(X, Xs), Ys, .(X, Zs)) -> APP_IN_AGA(Xs, Ys, Zs)

The TRS R consists of the following rules:

   suffix_in_ga(Xs, Ys) -> U1_ga(Xs, Ys, app_in_aga(X1, Xs, Ys))
   app_in_aga([], X, X) -> app_out_aga([], X, X)
   app_in_aga(.(X, Xs), Ys, .(X, Zs)) -> U2_aga(X, Xs, Ys, Zs, app_in_aga(Xs, Ys, Zs))
   U2_aga(X, Xs, Ys, Zs, app_out_aga(Xs, Ys, Zs)) -> app_out_aga(.(X, Xs), Ys, .(X, Zs))
   U1_ga(Xs, Ys, app_out_aga(X1, Xs, Ys)) -> suffix_out_ga(Xs, Ys)

The argument filtering Pi contains the following mapping:
suffix_in_ga(x1, x2)  =  suffix_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

app_in_aga(x1, x2, x3)  =  app_in_aga(x2)

app_out_aga(x1, x2, x3)  =  app_out_aga(x1, x2, x3)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x3, x5)

.(x1, x2)  =  .(x2)

suffix_out_ga(x1, x2)  =  suffix_out_ga(x1, x2)

APP_IN_AGA(x1, x2, x3)  =  APP_IN_AGA(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(7) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(8)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   APP_IN_AGA(.(X, Xs), Ys, .(X, Zs)) -> APP_IN_AGA(Xs, Ys, Zs)

R is empty.
The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x2)

APP_IN_AGA(x1, x2, x3)  =  APP_IN_AGA(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(9) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(10)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   APP_IN_AGA(Ys) -> APP_IN_AGA(Ys)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(11) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

suffix_in_2: (b,f)

app_in_3: (f,b,f)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   suffix_in_ga(Xs, Ys) -> U1_ga(Xs, Ys, app_in_aga(X1, Xs, Ys))
   app_in_aga([], X, X) -> app_out_aga([], X, X)
   app_in_aga(.(X, Xs), Ys, .(X, Zs)) -> U2_aga(X, Xs, Ys, Zs, app_in_aga(Xs, Ys, Zs))
   U2_aga(X, Xs, Ys, Zs, app_out_aga(Xs, Ys, Zs)) -> app_out_aga(.(X, Xs), Ys, .(X, Zs))
   U1_ga(Xs, Ys, app_out_aga(X1, Xs, Ys)) -> suffix_out_ga(Xs, Ys)

The argument filtering Pi contains the following mapping:
suffix_in_ga(x1, x2)  =  suffix_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

app_in_aga(x1, x2, x3)  =  app_in_aga(x2)

app_out_aga(x1, x2, x3)  =  app_out_aga(x1, x3)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x5)

.(x1, x2)  =  .(x2)

suffix_out_ga(x1, x2)  =  suffix_out_ga(x2)





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(12)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   suffix_in_ga(Xs, Ys) -> U1_ga(Xs, Ys, app_in_aga(X1, Xs, Ys))
   app_in_aga([], X, X) -> app_out_aga([], X, X)
   app_in_aga(.(X, Xs), Ys, .(X, Zs)) -> U2_aga(X, Xs, Ys, Zs, app_in_aga(Xs, Ys, Zs))
   U2_aga(X, Xs, Ys, Zs, app_out_aga(Xs, Ys, Zs)) -> app_out_aga(.(X, Xs), Ys, .(X, Zs))
   U1_ga(Xs, Ys, app_out_aga(X1, Xs, Ys)) -> suffix_out_ga(Xs, Ys)

The argument filtering Pi contains the following mapping:
suffix_in_ga(x1, x2)  =  suffix_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

app_in_aga(x1, x2, x3)  =  app_in_aga(x2)

app_out_aga(x1, x2, x3)  =  app_out_aga(x1, x3)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x5)

.(x1, x2)  =  .(x2)

suffix_out_ga(x1, x2)  =  suffix_out_ga(x2)



----------------------------------------

(13) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   SUFFIX_IN_GA(Xs, Ys) -> U1_GA(Xs, Ys, app_in_aga(X1, Xs, Ys))
   SUFFIX_IN_GA(Xs, Ys) -> APP_IN_AGA(X1, Xs, Ys)
   APP_IN_AGA(.(X, Xs), Ys, .(X, Zs)) -> U2_AGA(X, Xs, Ys, Zs, app_in_aga(Xs, Ys, Zs))
   APP_IN_AGA(.(X, Xs), Ys, .(X, Zs)) -> APP_IN_AGA(Xs, Ys, Zs)

The TRS R consists of the following rules:

   suffix_in_ga(Xs, Ys) -> U1_ga(Xs, Ys, app_in_aga(X1, Xs, Ys))
   app_in_aga([], X, X) -> app_out_aga([], X, X)
   app_in_aga(.(X, Xs), Ys, .(X, Zs)) -> U2_aga(X, Xs, Ys, Zs, app_in_aga(Xs, Ys, Zs))
   U2_aga(X, Xs, Ys, Zs, app_out_aga(Xs, Ys, Zs)) -> app_out_aga(.(X, Xs), Ys, .(X, Zs))
   U1_ga(Xs, Ys, app_out_aga(X1, Xs, Ys)) -> suffix_out_ga(Xs, Ys)

The argument filtering Pi contains the following mapping:
suffix_in_ga(x1, x2)  =  suffix_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

app_in_aga(x1, x2, x3)  =  app_in_aga(x2)

app_out_aga(x1, x2, x3)  =  app_out_aga(x1, x3)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x5)

.(x1, x2)  =  .(x2)

suffix_out_ga(x1, x2)  =  suffix_out_ga(x2)

SUFFIX_IN_GA(x1, x2)  =  SUFFIX_IN_GA(x1)

U1_GA(x1, x2, x3)  =  U1_GA(x3)

APP_IN_AGA(x1, x2, x3)  =  APP_IN_AGA(x2)

U2_AGA(x1, x2, x3, x4, x5)  =  U2_AGA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(14)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   SUFFIX_IN_GA(Xs, Ys) -> U1_GA(Xs, Ys, app_in_aga(X1, Xs, Ys))
   SUFFIX_IN_GA(Xs, Ys) -> APP_IN_AGA(X1, Xs, Ys)
   APP_IN_AGA(.(X, Xs), Ys, .(X, Zs)) -> U2_AGA(X, Xs, Ys, Zs, app_in_aga(Xs, Ys, Zs))
   APP_IN_AGA(.(X, Xs), Ys, .(X, Zs)) -> APP_IN_AGA(Xs, Ys, Zs)

The TRS R consists of the following rules:

   suffix_in_ga(Xs, Ys) -> U1_ga(Xs, Ys, app_in_aga(X1, Xs, Ys))
   app_in_aga([], X, X) -> app_out_aga([], X, X)
   app_in_aga(.(X, Xs), Ys, .(X, Zs)) -> U2_aga(X, Xs, Ys, Zs, app_in_aga(Xs, Ys, Zs))
   U2_aga(X, Xs, Ys, Zs, app_out_aga(Xs, Ys, Zs)) -> app_out_aga(.(X, Xs), Ys, .(X, Zs))
   U1_ga(Xs, Ys, app_out_aga(X1, Xs, Ys)) -> suffix_out_ga(Xs, Ys)

The argument filtering Pi contains the following mapping:
suffix_in_ga(x1, x2)  =  suffix_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

app_in_aga(x1, x2, x3)  =  app_in_aga(x2)

app_out_aga(x1, x2, x3)  =  app_out_aga(x1, x3)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x5)

.(x1, x2)  =  .(x2)

suffix_out_ga(x1, x2)  =  suffix_out_ga(x2)

SUFFIX_IN_GA(x1, x2)  =  SUFFIX_IN_GA(x1)

U1_GA(x1, x2, x3)  =  U1_GA(x3)

APP_IN_AGA(x1, x2, x3)  =  APP_IN_AGA(x2)

U2_AGA(x1, x2, x3, x4, x5)  =  U2_AGA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(15) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 3 less nodes.
----------------------------------------

(16)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   APP_IN_AGA(.(X, Xs), Ys, .(X, Zs)) -> APP_IN_AGA(Xs, Ys, Zs)

The TRS R consists of the following rules:

   suffix_in_ga(Xs, Ys) -> U1_ga(Xs, Ys, app_in_aga(X1, Xs, Ys))
   app_in_aga([], X, X) -> app_out_aga([], X, X)
   app_in_aga(.(X, Xs), Ys, .(X, Zs)) -> U2_aga(X, Xs, Ys, Zs, app_in_aga(Xs, Ys, Zs))
   U2_aga(X, Xs, Ys, Zs, app_out_aga(Xs, Ys, Zs)) -> app_out_aga(.(X, Xs), Ys, .(X, Zs))
   U1_ga(Xs, Ys, app_out_aga(X1, Xs, Ys)) -> suffix_out_ga(Xs, Ys)

The argument filtering Pi contains the following mapping:
suffix_in_ga(x1, x2)  =  suffix_in_ga(x1)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

app_in_aga(x1, x2, x3)  =  app_in_aga(x2)

app_out_aga(x1, x2, x3)  =  app_out_aga(x1, x3)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x5)

.(x1, x2)  =  .(x2)

suffix_out_ga(x1, x2)  =  suffix_out_ga(x2)

APP_IN_AGA(x1, x2, x3)  =  APP_IN_AGA(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(17) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(18)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   APP_IN_AGA(.(X, Xs), Ys, .(X, Zs)) -> APP_IN_AGA(Xs, Ys, Zs)

R is empty.
The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x2)

APP_IN_AGA(x1, x2, x3)  =  APP_IN_AGA(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(19) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(20)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   APP_IN_AGA(Ys) -> APP_IN_AGA(Ys)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(21) PrologToTRSTransformerProof (SOUND)
Transformed Prolog program to TRS.

{
    "root": 3,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(suffix Xs Ys)",
                "(app X1 Xs Ys)"
            ],
            [
                "(app ([]) X X)",
                null
            ],
            [
                "(app (. X Xs) Ys (. X Zs))",
                "(app Xs Ys Zs)"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "143": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "111": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(suffix T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "144": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "145": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(app X36 T26 T29)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T26"],
                    "free": ["X36"],
                    "exprvars": []
                }
            },
            "3": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(suffix T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "146": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "138": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(app X11 T10 T12)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T10"],
                    "free": ["X11"],
                    "exprvars": []
                }
            },
            "139": {
                "goal": [
                    {
                        "clause": 1,
                        "scope": 2,
                        "term": "(app X11 T10 T12)"
                    },
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(app X11 T10 T12)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T10"],
                    "free": ["X11"],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "140": {
                "goal": [{
                    "clause": 1,
                    "scope": 2,
                    "term": "(app X11 T10 T12)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T10"],
                    "free": ["X11"],
                    "exprvars": []
                }
            },
            "141": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(app X11 T10 T12)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T10"],
                    "free": ["X11"],
                    "exprvars": []
                }
            },
            "142": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 3,
                "to": 111,
                "label": "CASE"
            },
            {
                "from": 111,
                "to": 138,
                "label": "ONLY EVAL with clause\nsuffix(X9, X10) :- app(X11, X9, X10).\nand substitutionT1 -> T10,\nX9 -> T10,\nT2 -> T12,\nX10 -> T12,\nT11 -> T12"
            },
            {
                "from": 138,
                "to": 139,
                "label": "CASE"
            },
            {
                "from": 139,
                "to": 140,
                "label": "PARALLEL"
            },
            {
                "from": 139,
                "to": 141,
                "label": "PARALLEL"
            },
            {
                "from": 140,
                "to": 142,
                "label": "EVAL with clause\napp([], X18, X18).\nand substitutionX11 -> [],\nT10 -> T19,\nX18 -> T19,\nT12 -> T19"
            },
            {
                "from": 140,
                "to": 143,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 141,
                "to": 145,
                "label": "EVAL with clause\napp(.(X31, X32), X33, .(X31, X34)) :- app(X32, X33, X34).\nand substitutionX31 -> T27,\nX32 -> X36,\nX11 -> .(T27, X36),\nT10 -> T26,\nX33 -> T26,\nX35 -> T27,\nX34 -> T29,\nT12 -> .(T27, T29),\nT28 -> T29"
            },
            {
                "from": 141,
                "to": 146,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 142,
                "to": 144,
                "label": "SUCCESS"
            },
            {
                "from": 145,
                "to": 138,
                "label": "INSTANCE with matching:\nX11 -> X36\nT10 -> T26\nT12 -> T29"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(22)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f3_in(T10) -> U1(f138_in(T10), T10)
   U1(f138_out1, T10) -> f3_out1
   f138_in(T19) -> f138_out1
   f138_in(T26) -> U2(f138_in(T26), T26)
   U2(f138_out1, T26) -> f138_out1

Q is empty.

----------------------------------------

(23) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(24)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F3_IN(T10) -> U1^1(f138_in(T10), T10)
   F3_IN(T10) -> F138_IN(T10)
   F138_IN(T26) -> U2^1(f138_in(T26), T26)
   F138_IN(T26) -> F138_IN(T26)

The TRS R consists of the following rules:

   f3_in(T10) -> U1(f138_in(T10), T10)
   U1(f138_out1, T10) -> f3_out1
   f138_in(T19) -> f138_out1
   f138_in(T26) -> U2(f138_in(T26), T26)
   U2(f138_out1, T26) -> f138_out1

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(25) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 3 less nodes.
----------------------------------------

(26)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F138_IN(T26) -> F138_IN(T26)

The TRS R consists of the following rules:

   f3_in(T10) -> U1(f138_in(T10), T10)
   U1(f138_out1, T10) -> f3_out1
   f138_in(T19) -> f138_out1
   f138_in(T26) -> U2(f138_in(T26), T26)
   U2(f138_out1, T26) -> f138_out1

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(27) MNOCProof (EQUIVALENT)
We use the modular non-overlap check [LPAR04] to enlarge Q to all left-hand sides of R.
----------------------------------------

(28)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F138_IN(T26) -> F138_IN(T26)

The TRS R consists of the following rules:

   f3_in(T10) -> U1(f138_in(T10), T10)
   U1(f138_out1, T10) -> f3_out1
   f138_in(T19) -> f138_out1
   f138_in(T26) -> U2(f138_in(T26), T26)
   U2(f138_out1, T26) -> f138_out1

The set Q consists of the following terms:

   f3_in(x0)
   U1(f138_out1, x0)
   f138_in(x0)
   U2(f138_out1, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(29) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(30)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F138_IN(T26) -> F138_IN(T26)

R is empty.
The set Q consists of the following terms:

   f3_in(x0)
   U1(f138_out1, x0)
   f138_in(x0)
   U2(f138_out1, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(31) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   f3_in(x0)
   U1(f138_out1, x0)
   f138_in(x0)
   U2(f138_out1, x0)


----------------------------------------

(32)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F138_IN(T26) -> F138_IN(T26)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(33) PrologToIRSwTTransformerProof (SOUND)
Transformed Prolog program to IRSwT according to method in Master Thesis of A. Weinert

{
    "root": 2,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(suffix Xs Ys)",
                "(app X1 Xs Ys)"
            ],
            [
                "(app ([]) X X)",
                null
            ],
            [
                "(app (. X Xs) Ys (. X Zs))",
                "(app Xs Ys Zs)"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "110": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(suffix T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "132": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(app X11 T10 T12)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T10"],
                    "free": ["X11"],
                    "exprvars": []
                }
            },
            "133": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "2": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(suffix T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "134": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "124": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(app X11 T10 T12)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T10"],
                    "free": ["X11"],
                    "exprvars": []
                }
            },
            "135": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "136": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(app X36 T26 T29)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T26"],
                    "free": ["X36"],
                    "exprvars": []
                }
            },
            "137": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "128": {
                "goal": [
                    {
                        "clause": 1,
                        "scope": 2,
                        "term": "(app X11 T10 T12)"
                    },
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(app X11 T10 T12)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T10"],
                    "free": ["X11"],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "131": {
                "goal": [{
                    "clause": 1,
                    "scope": 2,
                    "term": "(app X11 T10 T12)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T10"],
                    "free": ["X11"],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 2,
                "to": 110,
                "label": "CASE"
            },
            {
                "from": 110,
                "to": 124,
                "label": "ONLY EVAL with clause\nsuffix(X9, X10) :- app(X11, X9, X10).\nand substitutionT1 -> T10,\nX9 -> T10,\nT2 -> T12,\nX10 -> T12,\nT11 -> T12"
            },
            {
                "from": 124,
                "to": 128,
                "label": "CASE"
            },
            {
                "from": 128,
                "to": 131,
                "label": "PARALLEL"
            },
            {
                "from": 128,
                "to": 132,
                "label": "PARALLEL"
            },
            {
                "from": 131,
                "to": 133,
                "label": "EVAL with clause\napp([], X18, X18).\nand substitutionX11 -> [],\nT10 -> T19,\nX18 -> T19,\nT12 -> T19"
            },
            {
                "from": 131,
                "to": 134,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 132,
                "to": 136,
                "label": "EVAL with clause\napp(.(X31, X32), X33, .(X31, X34)) :- app(X32, X33, X34).\nand substitutionX31 -> T27,\nX32 -> X36,\nX11 -> .(T27, X36),\nT10 -> T26,\nX33 -> T26,\nX35 -> T27,\nX34 -> T29,\nT12 -> .(T27, T29),\nT28 -> T29"
            },
            {
                "from": 132,
                "to": 137,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 133,
                "to": 135,
                "label": "SUCCESS"
            },
            {
                "from": 136,
                "to": 124,
                "label": "INSTANCE with matching:\nX11 -> X36\nT10 -> T26\nT12 -> T29"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(34)
Obligation:
Rules:
f128_out(T10) -> f124_out(T10) :|: TRUE
f124_in(x) -> f128_in(x) :|: TRUE
f136_in(T26) -> f124_in(T26) :|: TRUE
f124_out(x1) -> f136_out(x1) :|: TRUE
f136_out(x2) -> f132_out(x2) :|: TRUE
f137_out -> f132_out(x3) :|: TRUE
f132_in(x4) -> f136_in(x4) :|: TRUE
f132_in(x5) -> f137_in :|: TRUE
f131_out(x6) -> f128_out(x6) :|: TRUE
f128_in(x7) -> f132_in(x7) :|: TRUE
f132_out(x8) -> f128_out(x8) :|: TRUE
f128_in(x9) -> f131_in(x9) :|: TRUE
f2_in(T1) -> f110_in(T1) :|: TRUE
f110_out(x10) -> f2_out(x10) :|: TRUE
f110_in(x11) -> f124_in(x11) :|: TRUE
f124_out(x12) -> f110_out(x12) :|: TRUE
Start term: f2_in(T1)

----------------------------------------

(35) IRSwTSimpleDependencyGraphProof (EQUIVALENT)
Constructed simple dependency graph.

Simplified to the following IRSwTs:

intTRSProblem:
f124_in(x) -> f128_in(x) :|: TRUE
f136_in(T26) -> f124_in(T26) :|: TRUE
f132_in(x4) -> f136_in(x4) :|: TRUE
f128_in(x7) -> f132_in(x7) :|: TRUE


----------------------------------------

(36)
Obligation:
Rules:
f124_in(x) -> f128_in(x) :|: TRUE
f136_in(T26) -> f124_in(T26) :|: TRUE
f132_in(x4) -> f136_in(x4) :|: TRUE
f128_in(x7) -> f132_in(x7) :|: TRUE

----------------------------------------

(37) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(38)
Obligation:
Rules:
f132_in(x4:0) -> f132_in(x4:0) :|: TRUE

----------------------------------------

(39) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(40)
Obligation:
Rules:
f132_in(x4:0) -> f132_in(x4:0) :|: TRUE

----------------------------------------

(41) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f132_in(x4:0) -> f132_in(x4:0) :|: TRUE

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(42)
Obligation:

Termination digraph:
Nodes:
(1) f132_in(x4:0) -> f132_in(x4:0) :|: TRUE

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(43) FilterProof (EQUIVALENT)
Used the following sort dictionary for filtering: 
f132_in(VARIABLE)
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(44)
Obligation:
Rules:
f132_in(x4:0) -> f132_in(x4:0) :|: TRUE

----------------------------------------

(45) IntTRSPeriodicNontermProof (COMPLETE)
Normalized system to the following form:
f(pc, x4:0) -> f(1, x4:0) :|: pc = 1 && TRUE
Witness term starting non-terminating reduction: f(1, -8)
----------------------------------------

(46)
NO

----------------------------------------

(47) PrologToDTProblemTransformerProof (SOUND)
Built DT problem from termination graph DT10.

{
    "root": 1,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(suffix Xs Ys)",
                "(app X1 Xs Ys)"
            ],
            [
                "(app ([]) X X)",
                null
            ],
            [
                "(app (. X Xs) Ys (. X Zs))",
                "(app Xs Ys Zs)"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "1": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(suffix T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "112": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(app X6 T5 T7)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T5"],
                    "free": ["X6"],
                    "exprvars": []
                }
            },
            "113": {
                "goal": [
                    {
                        "clause": 1,
                        "scope": 2,
                        "term": "(app X6 T5 T7)"
                    },
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(app X6 T5 T7)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T5"],
                    "free": ["X6"],
                    "exprvars": []
                }
            },
            "114": {
                "goal": [{
                    "clause": 1,
                    "scope": 2,
                    "term": "(app X6 T5 T7)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T5"],
                    "free": ["X6"],
                    "exprvars": []
                }
            },
            "125": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "115": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(app X6 T5 T7)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T5"],
                    "free": ["X6"],
                    "exprvars": []
                }
            },
            "126": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "127": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "129": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(app X29 T19 T22)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T19"],
                    "free": ["X29"],
                    "exprvars": []
                }
            },
            "109": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(suffix T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "130": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 1,
                "to": 109,
                "label": "CASE"
            },
            {
                "from": 109,
                "to": 112,
                "label": "ONLY EVAL with clause\nsuffix(X4, X5) :- app(X6, X4, X5).\nand substitutionT1 -> T5,\nX4 -> T5,\nT2 -> T7,\nX5 -> T7,\nT6 -> T7"
            },
            {
                "from": 112,
                "to": 113,
                "label": "CASE"
            },
            {
                "from": 113,
                "to": 114,
                "label": "PARALLEL"
            },
            {
                "from": 113,
                "to": 115,
                "label": "PARALLEL"
            },
            {
                "from": 114,
                "to": 125,
                "label": "EVAL with clause\napp([], X11, X11).\nand substitutionX6 -> [],\nT5 -> T12,\nX11 -> T12,\nT7 -> T12"
            },
            {
                "from": 114,
                "to": 126,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 115,
                "to": 129,
                "label": "EVAL with clause\napp(.(X24, X25), X26, .(X24, X27)) :- app(X25, X26, X27).\nand substitutionX24 -> T20,\nX25 -> X29,\nX6 -> .(T20, X29),\nT5 -> T19,\nX26 -> T19,\nX28 -> T20,\nX27 -> T22,\nT7 -> .(T20, T22),\nT21 -> T22"
            },
            {
                "from": 115,
                "to": 130,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 125,
                "to": 127,
                "label": "SUCCESS"
            },
            {
                "from": 129,
                "to": 112,
                "label": "INSTANCE with matching:\nX6 -> X29\nT5 -> T19\nT7 -> T22"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(48)
Obligation:
Triples:

appA(.(X1, X2), X3, .(X1, X4)) :- appA(X2, X3, X4).
suffixB(X1, X2) :- appA(X3, X1, X2).

Clauses:

appcA([], X1, X1).
appcA(.(X1, X2), X3, .(X1, X4)) :- appcA(X2, X3, X4).

Afs:

suffixB(x1, x2)  =  suffixB(x1)


----------------------------------------

(49) TriplesToPiDPProof (SOUND)
We use the technique of [DT09]. With regard to the inferred argument filtering the predicates were used in the following modes:

suffixB_in_2: (b,f)

appA_in_3: (f,b,f)

Transforming TRIPLES into the following Term Rewriting System:

Pi DP problem:
The TRS P consists of the following rules:

   SUFFIXB_IN_GA(X1, X2) -> U2_GA(X1, X2, appA_in_aga(X3, X1, X2))
   SUFFIXB_IN_GA(X1, X2) -> APPA_IN_AGA(X3, X1, X2)
   APPA_IN_AGA(.(X1, X2), X3, .(X1, X4)) -> U1_AGA(X1, X2, X3, X4, appA_in_aga(X2, X3, X4))
   APPA_IN_AGA(.(X1, X2), X3, .(X1, X4)) -> APPA_IN_AGA(X2, X3, X4)

R is empty.
The argument filtering Pi contains the following mapping:
appA_in_aga(x1, x2, x3)  =  appA_in_aga(x2)

.(x1, x2)  =  .(x2)

SUFFIXB_IN_GA(x1, x2)  =  SUFFIXB_IN_GA(x1)

U2_GA(x1, x2, x3)  =  U2_GA(x1, x3)

APPA_IN_AGA(x1, x2, x3)  =  APPA_IN_AGA(x2)

U1_AGA(x1, x2, x3, x4, x5)  =  U1_AGA(x3, x5)


We have to consider all (P,R,Pi)-chains


Infinitary Constructor Rewriting Termination of PiDP implies Termination of TRIPLES



----------------------------------------

(50)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   SUFFIXB_IN_GA(X1, X2) -> U2_GA(X1, X2, appA_in_aga(X3, X1, X2))
   SUFFIXB_IN_GA(X1, X2) -> APPA_IN_AGA(X3, X1, X2)
   APPA_IN_AGA(.(X1, X2), X3, .(X1, X4)) -> U1_AGA(X1, X2, X3, X4, appA_in_aga(X2, X3, X4))
   APPA_IN_AGA(.(X1, X2), X3, .(X1, X4)) -> APPA_IN_AGA(X2, X3, X4)

R is empty.
The argument filtering Pi contains the following mapping:
appA_in_aga(x1, x2, x3)  =  appA_in_aga(x2)

.(x1, x2)  =  .(x2)

SUFFIXB_IN_GA(x1, x2)  =  SUFFIXB_IN_GA(x1)

U2_GA(x1, x2, x3)  =  U2_GA(x1, x3)

APPA_IN_AGA(x1, x2, x3)  =  APPA_IN_AGA(x2)

U1_AGA(x1, x2, x3, x4, x5)  =  U1_AGA(x3, x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(51) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 3 less nodes.
----------------------------------------

(52)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   APPA_IN_AGA(.(X1, X2), X3, .(X1, X4)) -> APPA_IN_AGA(X2, X3, X4)

R is empty.
The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x2)

APPA_IN_AGA(x1, x2, x3)  =  APPA_IN_AGA(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(53) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(54)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   APPA_IN_AGA(X3) -> APPA_IN_AGA(X3)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.