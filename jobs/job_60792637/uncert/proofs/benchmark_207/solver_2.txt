MAYBE
proof of /hpcwork/ff862203/termcomp25/benchmarks/AMHM9.pl
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Left Termination of the query pattern

div(g,g,a)

w.r.t. the given Prolog program could not be shown:

(0) Prolog
(1) PrologToPiTRSProof [SOUND, 0 ms]
(2) PiTRS
    (3) DependencyPairsProof [EQUIVALENT, 0 ms]
    (4) PiDP
    (5) DependencyGraphProof [EQUIVALENT, 0 ms]
    (6) AND
        (7) PiDP
            (8) UsableRulesProof [EQUIVALENT, 0 ms]
            (9) PiDP
            (10) PiDPToQDPProof [SOUND, 0 ms]
            (11) QDP
            (12) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (13) YES
        (14) PiDP
            (15) UsableRulesProof [EQUIVALENT, 0 ms]
            (16) PiDP
            (17) PiDPToQDPProof [SOUND, 0 ms]
            (18) QDP
            (19) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (20) YES
        (21) PiDP
            (22) UsableRulesProof [EQUIVALENT, 0 ms]
            (23) PiDP
            (24) PiDPToQDPProof [SOUND, 0 ms]
            (25) QDP
            (26) TransformationProof [SOUND, 0 ms]
            (27) QDP
            (28) TransformationProof [SOUND, 0 ms]
            (29) QDP
            (30) TransformationProof [EQUIVALENT, 0 ms]
            (31) QDP
            (32) DependencyGraphProof [EQUIVALENT, 0 ms]
            (33) QDP
            (34) TransformationProof [EQUIVALENT, 0 ms]
            (35) QDP
            (36) TransformationProof [EQUIVALENT, 0 ms]
            (37) QDP
            (38) TransformationProof [EQUIVALENT, 0 ms]
            (39) QDP
            (40) TransformationProof [EQUIVALENT, 0 ms]
            (41) QDP
            (42) TransformationProof [EQUIVALENT, 0 ms]
            (43) QDP
            (44) TransformationProof [EQUIVALENT, 0 ms]
            (45) QDP
            (46) DependencyGraphProof [EQUIVALENT, 0 ms]
            (47) AND
                (48) QDP
                    (49) UsableRulesProof [EQUIVALENT, 0 ms]
                    (50) QDP
                    (51) QReductionProof [EQUIVALENT, 0 ms]
                    (52) QDP
                    (53) NonTerminationLoopProof [COMPLETE, 0 ms]
                    (54) NO
                (55) QDP
                    (56) TransformationProof [EQUIVALENT, 0 ms]
                    (57) QDP
                    (58) TransformationProof [EQUIVALENT, 0 ms]
                    (59) QDP
                    (60) QDPOrderProof [EQUIVALENT, 6 ms]
                    (61) QDP
                    (62) DependencyGraphProof [EQUIVALENT, 0 ms]
                    (63) TRUE
(64) PrologToPiTRSProof [SOUND, 0 ms]
(65) PiTRS
    (66) DependencyPairsProof [EQUIVALENT, 0 ms]
    (67) PiDP
    (68) DependencyGraphProof [EQUIVALENT, 0 ms]
    (69) AND
        (70) PiDP
            (71) UsableRulesProof [EQUIVALENT, 0 ms]
            (72) PiDP
            (73) PiDPToQDPProof [SOUND, 2 ms]
            (74) QDP
            (75) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (76) YES
        (77) PiDP
            (78) UsableRulesProof [EQUIVALENT, 0 ms]
            (79) PiDP
            (80) PiDPToQDPProof [SOUND, 0 ms]
            (81) QDP
            (82) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (83) YES
        (84) PiDP
            (85) UsableRulesProof [EQUIVALENT, 0 ms]
            (86) PiDP
            (87) PiDPToQDPProof [SOUND, 0 ms]
            (88) QDP
            (89) QDPQMonotonicMRRProof [EQUIVALENT, 14 ms]
            (90) QDP
            (91) UsableRulesProof [EQUIVALENT, 0 ms]
            (92) QDP
            (93) QReductionProof [EQUIVALENT, 0 ms]
            (94) QDP
            (95) TransformationProof [SOUND, 0 ms]
            (96) QDP
            (97) UsableRulesProof [EQUIVALENT, 0 ms]
            (98) QDP
            (99) QReductionProof [EQUIVALENT, 0 ms]
            (100) QDP
            (101) TransformationProof [EQUIVALENT, 0 ms]
            (102) QDP
            (103) TransformationProof [EQUIVALENT, 0 ms]
            (104) QDP
            (105) TransformationProof [EQUIVALENT, 0 ms]
            (106) QDP
            (107) QDPQMonotonicMRRProof [EQUIVALENT, 8 ms]
            (108) QDP
            (109) TransformationProof [SOUND, 0 ms]
            (110) QDP
            (111) UsableRulesProof [EQUIVALENT, 0 ms]
            (112) QDP
            (113) TransformationProof [EQUIVALENT, 0 ms]
            (114) QDP
            (115) UsableRulesProof [EQUIVALENT, 0 ms]
            (116) QDP
            (117) QReductionProof [EQUIVALENT, 0 ms]
            (118) QDP
            (119) TransformationProof [EQUIVALENT, 0 ms]
            (120) QDP
            (121) UsableRulesProof [EQUIVALENT, 0 ms]
            (122) QDP
            (123) QReductionProof [EQUIVALENT, 0 ms]
            (124) QDP
            (125) TransformationProof [EQUIVALENT, 0 ms]
            (126) QDP
            (127) TransformationProof [EQUIVALENT, 0 ms]
            (128) QDP
            (129) TransformationProof [EQUIVALENT, 0 ms]
            (130) QDP
            (131) NonTerminationLoopProof [COMPLETE, 0 ms]
            (132) NO
(133) PrologToTRSTransformerProof [SOUND, 0 ms]
(134) QTRS
    (135) Overlay + Local Confluence [EQUIVALENT, 0 ms]
    (136) QTRS
    (137) DependencyPairsProof [EQUIVALENT, 0 ms]
    (138) QDP
    (139) DependencyGraphProof [EQUIVALENT, 0 ms]
    (140) AND
        (141) QDP
            (142) UsableRulesProof [EQUIVALENT, 0 ms]
            (143) QDP
            (144) QReductionProof [EQUIVALENT, 0 ms]
            (145) QDP
            (146) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (147) YES
        (148) QDP
            (149) UsableRulesProof [EQUIVALENT, 0 ms]
            (150) QDP
            (151) QReductionProof [EQUIVALENT, 0 ms]
            (152) QDP
            (153) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (154) YES
        (155) QDP
            (156) UsableRulesProof [EQUIVALENT, 0 ms]
            (157) QDP
            (158) QReductionProof [EQUIVALENT, 0 ms]
            (159) QDP
            (160) MNOCProof [EQUIVALENT, 0 ms]
            (161) QDP
            (162) NonTerminationLoopProof [COMPLETE, 0 ms]
            (163) NO
(164) PrologToDTProblemTransformerProof [SOUND, 0 ms]
(165) TRIPLES
    (166) TriplesToPiDPProof [SOUND, 3 ms]
    (167) PiDP
    (168) DependencyGraphProof [EQUIVALENT, 0 ms]
    (169) AND
        (170) PiDP
            (171) UsableRulesProof [EQUIVALENT, 0 ms]
            (172) PiDP
            (173) PiDPToQDPProof [SOUND, 0 ms]
            (174) QDP
            (175) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (176) YES
        (177) PiDP
            (178) UsableRulesProof [EQUIVALENT, 0 ms]
            (179) PiDP
            (180) PiDPToQDPProof [SOUND, 0 ms]
            (181) QDP
            (182) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (183) YES
        (184) PiDP
            (185) PiDPToQDPProof [SOUND, 0 ms]
            (186) QDP
            (187) QDPQMonotonicMRRProof [EQUIVALENT, 15 ms]
            (188) QDP
            (189) QDPQMonotonicMRRProof [EQUIVALENT, 12 ms]
            (190) QDP
            (191) UsableRulesProof [EQUIVALENT, 0 ms]
            (192) QDP
            (193) QReductionProof [EQUIVALENT, 0 ms]
            (194) QDP
            (195) TransformationProof [SOUND, 0 ms]
            (196) QDP
            (197) UsableRulesProof [EQUIVALENT, 0 ms]
            (198) QDP
            (199) QReductionProof [EQUIVALENT, 0 ms]
            (200) QDP
            (201) TransformationProof [EQUIVALENT, 0 ms]
            (202) QDP
            (203) TransformationProof [EQUIVALENT, 0 ms]
            (204) QDP
            (205) UsableRulesProof [EQUIVALENT, 0 ms]
            (206) QDP
            (207) QReductionProof [EQUIVALENT, 0 ms]
            (208) QDP
            (209) TransformationProof [EQUIVALENT, 0 ms]
            (210) QDP
            (211) UsableRulesProof [EQUIVALENT, 0 ms]
            (212) QDP
            (213) QReductionProof [EQUIVALENT, 0 ms]
            (214) QDP
            (215) NonTerminationLoopProof [COMPLETE, 0 ms]
            (216) NO
(217) PrologToIRSwTTransformerProof [SOUND, 35 ms]
(218) AND
    (219) IRSwT
        (220) IRSwTSimpleDependencyGraphProof [EQUIVALENT, 0 ms]
        (221) TRUE
    (222) IRSwT
        (223) IRSwTSimpleDependencyGraphProof [EQUIVALENT, 0 ms]
        (224) IRSwT
        (225) IntTRSCompressionProof [EQUIVALENT, 9 ms]
        (226) IRSwT
        (227) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
        (228) IRSwT
        (229) IRSwTTerminationDigraphProof [EQUIVALENT, 3 ms]
        (230) IRSwT
        (231) TempFilterProof [SOUND, 3 ms]
        (232) IRSwT
        (233) IRSwTToQDPProof [SOUND, 0 ms]
        (234) QDP
        (235) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (236) YES
    (237) IRSwT
        (238) IRSwTSimpleDependencyGraphProof [EQUIVALENT, 0 ms]
        (239) IRSwT
        (240) IntTRSCompressionProof [EQUIVALENT, 17 ms]
        (241) IRSwT
        (242) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
        (243) IRSwT
        (244) IRSwTTerminationDigraphProof [EQUIVALENT, 45 ms]
        (245) IRSwT
        (246) IntTRSCompressionProof [EQUIVALENT, 8 ms]
        (247) IRSwT
        (248) IntTRSUnneededArgumentFilterProof [EQUIVALENT, 0 ms]
        (249) IRSwT
        (250) IRSwTToIntTRSProof [SOUND, 14 ms]
        (251) IRSwT
        (252) IntTRSCompressionProof [EQUIVALENT, 8 ms]
        (253) IRSwT


----------------------------------------

(0)
Obligation:
Clauses:

le(0, Y, true).
le(s(X), 0, false).
le(s(X), s(Y), B) :- le(X, Y, B).
minus(X, 0, X).
minus(s(X), s(Y), Z) :- minus(X, Y, Z).
div(X, s(Y), Z) :- ','(le(s(Y), X, B), if(B, X, s(Y), Z)).
if(false, X, s(Y), 0).
if(true, X, s(Y), s(Z)) :- ','(minus(X, Y, U), div(U, s(Y), Z)).


Query: div(g,g,a)
----------------------------------------

(1) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

div_in_3: (b,b,f)

le_in_3: (b,b,f)

if_in_4: (b,b,b,f)

minus_in_3: (b,b,f)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   div_in_gga(X, s(Y), Z) -> U3_gga(X, Y, Z, le_in_gga(s(Y), X, B))
   le_in_gga(0, Y, true) -> le_out_gga(0, Y, true)
   le_in_gga(s(X), 0, false) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y), B) -> U1_gga(X, Y, B, le_in_gga(X, Y, B))
   U1_gga(X, Y, B, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)
   U3_gga(X, Y, Z, le_out_gga(s(Y), X, B)) -> U4_gga(X, Y, Z, if_in_ggga(B, X, s(Y), Z))
   if_in_ggga(false, X, s(Y), 0) -> if_out_ggga(false, X, s(Y), 0)
   if_in_ggga(true, X, s(Y), s(Z)) -> U5_ggga(X, Y, Z, minus_in_gga(X, Y, U))
   minus_in_gga(X, 0, X) -> minus_out_gga(X, 0, X)
   minus_in_gga(s(X), s(Y), Z) -> U2_gga(X, Y, Z, minus_in_gga(X, Y, Z))
   U2_gga(X, Y, Z, minus_out_gga(X, Y, Z)) -> minus_out_gga(s(X), s(Y), Z)
   U5_ggga(X, Y, Z, minus_out_gga(X, Y, U)) -> U6_ggga(X, Y, Z, div_in_gga(U, s(Y), Z))
   U6_ggga(X, Y, Z, div_out_gga(U, s(Y), Z)) -> if_out_ggga(true, X, s(Y), s(Z))
   U4_gga(X, Y, Z, if_out_ggga(B, X, s(Y), Z)) -> div_out_gga(X, s(Y), Z)

The argument filtering Pi contains the following mapping:
div_in_gga(x1, x2, x3)  =  div_in_gga(x1, x2)

s(x1)  =  s(x1)

U3_gga(x1, x2, x3, x4)  =  U3_gga(x1, x2, x4)

le_in_gga(x1, x2, x3)  =  le_in_gga(x1, x2)

0  =  0

le_out_gga(x1, x2, x3)  =  le_out_gga(x3)

U1_gga(x1, x2, x3, x4)  =  U1_gga(x4)

U4_gga(x1, x2, x3, x4)  =  U4_gga(x4)

if_in_ggga(x1, x2, x3, x4)  =  if_in_ggga(x1, x2, x3)

false  =  false

if_out_ggga(x1, x2, x3, x4)  =  if_out_ggga(x4)

true  =  true

U5_ggga(x1, x2, x3, x4)  =  U5_ggga(x2, x4)

minus_in_gga(x1, x2, x3)  =  minus_in_gga(x1, x2)

minus_out_gga(x1, x2, x3)  =  minus_out_gga(x3)

U2_gga(x1, x2, x3, x4)  =  U2_gga(x4)

U6_ggga(x1, x2, x3, x4)  =  U6_ggga(x4)

div_out_gga(x1, x2, x3)  =  div_out_gga(x3)





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(2)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   div_in_gga(X, s(Y), Z) -> U3_gga(X, Y, Z, le_in_gga(s(Y), X, B))
   le_in_gga(0, Y, true) -> le_out_gga(0, Y, true)
   le_in_gga(s(X), 0, false) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y), B) -> U1_gga(X, Y, B, le_in_gga(X, Y, B))
   U1_gga(X, Y, B, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)
   U3_gga(X, Y, Z, le_out_gga(s(Y), X, B)) -> U4_gga(X, Y, Z, if_in_ggga(B, X, s(Y), Z))
   if_in_ggga(false, X, s(Y), 0) -> if_out_ggga(false, X, s(Y), 0)
   if_in_ggga(true, X, s(Y), s(Z)) -> U5_ggga(X, Y, Z, minus_in_gga(X, Y, U))
   minus_in_gga(X, 0, X) -> minus_out_gga(X, 0, X)
   minus_in_gga(s(X), s(Y), Z) -> U2_gga(X, Y, Z, minus_in_gga(X, Y, Z))
   U2_gga(X, Y, Z, minus_out_gga(X, Y, Z)) -> minus_out_gga(s(X), s(Y), Z)
   U5_ggga(X, Y, Z, minus_out_gga(X, Y, U)) -> U6_ggga(X, Y, Z, div_in_gga(U, s(Y), Z))
   U6_ggga(X, Y, Z, div_out_gga(U, s(Y), Z)) -> if_out_ggga(true, X, s(Y), s(Z))
   U4_gga(X, Y, Z, if_out_ggga(B, X, s(Y), Z)) -> div_out_gga(X, s(Y), Z)

The argument filtering Pi contains the following mapping:
div_in_gga(x1, x2, x3)  =  div_in_gga(x1, x2)

s(x1)  =  s(x1)

U3_gga(x1, x2, x3, x4)  =  U3_gga(x1, x2, x4)

le_in_gga(x1, x2, x3)  =  le_in_gga(x1, x2)

0  =  0

le_out_gga(x1, x2, x3)  =  le_out_gga(x3)

U1_gga(x1, x2, x3, x4)  =  U1_gga(x4)

U4_gga(x1, x2, x3, x4)  =  U4_gga(x4)

if_in_ggga(x1, x2, x3, x4)  =  if_in_ggga(x1, x2, x3)

false  =  false

if_out_ggga(x1, x2, x3, x4)  =  if_out_ggga(x4)

true  =  true

U5_ggga(x1, x2, x3, x4)  =  U5_ggga(x2, x4)

minus_in_gga(x1, x2, x3)  =  minus_in_gga(x1, x2)

minus_out_gga(x1, x2, x3)  =  minus_out_gga(x3)

U2_gga(x1, x2, x3, x4)  =  U2_gga(x4)

U6_ggga(x1, x2, x3, x4)  =  U6_ggga(x4)

div_out_gga(x1, x2, x3)  =  div_out_gga(x3)



----------------------------------------

(3) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   DIV_IN_GGA(X, s(Y), Z) -> U3_GGA(X, Y, Z, le_in_gga(s(Y), X, B))
   DIV_IN_GGA(X, s(Y), Z) -> LE_IN_GGA(s(Y), X, B)
   LE_IN_GGA(s(X), s(Y), B) -> U1_GGA(X, Y, B, le_in_gga(X, Y, B))
   LE_IN_GGA(s(X), s(Y), B) -> LE_IN_GGA(X, Y, B)
   U3_GGA(X, Y, Z, le_out_gga(s(Y), X, B)) -> U4_GGA(X, Y, Z, if_in_ggga(B, X, s(Y), Z))
   U3_GGA(X, Y, Z, le_out_gga(s(Y), X, B)) -> IF_IN_GGGA(B, X, s(Y), Z)
   IF_IN_GGGA(true, X, s(Y), s(Z)) -> U5_GGGA(X, Y, Z, minus_in_gga(X, Y, U))
   IF_IN_GGGA(true, X, s(Y), s(Z)) -> MINUS_IN_GGA(X, Y, U)
   MINUS_IN_GGA(s(X), s(Y), Z) -> U2_GGA(X, Y, Z, minus_in_gga(X, Y, Z))
   MINUS_IN_GGA(s(X), s(Y), Z) -> MINUS_IN_GGA(X, Y, Z)
   U5_GGGA(X, Y, Z, minus_out_gga(X, Y, U)) -> U6_GGGA(X, Y, Z, div_in_gga(U, s(Y), Z))
   U5_GGGA(X, Y, Z, minus_out_gga(X, Y, U)) -> DIV_IN_GGA(U, s(Y), Z)

The TRS R consists of the following rules:

   div_in_gga(X, s(Y), Z) -> U3_gga(X, Y, Z, le_in_gga(s(Y), X, B))
   le_in_gga(0, Y, true) -> le_out_gga(0, Y, true)
   le_in_gga(s(X), 0, false) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y), B) -> U1_gga(X, Y, B, le_in_gga(X, Y, B))
   U1_gga(X, Y, B, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)
   U3_gga(X, Y, Z, le_out_gga(s(Y), X, B)) -> U4_gga(X, Y, Z, if_in_ggga(B, X, s(Y), Z))
   if_in_ggga(false, X, s(Y), 0) -> if_out_ggga(false, X, s(Y), 0)
   if_in_ggga(true, X, s(Y), s(Z)) -> U5_ggga(X, Y, Z, minus_in_gga(X, Y, U))
   minus_in_gga(X, 0, X) -> minus_out_gga(X, 0, X)
   minus_in_gga(s(X), s(Y), Z) -> U2_gga(X, Y, Z, minus_in_gga(X, Y, Z))
   U2_gga(X, Y, Z, minus_out_gga(X, Y, Z)) -> minus_out_gga(s(X), s(Y), Z)
   U5_ggga(X, Y, Z, minus_out_gga(X, Y, U)) -> U6_ggga(X, Y, Z, div_in_gga(U, s(Y), Z))
   U6_ggga(X, Y, Z, div_out_gga(U, s(Y), Z)) -> if_out_ggga(true, X, s(Y), s(Z))
   U4_gga(X, Y, Z, if_out_ggga(B, X, s(Y), Z)) -> div_out_gga(X, s(Y), Z)

The argument filtering Pi contains the following mapping:
div_in_gga(x1, x2, x3)  =  div_in_gga(x1, x2)

s(x1)  =  s(x1)

U3_gga(x1, x2, x3, x4)  =  U3_gga(x1, x2, x4)

le_in_gga(x1, x2, x3)  =  le_in_gga(x1, x2)

0  =  0

le_out_gga(x1, x2, x3)  =  le_out_gga(x3)

U1_gga(x1, x2, x3, x4)  =  U1_gga(x4)

U4_gga(x1, x2, x3, x4)  =  U4_gga(x4)

if_in_ggga(x1, x2, x3, x4)  =  if_in_ggga(x1, x2, x3)

false  =  false

if_out_ggga(x1, x2, x3, x4)  =  if_out_ggga(x4)

true  =  true

U5_ggga(x1, x2, x3, x4)  =  U5_ggga(x2, x4)

minus_in_gga(x1, x2, x3)  =  minus_in_gga(x1, x2)

minus_out_gga(x1, x2, x3)  =  minus_out_gga(x3)

U2_gga(x1, x2, x3, x4)  =  U2_gga(x4)

U6_ggga(x1, x2, x3, x4)  =  U6_ggga(x4)

div_out_gga(x1, x2, x3)  =  div_out_gga(x3)

DIV_IN_GGA(x1, x2, x3)  =  DIV_IN_GGA(x1, x2)

U3_GGA(x1, x2, x3, x4)  =  U3_GGA(x1, x2, x4)

LE_IN_GGA(x1, x2, x3)  =  LE_IN_GGA(x1, x2)

U1_GGA(x1, x2, x3, x4)  =  U1_GGA(x4)

U4_GGA(x1, x2, x3, x4)  =  U4_GGA(x4)

IF_IN_GGGA(x1, x2, x3, x4)  =  IF_IN_GGGA(x1, x2, x3)

U5_GGGA(x1, x2, x3, x4)  =  U5_GGGA(x2, x4)

MINUS_IN_GGA(x1, x2, x3)  =  MINUS_IN_GGA(x1, x2)

U2_GGA(x1, x2, x3, x4)  =  U2_GGA(x4)

U6_GGGA(x1, x2, x3, x4)  =  U6_GGGA(x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(4)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   DIV_IN_GGA(X, s(Y), Z) -> U3_GGA(X, Y, Z, le_in_gga(s(Y), X, B))
   DIV_IN_GGA(X, s(Y), Z) -> LE_IN_GGA(s(Y), X, B)
   LE_IN_GGA(s(X), s(Y), B) -> U1_GGA(X, Y, B, le_in_gga(X, Y, B))
   LE_IN_GGA(s(X), s(Y), B) -> LE_IN_GGA(X, Y, B)
   U3_GGA(X, Y, Z, le_out_gga(s(Y), X, B)) -> U4_GGA(X, Y, Z, if_in_ggga(B, X, s(Y), Z))
   U3_GGA(X, Y, Z, le_out_gga(s(Y), X, B)) -> IF_IN_GGGA(B, X, s(Y), Z)
   IF_IN_GGGA(true, X, s(Y), s(Z)) -> U5_GGGA(X, Y, Z, minus_in_gga(X, Y, U))
   IF_IN_GGGA(true, X, s(Y), s(Z)) -> MINUS_IN_GGA(X, Y, U)
   MINUS_IN_GGA(s(X), s(Y), Z) -> U2_GGA(X, Y, Z, minus_in_gga(X, Y, Z))
   MINUS_IN_GGA(s(X), s(Y), Z) -> MINUS_IN_GGA(X, Y, Z)
   U5_GGGA(X, Y, Z, minus_out_gga(X, Y, U)) -> U6_GGGA(X, Y, Z, div_in_gga(U, s(Y), Z))
   U5_GGGA(X, Y, Z, minus_out_gga(X, Y, U)) -> DIV_IN_GGA(U, s(Y), Z)

The TRS R consists of the following rules:

   div_in_gga(X, s(Y), Z) -> U3_gga(X, Y, Z, le_in_gga(s(Y), X, B))
   le_in_gga(0, Y, true) -> le_out_gga(0, Y, true)
   le_in_gga(s(X), 0, false) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y), B) -> U1_gga(X, Y, B, le_in_gga(X, Y, B))
   U1_gga(X, Y, B, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)
   U3_gga(X, Y, Z, le_out_gga(s(Y), X, B)) -> U4_gga(X, Y, Z, if_in_ggga(B, X, s(Y), Z))
   if_in_ggga(false, X, s(Y), 0) -> if_out_ggga(false, X, s(Y), 0)
   if_in_ggga(true, X, s(Y), s(Z)) -> U5_ggga(X, Y, Z, minus_in_gga(X, Y, U))
   minus_in_gga(X, 0, X) -> minus_out_gga(X, 0, X)
   minus_in_gga(s(X), s(Y), Z) -> U2_gga(X, Y, Z, minus_in_gga(X, Y, Z))
   U2_gga(X, Y, Z, minus_out_gga(X, Y, Z)) -> minus_out_gga(s(X), s(Y), Z)
   U5_ggga(X, Y, Z, minus_out_gga(X, Y, U)) -> U6_ggga(X, Y, Z, div_in_gga(U, s(Y), Z))
   U6_ggga(X, Y, Z, div_out_gga(U, s(Y), Z)) -> if_out_ggga(true, X, s(Y), s(Z))
   U4_gga(X, Y, Z, if_out_ggga(B, X, s(Y), Z)) -> div_out_gga(X, s(Y), Z)

The argument filtering Pi contains the following mapping:
div_in_gga(x1, x2, x3)  =  div_in_gga(x1, x2)

s(x1)  =  s(x1)

U3_gga(x1, x2, x3, x4)  =  U3_gga(x1, x2, x4)

le_in_gga(x1, x2, x3)  =  le_in_gga(x1, x2)

0  =  0

le_out_gga(x1, x2, x3)  =  le_out_gga(x3)

U1_gga(x1, x2, x3, x4)  =  U1_gga(x4)

U4_gga(x1, x2, x3, x4)  =  U4_gga(x4)

if_in_ggga(x1, x2, x3, x4)  =  if_in_ggga(x1, x2, x3)

false  =  false

if_out_ggga(x1, x2, x3, x4)  =  if_out_ggga(x4)

true  =  true

U5_ggga(x1, x2, x3, x4)  =  U5_ggga(x2, x4)

minus_in_gga(x1, x2, x3)  =  minus_in_gga(x1, x2)

minus_out_gga(x1, x2, x3)  =  minus_out_gga(x3)

U2_gga(x1, x2, x3, x4)  =  U2_gga(x4)

U6_ggga(x1, x2, x3, x4)  =  U6_ggga(x4)

div_out_gga(x1, x2, x3)  =  div_out_gga(x3)

DIV_IN_GGA(x1, x2, x3)  =  DIV_IN_GGA(x1, x2)

U3_GGA(x1, x2, x3, x4)  =  U3_GGA(x1, x2, x4)

LE_IN_GGA(x1, x2, x3)  =  LE_IN_GGA(x1, x2)

U1_GGA(x1, x2, x3, x4)  =  U1_GGA(x4)

U4_GGA(x1, x2, x3, x4)  =  U4_GGA(x4)

IF_IN_GGGA(x1, x2, x3, x4)  =  IF_IN_GGGA(x1, x2, x3)

U5_GGGA(x1, x2, x3, x4)  =  U5_GGGA(x2, x4)

MINUS_IN_GGA(x1, x2, x3)  =  MINUS_IN_GGA(x1, x2)

U2_GGA(x1, x2, x3, x4)  =  U2_GGA(x4)

U6_GGGA(x1, x2, x3, x4)  =  U6_GGGA(x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(5) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 3 SCCs with 6 less nodes.
----------------------------------------

(6)
Complex Obligation (AND)

----------------------------------------

(7)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MINUS_IN_GGA(s(X), s(Y), Z) -> MINUS_IN_GGA(X, Y, Z)

The TRS R consists of the following rules:

   div_in_gga(X, s(Y), Z) -> U3_gga(X, Y, Z, le_in_gga(s(Y), X, B))
   le_in_gga(0, Y, true) -> le_out_gga(0, Y, true)
   le_in_gga(s(X), 0, false) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y), B) -> U1_gga(X, Y, B, le_in_gga(X, Y, B))
   U1_gga(X, Y, B, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)
   U3_gga(X, Y, Z, le_out_gga(s(Y), X, B)) -> U4_gga(X, Y, Z, if_in_ggga(B, X, s(Y), Z))
   if_in_ggga(false, X, s(Y), 0) -> if_out_ggga(false, X, s(Y), 0)
   if_in_ggga(true, X, s(Y), s(Z)) -> U5_ggga(X, Y, Z, minus_in_gga(X, Y, U))
   minus_in_gga(X, 0, X) -> minus_out_gga(X, 0, X)
   minus_in_gga(s(X), s(Y), Z) -> U2_gga(X, Y, Z, minus_in_gga(X, Y, Z))
   U2_gga(X, Y, Z, minus_out_gga(X, Y, Z)) -> minus_out_gga(s(X), s(Y), Z)
   U5_ggga(X, Y, Z, minus_out_gga(X, Y, U)) -> U6_ggga(X, Y, Z, div_in_gga(U, s(Y), Z))
   U6_ggga(X, Y, Z, div_out_gga(U, s(Y), Z)) -> if_out_ggga(true, X, s(Y), s(Z))
   U4_gga(X, Y, Z, if_out_ggga(B, X, s(Y), Z)) -> div_out_gga(X, s(Y), Z)

The argument filtering Pi contains the following mapping:
div_in_gga(x1, x2, x3)  =  div_in_gga(x1, x2)

s(x1)  =  s(x1)

U3_gga(x1, x2, x3, x4)  =  U3_gga(x1, x2, x4)

le_in_gga(x1, x2, x3)  =  le_in_gga(x1, x2)

0  =  0

le_out_gga(x1, x2, x3)  =  le_out_gga(x3)

U1_gga(x1, x2, x3, x4)  =  U1_gga(x4)

U4_gga(x1, x2, x3, x4)  =  U4_gga(x4)

if_in_ggga(x1, x2, x3, x4)  =  if_in_ggga(x1, x2, x3)

false  =  false

if_out_ggga(x1, x2, x3, x4)  =  if_out_ggga(x4)

true  =  true

U5_ggga(x1, x2, x3, x4)  =  U5_ggga(x2, x4)

minus_in_gga(x1, x2, x3)  =  minus_in_gga(x1, x2)

minus_out_gga(x1, x2, x3)  =  minus_out_gga(x3)

U2_gga(x1, x2, x3, x4)  =  U2_gga(x4)

U6_ggga(x1, x2, x3, x4)  =  U6_ggga(x4)

div_out_gga(x1, x2, x3)  =  div_out_gga(x3)

MINUS_IN_GGA(x1, x2, x3)  =  MINUS_IN_GGA(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(8) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(9)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MINUS_IN_GGA(s(X), s(Y), Z) -> MINUS_IN_GGA(X, Y, Z)

R is empty.
The argument filtering Pi contains the following mapping:
s(x1)  =  s(x1)

MINUS_IN_GGA(x1, x2, x3)  =  MINUS_IN_GGA(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(10) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(11)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MINUS_IN_GGA(s(X), s(Y)) -> MINUS_IN_GGA(X, Y)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(12) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*MINUS_IN_GGA(s(X), s(Y)) -> MINUS_IN_GGA(X, Y)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(13)
YES

----------------------------------------

(14)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   LE_IN_GGA(s(X), s(Y), B) -> LE_IN_GGA(X, Y, B)

The TRS R consists of the following rules:

   div_in_gga(X, s(Y), Z) -> U3_gga(X, Y, Z, le_in_gga(s(Y), X, B))
   le_in_gga(0, Y, true) -> le_out_gga(0, Y, true)
   le_in_gga(s(X), 0, false) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y), B) -> U1_gga(X, Y, B, le_in_gga(X, Y, B))
   U1_gga(X, Y, B, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)
   U3_gga(X, Y, Z, le_out_gga(s(Y), X, B)) -> U4_gga(X, Y, Z, if_in_ggga(B, X, s(Y), Z))
   if_in_ggga(false, X, s(Y), 0) -> if_out_ggga(false, X, s(Y), 0)
   if_in_ggga(true, X, s(Y), s(Z)) -> U5_ggga(X, Y, Z, minus_in_gga(X, Y, U))
   minus_in_gga(X, 0, X) -> minus_out_gga(X, 0, X)
   minus_in_gga(s(X), s(Y), Z) -> U2_gga(X, Y, Z, minus_in_gga(X, Y, Z))
   U2_gga(X, Y, Z, minus_out_gga(X, Y, Z)) -> minus_out_gga(s(X), s(Y), Z)
   U5_ggga(X, Y, Z, minus_out_gga(X, Y, U)) -> U6_ggga(X, Y, Z, div_in_gga(U, s(Y), Z))
   U6_ggga(X, Y, Z, div_out_gga(U, s(Y), Z)) -> if_out_ggga(true, X, s(Y), s(Z))
   U4_gga(X, Y, Z, if_out_ggga(B, X, s(Y), Z)) -> div_out_gga(X, s(Y), Z)

The argument filtering Pi contains the following mapping:
div_in_gga(x1, x2, x3)  =  div_in_gga(x1, x2)

s(x1)  =  s(x1)

U3_gga(x1, x2, x3, x4)  =  U3_gga(x1, x2, x4)

le_in_gga(x1, x2, x3)  =  le_in_gga(x1, x2)

0  =  0

le_out_gga(x1, x2, x3)  =  le_out_gga(x3)

U1_gga(x1, x2, x3, x4)  =  U1_gga(x4)

U4_gga(x1, x2, x3, x4)  =  U4_gga(x4)

if_in_ggga(x1, x2, x3, x4)  =  if_in_ggga(x1, x2, x3)

false  =  false

if_out_ggga(x1, x2, x3, x4)  =  if_out_ggga(x4)

true  =  true

U5_ggga(x1, x2, x3, x4)  =  U5_ggga(x2, x4)

minus_in_gga(x1, x2, x3)  =  minus_in_gga(x1, x2)

minus_out_gga(x1, x2, x3)  =  minus_out_gga(x3)

U2_gga(x1, x2, x3, x4)  =  U2_gga(x4)

U6_ggga(x1, x2, x3, x4)  =  U6_ggga(x4)

div_out_gga(x1, x2, x3)  =  div_out_gga(x3)

LE_IN_GGA(x1, x2, x3)  =  LE_IN_GGA(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(15) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(16)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   LE_IN_GGA(s(X), s(Y), B) -> LE_IN_GGA(X, Y, B)

R is empty.
The argument filtering Pi contains the following mapping:
s(x1)  =  s(x1)

LE_IN_GGA(x1, x2, x3)  =  LE_IN_GGA(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(17) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(18)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LE_IN_GGA(s(X), s(Y)) -> LE_IN_GGA(X, Y)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(19) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*LE_IN_GGA(s(X), s(Y)) -> LE_IN_GGA(X, Y)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(20)
YES

----------------------------------------

(21)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U3_GGA(X, Y, Z, le_out_gga(s(Y), X, B)) -> IF_IN_GGGA(B, X, s(Y), Z)
   IF_IN_GGGA(true, X, s(Y), s(Z)) -> U5_GGGA(X, Y, Z, minus_in_gga(X, Y, U))
   U5_GGGA(X, Y, Z, minus_out_gga(X, Y, U)) -> DIV_IN_GGA(U, s(Y), Z)
   DIV_IN_GGA(X, s(Y), Z) -> U3_GGA(X, Y, Z, le_in_gga(s(Y), X, B))

The TRS R consists of the following rules:

   div_in_gga(X, s(Y), Z) -> U3_gga(X, Y, Z, le_in_gga(s(Y), X, B))
   le_in_gga(0, Y, true) -> le_out_gga(0, Y, true)
   le_in_gga(s(X), 0, false) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y), B) -> U1_gga(X, Y, B, le_in_gga(X, Y, B))
   U1_gga(X, Y, B, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)
   U3_gga(X, Y, Z, le_out_gga(s(Y), X, B)) -> U4_gga(X, Y, Z, if_in_ggga(B, X, s(Y), Z))
   if_in_ggga(false, X, s(Y), 0) -> if_out_ggga(false, X, s(Y), 0)
   if_in_ggga(true, X, s(Y), s(Z)) -> U5_ggga(X, Y, Z, minus_in_gga(X, Y, U))
   minus_in_gga(X, 0, X) -> minus_out_gga(X, 0, X)
   minus_in_gga(s(X), s(Y), Z) -> U2_gga(X, Y, Z, minus_in_gga(X, Y, Z))
   U2_gga(X, Y, Z, minus_out_gga(X, Y, Z)) -> minus_out_gga(s(X), s(Y), Z)
   U5_ggga(X, Y, Z, minus_out_gga(X, Y, U)) -> U6_ggga(X, Y, Z, div_in_gga(U, s(Y), Z))
   U6_ggga(X, Y, Z, div_out_gga(U, s(Y), Z)) -> if_out_ggga(true, X, s(Y), s(Z))
   U4_gga(X, Y, Z, if_out_ggga(B, X, s(Y), Z)) -> div_out_gga(X, s(Y), Z)

The argument filtering Pi contains the following mapping:
div_in_gga(x1, x2, x3)  =  div_in_gga(x1, x2)

s(x1)  =  s(x1)

U3_gga(x1, x2, x3, x4)  =  U3_gga(x1, x2, x4)

le_in_gga(x1, x2, x3)  =  le_in_gga(x1, x2)

0  =  0

le_out_gga(x1, x2, x3)  =  le_out_gga(x3)

U1_gga(x1, x2, x3, x4)  =  U1_gga(x4)

U4_gga(x1, x2, x3, x4)  =  U4_gga(x4)

if_in_ggga(x1, x2, x3, x4)  =  if_in_ggga(x1, x2, x3)

false  =  false

if_out_ggga(x1, x2, x3, x4)  =  if_out_ggga(x4)

true  =  true

U5_ggga(x1, x2, x3, x4)  =  U5_ggga(x2, x4)

minus_in_gga(x1, x2, x3)  =  minus_in_gga(x1, x2)

minus_out_gga(x1, x2, x3)  =  minus_out_gga(x3)

U2_gga(x1, x2, x3, x4)  =  U2_gga(x4)

U6_ggga(x1, x2, x3, x4)  =  U6_ggga(x4)

div_out_gga(x1, x2, x3)  =  div_out_gga(x3)

DIV_IN_GGA(x1, x2, x3)  =  DIV_IN_GGA(x1, x2)

U3_GGA(x1, x2, x3, x4)  =  U3_GGA(x1, x2, x4)

IF_IN_GGGA(x1, x2, x3, x4)  =  IF_IN_GGGA(x1, x2, x3)

U5_GGGA(x1, x2, x3, x4)  =  U5_GGGA(x2, x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(22) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(23)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U3_GGA(X, Y, Z, le_out_gga(s(Y), X, B)) -> IF_IN_GGGA(B, X, s(Y), Z)
   IF_IN_GGGA(true, X, s(Y), s(Z)) -> U5_GGGA(X, Y, Z, minus_in_gga(X, Y, U))
   U5_GGGA(X, Y, Z, minus_out_gga(X, Y, U)) -> DIV_IN_GGA(U, s(Y), Z)
   DIV_IN_GGA(X, s(Y), Z) -> U3_GGA(X, Y, Z, le_in_gga(s(Y), X, B))

The TRS R consists of the following rules:

   minus_in_gga(X, 0, X) -> minus_out_gga(X, 0, X)
   minus_in_gga(s(X), s(Y), Z) -> U2_gga(X, Y, Z, minus_in_gga(X, Y, Z))
   le_in_gga(s(X), 0, false) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y), B) -> U1_gga(X, Y, B, le_in_gga(X, Y, B))
   U2_gga(X, Y, Z, minus_out_gga(X, Y, Z)) -> minus_out_gga(s(X), s(Y), Z)
   U1_gga(X, Y, B, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)
   le_in_gga(0, Y, true) -> le_out_gga(0, Y, true)

The argument filtering Pi contains the following mapping:
s(x1)  =  s(x1)

le_in_gga(x1, x2, x3)  =  le_in_gga(x1, x2)

0  =  0

le_out_gga(x1, x2, x3)  =  le_out_gga(x3)

U1_gga(x1, x2, x3, x4)  =  U1_gga(x4)

false  =  false

true  =  true

minus_in_gga(x1, x2, x3)  =  minus_in_gga(x1, x2)

minus_out_gga(x1, x2, x3)  =  minus_out_gga(x3)

U2_gga(x1, x2, x3, x4)  =  U2_gga(x4)

DIV_IN_GGA(x1, x2, x3)  =  DIV_IN_GGA(x1, x2)

U3_GGA(x1, x2, x3, x4)  =  U3_GGA(x1, x2, x4)

IF_IN_GGGA(x1, x2, x3, x4)  =  IF_IN_GGGA(x1, x2, x3)

U5_GGGA(x1, x2, x3, x4)  =  U5_GGGA(x2, x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(24) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(25)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U3_GGA(X, Y, le_out_gga(B)) -> IF_IN_GGGA(B, X, s(Y))
   IF_IN_GGGA(true, X, s(Y)) -> U5_GGGA(Y, minus_in_gga(X, Y))
   U5_GGGA(Y, minus_out_gga(U)) -> DIV_IN_GGA(U, s(Y))
   DIV_IN_GGA(X, s(Y)) -> U3_GGA(X, Y, le_in_gga(s(Y), X))

The TRS R consists of the following rules:

   minus_in_gga(X, 0) -> minus_out_gga(X)
   minus_in_gga(s(X), s(Y)) -> U2_gga(minus_in_gga(X, Y))
   le_in_gga(s(X), 0) -> le_out_gga(false)
   le_in_gga(s(X), s(Y)) -> U1_gga(le_in_gga(X, Y))
   U2_gga(minus_out_gga(Z)) -> minus_out_gga(Z)
   U1_gga(le_out_gga(B)) -> le_out_gga(B)
   le_in_gga(0, Y) -> le_out_gga(true)

The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U2_gga(x0)
   U1_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(26) TransformationProof (SOUND)
By narrowing [LPAR04] the rule IF_IN_GGGA(true, X, s(Y)) -> U5_GGGA(Y, minus_in_gga(X, Y)) at position [1] we obtained the following new rules [LPAR04]:

   (IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(0, minus_out_gga(x0)),IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(0, minus_out_gga(x0)))
   (IF_IN_GGGA(true, s(x0), s(s(x1))) -> U5_GGGA(s(x1), U2_gga(minus_in_gga(x0, x1))),IF_IN_GGGA(true, s(x0), s(s(x1))) -> U5_GGGA(s(x1), U2_gga(minus_in_gga(x0, x1))))


----------------------------------------

(27)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U3_GGA(X, Y, le_out_gga(B)) -> IF_IN_GGGA(B, X, s(Y))
   U5_GGGA(Y, minus_out_gga(U)) -> DIV_IN_GGA(U, s(Y))
   DIV_IN_GGA(X, s(Y)) -> U3_GGA(X, Y, le_in_gga(s(Y), X))
   IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(0, minus_out_gga(x0))
   IF_IN_GGGA(true, s(x0), s(s(x1))) -> U5_GGGA(s(x1), U2_gga(minus_in_gga(x0, x1)))

The TRS R consists of the following rules:

   minus_in_gga(X, 0) -> minus_out_gga(X)
   minus_in_gga(s(X), s(Y)) -> U2_gga(minus_in_gga(X, Y))
   le_in_gga(s(X), 0) -> le_out_gga(false)
   le_in_gga(s(X), s(Y)) -> U1_gga(le_in_gga(X, Y))
   U2_gga(minus_out_gga(Z)) -> minus_out_gga(Z)
   U1_gga(le_out_gga(B)) -> le_out_gga(B)
   le_in_gga(0, Y) -> le_out_gga(true)

The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U2_gga(x0)
   U1_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(28) TransformationProof (SOUND)
By narrowing [LPAR04] the rule DIV_IN_GGA(X, s(Y)) -> U3_GGA(X, Y, le_in_gga(s(Y), X)) at position [2] we obtained the following new rules [LPAR04]:

   (DIV_IN_GGA(0, s(x0)) -> U3_GGA(0, x0, le_out_gga(false)),DIV_IN_GGA(0, s(x0)) -> U3_GGA(0, x0, le_out_gga(false)))
   (DIV_IN_GGA(s(x1), s(x0)) -> U3_GGA(s(x1), x0, U1_gga(le_in_gga(x0, x1))),DIV_IN_GGA(s(x1), s(x0)) -> U3_GGA(s(x1), x0, U1_gga(le_in_gga(x0, x1))))


----------------------------------------

(29)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U3_GGA(X, Y, le_out_gga(B)) -> IF_IN_GGGA(B, X, s(Y))
   U5_GGGA(Y, minus_out_gga(U)) -> DIV_IN_GGA(U, s(Y))
   IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(0, minus_out_gga(x0))
   IF_IN_GGGA(true, s(x0), s(s(x1))) -> U5_GGGA(s(x1), U2_gga(minus_in_gga(x0, x1)))
   DIV_IN_GGA(0, s(x0)) -> U3_GGA(0, x0, le_out_gga(false))
   DIV_IN_GGA(s(x1), s(x0)) -> U3_GGA(s(x1), x0, U1_gga(le_in_gga(x0, x1)))

The TRS R consists of the following rules:

   minus_in_gga(X, 0) -> minus_out_gga(X)
   minus_in_gga(s(X), s(Y)) -> U2_gga(minus_in_gga(X, Y))
   le_in_gga(s(X), 0) -> le_out_gga(false)
   le_in_gga(s(X), s(Y)) -> U1_gga(le_in_gga(X, Y))
   U2_gga(minus_out_gga(Z)) -> minus_out_gga(Z)
   U1_gga(le_out_gga(B)) -> le_out_gga(B)
   le_in_gga(0, Y) -> le_out_gga(true)

The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U2_gga(x0)
   U1_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(30) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U3_GGA(X, Y, le_out_gga(B)) -> IF_IN_GGGA(B, X, s(Y)) we obtained the following new rules [LPAR04]:

   (U3_GGA(0, z0, le_out_gga(false)) -> IF_IN_GGGA(false, 0, s(z0)),U3_GGA(0, z0, le_out_gga(false)) -> IF_IN_GGGA(false, 0, s(z0)))
   (U3_GGA(s(z0), z1, le_out_gga(x2)) -> IF_IN_GGGA(x2, s(z0), s(z1)),U3_GGA(s(z0), z1, le_out_gga(x2)) -> IF_IN_GGGA(x2, s(z0), s(z1)))


----------------------------------------

(31)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U5_GGGA(Y, minus_out_gga(U)) -> DIV_IN_GGA(U, s(Y))
   IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(0, minus_out_gga(x0))
   IF_IN_GGGA(true, s(x0), s(s(x1))) -> U5_GGGA(s(x1), U2_gga(minus_in_gga(x0, x1)))
   DIV_IN_GGA(0, s(x0)) -> U3_GGA(0, x0, le_out_gga(false))
   DIV_IN_GGA(s(x1), s(x0)) -> U3_GGA(s(x1), x0, U1_gga(le_in_gga(x0, x1)))
   U3_GGA(0, z0, le_out_gga(false)) -> IF_IN_GGGA(false, 0, s(z0))
   U3_GGA(s(z0), z1, le_out_gga(x2)) -> IF_IN_GGGA(x2, s(z0), s(z1))

The TRS R consists of the following rules:

   minus_in_gga(X, 0) -> minus_out_gga(X)
   minus_in_gga(s(X), s(Y)) -> U2_gga(minus_in_gga(X, Y))
   le_in_gga(s(X), 0) -> le_out_gga(false)
   le_in_gga(s(X), s(Y)) -> U1_gga(le_in_gga(X, Y))
   U2_gga(minus_out_gga(Z)) -> minus_out_gga(Z)
   U1_gga(le_out_gga(B)) -> le_out_gga(B)
   le_in_gga(0, Y) -> le_out_gga(true)

The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U2_gga(x0)
   U1_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(32) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(33)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   DIV_IN_GGA(s(x1), s(x0)) -> U3_GGA(s(x1), x0, U1_gga(le_in_gga(x0, x1)))
   U3_GGA(s(z0), z1, le_out_gga(x2)) -> IF_IN_GGGA(x2, s(z0), s(z1))
   IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(0, minus_out_gga(x0))
   U5_GGGA(Y, minus_out_gga(U)) -> DIV_IN_GGA(U, s(Y))
   IF_IN_GGGA(true, s(x0), s(s(x1))) -> U5_GGGA(s(x1), U2_gga(minus_in_gga(x0, x1)))

The TRS R consists of the following rules:

   minus_in_gga(X, 0) -> minus_out_gga(X)
   minus_in_gga(s(X), s(Y)) -> U2_gga(minus_in_gga(X, Y))
   le_in_gga(s(X), 0) -> le_out_gga(false)
   le_in_gga(s(X), s(Y)) -> U1_gga(le_in_gga(X, Y))
   U2_gga(minus_out_gga(Z)) -> minus_out_gga(Z)
   U1_gga(le_out_gga(B)) -> le_out_gga(B)
   le_in_gga(0, Y) -> le_out_gga(true)

The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U2_gga(x0)
   U1_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(34) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(0, minus_out_gga(x0)) we obtained the following new rules [LPAR04]:

   (IF_IN_GGGA(true, s(z0), s(0)) -> U5_GGGA(0, minus_out_gga(s(z0))),IF_IN_GGGA(true, s(z0), s(0)) -> U5_GGGA(0, minus_out_gga(s(z0))))


----------------------------------------

(35)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   DIV_IN_GGA(s(x1), s(x0)) -> U3_GGA(s(x1), x0, U1_gga(le_in_gga(x0, x1)))
   U3_GGA(s(z0), z1, le_out_gga(x2)) -> IF_IN_GGGA(x2, s(z0), s(z1))
   U5_GGGA(Y, minus_out_gga(U)) -> DIV_IN_GGA(U, s(Y))
   IF_IN_GGGA(true, s(x0), s(s(x1))) -> U5_GGGA(s(x1), U2_gga(minus_in_gga(x0, x1)))
   IF_IN_GGGA(true, s(z0), s(0)) -> U5_GGGA(0, minus_out_gga(s(z0)))

The TRS R consists of the following rules:

   minus_in_gga(X, 0) -> minus_out_gga(X)
   minus_in_gga(s(X), s(Y)) -> U2_gga(minus_in_gga(X, Y))
   le_in_gga(s(X), 0) -> le_out_gga(false)
   le_in_gga(s(X), s(Y)) -> U1_gga(le_in_gga(X, Y))
   U2_gga(minus_out_gga(Z)) -> minus_out_gga(Z)
   U1_gga(le_out_gga(B)) -> le_out_gga(B)
   le_in_gga(0, Y) -> le_out_gga(true)

The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U2_gga(x0)
   U1_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(36) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U5_GGGA(Y, minus_out_gga(U)) -> DIV_IN_GGA(U, s(Y)) we obtained the following new rules [LPAR04]:

   (U5_GGGA(s(z1), minus_out_gga(x1)) -> DIV_IN_GGA(x1, s(s(z1))),U5_GGGA(s(z1), minus_out_gga(x1)) -> DIV_IN_GGA(x1, s(s(z1))))
   (U5_GGGA(0, minus_out_gga(s(z0))) -> DIV_IN_GGA(s(z0), s(0)),U5_GGGA(0, minus_out_gga(s(z0))) -> DIV_IN_GGA(s(z0), s(0)))


----------------------------------------

(37)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   DIV_IN_GGA(s(x1), s(x0)) -> U3_GGA(s(x1), x0, U1_gga(le_in_gga(x0, x1)))
   U3_GGA(s(z0), z1, le_out_gga(x2)) -> IF_IN_GGGA(x2, s(z0), s(z1))
   IF_IN_GGGA(true, s(x0), s(s(x1))) -> U5_GGGA(s(x1), U2_gga(minus_in_gga(x0, x1)))
   IF_IN_GGGA(true, s(z0), s(0)) -> U5_GGGA(0, minus_out_gga(s(z0)))
   U5_GGGA(s(z1), minus_out_gga(x1)) -> DIV_IN_GGA(x1, s(s(z1)))
   U5_GGGA(0, minus_out_gga(s(z0))) -> DIV_IN_GGA(s(z0), s(0))

The TRS R consists of the following rules:

   minus_in_gga(X, 0) -> minus_out_gga(X)
   minus_in_gga(s(X), s(Y)) -> U2_gga(minus_in_gga(X, Y))
   le_in_gga(s(X), 0) -> le_out_gga(false)
   le_in_gga(s(X), s(Y)) -> U1_gga(le_in_gga(X, Y))
   U2_gga(minus_out_gga(Z)) -> minus_out_gga(Z)
   U1_gga(le_out_gga(B)) -> le_out_gga(B)
   le_in_gga(0, Y) -> le_out_gga(true)

The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U2_gga(x0)
   U1_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(38) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule DIV_IN_GGA(s(x1), s(x0)) -> U3_GGA(s(x1), x0, U1_gga(le_in_gga(x0, x1))) we obtained the following new rules [LPAR04]:

   (DIV_IN_GGA(s(x0), s(s(z0))) -> U3_GGA(s(x0), s(z0), U1_gga(le_in_gga(s(z0), x0))),DIV_IN_GGA(s(x0), s(s(z0))) -> U3_GGA(s(x0), s(z0), U1_gga(le_in_gga(s(z0), x0))))
   (DIV_IN_GGA(s(z0), s(0)) -> U3_GGA(s(z0), 0, U1_gga(le_in_gga(0, z0))),DIV_IN_GGA(s(z0), s(0)) -> U3_GGA(s(z0), 0, U1_gga(le_in_gga(0, z0))))


----------------------------------------

(39)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U3_GGA(s(z0), z1, le_out_gga(x2)) -> IF_IN_GGGA(x2, s(z0), s(z1))
   IF_IN_GGGA(true, s(x0), s(s(x1))) -> U5_GGGA(s(x1), U2_gga(minus_in_gga(x0, x1)))
   IF_IN_GGGA(true, s(z0), s(0)) -> U5_GGGA(0, minus_out_gga(s(z0)))
   U5_GGGA(s(z1), minus_out_gga(x1)) -> DIV_IN_GGA(x1, s(s(z1)))
   U5_GGGA(0, minus_out_gga(s(z0))) -> DIV_IN_GGA(s(z0), s(0))
   DIV_IN_GGA(s(x0), s(s(z0))) -> U3_GGA(s(x0), s(z0), U1_gga(le_in_gga(s(z0), x0)))
   DIV_IN_GGA(s(z0), s(0)) -> U3_GGA(s(z0), 0, U1_gga(le_in_gga(0, z0)))

The TRS R consists of the following rules:

   minus_in_gga(X, 0) -> minus_out_gga(X)
   minus_in_gga(s(X), s(Y)) -> U2_gga(minus_in_gga(X, Y))
   le_in_gga(s(X), 0) -> le_out_gga(false)
   le_in_gga(s(X), s(Y)) -> U1_gga(le_in_gga(X, Y))
   U2_gga(minus_out_gga(Z)) -> minus_out_gga(Z)
   U1_gga(le_out_gga(B)) -> le_out_gga(B)
   le_in_gga(0, Y) -> le_out_gga(true)

The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U2_gga(x0)
   U1_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(40) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule DIV_IN_GGA(s(z0), s(0)) -> U3_GGA(s(z0), 0, U1_gga(le_in_gga(0, z0))) at position [2,0] we obtained the following new rules [LPAR04]:

   (DIV_IN_GGA(s(z0), s(0)) -> U3_GGA(s(z0), 0, U1_gga(le_out_gga(true))),DIV_IN_GGA(s(z0), s(0)) -> U3_GGA(s(z0), 0, U1_gga(le_out_gga(true))))


----------------------------------------

(41)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U3_GGA(s(z0), z1, le_out_gga(x2)) -> IF_IN_GGGA(x2, s(z0), s(z1))
   IF_IN_GGGA(true, s(x0), s(s(x1))) -> U5_GGGA(s(x1), U2_gga(minus_in_gga(x0, x1)))
   IF_IN_GGGA(true, s(z0), s(0)) -> U5_GGGA(0, minus_out_gga(s(z0)))
   U5_GGGA(s(z1), minus_out_gga(x1)) -> DIV_IN_GGA(x1, s(s(z1)))
   U5_GGGA(0, minus_out_gga(s(z0))) -> DIV_IN_GGA(s(z0), s(0))
   DIV_IN_GGA(s(x0), s(s(z0))) -> U3_GGA(s(x0), s(z0), U1_gga(le_in_gga(s(z0), x0)))
   DIV_IN_GGA(s(z0), s(0)) -> U3_GGA(s(z0), 0, U1_gga(le_out_gga(true)))

The TRS R consists of the following rules:

   minus_in_gga(X, 0) -> minus_out_gga(X)
   minus_in_gga(s(X), s(Y)) -> U2_gga(minus_in_gga(X, Y))
   le_in_gga(s(X), 0) -> le_out_gga(false)
   le_in_gga(s(X), s(Y)) -> U1_gga(le_in_gga(X, Y))
   U2_gga(minus_out_gga(Z)) -> minus_out_gga(Z)
   U1_gga(le_out_gga(B)) -> le_out_gga(B)
   le_in_gga(0, Y) -> le_out_gga(true)

The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U2_gga(x0)
   U1_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(42) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule DIV_IN_GGA(s(z0), s(0)) -> U3_GGA(s(z0), 0, U1_gga(le_out_gga(true))) at position [2] we obtained the following new rules [LPAR04]:

   (DIV_IN_GGA(s(z0), s(0)) -> U3_GGA(s(z0), 0, le_out_gga(true)),DIV_IN_GGA(s(z0), s(0)) -> U3_GGA(s(z0), 0, le_out_gga(true)))


----------------------------------------

(43)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U3_GGA(s(z0), z1, le_out_gga(x2)) -> IF_IN_GGGA(x2, s(z0), s(z1))
   IF_IN_GGGA(true, s(x0), s(s(x1))) -> U5_GGGA(s(x1), U2_gga(minus_in_gga(x0, x1)))
   IF_IN_GGGA(true, s(z0), s(0)) -> U5_GGGA(0, minus_out_gga(s(z0)))
   U5_GGGA(s(z1), minus_out_gga(x1)) -> DIV_IN_GGA(x1, s(s(z1)))
   U5_GGGA(0, minus_out_gga(s(z0))) -> DIV_IN_GGA(s(z0), s(0))
   DIV_IN_GGA(s(x0), s(s(z0))) -> U3_GGA(s(x0), s(z0), U1_gga(le_in_gga(s(z0), x0)))
   DIV_IN_GGA(s(z0), s(0)) -> U3_GGA(s(z0), 0, le_out_gga(true))

The TRS R consists of the following rules:

   minus_in_gga(X, 0) -> minus_out_gga(X)
   minus_in_gga(s(X), s(Y)) -> U2_gga(minus_in_gga(X, Y))
   le_in_gga(s(X), 0) -> le_out_gga(false)
   le_in_gga(s(X), s(Y)) -> U1_gga(le_in_gga(X, Y))
   U2_gga(minus_out_gga(Z)) -> minus_out_gga(Z)
   U1_gga(le_out_gga(B)) -> le_out_gga(B)
   le_in_gga(0, Y) -> le_out_gga(true)

The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U2_gga(x0)
   U1_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(44) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U3_GGA(s(z0), z1, le_out_gga(x2)) -> IF_IN_GGGA(x2, s(z0), s(z1)) we obtained the following new rules [LPAR04]:

   (U3_GGA(s(z0), s(z1), le_out_gga(x2)) -> IF_IN_GGGA(x2, s(z0), s(s(z1))),U3_GGA(s(z0), s(z1), le_out_gga(x2)) -> IF_IN_GGGA(x2, s(z0), s(s(z1))))
   (U3_GGA(s(z0), 0, le_out_gga(true)) -> IF_IN_GGGA(true, s(z0), s(0)),U3_GGA(s(z0), 0, le_out_gga(true)) -> IF_IN_GGGA(true, s(z0), s(0)))


----------------------------------------

(45)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF_IN_GGGA(true, s(x0), s(s(x1))) -> U5_GGGA(s(x1), U2_gga(minus_in_gga(x0, x1)))
   IF_IN_GGGA(true, s(z0), s(0)) -> U5_GGGA(0, minus_out_gga(s(z0)))
   U5_GGGA(s(z1), minus_out_gga(x1)) -> DIV_IN_GGA(x1, s(s(z1)))
   U5_GGGA(0, minus_out_gga(s(z0))) -> DIV_IN_GGA(s(z0), s(0))
   DIV_IN_GGA(s(x0), s(s(z0))) -> U3_GGA(s(x0), s(z0), U1_gga(le_in_gga(s(z0), x0)))
   DIV_IN_GGA(s(z0), s(0)) -> U3_GGA(s(z0), 0, le_out_gga(true))
   U3_GGA(s(z0), s(z1), le_out_gga(x2)) -> IF_IN_GGGA(x2, s(z0), s(s(z1)))
   U3_GGA(s(z0), 0, le_out_gga(true)) -> IF_IN_GGGA(true, s(z0), s(0))

The TRS R consists of the following rules:

   minus_in_gga(X, 0) -> minus_out_gga(X)
   minus_in_gga(s(X), s(Y)) -> U2_gga(minus_in_gga(X, Y))
   le_in_gga(s(X), 0) -> le_out_gga(false)
   le_in_gga(s(X), s(Y)) -> U1_gga(le_in_gga(X, Y))
   U2_gga(minus_out_gga(Z)) -> minus_out_gga(Z)
   U1_gga(le_out_gga(B)) -> le_out_gga(B)
   le_in_gga(0, Y) -> le_out_gga(true)

The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U2_gga(x0)
   U1_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(46) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs.
----------------------------------------

(47)
Complex Obligation (AND)

----------------------------------------

(48)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U5_GGGA(0, minus_out_gga(s(z0))) -> DIV_IN_GGA(s(z0), s(0))
   DIV_IN_GGA(s(z0), s(0)) -> U3_GGA(s(z0), 0, le_out_gga(true))
   U3_GGA(s(z0), 0, le_out_gga(true)) -> IF_IN_GGGA(true, s(z0), s(0))
   IF_IN_GGGA(true, s(z0), s(0)) -> U5_GGGA(0, minus_out_gga(s(z0)))

The TRS R consists of the following rules:

   minus_in_gga(X, 0) -> minus_out_gga(X)
   minus_in_gga(s(X), s(Y)) -> U2_gga(minus_in_gga(X, Y))
   le_in_gga(s(X), 0) -> le_out_gga(false)
   le_in_gga(s(X), s(Y)) -> U1_gga(le_in_gga(X, Y))
   U2_gga(minus_out_gga(Z)) -> minus_out_gga(Z)
   U1_gga(le_out_gga(B)) -> le_out_gga(B)
   le_in_gga(0, Y) -> le_out_gga(true)

The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U2_gga(x0)
   U1_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(49) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(50)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U5_GGGA(0, minus_out_gga(s(z0))) -> DIV_IN_GGA(s(z0), s(0))
   DIV_IN_GGA(s(z0), s(0)) -> U3_GGA(s(z0), 0, le_out_gga(true))
   U3_GGA(s(z0), 0, le_out_gga(true)) -> IF_IN_GGGA(true, s(z0), s(0))
   IF_IN_GGGA(true, s(z0), s(0)) -> U5_GGGA(0, minus_out_gga(s(z0)))

R is empty.
The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U2_gga(x0)
   U1_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(51) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U2_gga(x0)
   U1_gga(x0)


----------------------------------------

(52)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U5_GGGA(0, minus_out_gga(s(z0))) -> DIV_IN_GGA(s(z0), s(0))
   DIV_IN_GGA(s(z0), s(0)) -> U3_GGA(s(z0), 0, le_out_gga(true))
   U3_GGA(s(z0), 0, le_out_gga(true)) -> IF_IN_GGGA(true, s(z0), s(0))
   IF_IN_GGGA(true, s(z0), s(0)) -> U5_GGGA(0, minus_out_gga(s(z0)))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(53) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = DIV_IN_GGA(s(z0'), s(0)) evaluates to  t =DIV_IN_GGA(s(z0'), s(0))

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

DIV_IN_GGA(s(z0'), s(0)) -> U3_GGA(s(z0'), 0, le_out_gga(true))
with rule DIV_IN_GGA(s(z0''), s(0)) -> U3_GGA(s(z0''), 0, le_out_gga(true)) at position [] and matcher [z0'' / z0']

U3_GGA(s(z0'), 0, le_out_gga(true)) -> IF_IN_GGGA(true, s(z0'), s(0))
with rule U3_GGA(s(z0), 0, le_out_gga(true)) -> IF_IN_GGGA(true, s(z0), s(0)) at position [] and matcher [z0 / z0']

IF_IN_GGGA(true, s(z0'), s(0)) -> U5_GGGA(0, minus_out_gga(s(z0')))
with rule IF_IN_GGGA(true, s(z0''), s(0)) -> U5_GGGA(0, minus_out_gga(s(z0''))) at position [] and matcher [z0'' / z0']

U5_GGGA(0, minus_out_gga(s(z0'))) -> DIV_IN_GGA(s(z0'), s(0))
with rule U5_GGGA(0, minus_out_gga(s(z0))) -> DIV_IN_GGA(s(z0), s(0))

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(54)
NO

----------------------------------------

(55)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U5_GGGA(s(z1), minus_out_gga(x1)) -> DIV_IN_GGA(x1, s(s(z1)))
   DIV_IN_GGA(s(x0), s(s(z0))) -> U3_GGA(s(x0), s(z0), U1_gga(le_in_gga(s(z0), x0)))
   U3_GGA(s(z0), s(z1), le_out_gga(x2)) -> IF_IN_GGGA(x2, s(z0), s(s(z1)))
   IF_IN_GGGA(true, s(x0), s(s(x1))) -> U5_GGGA(s(x1), U2_gga(minus_in_gga(x0, x1)))

The TRS R consists of the following rules:

   minus_in_gga(X, 0) -> minus_out_gga(X)
   minus_in_gga(s(X), s(Y)) -> U2_gga(minus_in_gga(X, Y))
   le_in_gga(s(X), 0) -> le_out_gga(false)
   le_in_gga(s(X), s(Y)) -> U1_gga(le_in_gga(X, Y))
   U2_gga(minus_out_gga(Z)) -> minus_out_gga(Z)
   U1_gga(le_out_gga(B)) -> le_out_gga(B)
   le_in_gga(0, Y) -> le_out_gga(true)

The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U2_gga(x0)
   U1_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(56) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule U5_GGGA(s(z1), minus_out_gga(x1)) -> DIV_IN_GGA(x1, s(s(z1))) we obtained the following new rules [LPAR04]:

   (U5_GGGA(s(x0), minus_out_gga(s(y_0))) -> DIV_IN_GGA(s(y_0), s(s(x0))),U5_GGGA(s(x0), minus_out_gga(s(y_0))) -> DIV_IN_GGA(s(y_0), s(s(x0))))


----------------------------------------

(57)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   DIV_IN_GGA(s(x0), s(s(z0))) -> U3_GGA(s(x0), s(z0), U1_gga(le_in_gga(s(z0), x0)))
   U3_GGA(s(z0), s(z1), le_out_gga(x2)) -> IF_IN_GGGA(x2, s(z0), s(s(z1)))
   IF_IN_GGGA(true, s(x0), s(s(x1))) -> U5_GGGA(s(x1), U2_gga(minus_in_gga(x0, x1)))
   U5_GGGA(s(x0), minus_out_gga(s(y_0))) -> DIV_IN_GGA(s(y_0), s(s(x0)))

The TRS R consists of the following rules:

   minus_in_gga(X, 0) -> minus_out_gga(X)
   minus_in_gga(s(X), s(Y)) -> U2_gga(minus_in_gga(X, Y))
   le_in_gga(s(X), 0) -> le_out_gga(false)
   le_in_gga(s(X), s(Y)) -> U1_gga(le_in_gga(X, Y))
   U2_gga(minus_out_gga(Z)) -> minus_out_gga(Z)
   U1_gga(le_out_gga(B)) -> le_out_gga(B)
   le_in_gga(0, Y) -> le_out_gga(true)

The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U2_gga(x0)
   U1_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(58) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule U3_GGA(s(z0), s(z1), le_out_gga(x2)) -> IF_IN_GGGA(x2, s(z0), s(s(z1))) we obtained the following new rules [LPAR04]:

   (U3_GGA(s(x0), s(x1), le_out_gga(true)) -> IF_IN_GGGA(true, s(x0), s(s(x1))),U3_GGA(s(x0), s(x1), le_out_gga(true)) -> IF_IN_GGGA(true, s(x0), s(s(x1))))


----------------------------------------

(59)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   DIV_IN_GGA(s(x0), s(s(z0))) -> U3_GGA(s(x0), s(z0), U1_gga(le_in_gga(s(z0), x0)))
   IF_IN_GGGA(true, s(x0), s(s(x1))) -> U5_GGGA(s(x1), U2_gga(minus_in_gga(x0, x1)))
   U5_GGGA(s(x0), minus_out_gga(s(y_0))) -> DIV_IN_GGA(s(y_0), s(s(x0)))
   U3_GGA(s(x0), s(x1), le_out_gga(true)) -> IF_IN_GGGA(true, s(x0), s(s(x1)))

The TRS R consists of the following rules:

   minus_in_gga(X, 0) -> minus_out_gga(X)
   minus_in_gga(s(X), s(Y)) -> U2_gga(minus_in_gga(X, Y))
   le_in_gga(s(X), 0) -> le_out_gga(false)
   le_in_gga(s(X), s(Y)) -> U1_gga(le_in_gga(X, Y))
   U2_gga(minus_out_gga(Z)) -> minus_out_gga(Z)
   U1_gga(le_out_gga(B)) -> le_out_gga(B)
   le_in_gga(0, Y) -> le_out_gga(true)

The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U2_gga(x0)
   U1_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(60) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   U3_GGA(s(x0), s(x1), le_out_gga(true)) -> IF_IN_GGGA(true, s(x0), s(s(x1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( U1_gga_1(x_1) ) = max{0, -2}
POL( U3_GGA_3(x_1, ..., x_3) ) = x_1 + 1
POL( le_in_gga_2(x_1, x_2) ) = max{0, 2x_2 - 2}
POL( s_1(x_1) ) = 2x_1 + 1
POL( 0 ) = 1
POL( le_out_gga_1(x_1) ) = 2
POL( false ) = 2
POL( U2_gga_1(x_1) ) = 2x_1
POL( U5_GGGA_2(x_1, x_2) ) = x_2 + 1
POL( minus_in_gga_2(x_1, x_2) ) = x_1
POL( minus_out_gga_1(x_1) ) = x_1
POL( true ) = 1
POL( DIV_IN_GGA_2(x_1, x_2) ) = x_1 + 1
POL( IF_IN_GGGA_3(x_1, ..., x_3) ) = max{0, 2x_1 + x_2 - 2}

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   minus_in_gga(X, 0) -> minus_out_gga(X)
   minus_in_gga(s(X), s(Y)) -> U2_gga(minus_in_gga(X, Y))
   U2_gga(minus_out_gga(Z)) -> minus_out_gga(Z)


----------------------------------------

(61)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   DIV_IN_GGA(s(x0), s(s(z0))) -> U3_GGA(s(x0), s(z0), U1_gga(le_in_gga(s(z0), x0)))
   IF_IN_GGGA(true, s(x0), s(s(x1))) -> U5_GGGA(s(x1), U2_gga(minus_in_gga(x0, x1)))
   U5_GGGA(s(x0), minus_out_gga(s(y_0))) -> DIV_IN_GGA(s(y_0), s(s(x0)))

The TRS R consists of the following rules:

   minus_in_gga(X, 0) -> minus_out_gga(X)
   minus_in_gga(s(X), s(Y)) -> U2_gga(minus_in_gga(X, Y))
   le_in_gga(s(X), 0) -> le_out_gga(false)
   le_in_gga(s(X), s(Y)) -> U1_gga(le_in_gga(X, Y))
   U2_gga(minus_out_gga(Z)) -> minus_out_gga(Z)
   U1_gga(le_out_gga(B)) -> le_out_gga(B)
   le_in_gga(0, Y) -> le_out_gga(true)

The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U2_gga(x0)
   U1_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(62) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 3 less nodes.
----------------------------------------

(63)
TRUE

----------------------------------------

(64) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

div_in_3: (b,b,f)

le_in_3: (b,b,f)

if_in_4: (b,b,b,f)

minus_in_3: (b,b,f)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   div_in_gga(X, s(Y), Z) -> U3_gga(X, Y, Z, le_in_gga(s(Y), X, B))
   le_in_gga(0, Y, true) -> le_out_gga(0, Y, true)
   le_in_gga(s(X), 0, false) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y), B) -> U1_gga(X, Y, B, le_in_gga(X, Y, B))
   U1_gga(X, Y, B, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)
   U3_gga(X, Y, Z, le_out_gga(s(Y), X, B)) -> U4_gga(X, Y, Z, if_in_ggga(B, X, s(Y), Z))
   if_in_ggga(false, X, s(Y), 0) -> if_out_ggga(false, X, s(Y), 0)
   if_in_ggga(true, X, s(Y), s(Z)) -> U5_ggga(X, Y, Z, minus_in_gga(X, Y, U))
   minus_in_gga(X, 0, X) -> minus_out_gga(X, 0, X)
   minus_in_gga(s(X), s(Y), Z) -> U2_gga(X, Y, Z, minus_in_gga(X, Y, Z))
   U2_gga(X, Y, Z, minus_out_gga(X, Y, Z)) -> minus_out_gga(s(X), s(Y), Z)
   U5_ggga(X, Y, Z, minus_out_gga(X, Y, U)) -> U6_ggga(X, Y, Z, div_in_gga(U, s(Y), Z))
   U6_ggga(X, Y, Z, div_out_gga(U, s(Y), Z)) -> if_out_ggga(true, X, s(Y), s(Z))
   U4_gga(X, Y, Z, if_out_ggga(B, X, s(Y), Z)) -> div_out_gga(X, s(Y), Z)

The argument filtering Pi contains the following mapping:
div_in_gga(x1, x2, x3)  =  div_in_gga(x1, x2)

s(x1)  =  s(x1)

U3_gga(x1, x2, x3, x4)  =  U3_gga(x1, x2, x4)

le_in_gga(x1, x2, x3)  =  le_in_gga(x1, x2)

0  =  0

le_out_gga(x1, x2, x3)  =  le_out_gga(x1, x2, x3)

U1_gga(x1, x2, x3, x4)  =  U1_gga(x1, x2, x4)

U4_gga(x1, x2, x3, x4)  =  U4_gga(x1, x2, x4)

if_in_ggga(x1, x2, x3, x4)  =  if_in_ggga(x1, x2, x3)

false  =  false

if_out_ggga(x1, x2, x3, x4)  =  if_out_ggga(x1, x2, x3, x4)

true  =  true

U5_ggga(x1, x2, x3, x4)  =  U5_ggga(x1, x2, x4)

minus_in_gga(x1, x2, x3)  =  minus_in_gga(x1, x2)

minus_out_gga(x1, x2, x3)  =  minus_out_gga(x1, x2, x3)

U2_gga(x1, x2, x3, x4)  =  U2_gga(x1, x2, x4)

U6_ggga(x1, x2, x3, x4)  =  U6_ggga(x1, x2, x4)

div_out_gga(x1, x2, x3)  =  div_out_gga(x1, x2, x3)





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(65)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   div_in_gga(X, s(Y), Z) -> U3_gga(X, Y, Z, le_in_gga(s(Y), X, B))
   le_in_gga(0, Y, true) -> le_out_gga(0, Y, true)
   le_in_gga(s(X), 0, false) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y), B) -> U1_gga(X, Y, B, le_in_gga(X, Y, B))
   U1_gga(X, Y, B, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)
   U3_gga(X, Y, Z, le_out_gga(s(Y), X, B)) -> U4_gga(X, Y, Z, if_in_ggga(B, X, s(Y), Z))
   if_in_ggga(false, X, s(Y), 0) -> if_out_ggga(false, X, s(Y), 0)
   if_in_ggga(true, X, s(Y), s(Z)) -> U5_ggga(X, Y, Z, minus_in_gga(X, Y, U))
   minus_in_gga(X, 0, X) -> minus_out_gga(X, 0, X)
   minus_in_gga(s(X), s(Y), Z) -> U2_gga(X, Y, Z, minus_in_gga(X, Y, Z))
   U2_gga(X, Y, Z, minus_out_gga(X, Y, Z)) -> minus_out_gga(s(X), s(Y), Z)
   U5_ggga(X, Y, Z, minus_out_gga(X, Y, U)) -> U6_ggga(X, Y, Z, div_in_gga(U, s(Y), Z))
   U6_ggga(X, Y, Z, div_out_gga(U, s(Y), Z)) -> if_out_ggga(true, X, s(Y), s(Z))
   U4_gga(X, Y, Z, if_out_ggga(B, X, s(Y), Z)) -> div_out_gga(X, s(Y), Z)

The argument filtering Pi contains the following mapping:
div_in_gga(x1, x2, x3)  =  div_in_gga(x1, x2)

s(x1)  =  s(x1)

U3_gga(x1, x2, x3, x4)  =  U3_gga(x1, x2, x4)

le_in_gga(x1, x2, x3)  =  le_in_gga(x1, x2)

0  =  0

le_out_gga(x1, x2, x3)  =  le_out_gga(x1, x2, x3)

U1_gga(x1, x2, x3, x4)  =  U1_gga(x1, x2, x4)

U4_gga(x1, x2, x3, x4)  =  U4_gga(x1, x2, x4)

if_in_ggga(x1, x2, x3, x4)  =  if_in_ggga(x1, x2, x3)

false  =  false

if_out_ggga(x1, x2, x3, x4)  =  if_out_ggga(x1, x2, x3, x4)

true  =  true

U5_ggga(x1, x2, x3, x4)  =  U5_ggga(x1, x2, x4)

minus_in_gga(x1, x2, x3)  =  minus_in_gga(x1, x2)

minus_out_gga(x1, x2, x3)  =  minus_out_gga(x1, x2, x3)

U2_gga(x1, x2, x3, x4)  =  U2_gga(x1, x2, x4)

U6_ggga(x1, x2, x3, x4)  =  U6_ggga(x1, x2, x4)

div_out_gga(x1, x2, x3)  =  div_out_gga(x1, x2, x3)



----------------------------------------

(66) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   DIV_IN_GGA(X, s(Y), Z) -> U3_GGA(X, Y, Z, le_in_gga(s(Y), X, B))
   DIV_IN_GGA(X, s(Y), Z) -> LE_IN_GGA(s(Y), X, B)
   LE_IN_GGA(s(X), s(Y), B) -> U1_GGA(X, Y, B, le_in_gga(X, Y, B))
   LE_IN_GGA(s(X), s(Y), B) -> LE_IN_GGA(X, Y, B)
   U3_GGA(X, Y, Z, le_out_gga(s(Y), X, B)) -> U4_GGA(X, Y, Z, if_in_ggga(B, X, s(Y), Z))
   U3_GGA(X, Y, Z, le_out_gga(s(Y), X, B)) -> IF_IN_GGGA(B, X, s(Y), Z)
   IF_IN_GGGA(true, X, s(Y), s(Z)) -> U5_GGGA(X, Y, Z, minus_in_gga(X, Y, U))
   IF_IN_GGGA(true, X, s(Y), s(Z)) -> MINUS_IN_GGA(X, Y, U)
   MINUS_IN_GGA(s(X), s(Y), Z) -> U2_GGA(X, Y, Z, minus_in_gga(X, Y, Z))
   MINUS_IN_GGA(s(X), s(Y), Z) -> MINUS_IN_GGA(X, Y, Z)
   U5_GGGA(X, Y, Z, minus_out_gga(X, Y, U)) -> U6_GGGA(X, Y, Z, div_in_gga(U, s(Y), Z))
   U5_GGGA(X, Y, Z, minus_out_gga(X, Y, U)) -> DIV_IN_GGA(U, s(Y), Z)

The TRS R consists of the following rules:

   div_in_gga(X, s(Y), Z) -> U3_gga(X, Y, Z, le_in_gga(s(Y), X, B))
   le_in_gga(0, Y, true) -> le_out_gga(0, Y, true)
   le_in_gga(s(X), 0, false) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y), B) -> U1_gga(X, Y, B, le_in_gga(X, Y, B))
   U1_gga(X, Y, B, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)
   U3_gga(X, Y, Z, le_out_gga(s(Y), X, B)) -> U4_gga(X, Y, Z, if_in_ggga(B, X, s(Y), Z))
   if_in_ggga(false, X, s(Y), 0) -> if_out_ggga(false, X, s(Y), 0)
   if_in_ggga(true, X, s(Y), s(Z)) -> U5_ggga(X, Y, Z, minus_in_gga(X, Y, U))
   minus_in_gga(X, 0, X) -> minus_out_gga(X, 0, X)
   minus_in_gga(s(X), s(Y), Z) -> U2_gga(X, Y, Z, minus_in_gga(X, Y, Z))
   U2_gga(X, Y, Z, minus_out_gga(X, Y, Z)) -> minus_out_gga(s(X), s(Y), Z)
   U5_ggga(X, Y, Z, minus_out_gga(X, Y, U)) -> U6_ggga(X, Y, Z, div_in_gga(U, s(Y), Z))
   U6_ggga(X, Y, Z, div_out_gga(U, s(Y), Z)) -> if_out_ggga(true, X, s(Y), s(Z))
   U4_gga(X, Y, Z, if_out_ggga(B, X, s(Y), Z)) -> div_out_gga(X, s(Y), Z)

The argument filtering Pi contains the following mapping:
div_in_gga(x1, x2, x3)  =  div_in_gga(x1, x2)

s(x1)  =  s(x1)

U3_gga(x1, x2, x3, x4)  =  U3_gga(x1, x2, x4)

le_in_gga(x1, x2, x3)  =  le_in_gga(x1, x2)

0  =  0

le_out_gga(x1, x2, x3)  =  le_out_gga(x1, x2, x3)

U1_gga(x1, x2, x3, x4)  =  U1_gga(x1, x2, x4)

U4_gga(x1, x2, x3, x4)  =  U4_gga(x1, x2, x4)

if_in_ggga(x1, x2, x3, x4)  =  if_in_ggga(x1, x2, x3)

false  =  false

if_out_ggga(x1, x2, x3, x4)  =  if_out_ggga(x1, x2, x3, x4)

true  =  true

U5_ggga(x1, x2, x3, x4)  =  U5_ggga(x1, x2, x4)

minus_in_gga(x1, x2, x3)  =  minus_in_gga(x1, x2)

minus_out_gga(x1, x2, x3)  =  minus_out_gga(x1, x2, x3)

U2_gga(x1, x2, x3, x4)  =  U2_gga(x1, x2, x4)

U6_ggga(x1, x2, x3, x4)  =  U6_ggga(x1, x2, x4)

div_out_gga(x1, x2, x3)  =  div_out_gga(x1, x2, x3)

DIV_IN_GGA(x1, x2, x3)  =  DIV_IN_GGA(x1, x2)

U3_GGA(x1, x2, x3, x4)  =  U3_GGA(x1, x2, x4)

LE_IN_GGA(x1, x2, x3)  =  LE_IN_GGA(x1, x2)

U1_GGA(x1, x2, x3, x4)  =  U1_GGA(x1, x2, x4)

U4_GGA(x1, x2, x3, x4)  =  U4_GGA(x1, x2, x4)

IF_IN_GGGA(x1, x2, x3, x4)  =  IF_IN_GGGA(x1, x2, x3)

U5_GGGA(x1, x2, x3, x4)  =  U5_GGGA(x1, x2, x4)

MINUS_IN_GGA(x1, x2, x3)  =  MINUS_IN_GGA(x1, x2)

U2_GGA(x1, x2, x3, x4)  =  U2_GGA(x1, x2, x4)

U6_GGGA(x1, x2, x3, x4)  =  U6_GGGA(x1, x2, x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(67)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   DIV_IN_GGA(X, s(Y), Z) -> U3_GGA(X, Y, Z, le_in_gga(s(Y), X, B))
   DIV_IN_GGA(X, s(Y), Z) -> LE_IN_GGA(s(Y), X, B)
   LE_IN_GGA(s(X), s(Y), B) -> U1_GGA(X, Y, B, le_in_gga(X, Y, B))
   LE_IN_GGA(s(X), s(Y), B) -> LE_IN_GGA(X, Y, B)
   U3_GGA(X, Y, Z, le_out_gga(s(Y), X, B)) -> U4_GGA(X, Y, Z, if_in_ggga(B, X, s(Y), Z))
   U3_GGA(X, Y, Z, le_out_gga(s(Y), X, B)) -> IF_IN_GGGA(B, X, s(Y), Z)
   IF_IN_GGGA(true, X, s(Y), s(Z)) -> U5_GGGA(X, Y, Z, minus_in_gga(X, Y, U))
   IF_IN_GGGA(true, X, s(Y), s(Z)) -> MINUS_IN_GGA(X, Y, U)
   MINUS_IN_GGA(s(X), s(Y), Z) -> U2_GGA(X, Y, Z, minus_in_gga(X, Y, Z))
   MINUS_IN_GGA(s(X), s(Y), Z) -> MINUS_IN_GGA(X, Y, Z)
   U5_GGGA(X, Y, Z, minus_out_gga(X, Y, U)) -> U6_GGGA(X, Y, Z, div_in_gga(U, s(Y), Z))
   U5_GGGA(X, Y, Z, minus_out_gga(X, Y, U)) -> DIV_IN_GGA(U, s(Y), Z)

The TRS R consists of the following rules:

   div_in_gga(X, s(Y), Z) -> U3_gga(X, Y, Z, le_in_gga(s(Y), X, B))
   le_in_gga(0, Y, true) -> le_out_gga(0, Y, true)
   le_in_gga(s(X), 0, false) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y), B) -> U1_gga(X, Y, B, le_in_gga(X, Y, B))
   U1_gga(X, Y, B, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)
   U3_gga(X, Y, Z, le_out_gga(s(Y), X, B)) -> U4_gga(X, Y, Z, if_in_ggga(B, X, s(Y), Z))
   if_in_ggga(false, X, s(Y), 0) -> if_out_ggga(false, X, s(Y), 0)
   if_in_ggga(true, X, s(Y), s(Z)) -> U5_ggga(X, Y, Z, minus_in_gga(X, Y, U))
   minus_in_gga(X, 0, X) -> minus_out_gga(X, 0, X)
   minus_in_gga(s(X), s(Y), Z) -> U2_gga(X, Y, Z, minus_in_gga(X, Y, Z))
   U2_gga(X, Y, Z, minus_out_gga(X, Y, Z)) -> minus_out_gga(s(X), s(Y), Z)
   U5_ggga(X, Y, Z, minus_out_gga(X, Y, U)) -> U6_ggga(X, Y, Z, div_in_gga(U, s(Y), Z))
   U6_ggga(X, Y, Z, div_out_gga(U, s(Y), Z)) -> if_out_ggga(true, X, s(Y), s(Z))
   U4_gga(X, Y, Z, if_out_ggga(B, X, s(Y), Z)) -> div_out_gga(X, s(Y), Z)

The argument filtering Pi contains the following mapping:
div_in_gga(x1, x2, x3)  =  div_in_gga(x1, x2)

s(x1)  =  s(x1)

U3_gga(x1, x2, x3, x4)  =  U3_gga(x1, x2, x4)

le_in_gga(x1, x2, x3)  =  le_in_gga(x1, x2)

0  =  0

le_out_gga(x1, x2, x3)  =  le_out_gga(x1, x2, x3)

U1_gga(x1, x2, x3, x4)  =  U1_gga(x1, x2, x4)

U4_gga(x1, x2, x3, x4)  =  U4_gga(x1, x2, x4)

if_in_ggga(x1, x2, x3, x4)  =  if_in_ggga(x1, x2, x3)

false  =  false

if_out_ggga(x1, x2, x3, x4)  =  if_out_ggga(x1, x2, x3, x4)

true  =  true

U5_ggga(x1, x2, x3, x4)  =  U5_ggga(x1, x2, x4)

minus_in_gga(x1, x2, x3)  =  minus_in_gga(x1, x2)

minus_out_gga(x1, x2, x3)  =  minus_out_gga(x1, x2, x3)

U2_gga(x1, x2, x3, x4)  =  U2_gga(x1, x2, x4)

U6_ggga(x1, x2, x3, x4)  =  U6_ggga(x1, x2, x4)

div_out_gga(x1, x2, x3)  =  div_out_gga(x1, x2, x3)

DIV_IN_GGA(x1, x2, x3)  =  DIV_IN_GGA(x1, x2)

U3_GGA(x1, x2, x3, x4)  =  U3_GGA(x1, x2, x4)

LE_IN_GGA(x1, x2, x3)  =  LE_IN_GGA(x1, x2)

U1_GGA(x1, x2, x3, x4)  =  U1_GGA(x1, x2, x4)

U4_GGA(x1, x2, x3, x4)  =  U4_GGA(x1, x2, x4)

IF_IN_GGGA(x1, x2, x3, x4)  =  IF_IN_GGGA(x1, x2, x3)

U5_GGGA(x1, x2, x3, x4)  =  U5_GGGA(x1, x2, x4)

MINUS_IN_GGA(x1, x2, x3)  =  MINUS_IN_GGA(x1, x2)

U2_GGA(x1, x2, x3, x4)  =  U2_GGA(x1, x2, x4)

U6_GGGA(x1, x2, x3, x4)  =  U6_GGGA(x1, x2, x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(68) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 3 SCCs with 6 less nodes.
----------------------------------------

(69)
Complex Obligation (AND)

----------------------------------------

(70)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MINUS_IN_GGA(s(X), s(Y), Z) -> MINUS_IN_GGA(X, Y, Z)

The TRS R consists of the following rules:

   div_in_gga(X, s(Y), Z) -> U3_gga(X, Y, Z, le_in_gga(s(Y), X, B))
   le_in_gga(0, Y, true) -> le_out_gga(0, Y, true)
   le_in_gga(s(X), 0, false) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y), B) -> U1_gga(X, Y, B, le_in_gga(X, Y, B))
   U1_gga(X, Y, B, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)
   U3_gga(X, Y, Z, le_out_gga(s(Y), X, B)) -> U4_gga(X, Y, Z, if_in_ggga(B, X, s(Y), Z))
   if_in_ggga(false, X, s(Y), 0) -> if_out_ggga(false, X, s(Y), 0)
   if_in_ggga(true, X, s(Y), s(Z)) -> U5_ggga(X, Y, Z, minus_in_gga(X, Y, U))
   minus_in_gga(X, 0, X) -> minus_out_gga(X, 0, X)
   minus_in_gga(s(X), s(Y), Z) -> U2_gga(X, Y, Z, minus_in_gga(X, Y, Z))
   U2_gga(X, Y, Z, minus_out_gga(X, Y, Z)) -> minus_out_gga(s(X), s(Y), Z)
   U5_ggga(X, Y, Z, minus_out_gga(X, Y, U)) -> U6_ggga(X, Y, Z, div_in_gga(U, s(Y), Z))
   U6_ggga(X, Y, Z, div_out_gga(U, s(Y), Z)) -> if_out_ggga(true, X, s(Y), s(Z))
   U4_gga(X, Y, Z, if_out_ggga(B, X, s(Y), Z)) -> div_out_gga(X, s(Y), Z)

The argument filtering Pi contains the following mapping:
div_in_gga(x1, x2, x3)  =  div_in_gga(x1, x2)

s(x1)  =  s(x1)

U3_gga(x1, x2, x3, x4)  =  U3_gga(x1, x2, x4)

le_in_gga(x1, x2, x3)  =  le_in_gga(x1, x2)

0  =  0

le_out_gga(x1, x2, x3)  =  le_out_gga(x1, x2, x3)

U1_gga(x1, x2, x3, x4)  =  U1_gga(x1, x2, x4)

U4_gga(x1, x2, x3, x4)  =  U4_gga(x1, x2, x4)

if_in_ggga(x1, x2, x3, x4)  =  if_in_ggga(x1, x2, x3)

false  =  false

if_out_ggga(x1, x2, x3, x4)  =  if_out_ggga(x1, x2, x3, x4)

true  =  true

U5_ggga(x1, x2, x3, x4)  =  U5_ggga(x1, x2, x4)

minus_in_gga(x1, x2, x3)  =  minus_in_gga(x1, x2)

minus_out_gga(x1, x2, x3)  =  minus_out_gga(x1, x2, x3)

U2_gga(x1, x2, x3, x4)  =  U2_gga(x1, x2, x4)

U6_ggga(x1, x2, x3, x4)  =  U6_ggga(x1, x2, x4)

div_out_gga(x1, x2, x3)  =  div_out_gga(x1, x2, x3)

MINUS_IN_GGA(x1, x2, x3)  =  MINUS_IN_GGA(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(71) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(72)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MINUS_IN_GGA(s(X), s(Y), Z) -> MINUS_IN_GGA(X, Y, Z)

R is empty.
The argument filtering Pi contains the following mapping:
s(x1)  =  s(x1)

MINUS_IN_GGA(x1, x2, x3)  =  MINUS_IN_GGA(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(73) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(74)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MINUS_IN_GGA(s(X), s(Y)) -> MINUS_IN_GGA(X, Y)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(75) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*MINUS_IN_GGA(s(X), s(Y)) -> MINUS_IN_GGA(X, Y)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(76)
YES

----------------------------------------

(77)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   LE_IN_GGA(s(X), s(Y), B) -> LE_IN_GGA(X, Y, B)

The TRS R consists of the following rules:

   div_in_gga(X, s(Y), Z) -> U3_gga(X, Y, Z, le_in_gga(s(Y), X, B))
   le_in_gga(0, Y, true) -> le_out_gga(0, Y, true)
   le_in_gga(s(X), 0, false) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y), B) -> U1_gga(X, Y, B, le_in_gga(X, Y, B))
   U1_gga(X, Y, B, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)
   U3_gga(X, Y, Z, le_out_gga(s(Y), X, B)) -> U4_gga(X, Y, Z, if_in_ggga(B, X, s(Y), Z))
   if_in_ggga(false, X, s(Y), 0) -> if_out_ggga(false, X, s(Y), 0)
   if_in_ggga(true, X, s(Y), s(Z)) -> U5_ggga(X, Y, Z, minus_in_gga(X, Y, U))
   minus_in_gga(X, 0, X) -> minus_out_gga(X, 0, X)
   minus_in_gga(s(X), s(Y), Z) -> U2_gga(X, Y, Z, minus_in_gga(X, Y, Z))
   U2_gga(X, Y, Z, minus_out_gga(X, Y, Z)) -> minus_out_gga(s(X), s(Y), Z)
   U5_ggga(X, Y, Z, minus_out_gga(X, Y, U)) -> U6_ggga(X, Y, Z, div_in_gga(U, s(Y), Z))
   U6_ggga(X, Y, Z, div_out_gga(U, s(Y), Z)) -> if_out_ggga(true, X, s(Y), s(Z))
   U4_gga(X, Y, Z, if_out_ggga(B, X, s(Y), Z)) -> div_out_gga(X, s(Y), Z)

The argument filtering Pi contains the following mapping:
div_in_gga(x1, x2, x3)  =  div_in_gga(x1, x2)

s(x1)  =  s(x1)

U3_gga(x1, x2, x3, x4)  =  U3_gga(x1, x2, x4)

le_in_gga(x1, x2, x3)  =  le_in_gga(x1, x2)

0  =  0

le_out_gga(x1, x2, x3)  =  le_out_gga(x1, x2, x3)

U1_gga(x1, x2, x3, x4)  =  U1_gga(x1, x2, x4)

U4_gga(x1, x2, x3, x4)  =  U4_gga(x1, x2, x4)

if_in_ggga(x1, x2, x3, x4)  =  if_in_ggga(x1, x2, x3)

false  =  false

if_out_ggga(x1, x2, x3, x4)  =  if_out_ggga(x1, x2, x3, x4)

true  =  true

U5_ggga(x1, x2, x3, x4)  =  U5_ggga(x1, x2, x4)

minus_in_gga(x1, x2, x3)  =  minus_in_gga(x1, x2)

minus_out_gga(x1, x2, x3)  =  minus_out_gga(x1, x2, x3)

U2_gga(x1, x2, x3, x4)  =  U2_gga(x1, x2, x4)

U6_ggga(x1, x2, x3, x4)  =  U6_ggga(x1, x2, x4)

div_out_gga(x1, x2, x3)  =  div_out_gga(x1, x2, x3)

LE_IN_GGA(x1, x2, x3)  =  LE_IN_GGA(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(78) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(79)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   LE_IN_GGA(s(X), s(Y), B) -> LE_IN_GGA(X, Y, B)

R is empty.
The argument filtering Pi contains the following mapping:
s(x1)  =  s(x1)

LE_IN_GGA(x1, x2, x3)  =  LE_IN_GGA(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(80) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(81)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LE_IN_GGA(s(X), s(Y)) -> LE_IN_GGA(X, Y)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(82) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*LE_IN_GGA(s(X), s(Y)) -> LE_IN_GGA(X, Y)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(83)
YES

----------------------------------------

(84)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U3_GGA(X, Y, Z, le_out_gga(s(Y), X, B)) -> IF_IN_GGGA(B, X, s(Y), Z)
   IF_IN_GGGA(true, X, s(Y), s(Z)) -> U5_GGGA(X, Y, Z, minus_in_gga(X, Y, U))
   U5_GGGA(X, Y, Z, minus_out_gga(X, Y, U)) -> DIV_IN_GGA(U, s(Y), Z)
   DIV_IN_GGA(X, s(Y), Z) -> U3_GGA(X, Y, Z, le_in_gga(s(Y), X, B))

The TRS R consists of the following rules:

   div_in_gga(X, s(Y), Z) -> U3_gga(X, Y, Z, le_in_gga(s(Y), X, B))
   le_in_gga(0, Y, true) -> le_out_gga(0, Y, true)
   le_in_gga(s(X), 0, false) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y), B) -> U1_gga(X, Y, B, le_in_gga(X, Y, B))
   U1_gga(X, Y, B, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)
   U3_gga(X, Y, Z, le_out_gga(s(Y), X, B)) -> U4_gga(X, Y, Z, if_in_ggga(B, X, s(Y), Z))
   if_in_ggga(false, X, s(Y), 0) -> if_out_ggga(false, X, s(Y), 0)
   if_in_ggga(true, X, s(Y), s(Z)) -> U5_ggga(X, Y, Z, minus_in_gga(X, Y, U))
   minus_in_gga(X, 0, X) -> minus_out_gga(X, 0, X)
   minus_in_gga(s(X), s(Y), Z) -> U2_gga(X, Y, Z, minus_in_gga(X, Y, Z))
   U2_gga(X, Y, Z, minus_out_gga(X, Y, Z)) -> minus_out_gga(s(X), s(Y), Z)
   U5_ggga(X, Y, Z, minus_out_gga(X, Y, U)) -> U6_ggga(X, Y, Z, div_in_gga(U, s(Y), Z))
   U6_ggga(X, Y, Z, div_out_gga(U, s(Y), Z)) -> if_out_ggga(true, X, s(Y), s(Z))
   U4_gga(X, Y, Z, if_out_ggga(B, X, s(Y), Z)) -> div_out_gga(X, s(Y), Z)

The argument filtering Pi contains the following mapping:
div_in_gga(x1, x2, x3)  =  div_in_gga(x1, x2)

s(x1)  =  s(x1)

U3_gga(x1, x2, x3, x4)  =  U3_gga(x1, x2, x4)

le_in_gga(x1, x2, x3)  =  le_in_gga(x1, x2)

0  =  0

le_out_gga(x1, x2, x3)  =  le_out_gga(x1, x2, x3)

U1_gga(x1, x2, x3, x4)  =  U1_gga(x1, x2, x4)

U4_gga(x1, x2, x3, x4)  =  U4_gga(x1, x2, x4)

if_in_ggga(x1, x2, x3, x4)  =  if_in_ggga(x1, x2, x3)

false  =  false

if_out_ggga(x1, x2, x3, x4)  =  if_out_ggga(x1, x2, x3, x4)

true  =  true

U5_ggga(x1, x2, x3, x4)  =  U5_ggga(x1, x2, x4)

minus_in_gga(x1, x2, x3)  =  minus_in_gga(x1, x2)

minus_out_gga(x1, x2, x3)  =  minus_out_gga(x1, x2, x3)

U2_gga(x1, x2, x3, x4)  =  U2_gga(x1, x2, x4)

U6_ggga(x1, x2, x3, x4)  =  U6_ggga(x1, x2, x4)

div_out_gga(x1, x2, x3)  =  div_out_gga(x1, x2, x3)

DIV_IN_GGA(x1, x2, x3)  =  DIV_IN_GGA(x1, x2)

U3_GGA(x1, x2, x3, x4)  =  U3_GGA(x1, x2, x4)

IF_IN_GGGA(x1, x2, x3, x4)  =  IF_IN_GGGA(x1, x2, x3)

U5_GGGA(x1, x2, x3, x4)  =  U5_GGGA(x1, x2, x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(85) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(86)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U3_GGA(X, Y, Z, le_out_gga(s(Y), X, B)) -> IF_IN_GGGA(B, X, s(Y), Z)
   IF_IN_GGGA(true, X, s(Y), s(Z)) -> U5_GGGA(X, Y, Z, minus_in_gga(X, Y, U))
   U5_GGGA(X, Y, Z, minus_out_gga(X, Y, U)) -> DIV_IN_GGA(U, s(Y), Z)
   DIV_IN_GGA(X, s(Y), Z) -> U3_GGA(X, Y, Z, le_in_gga(s(Y), X, B))

The TRS R consists of the following rules:

   minus_in_gga(X, 0, X) -> minus_out_gga(X, 0, X)
   minus_in_gga(s(X), s(Y), Z) -> U2_gga(X, Y, Z, minus_in_gga(X, Y, Z))
   le_in_gga(s(X), 0, false) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y), B) -> U1_gga(X, Y, B, le_in_gga(X, Y, B))
   U2_gga(X, Y, Z, minus_out_gga(X, Y, Z)) -> minus_out_gga(s(X), s(Y), Z)
   U1_gga(X, Y, B, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)
   le_in_gga(0, Y, true) -> le_out_gga(0, Y, true)

The argument filtering Pi contains the following mapping:
s(x1)  =  s(x1)

le_in_gga(x1, x2, x3)  =  le_in_gga(x1, x2)

0  =  0

le_out_gga(x1, x2, x3)  =  le_out_gga(x1, x2, x3)

U1_gga(x1, x2, x3, x4)  =  U1_gga(x1, x2, x4)

false  =  false

true  =  true

minus_in_gga(x1, x2, x3)  =  minus_in_gga(x1, x2)

minus_out_gga(x1, x2, x3)  =  minus_out_gga(x1, x2, x3)

U2_gga(x1, x2, x3, x4)  =  U2_gga(x1, x2, x4)

DIV_IN_GGA(x1, x2, x3)  =  DIV_IN_GGA(x1, x2)

U3_GGA(x1, x2, x3, x4)  =  U3_GGA(x1, x2, x4)

IF_IN_GGGA(x1, x2, x3, x4)  =  IF_IN_GGGA(x1, x2, x3)

U5_GGGA(x1, x2, x3, x4)  =  U5_GGGA(x1, x2, x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(87) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(88)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U3_GGA(X, Y, le_out_gga(s(Y), X, B)) -> IF_IN_GGGA(B, X, s(Y))
   IF_IN_GGGA(true, X, s(Y)) -> U5_GGGA(X, Y, minus_in_gga(X, Y))
   U5_GGGA(X, Y, minus_out_gga(X, Y, U)) -> DIV_IN_GGA(U, s(Y))
   DIV_IN_GGA(X, s(Y)) -> U3_GGA(X, Y, le_in_gga(s(Y), X))

The TRS R consists of the following rules:

   minus_in_gga(X, 0) -> minus_out_gga(X, 0, X)
   minus_in_gga(s(X), s(Y)) -> U2_gga(X, Y, minus_in_gga(X, Y))
   le_in_gga(s(X), 0) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y)) -> U1_gga(X, Y, le_in_gga(X, Y))
   U2_gga(X, Y, minus_out_gga(X, Y, Z)) -> minus_out_gga(s(X), s(Y), Z)
   U1_gga(X, Y, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)
   le_in_gga(0, Y) -> le_out_gga(0, Y, true)

The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U2_gga(x0, x1, x2)
   U1_gga(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(89) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.


Strictly oriented rules of the TRS R:

   minus_in_gga(s(X), s(Y)) -> U2_gga(X, Y, minus_in_gga(X, Y))

Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(DIV_IN_GGA(x_1, x_2)) = 2*x_1
   POL(IF_IN_GGGA(x_1, x_2, x_3)) = 2*x_2
   POL(U1_gga(x_1, x_2, x_3)) = 0
   POL(U2_gga(x_1, x_2, x_3)) = x_3
   POL(U3_GGA(x_1, x_2, x_3)) = 2*x_1
   POL(U5_GGGA(x_1, x_2, x_3)) = 2*x_3
   POL(false) = 2
   POL(le_in_gga(x_1, x_2)) = 0
   POL(le_out_gga(x_1, x_2, x_3)) = 0
   POL(minus_in_gga(x_1, x_2)) = x_1
   POL(minus_out_gga(x_1, x_2, x_3)) = x_3
   POL(s(x_1)) = 2 + x_1
   POL(true) = 0


----------------------------------------

(90)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U3_GGA(X, Y, le_out_gga(s(Y), X, B)) -> IF_IN_GGGA(B, X, s(Y))
   IF_IN_GGGA(true, X, s(Y)) -> U5_GGGA(X, Y, minus_in_gga(X, Y))
   U5_GGGA(X, Y, minus_out_gga(X, Y, U)) -> DIV_IN_GGA(U, s(Y))
   DIV_IN_GGA(X, s(Y)) -> U3_GGA(X, Y, le_in_gga(s(Y), X))

The TRS R consists of the following rules:

   minus_in_gga(X, 0) -> minus_out_gga(X, 0, X)
   le_in_gga(s(X), 0) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y)) -> U1_gga(X, Y, le_in_gga(X, Y))
   U2_gga(X, Y, minus_out_gga(X, Y, Z)) -> minus_out_gga(s(X), s(Y), Z)
   U1_gga(X, Y, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)
   le_in_gga(0, Y) -> le_out_gga(0, Y, true)

The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U2_gga(x0, x1, x2)
   U1_gga(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(91) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(92)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U3_GGA(X, Y, le_out_gga(s(Y), X, B)) -> IF_IN_GGGA(B, X, s(Y))
   IF_IN_GGGA(true, X, s(Y)) -> U5_GGGA(X, Y, minus_in_gga(X, Y))
   U5_GGGA(X, Y, minus_out_gga(X, Y, U)) -> DIV_IN_GGA(U, s(Y))
   DIV_IN_GGA(X, s(Y)) -> U3_GGA(X, Y, le_in_gga(s(Y), X))

The TRS R consists of the following rules:

   le_in_gga(s(X), 0) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y)) -> U1_gga(X, Y, le_in_gga(X, Y))
   le_in_gga(0, Y) -> le_out_gga(0, Y, true)
   U1_gga(X, Y, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)
   minus_in_gga(X, 0) -> minus_out_gga(X, 0, X)

The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U2_gga(x0, x1, x2)
   U1_gga(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(93) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   U2_gga(x0, x1, x2)


----------------------------------------

(94)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U3_GGA(X, Y, le_out_gga(s(Y), X, B)) -> IF_IN_GGGA(B, X, s(Y))
   IF_IN_GGGA(true, X, s(Y)) -> U5_GGGA(X, Y, minus_in_gga(X, Y))
   U5_GGGA(X, Y, minus_out_gga(X, Y, U)) -> DIV_IN_GGA(U, s(Y))
   DIV_IN_GGA(X, s(Y)) -> U3_GGA(X, Y, le_in_gga(s(Y), X))

The TRS R consists of the following rules:

   le_in_gga(s(X), 0) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y)) -> U1_gga(X, Y, le_in_gga(X, Y))
   le_in_gga(0, Y) -> le_out_gga(0, Y, true)
   U1_gga(X, Y, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)
   minus_in_gga(X, 0) -> minus_out_gga(X, 0, X)

The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U1_gga(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(95) TransformationProof (SOUND)
By narrowing [LPAR04] the rule IF_IN_GGGA(true, X, s(Y)) -> U5_GGGA(X, Y, minus_in_gga(X, Y)) at position [2] we obtained the following new rules [LPAR04]:

   (IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(x0, 0, minus_out_gga(x0, 0, x0)),IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(x0, 0, minus_out_gga(x0, 0, x0)))


----------------------------------------

(96)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U3_GGA(X, Y, le_out_gga(s(Y), X, B)) -> IF_IN_GGGA(B, X, s(Y))
   U5_GGGA(X, Y, minus_out_gga(X, Y, U)) -> DIV_IN_GGA(U, s(Y))
   DIV_IN_GGA(X, s(Y)) -> U3_GGA(X, Y, le_in_gga(s(Y), X))
   IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(x0, 0, minus_out_gga(x0, 0, x0))

The TRS R consists of the following rules:

   le_in_gga(s(X), 0) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y)) -> U1_gga(X, Y, le_in_gga(X, Y))
   le_in_gga(0, Y) -> le_out_gga(0, Y, true)
   U1_gga(X, Y, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)
   minus_in_gga(X, 0) -> minus_out_gga(X, 0, X)

The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U1_gga(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(97) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(98)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U3_GGA(X, Y, le_out_gga(s(Y), X, B)) -> IF_IN_GGGA(B, X, s(Y))
   U5_GGGA(X, Y, minus_out_gga(X, Y, U)) -> DIV_IN_GGA(U, s(Y))
   DIV_IN_GGA(X, s(Y)) -> U3_GGA(X, Y, le_in_gga(s(Y), X))
   IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(x0, 0, minus_out_gga(x0, 0, x0))

The TRS R consists of the following rules:

   le_in_gga(s(X), 0) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y)) -> U1_gga(X, Y, le_in_gga(X, Y))
   le_in_gga(0, Y) -> le_out_gga(0, Y, true)
   U1_gga(X, Y, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)

The set Q consists of the following terms:

   minus_in_gga(x0, x1)
   le_in_gga(x0, x1)
   U1_gga(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(99) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   minus_in_gga(x0, x1)


----------------------------------------

(100)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U3_GGA(X, Y, le_out_gga(s(Y), X, B)) -> IF_IN_GGGA(B, X, s(Y))
   U5_GGGA(X, Y, minus_out_gga(X, Y, U)) -> DIV_IN_GGA(U, s(Y))
   DIV_IN_GGA(X, s(Y)) -> U3_GGA(X, Y, le_in_gga(s(Y), X))
   IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(x0, 0, minus_out_gga(x0, 0, x0))

The TRS R consists of the following rules:

   le_in_gga(s(X), 0) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y)) -> U1_gga(X, Y, le_in_gga(X, Y))
   le_in_gga(0, Y) -> le_out_gga(0, Y, true)
   U1_gga(X, Y, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)

The set Q consists of the following terms:

   le_in_gga(x0, x1)
   U1_gga(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(101) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U5_GGGA(X, Y, minus_out_gga(X, Y, U)) -> DIV_IN_GGA(U, s(Y)) we obtained the following new rules [LPAR04]:

   (U5_GGGA(z0, 0, minus_out_gga(z0, 0, z0)) -> DIV_IN_GGA(z0, s(0)),U5_GGGA(z0, 0, minus_out_gga(z0, 0, z0)) -> DIV_IN_GGA(z0, s(0)))


----------------------------------------

(102)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U3_GGA(X, Y, le_out_gga(s(Y), X, B)) -> IF_IN_GGGA(B, X, s(Y))
   DIV_IN_GGA(X, s(Y)) -> U3_GGA(X, Y, le_in_gga(s(Y), X))
   IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(x0, 0, minus_out_gga(x0, 0, x0))
   U5_GGGA(z0, 0, minus_out_gga(z0, 0, z0)) -> DIV_IN_GGA(z0, s(0))

The TRS R consists of the following rules:

   le_in_gga(s(X), 0) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y)) -> U1_gga(X, Y, le_in_gga(X, Y))
   le_in_gga(0, Y) -> le_out_gga(0, Y, true)
   U1_gga(X, Y, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)

The set Q consists of the following terms:

   le_in_gga(x0, x1)
   U1_gga(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(103) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule DIV_IN_GGA(X, s(Y)) -> U3_GGA(X, Y, le_in_gga(s(Y), X)) we obtained the following new rules [LPAR04]:

   (DIV_IN_GGA(z0, s(0)) -> U3_GGA(z0, 0, le_in_gga(s(0), z0)),DIV_IN_GGA(z0, s(0)) -> U3_GGA(z0, 0, le_in_gga(s(0), z0)))


----------------------------------------

(104)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U3_GGA(X, Y, le_out_gga(s(Y), X, B)) -> IF_IN_GGGA(B, X, s(Y))
   IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(x0, 0, minus_out_gga(x0, 0, x0))
   U5_GGGA(z0, 0, minus_out_gga(z0, 0, z0)) -> DIV_IN_GGA(z0, s(0))
   DIV_IN_GGA(z0, s(0)) -> U3_GGA(z0, 0, le_in_gga(s(0), z0))

The TRS R consists of the following rules:

   le_in_gga(s(X), 0) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y)) -> U1_gga(X, Y, le_in_gga(X, Y))
   le_in_gga(0, Y) -> le_out_gga(0, Y, true)
   U1_gga(X, Y, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)

The set Q consists of the following terms:

   le_in_gga(x0, x1)
   U1_gga(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(105) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U3_GGA(X, Y, le_out_gga(s(Y), X, B)) -> IF_IN_GGGA(B, X, s(Y)) we obtained the following new rules [LPAR04]:

   (U3_GGA(z0, 0, le_out_gga(s(0), z0, x2)) -> IF_IN_GGGA(x2, z0, s(0)),U3_GGA(z0, 0, le_out_gga(s(0), z0, x2)) -> IF_IN_GGGA(x2, z0, s(0)))


----------------------------------------

(106)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(x0, 0, minus_out_gga(x0, 0, x0))
   U5_GGGA(z0, 0, minus_out_gga(z0, 0, z0)) -> DIV_IN_GGA(z0, s(0))
   DIV_IN_GGA(z0, s(0)) -> U3_GGA(z0, 0, le_in_gga(s(0), z0))
   U3_GGA(z0, 0, le_out_gga(s(0), z0, x2)) -> IF_IN_GGGA(x2, z0, s(0))

The TRS R consists of the following rules:

   le_in_gga(s(X), 0) -> le_out_gga(s(X), 0, false)
   le_in_gga(s(X), s(Y)) -> U1_gga(X, Y, le_in_gga(X, Y))
   le_in_gga(0, Y) -> le_out_gga(0, Y, true)
   U1_gga(X, Y, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)

The set Q consists of the following terms:

   le_in_gga(x0, x1)
   U1_gga(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(107) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.


Strictly oriented rules of the TRS R:

   le_in_gga(s(X), 0) -> le_out_gga(s(X), 0, false)

Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(DIV_IN_GGA(x_1, x_2)) = 2
   POL(IF_IN_GGGA(x_1, x_2, x_3)) = 2*x_1
   POL(U1_gga(x_1, x_2, x_3)) = x_3
   POL(U3_GGA(x_1, x_2, x_3)) = 2*x_2 + 2*x_3
   POL(U5_GGGA(x_1, x_2, x_3)) = x_2 + x_3
   POL(false) = 0
   POL(le_in_gga(x_1, x_2)) = 1
   POL(le_out_gga(x_1, x_2, x_3)) = x_3
   POL(minus_out_gga(x_1, x_2, x_3)) = 2
   POL(s(x_1)) = 0
   POL(true) = 1


----------------------------------------

(108)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(x0, 0, minus_out_gga(x0, 0, x0))
   U5_GGGA(z0, 0, minus_out_gga(z0, 0, z0)) -> DIV_IN_GGA(z0, s(0))
   DIV_IN_GGA(z0, s(0)) -> U3_GGA(z0, 0, le_in_gga(s(0), z0))
   U3_GGA(z0, 0, le_out_gga(s(0), z0, x2)) -> IF_IN_GGGA(x2, z0, s(0))

The TRS R consists of the following rules:

   le_in_gga(s(X), s(Y)) -> U1_gga(X, Y, le_in_gga(X, Y))
   le_in_gga(0, Y) -> le_out_gga(0, Y, true)
   U1_gga(X, Y, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)

The set Q consists of the following terms:

   le_in_gga(x0, x1)
   U1_gga(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(109) TransformationProof (SOUND)
By narrowing [LPAR04] the rule DIV_IN_GGA(z0, s(0)) -> U3_GGA(z0, 0, le_in_gga(s(0), z0)) at position [2] we obtained the following new rules [LPAR04]:

   (DIV_IN_GGA(s(x1), s(0)) -> U3_GGA(s(x1), 0, U1_gga(0, x1, le_in_gga(0, x1))),DIV_IN_GGA(s(x1), s(0)) -> U3_GGA(s(x1), 0, U1_gga(0, x1, le_in_gga(0, x1))))


----------------------------------------

(110)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(x0, 0, minus_out_gga(x0, 0, x0))
   U5_GGGA(z0, 0, minus_out_gga(z0, 0, z0)) -> DIV_IN_GGA(z0, s(0))
   U3_GGA(z0, 0, le_out_gga(s(0), z0, x2)) -> IF_IN_GGGA(x2, z0, s(0))
   DIV_IN_GGA(s(x1), s(0)) -> U3_GGA(s(x1), 0, U1_gga(0, x1, le_in_gga(0, x1)))

The TRS R consists of the following rules:

   le_in_gga(s(X), s(Y)) -> U1_gga(X, Y, le_in_gga(X, Y))
   le_in_gga(0, Y) -> le_out_gga(0, Y, true)
   U1_gga(X, Y, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)

The set Q consists of the following terms:

   le_in_gga(x0, x1)
   U1_gga(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(111) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(112)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(x0, 0, minus_out_gga(x0, 0, x0))
   U5_GGGA(z0, 0, minus_out_gga(z0, 0, z0)) -> DIV_IN_GGA(z0, s(0))
   U3_GGA(z0, 0, le_out_gga(s(0), z0, x2)) -> IF_IN_GGGA(x2, z0, s(0))
   DIV_IN_GGA(s(x1), s(0)) -> U3_GGA(s(x1), 0, U1_gga(0, x1, le_in_gga(0, x1)))

The TRS R consists of the following rules:

   le_in_gga(0, Y) -> le_out_gga(0, Y, true)
   U1_gga(X, Y, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)

The set Q consists of the following terms:

   le_in_gga(x0, x1)
   U1_gga(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(113) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule DIV_IN_GGA(s(x1), s(0)) -> U3_GGA(s(x1), 0, U1_gga(0, x1, le_in_gga(0, x1))) at position [2,2] we obtained the following new rules [LPAR04]:

   (DIV_IN_GGA(s(x1), s(0)) -> U3_GGA(s(x1), 0, U1_gga(0, x1, le_out_gga(0, x1, true))),DIV_IN_GGA(s(x1), s(0)) -> U3_GGA(s(x1), 0, U1_gga(0, x1, le_out_gga(0, x1, true))))


----------------------------------------

(114)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(x0, 0, minus_out_gga(x0, 0, x0))
   U5_GGGA(z0, 0, minus_out_gga(z0, 0, z0)) -> DIV_IN_GGA(z0, s(0))
   U3_GGA(z0, 0, le_out_gga(s(0), z0, x2)) -> IF_IN_GGGA(x2, z0, s(0))
   DIV_IN_GGA(s(x1), s(0)) -> U3_GGA(s(x1), 0, U1_gga(0, x1, le_out_gga(0, x1, true)))

The TRS R consists of the following rules:

   le_in_gga(0, Y) -> le_out_gga(0, Y, true)
   U1_gga(X, Y, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)

The set Q consists of the following terms:

   le_in_gga(x0, x1)
   U1_gga(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(115) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(116)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(x0, 0, minus_out_gga(x0, 0, x0))
   U5_GGGA(z0, 0, minus_out_gga(z0, 0, z0)) -> DIV_IN_GGA(z0, s(0))
   U3_GGA(z0, 0, le_out_gga(s(0), z0, x2)) -> IF_IN_GGGA(x2, z0, s(0))
   DIV_IN_GGA(s(x1), s(0)) -> U3_GGA(s(x1), 0, U1_gga(0, x1, le_out_gga(0, x1, true)))

The TRS R consists of the following rules:

   U1_gga(X, Y, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)

The set Q consists of the following terms:

   le_in_gga(x0, x1)
   U1_gga(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(117) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   le_in_gga(x0, x1)


----------------------------------------

(118)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(x0, 0, minus_out_gga(x0, 0, x0))
   U5_GGGA(z0, 0, minus_out_gga(z0, 0, z0)) -> DIV_IN_GGA(z0, s(0))
   U3_GGA(z0, 0, le_out_gga(s(0), z0, x2)) -> IF_IN_GGGA(x2, z0, s(0))
   DIV_IN_GGA(s(x1), s(0)) -> U3_GGA(s(x1), 0, U1_gga(0, x1, le_out_gga(0, x1, true)))

The TRS R consists of the following rules:

   U1_gga(X, Y, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)

The set Q consists of the following terms:

   U1_gga(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(119) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule DIV_IN_GGA(s(x1), s(0)) -> U3_GGA(s(x1), 0, U1_gga(0, x1, le_out_gga(0, x1, true))) at position [2] we obtained the following new rules [LPAR04]:

   (DIV_IN_GGA(s(x1), s(0)) -> U3_GGA(s(x1), 0, le_out_gga(s(0), s(x1), true)),DIV_IN_GGA(s(x1), s(0)) -> U3_GGA(s(x1), 0, le_out_gga(s(0), s(x1), true)))


----------------------------------------

(120)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(x0, 0, minus_out_gga(x0, 0, x0))
   U5_GGGA(z0, 0, minus_out_gga(z0, 0, z0)) -> DIV_IN_GGA(z0, s(0))
   U3_GGA(z0, 0, le_out_gga(s(0), z0, x2)) -> IF_IN_GGGA(x2, z0, s(0))
   DIV_IN_GGA(s(x1), s(0)) -> U3_GGA(s(x1), 0, le_out_gga(s(0), s(x1), true))

The TRS R consists of the following rules:

   U1_gga(X, Y, le_out_gga(X, Y, B)) -> le_out_gga(s(X), s(Y), B)

The set Q consists of the following terms:

   U1_gga(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(121) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(122)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(x0, 0, minus_out_gga(x0, 0, x0))
   U5_GGGA(z0, 0, minus_out_gga(z0, 0, z0)) -> DIV_IN_GGA(z0, s(0))
   U3_GGA(z0, 0, le_out_gga(s(0), z0, x2)) -> IF_IN_GGGA(x2, z0, s(0))
   DIV_IN_GGA(s(x1), s(0)) -> U3_GGA(s(x1), 0, le_out_gga(s(0), s(x1), true))

R is empty.
The set Q consists of the following terms:

   U1_gga(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(123) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   U1_gga(x0, x1, x2)


----------------------------------------

(124)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(x0, 0, minus_out_gga(x0, 0, x0))
   U5_GGGA(z0, 0, minus_out_gga(z0, 0, z0)) -> DIV_IN_GGA(z0, s(0))
   U3_GGA(z0, 0, le_out_gga(s(0), z0, x2)) -> IF_IN_GGGA(x2, z0, s(0))
   DIV_IN_GGA(s(x1), s(0)) -> U3_GGA(s(x1), 0, le_out_gga(s(0), s(x1), true))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(125) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U3_GGA(z0, 0, le_out_gga(s(0), z0, x2)) -> IF_IN_GGGA(x2, z0, s(0)) we obtained the following new rules [LPAR04]:

   (U3_GGA(s(z0), 0, le_out_gga(s(0), s(z0), true)) -> IF_IN_GGGA(true, s(z0), s(0)),U3_GGA(s(z0), 0, le_out_gga(s(0), s(z0), true)) -> IF_IN_GGGA(true, s(z0), s(0)))


----------------------------------------

(126)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(x0, 0, minus_out_gga(x0, 0, x0))
   U5_GGGA(z0, 0, minus_out_gga(z0, 0, z0)) -> DIV_IN_GGA(z0, s(0))
   DIV_IN_GGA(s(x1), s(0)) -> U3_GGA(s(x1), 0, le_out_gga(s(0), s(x1), true))
   U3_GGA(s(z0), 0, le_out_gga(s(0), s(z0), true)) -> IF_IN_GGGA(true, s(z0), s(0))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(127) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF_IN_GGGA(true, x0, s(0)) -> U5_GGGA(x0, 0, minus_out_gga(x0, 0, x0)) we obtained the following new rules [LPAR04]:

   (IF_IN_GGGA(true, s(z0), s(0)) -> U5_GGGA(s(z0), 0, minus_out_gga(s(z0), 0, s(z0))),IF_IN_GGGA(true, s(z0), s(0)) -> U5_GGGA(s(z0), 0, minus_out_gga(s(z0), 0, s(z0))))


----------------------------------------

(128)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U5_GGGA(z0, 0, minus_out_gga(z0, 0, z0)) -> DIV_IN_GGA(z0, s(0))
   DIV_IN_GGA(s(x1), s(0)) -> U3_GGA(s(x1), 0, le_out_gga(s(0), s(x1), true))
   U3_GGA(s(z0), 0, le_out_gga(s(0), s(z0), true)) -> IF_IN_GGGA(true, s(z0), s(0))
   IF_IN_GGGA(true, s(z0), s(0)) -> U5_GGGA(s(z0), 0, minus_out_gga(s(z0), 0, s(z0)))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(129) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U5_GGGA(z0, 0, minus_out_gga(z0, 0, z0)) -> DIV_IN_GGA(z0, s(0)) we obtained the following new rules [LPAR04]:

   (U5_GGGA(s(z0), 0, minus_out_gga(s(z0), 0, s(z0))) -> DIV_IN_GGA(s(z0), s(0)),U5_GGGA(s(z0), 0, minus_out_gga(s(z0), 0, s(z0))) -> DIV_IN_GGA(s(z0), s(0)))


----------------------------------------

(130)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   DIV_IN_GGA(s(x1), s(0)) -> U3_GGA(s(x1), 0, le_out_gga(s(0), s(x1), true))
   U3_GGA(s(z0), 0, le_out_gga(s(0), s(z0), true)) -> IF_IN_GGGA(true, s(z0), s(0))
   IF_IN_GGGA(true, s(z0), s(0)) -> U5_GGGA(s(z0), 0, minus_out_gga(s(z0), 0, s(z0)))
   U5_GGGA(s(z0), 0, minus_out_gga(s(z0), 0, s(z0))) -> DIV_IN_GGA(s(z0), s(0))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(131) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = U3_GGA(s(z0), 0, le_out_gga(s(0), s(z0), true)) evaluates to  t =U3_GGA(s(z0), 0, le_out_gga(s(0), s(z0), true))

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

U3_GGA(s(z0), 0, le_out_gga(s(0), s(z0), true)) -> IF_IN_GGGA(true, s(z0), s(0))
with rule U3_GGA(s(z0'), 0, le_out_gga(s(0), s(z0'), true)) -> IF_IN_GGGA(true, s(z0'), s(0)) at position [] and matcher [z0' / z0]

IF_IN_GGGA(true, s(z0), s(0)) -> U5_GGGA(s(z0), 0, minus_out_gga(s(z0), 0, s(z0)))
with rule IF_IN_GGGA(true, s(z0'), s(0)) -> U5_GGGA(s(z0'), 0, minus_out_gga(s(z0'), 0, s(z0'))) at position [] and matcher [z0' / z0]

U5_GGGA(s(z0), 0, minus_out_gga(s(z0), 0, s(z0))) -> DIV_IN_GGA(s(z0), s(0))
with rule U5_GGGA(s(z0'), 0, minus_out_gga(s(z0'), 0, s(z0'))) -> DIV_IN_GGA(s(z0'), s(0)) at position [] and matcher [z0' / z0]

DIV_IN_GGA(s(z0), s(0)) -> U3_GGA(s(z0), 0, le_out_gga(s(0), s(z0), true))
with rule DIV_IN_GGA(s(x1), s(0)) -> U3_GGA(s(x1), 0, le_out_gga(s(0), s(x1), true))

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(132)
NO

----------------------------------------

(133) PrologToTRSTransformerProof (SOUND)
Transformed Prolog program to TRS.

{
    "root": 3,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(le (0) Y (true))",
                null
            ],
            [
                "(le (s X) (0) (false))",
                null
            ],
            [
                "(le (s X) (s Y) B)",
                "(le X Y B)"
            ],
            [
                "(minus X (0) X)",
                null
            ],
            [
                "(minus (s X) (s Y) Z)",
                "(minus X Y Z)"
            ],
            [
                "(div X (s Y) Z)",
                "(',' (le (s Y) X B) (if B X (s Y) Z))"
            ],
            [
                "(if (false) X (s Y) (0))",
                null
            ],
            [
                "(if (true) X (s Y) (s Z))",
                "(',' (minus X Y U) (div U (s Y) Z))"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "27": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (le (s T11) T10 X11) (if X11 T10 (s T11) T13))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T10",
                        "T11"
                    ],
                    "free": ["X11"],
                    "exprvars": []
                }
            },
            "29": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "230": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(if T14 T10 (s T11) T13)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T10",
                        "T11",
                        "T14"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "231": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 2,
                        "term": "(le (s T11) T10 X11)"
                    },
                    {
                        "clause": 1,
                        "scope": 2,
                        "term": "(le (s T11) T10 X11)"
                    },
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(le (s T11) T10 X11)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T10",
                        "T11"
                    ],
                    "free": ["X11"],
                    "exprvars": []
                }
            },
            "232": {
                "goal": [
                    {
                        "clause": 1,
                        "scope": 2,
                        "term": "(le (s T11) T10 X11)"
                    },
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(le (s T11) T10 X11)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T10",
                        "T11"
                    ],
                    "free": ["X11"],
                    "exprvars": []
                }
            },
            "233": {
                "goal": [{
                    "clause": 1,
                    "scope": 2,
                    "term": "(le (s T11) T10 X11)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T10",
                        "T11"
                    ],
                    "free": ["X11"],
                    "exprvars": []
                }
            },
            "234": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(le (s T11) T10 X11)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T10",
                        "T11"
                    ],
                    "free": ["X11"],
                    "exprvars": []
                }
            },
            "256": {
                "goal": [{
                    "clause": 0,
                    "scope": 3,
                    "term": "(le T24 T25 X33)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T24",
                        "T25"
                    ],
                    "free": ["X33"],
                    "exprvars": []
                }
            },
            "355": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "235": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "257": {
                "goal": [
                    {
                        "clause": 1,
                        "scope": 3,
                        "term": "(le T24 T25 X33)"
                    },
                    {
                        "clause": 2,
                        "scope": 3,
                        "term": "(le T24 T25 X33)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T24",
                        "T25"
                    ],
                    "free": ["X33"],
                    "exprvars": []
                }
            },
            "378": {
                "goal": [{
                    "clause": 1,
                    "scope": 3,
                    "term": "(le T24 T25 X33)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T24",
                        "T25"
                    ],
                    "free": ["X33"],
                    "exprvars": []
                }
            },
            "236": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "379": {
                "goal": [{
                    "clause": 2,
                    "scope": 3,
                    "term": "(le T24 T25 X33)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T24",
                        "T25"
                    ],
                    "free": ["X33"],
                    "exprvars": []
                }
            },
            "237": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "239": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(le T24 T25 X33)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T24",
                        "T25"
                    ],
                    "free": ["X33"],
                    "exprvars": []
                }
            },
            "437": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(minus T66 T67 X84)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T66",
                        "T67"
                    ],
                    "free": ["X84"],
                    "exprvars": []
                }
            },
            "438": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(div T72 (s T67) T69)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T67",
                        "T72"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "439": {
                "goal": [
                    {
                        "clause": 3,
                        "scope": 5,
                        "term": "(minus T66 T67 X84)"
                    },
                    {
                        "clause": 4,
                        "scope": 5,
                        "term": "(minus T66 T67 X84)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T66",
                        "T67"
                    ],
                    "free": ["X84"],
                    "exprvars": []
                }
            },
            "240": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "384": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "363": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "385": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "243": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 3,
                        "term": "(le T24 T25 X33)"
                    },
                    {
                        "clause": 1,
                        "scope": 3,
                        "term": "(le T24 T25 X33)"
                    },
                    {
                        "clause": 2,
                        "scope": 3,
                        "term": "(le T24 T25 X33)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T24",
                        "T25"
                    ],
                    "free": ["X33"],
                    "exprvars": []
                }
            },
            "386": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "387": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(le T42 T43 X57)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T42",
                        "T43"
                    ],
                    "free": ["X57"],
                    "exprvars": []
                }
            },
            "420": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "442": {
                "goal": [{
                    "clause": 3,
                    "scope": 5,
                    "term": "(minus T66 T67 X84)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T66",
                        "T67"
                    ],
                    "free": ["X84"],
                    "exprvars": []
                }
            },
            "3": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(div T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "388": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "421": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "443": {
                "goal": [{
                    "clause": 4,
                    "scope": 5,
                    "term": "(minus T66 T67 X84)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T66",
                        "T67"
                    ],
                    "free": ["X84"],
                    "exprvars": []
                }
            },
            "4": {
                "goal": [{
                    "clause": 5,
                    "scope": 1,
                    "term": "(div T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "444": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "401": {
                "goal": [
                    {
                        "clause": 6,
                        "scope": 4,
                        "term": "(if T14 T10 (s T11) T13)"
                    },
                    {
                        "clause": 7,
                        "scope": 4,
                        "term": "(if T14 T10 (s T11) T13)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T10",
                        "T11",
                        "T14"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "423": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "445": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "347": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "402": {
                "goal": [{
                    "clause": 6,
                    "scope": 4,
                    "term": "(if T14 T10 (s T11) T13)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T10",
                        "T11",
                        "T14"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "446": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "403": {
                "goal": [{
                    "clause": 7,
                    "scope": 4,
                    "term": "(if T14 T10 (s T11) T13)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T10",
                        "T11",
                        "T14"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "425": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (minus T66 T67 X84) (div X84 (s T67) T69))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T66",
                        "T67"
                    ],
                    "free": ["X84"],
                    "exprvars": []
                }
            },
            "447": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(minus T84 T85 X105)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T84",
                        "T85"
                    ],
                    "free": ["X105"],
                    "exprvars": []
                }
            },
            "426": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "448": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "229": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(le (s T11) T10 X11)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T10",
                        "T11"
                    ],
                    "free": ["X11"],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 3,
                "to": 4,
                "label": "CASE"
            },
            {
                "from": 4,
                "to": 27,
                "label": "EVAL with clause\ndiv(X8, s(X9), X10) :- ','(le(s(X9), X8, X11), if(X11, X8, s(X9), X10)).\nand substitutionT1 -> T10,\nX8 -> T10,\nX9 -> T11,\nT2 -> s(T11),\nT3 -> T13,\nX10 -> T13,\nT12 -> T13"
            },
            {
                "from": 4,
                "to": 29,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 27,
                "to": 229,
                "label": "SPLIT 1"
            },
            {
                "from": 27,
                "to": 230,
                "label": "SPLIT 2\nnew knowledge:\nT11 is ground\nT10 is ground\nT14 is ground\nreplacements:X11 -> T14"
            },
            {
                "from": 229,
                "to": 231,
                "label": "CASE"
            },
            {
                "from": 230,
                "to": 401,
                "label": "CASE"
            },
            {
                "from": 231,
                "to": 232,
                "label": "BACKTRACK\nfor clause: le(0, Y, true)because of non-unification"
            },
            {
                "from": 232,
                "to": 233,
                "label": "PARALLEL"
            },
            {
                "from": 232,
                "to": 234,
                "label": "PARALLEL"
            },
            {
                "from": 233,
                "to": 235,
                "label": "EVAL with clause\nle(s(X21), 0, false).\nand substitutionT11 -> T19,\nX21 -> T19,\nT10 -> 0,\nX11 -> false"
            },
            {
                "from": 233,
                "to": 236,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 234,
                "to": 239,
                "label": "EVAL with clause\nle(s(X30), s(X31), X32) :- le(X30, X31, X32).\nand substitutionT11 -> T24,\nX30 -> T24,\nX31 -> T25,\nT10 -> s(T25),\nX11 -> X33,\nX32 -> X33"
            },
            {
                "from": 234,
                "to": 240,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 235,
                "to": 237,
                "label": "SUCCESS"
            },
            {
                "from": 239,
                "to": 243,
                "label": "CASE"
            },
            {
                "from": 243,
                "to": 256,
                "label": "PARALLEL"
            },
            {
                "from": 243,
                "to": 257,
                "label": "PARALLEL"
            },
            {
                "from": 256,
                "to": 347,
                "label": "EVAL with clause\nle(0, X40, true).\nand substitutionT24 -> 0,\nT25 -> T32,\nX40 -> T32,\nX33 -> true"
            },
            {
                "from": 256,
                "to": 355,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 257,
                "to": 378,
                "label": "PARALLEL"
            },
            {
                "from": 257,
                "to": 379,
                "label": "PARALLEL"
            },
            {
                "from": 347,
                "to": 363,
                "label": "SUCCESS"
            },
            {
                "from": 378,
                "to": 384,
                "label": "EVAL with clause\nle(s(X45), 0, false).\nand substitutionX45 -> T37,\nT24 -> s(T37),\nT25 -> 0,\nX33 -> false"
            },
            {
                "from": 378,
                "to": 385,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 379,
                "to": 387,
                "label": "EVAL with clause\nle(s(X54), s(X55), X56) :- le(X54, X55, X56).\nand substitutionX54 -> T42,\nT24 -> s(T42),\nX55 -> T43,\nT25 -> s(T43),\nX33 -> X57,\nX56 -> X57"
            },
            {
                "from": 379,
                "to": 388,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 384,
                "to": 386,
                "label": "SUCCESS"
            },
            {
                "from": 387,
                "to": 239,
                "label": "INSTANCE with matching:\nT24 -> T42\nT25 -> T43\nX33 -> X57"
            },
            {
                "from": 401,
                "to": 402,
                "label": "PARALLEL"
            },
            {
                "from": 401,
                "to": 403,
                "label": "PARALLEL"
            },
            {
                "from": 402,
                "to": 420,
                "label": "EVAL with clause\nif(false, X72, s(X73), 0).\nand substitutionT14 -> false,\nT10 -> T58,\nX72 -> T58,\nT11 -> T59,\nX73 -> T59,\nT13 -> 0"
            },
            {
                "from": 402,
                "to": 421,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 403,
                "to": 425,
                "label": "EVAL with clause\nif(true, X81, s(X82), s(X83)) :- ','(minus(X81, X82, X84), div(X84, s(X82), X83)).\nand substitutionT14 -> true,\nT10 -> T66,\nX81 -> T66,\nT11 -> T67,\nX82 -> T67,\nX83 -> T69,\nT13 -> s(T69),\nT68 -> T69"
            },
            {
                "from": 403,
                "to": 426,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 420,
                "to": 423,
                "label": "SUCCESS"
            },
            {
                "from": 425,
                "to": 437,
                "label": "SPLIT 1"
            },
            {
                "from": 425,
                "to": 438,
                "label": "SPLIT 2\nnew knowledge:\nT66 is ground\nT67 is ground\nT72 is ground\nreplacements:X84 -> T72"
            },
            {
                "from": 437,
                "to": 439,
                "label": "CASE"
            },
            {
                "from": 438,
                "to": 3,
                "label": "INSTANCE with matching:\nT1 -> T72\nT2 -> s(T67)\nT3 -> T69"
            },
            {
                "from": 439,
                "to": 442,
                "label": "PARALLEL"
            },
            {
                "from": 439,
                "to": 443,
                "label": "PARALLEL"
            },
            {
                "from": 442,
                "to": 444,
                "label": "EVAL with clause\nminus(X93, 0, X93).\nand substitutionT66 -> T79,\nX93 -> T79,\nT67 -> 0,\nX84 -> T79"
            },
            {
                "from": 442,
                "to": 445,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 443,
                "to": 447,
                "label": "EVAL with clause\nminus(s(X102), s(X103), X104) :- minus(X102, X103, X104).\nand substitutionX102 -> T84,\nT66 -> s(T84),\nX103 -> T85,\nT67 -> s(T85),\nX84 -> X105,\nX104 -> X105"
            },
            {
                "from": 443,
                "to": 448,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 444,
                "to": 446,
                "label": "SUCCESS"
            },
            {
                "from": 447,
                "to": 437,
                "label": "INSTANCE with matching:\nT66 -> T84\nT67 -> T85\nX84 -> X105"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(134)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f3_in(T10, s(T11)) -> U1(f27_in(T11, T10), T10, s(T11))
   U1(f27_out1(X11, T13), T10, s(T11)) -> f3_out1(T13)
   f239_in(0, T32) -> f239_out1(true)
   f239_in(s(T37), 0) -> f239_out1(false)
   f239_in(s(T42), s(T43)) -> U2(f239_in(T42, T43), s(T42), s(T43))
   U2(f239_out1(X57), s(T42), s(T43)) -> f239_out1(X57)
   f437_in(T79, 0) -> f437_out1(T79)
   f437_in(s(T84), s(T85)) -> U3(f437_in(T84, T85), s(T84), s(T85))
   U3(f437_out1(X105), s(T84), s(T85)) -> f437_out1(X105)
   f229_in(T19, 0) -> f229_out1(false)
   f229_in(T24, s(T25)) -> U4(f239_in(T24, T25), T24, s(T25))
   U4(f239_out1(X33), T24, s(T25)) -> f229_out1(X33)
   f230_in(false, T58, T59) -> f230_out1(0)
   f230_in(true, T66, T67) -> U5(f425_in(T66, T67), true, T66, T67)
   U5(f425_out1(X84, T69), true, T66, T67) -> f230_out1(s(T69))
   f27_in(T11, T10) -> U6(f229_in(T11, T10), T11, T10)
   U6(f229_out1(T14), T11, T10) -> U7(f230_in(T14, T10, T11), T11, T10, T14)
   U7(f230_out1(T13), T11, T10, T14) -> f27_out1(T14, T13)
   f425_in(T66, T67) -> U8(f437_in(T66, T67), T66, T67)
   U8(f437_out1(T72), T66, T67) -> U9(f3_in(T72, s(T67)), T66, T67, T72)
   U9(f3_out1(T69), T66, T67, T72) -> f425_out1(T72, T69)

Q is empty.

----------------------------------------

(135) Overlay + Local Confluence (EQUIVALENT)
The TRS is overlay and locally confluent. By [NOC] we can switch to innermost.
----------------------------------------

(136)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f3_in(T10, s(T11)) -> U1(f27_in(T11, T10), T10, s(T11))
   U1(f27_out1(X11, T13), T10, s(T11)) -> f3_out1(T13)
   f239_in(0, T32) -> f239_out1(true)
   f239_in(s(T37), 0) -> f239_out1(false)
   f239_in(s(T42), s(T43)) -> U2(f239_in(T42, T43), s(T42), s(T43))
   U2(f239_out1(X57), s(T42), s(T43)) -> f239_out1(X57)
   f437_in(T79, 0) -> f437_out1(T79)
   f437_in(s(T84), s(T85)) -> U3(f437_in(T84, T85), s(T84), s(T85))
   U3(f437_out1(X105), s(T84), s(T85)) -> f437_out1(X105)
   f229_in(T19, 0) -> f229_out1(false)
   f229_in(T24, s(T25)) -> U4(f239_in(T24, T25), T24, s(T25))
   U4(f239_out1(X33), T24, s(T25)) -> f229_out1(X33)
   f230_in(false, T58, T59) -> f230_out1(0)
   f230_in(true, T66, T67) -> U5(f425_in(T66, T67), true, T66, T67)
   U5(f425_out1(X84, T69), true, T66, T67) -> f230_out1(s(T69))
   f27_in(T11, T10) -> U6(f229_in(T11, T10), T11, T10)
   U6(f229_out1(T14), T11, T10) -> U7(f230_in(T14, T10, T11), T11, T10, T14)
   U7(f230_out1(T13), T11, T10, T14) -> f27_out1(T14, T13)
   f425_in(T66, T67) -> U8(f437_in(T66, T67), T66, T67)
   U8(f437_out1(T72), T66, T67) -> U9(f3_in(T72, s(T67)), T66, T67, T72)
   U9(f3_out1(T69), T66, T67, T72) -> f425_out1(T72, T69)

The set Q consists of the following terms:

   f3_in(x0, s(x1))
   U1(f27_out1(x0, x1), x2, s(x3))
   f239_in(0, x0)
   f239_in(s(x0), 0)
   f239_in(s(x0), s(x1))
   U2(f239_out1(x0), s(x1), s(x2))
   f437_in(x0, 0)
   f437_in(s(x0), s(x1))
   U3(f437_out1(x0), s(x1), s(x2))
   f229_in(x0, 0)
   f229_in(x0, s(x1))
   U4(f239_out1(x0), x1, s(x2))
   f230_in(false, x0, x1)
   f230_in(true, x0, x1)
   U5(f425_out1(x0, x1), true, x2, x3)
   f27_in(x0, x1)
   U6(f229_out1(x0), x1, x2)
   U7(f230_out1(x0), x1, x2, x3)
   f425_in(x0, x1)
   U8(f437_out1(x0), x1, x2)
   U9(f3_out1(x0), x1, x2, x3)


----------------------------------------

(137) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(138)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F3_IN(T10, s(T11)) -> U1^1(f27_in(T11, T10), T10, s(T11))
   F3_IN(T10, s(T11)) -> F27_IN(T11, T10)
   F239_IN(s(T42), s(T43)) -> U2^1(f239_in(T42, T43), s(T42), s(T43))
   F239_IN(s(T42), s(T43)) -> F239_IN(T42, T43)
   F437_IN(s(T84), s(T85)) -> U3^1(f437_in(T84, T85), s(T84), s(T85))
   F437_IN(s(T84), s(T85)) -> F437_IN(T84, T85)
   F229_IN(T24, s(T25)) -> U4^1(f239_in(T24, T25), T24, s(T25))
   F229_IN(T24, s(T25)) -> F239_IN(T24, T25)
   F230_IN(true, T66, T67) -> U5^1(f425_in(T66, T67), true, T66, T67)
   F230_IN(true, T66, T67) -> F425_IN(T66, T67)
   F27_IN(T11, T10) -> U6^1(f229_in(T11, T10), T11, T10)
   F27_IN(T11, T10) -> F229_IN(T11, T10)
   U6^1(f229_out1(T14), T11, T10) -> U7^1(f230_in(T14, T10, T11), T11, T10, T14)
   U6^1(f229_out1(T14), T11, T10) -> F230_IN(T14, T10, T11)
   F425_IN(T66, T67) -> U8^1(f437_in(T66, T67), T66, T67)
   F425_IN(T66, T67) -> F437_IN(T66, T67)
   U8^1(f437_out1(T72), T66, T67) -> U9^1(f3_in(T72, s(T67)), T66, T67, T72)
   U8^1(f437_out1(T72), T66, T67) -> F3_IN(T72, s(T67))

The TRS R consists of the following rules:

   f3_in(T10, s(T11)) -> U1(f27_in(T11, T10), T10, s(T11))
   U1(f27_out1(X11, T13), T10, s(T11)) -> f3_out1(T13)
   f239_in(0, T32) -> f239_out1(true)
   f239_in(s(T37), 0) -> f239_out1(false)
   f239_in(s(T42), s(T43)) -> U2(f239_in(T42, T43), s(T42), s(T43))
   U2(f239_out1(X57), s(T42), s(T43)) -> f239_out1(X57)
   f437_in(T79, 0) -> f437_out1(T79)
   f437_in(s(T84), s(T85)) -> U3(f437_in(T84, T85), s(T84), s(T85))
   U3(f437_out1(X105), s(T84), s(T85)) -> f437_out1(X105)
   f229_in(T19, 0) -> f229_out1(false)
   f229_in(T24, s(T25)) -> U4(f239_in(T24, T25), T24, s(T25))
   U4(f239_out1(X33), T24, s(T25)) -> f229_out1(X33)
   f230_in(false, T58, T59) -> f230_out1(0)
   f230_in(true, T66, T67) -> U5(f425_in(T66, T67), true, T66, T67)
   U5(f425_out1(X84, T69), true, T66, T67) -> f230_out1(s(T69))
   f27_in(T11, T10) -> U6(f229_in(T11, T10), T11, T10)
   U6(f229_out1(T14), T11, T10) -> U7(f230_in(T14, T10, T11), T11, T10, T14)
   U7(f230_out1(T13), T11, T10, T14) -> f27_out1(T14, T13)
   f425_in(T66, T67) -> U8(f437_in(T66, T67), T66, T67)
   U8(f437_out1(T72), T66, T67) -> U9(f3_in(T72, s(T67)), T66, T67, T72)
   U9(f3_out1(T69), T66, T67, T72) -> f425_out1(T72, T69)

The set Q consists of the following terms:

   f3_in(x0, s(x1))
   U1(f27_out1(x0, x1), x2, s(x3))
   f239_in(0, x0)
   f239_in(s(x0), 0)
   f239_in(s(x0), s(x1))
   U2(f239_out1(x0), s(x1), s(x2))
   f437_in(x0, 0)
   f437_in(s(x0), s(x1))
   U3(f437_out1(x0), s(x1), s(x2))
   f229_in(x0, 0)
   f229_in(x0, s(x1))
   U4(f239_out1(x0), x1, s(x2))
   f230_in(false, x0, x1)
   f230_in(true, x0, x1)
   U5(f425_out1(x0, x1), true, x2, x3)
   f27_in(x0, x1)
   U6(f229_out1(x0), x1, x2)
   U7(f230_out1(x0), x1, x2, x3)
   f425_in(x0, x1)
   U8(f437_out1(x0), x1, x2)
   U9(f3_out1(x0), x1, x2, x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(139) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 3 SCCs with 10 less nodes.
----------------------------------------

(140)
Complex Obligation (AND)

----------------------------------------

(141)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F437_IN(s(T84), s(T85)) -> F437_IN(T84, T85)

The TRS R consists of the following rules:

   f3_in(T10, s(T11)) -> U1(f27_in(T11, T10), T10, s(T11))
   U1(f27_out1(X11, T13), T10, s(T11)) -> f3_out1(T13)
   f239_in(0, T32) -> f239_out1(true)
   f239_in(s(T37), 0) -> f239_out1(false)
   f239_in(s(T42), s(T43)) -> U2(f239_in(T42, T43), s(T42), s(T43))
   U2(f239_out1(X57), s(T42), s(T43)) -> f239_out1(X57)
   f437_in(T79, 0) -> f437_out1(T79)
   f437_in(s(T84), s(T85)) -> U3(f437_in(T84, T85), s(T84), s(T85))
   U3(f437_out1(X105), s(T84), s(T85)) -> f437_out1(X105)
   f229_in(T19, 0) -> f229_out1(false)
   f229_in(T24, s(T25)) -> U4(f239_in(T24, T25), T24, s(T25))
   U4(f239_out1(X33), T24, s(T25)) -> f229_out1(X33)
   f230_in(false, T58, T59) -> f230_out1(0)
   f230_in(true, T66, T67) -> U5(f425_in(T66, T67), true, T66, T67)
   U5(f425_out1(X84, T69), true, T66, T67) -> f230_out1(s(T69))
   f27_in(T11, T10) -> U6(f229_in(T11, T10), T11, T10)
   U6(f229_out1(T14), T11, T10) -> U7(f230_in(T14, T10, T11), T11, T10, T14)
   U7(f230_out1(T13), T11, T10, T14) -> f27_out1(T14, T13)
   f425_in(T66, T67) -> U8(f437_in(T66, T67), T66, T67)
   U8(f437_out1(T72), T66, T67) -> U9(f3_in(T72, s(T67)), T66, T67, T72)
   U9(f3_out1(T69), T66, T67, T72) -> f425_out1(T72, T69)

The set Q consists of the following terms:

   f3_in(x0, s(x1))
   U1(f27_out1(x0, x1), x2, s(x3))
   f239_in(0, x0)
   f239_in(s(x0), 0)
   f239_in(s(x0), s(x1))
   U2(f239_out1(x0), s(x1), s(x2))
   f437_in(x0, 0)
   f437_in(s(x0), s(x1))
   U3(f437_out1(x0), s(x1), s(x2))
   f229_in(x0, 0)
   f229_in(x0, s(x1))
   U4(f239_out1(x0), x1, s(x2))
   f230_in(false, x0, x1)
   f230_in(true, x0, x1)
   U5(f425_out1(x0, x1), true, x2, x3)
   f27_in(x0, x1)
   U6(f229_out1(x0), x1, x2)
   U7(f230_out1(x0), x1, x2, x3)
   f425_in(x0, x1)
   U8(f437_out1(x0), x1, x2)
   U9(f3_out1(x0), x1, x2, x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(142) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(143)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F437_IN(s(T84), s(T85)) -> F437_IN(T84, T85)

R is empty.
The set Q consists of the following terms:

   f3_in(x0, s(x1))
   U1(f27_out1(x0, x1), x2, s(x3))
   f239_in(0, x0)
   f239_in(s(x0), 0)
   f239_in(s(x0), s(x1))
   U2(f239_out1(x0), s(x1), s(x2))
   f437_in(x0, 0)
   f437_in(s(x0), s(x1))
   U3(f437_out1(x0), s(x1), s(x2))
   f229_in(x0, 0)
   f229_in(x0, s(x1))
   U4(f239_out1(x0), x1, s(x2))
   f230_in(false, x0, x1)
   f230_in(true, x0, x1)
   U5(f425_out1(x0, x1), true, x2, x3)
   f27_in(x0, x1)
   U6(f229_out1(x0), x1, x2)
   U7(f230_out1(x0), x1, x2, x3)
   f425_in(x0, x1)
   U8(f437_out1(x0), x1, x2)
   U9(f3_out1(x0), x1, x2, x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(144) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   f3_in(x0, s(x1))
   U1(f27_out1(x0, x1), x2, s(x3))
   f239_in(0, x0)
   f239_in(s(x0), 0)
   f239_in(s(x0), s(x1))
   U2(f239_out1(x0), s(x1), s(x2))
   f437_in(x0, 0)
   f437_in(s(x0), s(x1))
   U3(f437_out1(x0), s(x1), s(x2))
   f229_in(x0, 0)
   f229_in(x0, s(x1))
   U4(f239_out1(x0), x1, s(x2))
   f230_in(false, x0, x1)
   f230_in(true, x0, x1)
   U5(f425_out1(x0, x1), true, x2, x3)
   f27_in(x0, x1)
   U6(f229_out1(x0), x1, x2)
   U7(f230_out1(x0), x1, x2, x3)
   f425_in(x0, x1)
   U8(f437_out1(x0), x1, x2)
   U9(f3_out1(x0), x1, x2, x3)


----------------------------------------

(145)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F437_IN(s(T84), s(T85)) -> F437_IN(T84, T85)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(146) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*F437_IN(s(T84), s(T85)) -> F437_IN(T84, T85)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(147)
YES

----------------------------------------

(148)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F239_IN(s(T42), s(T43)) -> F239_IN(T42, T43)

The TRS R consists of the following rules:

   f3_in(T10, s(T11)) -> U1(f27_in(T11, T10), T10, s(T11))
   U1(f27_out1(X11, T13), T10, s(T11)) -> f3_out1(T13)
   f239_in(0, T32) -> f239_out1(true)
   f239_in(s(T37), 0) -> f239_out1(false)
   f239_in(s(T42), s(T43)) -> U2(f239_in(T42, T43), s(T42), s(T43))
   U2(f239_out1(X57), s(T42), s(T43)) -> f239_out1(X57)
   f437_in(T79, 0) -> f437_out1(T79)
   f437_in(s(T84), s(T85)) -> U3(f437_in(T84, T85), s(T84), s(T85))
   U3(f437_out1(X105), s(T84), s(T85)) -> f437_out1(X105)
   f229_in(T19, 0) -> f229_out1(false)
   f229_in(T24, s(T25)) -> U4(f239_in(T24, T25), T24, s(T25))
   U4(f239_out1(X33), T24, s(T25)) -> f229_out1(X33)
   f230_in(false, T58, T59) -> f230_out1(0)
   f230_in(true, T66, T67) -> U5(f425_in(T66, T67), true, T66, T67)
   U5(f425_out1(X84, T69), true, T66, T67) -> f230_out1(s(T69))
   f27_in(T11, T10) -> U6(f229_in(T11, T10), T11, T10)
   U6(f229_out1(T14), T11, T10) -> U7(f230_in(T14, T10, T11), T11, T10, T14)
   U7(f230_out1(T13), T11, T10, T14) -> f27_out1(T14, T13)
   f425_in(T66, T67) -> U8(f437_in(T66, T67), T66, T67)
   U8(f437_out1(T72), T66, T67) -> U9(f3_in(T72, s(T67)), T66, T67, T72)
   U9(f3_out1(T69), T66, T67, T72) -> f425_out1(T72, T69)

The set Q consists of the following terms:

   f3_in(x0, s(x1))
   U1(f27_out1(x0, x1), x2, s(x3))
   f239_in(0, x0)
   f239_in(s(x0), 0)
   f239_in(s(x0), s(x1))
   U2(f239_out1(x0), s(x1), s(x2))
   f437_in(x0, 0)
   f437_in(s(x0), s(x1))
   U3(f437_out1(x0), s(x1), s(x2))
   f229_in(x0, 0)
   f229_in(x0, s(x1))
   U4(f239_out1(x0), x1, s(x2))
   f230_in(false, x0, x1)
   f230_in(true, x0, x1)
   U5(f425_out1(x0, x1), true, x2, x3)
   f27_in(x0, x1)
   U6(f229_out1(x0), x1, x2)
   U7(f230_out1(x0), x1, x2, x3)
   f425_in(x0, x1)
   U8(f437_out1(x0), x1, x2)
   U9(f3_out1(x0), x1, x2, x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(149) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(150)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F239_IN(s(T42), s(T43)) -> F239_IN(T42, T43)

R is empty.
The set Q consists of the following terms:

   f3_in(x0, s(x1))
   U1(f27_out1(x0, x1), x2, s(x3))
   f239_in(0, x0)
   f239_in(s(x0), 0)
   f239_in(s(x0), s(x1))
   U2(f239_out1(x0), s(x1), s(x2))
   f437_in(x0, 0)
   f437_in(s(x0), s(x1))
   U3(f437_out1(x0), s(x1), s(x2))
   f229_in(x0, 0)
   f229_in(x0, s(x1))
   U4(f239_out1(x0), x1, s(x2))
   f230_in(false, x0, x1)
   f230_in(true, x0, x1)
   U5(f425_out1(x0, x1), true, x2, x3)
   f27_in(x0, x1)
   U6(f229_out1(x0), x1, x2)
   U7(f230_out1(x0), x1, x2, x3)
   f425_in(x0, x1)
   U8(f437_out1(x0), x1, x2)
   U9(f3_out1(x0), x1, x2, x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(151) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   f3_in(x0, s(x1))
   U1(f27_out1(x0, x1), x2, s(x3))
   f239_in(0, x0)
   f239_in(s(x0), 0)
   f239_in(s(x0), s(x1))
   U2(f239_out1(x0), s(x1), s(x2))
   f437_in(x0, 0)
   f437_in(s(x0), s(x1))
   U3(f437_out1(x0), s(x1), s(x2))
   f229_in(x0, 0)
   f229_in(x0, s(x1))
   U4(f239_out1(x0), x1, s(x2))
   f230_in(false, x0, x1)
   f230_in(true, x0, x1)
   U5(f425_out1(x0, x1), true, x2, x3)
   f27_in(x0, x1)
   U6(f229_out1(x0), x1, x2)
   U7(f230_out1(x0), x1, x2, x3)
   f425_in(x0, x1)
   U8(f437_out1(x0), x1, x2)
   U9(f3_out1(x0), x1, x2, x3)


----------------------------------------

(152)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F239_IN(s(T42), s(T43)) -> F239_IN(T42, T43)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(153) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*F239_IN(s(T42), s(T43)) -> F239_IN(T42, T43)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(154)
YES

----------------------------------------

(155)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F3_IN(T10, s(T11)) -> F27_IN(T11, T10)
   F27_IN(T11, T10) -> U6^1(f229_in(T11, T10), T11, T10)
   U6^1(f229_out1(T14), T11, T10) -> F230_IN(T14, T10, T11)
   F230_IN(true, T66, T67) -> F425_IN(T66, T67)
   F425_IN(T66, T67) -> U8^1(f437_in(T66, T67), T66, T67)
   U8^1(f437_out1(T72), T66, T67) -> F3_IN(T72, s(T67))

The TRS R consists of the following rules:

   f3_in(T10, s(T11)) -> U1(f27_in(T11, T10), T10, s(T11))
   U1(f27_out1(X11, T13), T10, s(T11)) -> f3_out1(T13)
   f239_in(0, T32) -> f239_out1(true)
   f239_in(s(T37), 0) -> f239_out1(false)
   f239_in(s(T42), s(T43)) -> U2(f239_in(T42, T43), s(T42), s(T43))
   U2(f239_out1(X57), s(T42), s(T43)) -> f239_out1(X57)
   f437_in(T79, 0) -> f437_out1(T79)
   f437_in(s(T84), s(T85)) -> U3(f437_in(T84, T85), s(T84), s(T85))
   U3(f437_out1(X105), s(T84), s(T85)) -> f437_out1(X105)
   f229_in(T19, 0) -> f229_out1(false)
   f229_in(T24, s(T25)) -> U4(f239_in(T24, T25), T24, s(T25))
   U4(f239_out1(X33), T24, s(T25)) -> f229_out1(X33)
   f230_in(false, T58, T59) -> f230_out1(0)
   f230_in(true, T66, T67) -> U5(f425_in(T66, T67), true, T66, T67)
   U5(f425_out1(X84, T69), true, T66, T67) -> f230_out1(s(T69))
   f27_in(T11, T10) -> U6(f229_in(T11, T10), T11, T10)
   U6(f229_out1(T14), T11, T10) -> U7(f230_in(T14, T10, T11), T11, T10, T14)
   U7(f230_out1(T13), T11, T10, T14) -> f27_out1(T14, T13)
   f425_in(T66, T67) -> U8(f437_in(T66, T67), T66, T67)
   U8(f437_out1(T72), T66, T67) -> U9(f3_in(T72, s(T67)), T66, T67, T72)
   U9(f3_out1(T69), T66, T67, T72) -> f425_out1(T72, T69)

The set Q consists of the following terms:

   f3_in(x0, s(x1))
   U1(f27_out1(x0, x1), x2, s(x3))
   f239_in(0, x0)
   f239_in(s(x0), 0)
   f239_in(s(x0), s(x1))
   U2(f239_out1(x0), s(x1), s(x2))
   f437_in(x0, 0)
   f437_in(s(x0), s(x1))
   U3(f437_out1(x0), s(x1), s(x2))
   f229_in(x0, 0)
   f229_in(x0, s(x1))
   U4(f239_out1(x0), x1, s(x2))
   f230_in(false, x0, x1)
   f230_in(true, x0, x1)
   U5(f425_out1(x0, x1), true, x2, x3)
   f27_in(x0, x1)
   U6(f229_out1(x0), x1, x2)
   U7(f230_out1(x0), x1, x2, x3)
   f425_in(x0, x1)
   U8(f437_out1(x0), x1, x2)
   U9(f3_out1(x0), x1, x2, x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(156) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(157)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F3_IN(T10, s(T11)) -> F27_IN(T11, T10)
   F27_IN(T11, T10) -> U6^1(f229_in(T11, T10), T11, T10)
   U6^1(f229_out1(T14), T11, T10) -> F230_IN(T14, T10, T11)
   F230_IN(true, T66, T67) -> F425_IN(T66, T67)
   F425_IN(T66, T67) -> U8^1(f437_in(T66, T67), T66, T67)
   U8^1(f437_out1(T72), T66, T67) -> F3_IN(T72, s(T67))

The TRS R consists of the following rules:

   f437_in(T79, 0) -> f437_out1(T79)
   f437_in(s(T84), s(T85)) -> U3(f437_in(T84, T85), s(T84), s(T85))
   U3(f437_out1(X105), s(T84), s(T85)) -> f437_out1(X105)
   f229_in(T19, 0) -> f229_out1(false)
   f229_in(T24, s(T25)) -> U4(f239_in(T24, T25), T24, s(T25))
   f239_in(0, T32) -> f239_out1(true)
   f239_in(s(T37), 0) -> f239_out1(false)
   f239_in(s(T42), s(T43)) -> U2(f239_in(T42, T43), s(T42), s(T43))
   U4(f239_out1(X33), T24, s(T25)) -> f229_out1(X33)
   U2(f239_out1(X57), s(T42), s(T43)) -> f239_out1(X57)

The set Q consists of the following terms:

   f3_in(x0, s(x1))
   U1(f27_out1(x0, x1), x2, s(x3))
   f239_in(0, x0)
   f239_in(s(x0), 0)
   f239_in(s(x0), s(x1))
   U2(f239_out1(x0), s(x1), s(x2))
   f437_in(x0, 0)
   f437_in(s(x0), s(x1))
   U3(f437_out1(x0), s(x1), s(x2))
   f229_in(x0, 0)
   f229_in(x0, s(x1))
   U4(f239_out1(x0), x1, s(x2))
   f230_in(false, x0, x1)
   f230_in(true, x0, x1)
   U5(f425_out1(x0, x1), true, x2, x3)
   f27_in(x0, x1)
   U6(f229_out1(x0), x1, x2)
   U7(f230_out1(x0), x1, x2, x3)
   f425_in(x0, x1)
   U8(f437_out1(x0), x1, x2)
   U9(f3_out1(x0), x1, x2, x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(158) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   f3_in(x0, s(x1))
   U1(f27_out1(x0, x1), x2, s(x3))
   f230_in(false, x0, x1)
   f230_in(true, x0, x1)
   U5(f425_out1(x0, x1), true, x2, x3)
   f27_in(x0, x1)
   U6(f229_out1(x0), x1, x2)
   U7(f230_out1(x0), x1, x2, x3)
   f425_in(x0, x1)
   U8(f437_out1(x0), x1, x2)
   U9(f3_out1(x0), x1, x2, x3)


----------------------------------------

(159)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F3_IN(T10, s(T11)) -> F27_IN(T11, T10)
   F27_IN(T11, T10) -> U6^1(f229_in(T11, T10), T11, T10)
   U6^1(f229_out1(T14), T11, T10) -> F230_IN(T14, T10, T11)
   F230_IN(true, T66, T67) -> F425_IN(T66, T67)
   F425_IN(T66, T67) -> U8^1(f437_in(T66, T67), T66, T67)
   U8^1(f437_out1(T72), T66, T67) -> F3_IN(T72, s(T67))

The TRS R consists of the following rules:

   f437_in(T79, 0) -> f437_out1(T79)
   f437_in(s(T84), s(T85)) -> U3(f437_in(T84, T85), s(T84), s(T85))
   U3(f437_out1(X105), s(T84), s(T85)) -> f437_out1(X105)
   f229_in(T19, 0) -> f229_out1(false)
   f229_in(T24, s(T25)) -> U4(f239_in(T24, T25), T24, s(T25))
   f239_in(0, T32) -> f239_out1(true)
   f239_in(s(T37), 0) -> f239_out1(false)
   f239_in(s(T42), s(T43)) -> U2(f239_in(T42, T43), s(T42), s(T43))
   U4(f239_out1(X33), T24, s(T25)) -> f229_out1(X33)
   U2(f239_out1(X57), s(T42), s(T43)) -> f239_out1(X57)

The set Q consists of the following terms:

   f239_in(0, x0)
   f239_in(s(x0), 0)
   f239_in(s(x0), s(x1))
   U2(f239_out1(x0), s(x1), s(x2))
   f437_in(x0, 0)
   f437_in(s(x0), s(x1))
   U3(f437_out1(x0), s(x1), s(x2))
   f229_in(x0, 0)
   f229_in(x0, s(x1))
   U4(f239_out1(x0), x1, s(x2))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(160) MNOCProof (EQUIVALENT)
We use the modular non-overlap check [FROCOS05] to decrease Q to the empty set.
----------------------------------------

(161)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F3_IN(T10, s(T11)) -> F27_IN(T11, T10)
   F27_IN(T11, T10) -> U6^1(f229_in(T11, T10), T11, T10)
   U6^1(f229_out1(T14), T11, T10) -> F230_IN(T14, T10, T11)
   F230_IN(true, T66, T67) -> F425_IN(T66, T67)
   F425_IN(T66, T67) -> U8^1(f437_in(T66, T67), T66, T67)
   U8^1(f437_out1(T72), T66, T67) -> F3_IN(T72, s(T67))

The TRS R consists of the following rules:

   f437_in(T79, 0) -> f437_out1(T79)
   f437_in(s(T84), s(T85)) -> U3(f437_in(T84, T85), s(T84), s(T85))
   U3(f437_out1(X105), s(T84), s(T85)) -> f437_out1(X105)
   f229_in(T19, 0) -> f229_out1(false)
   f229_in(T24, s(T25)) -> U4(f239_in(T24, T25), T24, s(T25))
   f239_in(0, T32) -> f239_out1(true)
   f239_in(s(T37), 0) -> f239_out1(false)
   f239_in(s(T42), s(T43)) -> U2(f239_in(T42, T43), s(T42), s(T43))
   U4(f239_out1(X33), T24, s(T25)) -> f229_out1(X33)
   U2(f239_out1(X57), s(T42), s(T43)) -> f239_out1(X57)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(162) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = F27_IN(0, s(T25')) evaluates to  t =F27_IN(0, s(T25'))

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

F27_IN(0, s(T25')) -> U6^1(f229_in(0, s(T25')), 0, s(T25'))
with rule F27_IN(T11, T10') -> U6^1(f229_in(T11, T10'), T11, T10') at position [] and matcher [T11 / 0, T10' / s(T25')]

U6^1(f229_in(0, s(T25')), 0, s(T25')) -> U6^1(U4(f239_in(0, T25'), 0, s(T25')), 0, s(T25'))
with rule f229_in(T24', s(T25'')) -> U4(f239_in(T24', T25''), T24', s(T25'')) at position [0] and matcher [T24' / 0, T25'' / T25']

U6^1(U4(f239_in(0, T25'), 0, s(T25')), 0, s(T25')) -> U6^1(U4(f239_out1(true), 0, s(T25')), 0, s(T25'))
with rule f239_in(0, T32) -> f239_out1(true) at position [0,0] and matcher [T32 / T25']

U6^1(U4(f239_out1(true), 0, s(T25')), 0, s(T25')) -> U6^1(f229_out1(true), 0, s(T25'))
with rule U4(f239_out1(X33), T24, s(T25)) -> f229_out1(X33) at position [0] and matcher [X33 / true, T24 / 0, T25 / T25']

U6^1(f229_out1(true), 0, s(T25')) -> F230_IN(true, s(T25'), 0)
with rule U6^1(f229_out1(T14), T11, T10) -> F230_IN(T14, T10, T11) at position [] and matcher [T14 / true, T11 / 0, T10 / s(T25')]

F230_IN(true, s(T25'), 0) -> F425_IN(s(T25'), 0)
with rule F230_IN(true, T66, T67) -> F425_IN(T66, T67) at position [] and matcher [T66 / s(T25'), T67 / 0]

F425_IN(s(T25'), 0) -> U8^1(f437_in(s(T25'), 0), s(T25'), 0)
with rule F425_IN(T66', T67') -> U8^1(f437_in(T66', T67'), T66', T67') at position [] and matcher [T66' / s(T25'), T67' / 0]

U8^1(f437_in(s(T25'), 0), s(T25'), 0) -> U8^1(f437_out1(s(T25')), s(T25'), 0)
with rule f437_in(T79, 0) -> f437_out1(T79) at position [0] and matcher [T79 / s(T25')]

U8^1(f437_out1(s(T25')), s(T25'), 0) -> F3_IN(s(T25'), s(0))
with rule U8^1(f437_out1(T72), T66, T67) -> F3_IN(T72, s(T67)) at position [] and matcher [T72 / s(T25'), T66 / s(T25'), T67 / 0]

F3_IN(s(T25'), s(0)) -> F27_IN(0, s(T25'))
with rule F3_IN(T10, s(T11)) -> F27_IN(T11, T10)

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(163)
NO

----------------------------------------

(164) PrologToDTProblemTransformerProof (SOUND)
Built DT problem from termination graph DT10.

{
    "root": 2,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(le (0) Y (true))",
                null
            ],
            [
                "(le (s X) (0) (false))",
                null
            ],
            [
                "(le (s X) (s Y) B)",
                "(le X Y B)"
            ],
            [
                "(minus X (0) X)",
                null
            ],
            [
                "(minus (s X) (s Y) Z)",
                "(minus X Y Z)"
            ],
            [
                "(div X (s Y) Z)",
                "(',' (le (s Y) X B) (if B X (s Y) Z))"
            ],
            [
                "(if (false) X (s Y) (0))",
                null
            ],
            [
                "(if (true) X (s Y) (s Z))",
                "(',' (minus X Y U) (div U (s Y) Z))"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "44": {
                "goal": [{
                    "clause": 6,
                    "scope": 3,
                    "term": "(if (false) (0) (s T15) T10)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T15"],
                    "free": [],
                    "exprvars": []
                }
            },
            "45": {
                "goal": [{
                    "clause": 7,
                    "scope": 3,
                    "term": "(if (false) (0) (s T15) T10)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T15"],
                    "free": [],
                    "exprvars": []
                }
            },
            "49": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "194": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "195": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "196": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "430": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "50": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "51": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "52": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "56": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (le T27 T28 X42) (if X42 (s T28) (s T27) T10))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T27",
                        "T28"
                    ],
                    "free": ["X42"],
                    "exprvars": []
                }
            },
            "57": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "2": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(div T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "5": {
                "goal": [{
                    "clause": 5,
                    "scope": 1,
                    "term": "(div T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "129": {
                "goal": [{
                    "clause": 1,
                    "scope": 4,
                    "term": "(le T27 T28 X42)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T27",
                        "T28"
                    ],
                    "free": ["X42"],
                    "exprvars": []
                }
            },
            "404": {
                "goal": [
                    {
                        "clause": 6,
                        "scope": 5,
                        "term": "(if T31 (s T28) (s T27) T10)"
                    },
                    {
                        "clause": 7,
                        "scope": 5,
                        "term": "(if T31 (s T28) (s T27) T10)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T27",
                        "T28",
                        "T31"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "405": {
                "goal": [{
                    "clause": 6,
                    "scope": 5,
                    "term": "(if T31 (s T28) (s T27) T10)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T27",
                        "T28",
                        "T31"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "449": {
                "goal": [
                    {
                        "clause": 3,
                        "scope": 7,
                        "term": "(minus T90 T91 X116)"
                    },
                    {
                        "clause": 4,
                        "scope": 7,
                        "term": "(minus T90 T91 X116)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T90",
                        "T91"
                    ],
                    "free": ["X116"],
                    "exprvars": []
                }
            },
            "60": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(le T27 T28 X42)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T27",
                        "T28"
                    ],
                    "free": ["X42"],
                    "exprvars": []
                }
            },
            "406": {
                "goal": [{
                    "clause": 7,
                    "scope": 5,
                    "term": "(if T31 (s T28) (s T27) T10)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T27",
                        "T28",
                        "T31"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "407": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "62": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(if T31 (s T28) (s T27) T10)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T27",
                        "T28",
                        "T31"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "408": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "409": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "25": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (le (s T8) T7 X7) (if X7 T7 (s T8) T10))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T7",
                        "T8"
                    ],
                    "free": ["X7"],
                    "exprvars": []
                }
            },
            "26": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "28": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 2,
                        "term": "(',' (le (s T8) T7 X7) (if X7 T7 (s T8) T10))"
                    },
                    {
                        "clause": 1,
                        "scope": 2,
                        "term": "(',' (le (s T8) T7 X7) (if X7 T7 (s T8) T10))"
                    },
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(',' (le (s T8) T7 X7) (if X7 T7 (s T8) T10))"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T7",
                        "T8"
                    ],
                    "free": ["X7"],
                    "exprvars": []
                }
            },
            "130": {
                "goal": [{
                    "clause": 2,
                    "scope": 4,
                    "term": "(le T27 T28 X42)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T27",
                        "T28"
                    ],
                    "free": ["X42"],
                    "exprvars": []
                }
            },
            "450": {
                "goal": [{
                    "clause": 3,
                    "scope": 7,
                    "term": "(minus T90 T91 X116)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T90",
                        "T91"
                    ],
                    "free": ["X116"],
                    "exprvars": []
                }
            },
            "451": {
                "goal": [{
                    "clause": 4,
                    "scope": 7,
                    "term": "(minus T90 T91 X116)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T90",
                        "T91"
                    ],
                    "free": ["X116"],
                    "exprvars": []
                }
            },
            "452": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "453": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "410": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (minus (s T72) T73 X95) (div X95 (s T73) T75))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T72",
                        "T73"
                    ],
                    "free": ["X95"],
                    "exprvars": []
                }
            },
            "454": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "411": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "455": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(minus T103 T104 X135)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T103",
                        "T104"
                    ],
                    "free": ["X135"],
                    "exprvars": []
                }
            },
            "412": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(minus (s T72) T73 X95)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T72",
                        "T73"
                    ],
                    "free": ["X95"],
                    "exprvars": []
                }
            },
            "456": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "413": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(div T78 (s T73) T75)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T73",
                        "T78"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "414": {
                "goal": [
                    {
                        "clause": 3,
                        "scope": 6,
                        "term": "(minus (s T72) T73 X95)"
                    },
                    {
                        "clause": 4,
                        "scope": 6,
                        "term": "(minus (s T72) T73 X95)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T72",
                        "T73"
                    ],
                    "free": ["X95"],
                    "exprvars": []
                }
            },
            "415": {
                "goal": [{
                    "clause": 3,
                    "scope": 6,
                    "term": "(minus (s T72) T73 X95)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T72",
                        "T73"
                    ],
                    "free": ["X95"],
                    "exprvars": []
                }
            },
            "416": {
                "goal": [{
                    "clause": 4,
                    "scope": 6,
                    "term": "(minus (s T72) T73 X95)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T72",
                        "T73"
                    ],
                    "free": ["X95"],
                    "exprvars": []
                }
            },
            "417": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "418": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "419": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "30": {
                "goal": [
                    {
                        "clause": 1,
                        "scope": 2,
                        "term": "(',' (le (s T8) T7 X7) (if X7 T7 (s T8) T10))"
                    },
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(',' (le (s T8) T7 X7) (if X7 T7 (s T8) T10))"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T7",
                        "T8"
                    ],
                    "free": ["X7"],
                    "exprvars": []
                }
            },
            "75": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 4,
                        "term": "(le T27 T28 X42)"
                    },
                    {
                        "clause": 1,
                        "scope": 4,
                        "term": "(le T27 T28 X42)"
                    },
                    {
                        "clause": 2,
                        "scope": 4,
                        "term": "(le T27 T28 X42)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T27",
                        "T28"
                    ],
                    "free": ["X42"],
                    "exprvars": []
                }
            },
            "76": {
                "goal": [{
                    "clause": 0,
                    "scope": 4,
                    "term": "(le T27 T28 X42)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T27",
                        "T28"
                    ],
                    "free": ["X42"],
                    "exprvars": []
                }
            },
            "33": {
                "goal": [{
                    "clause": 1,
                    "scope": 2,
                    "term": "(',' (le (s T8) T7 X7) (if X7 T7 (s T8) T10))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T7",
                        "T8"
                    ],
                    "free": ["X7"],
                    "exprvars": []
                }
            },
            "77": {
                "goal": [
                    {
                        "clause": 1,
                        "scope": 4,
                        "term": "(le T27 T28 X42)"
                    },
                    {
                        "clause": 2,
                        "scope": 4,
                        "term": "(le T27 T28 X42)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T27",
                        "T28"
                    ],
                    "free": ["X42"],
                    "exprvars": []
                }
            },
            "34": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(',' (le (s T8) T7 X7) (if X7 T7 (s T8) T10))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T7",
                        "T8"
                    ],
                    "free": ["X7"],
                    "exprvars": []
                }
            },
            "37": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(if (false) (0) (s T15) T10)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T15"],
                    "free": [],
                    "exprvars": []
                }
            },
            "38": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "227": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(le T48 T49 X68)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T48",
                        "T49"
                    ],
                    "free": ["X68"],
                    "exprvars": []
                }
            },
            "80": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "228": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "81": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "82": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "429": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(minus T90 T91 X116)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T90",
                        "T91"
                    ],
                    "free": ["X116"],
                    "exprvars": []
                }
            },
            "41": {
                "goal": [
                    {
                        "clause": 6,
                        "scope": 3,
                        "term": "(if (false) (0) (s T15) T10)"
                    },
                    {
                        "clause": 7,
                        "scope": 3,
                        "term": "(if (false) (0) (s T15) T10)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T15"],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 2,
                "to": 5,
                "label": "CASE"
            },
            {
                "from": 5,
                "to": 25,
                "label": "EVAL with clause\ndiv(X4, s(X5), X6) :- ','(le(s(X5), X4, X7), if(X7, X4, s(X5), X6)).\nand substitutionT1 -> T7,\nX4 -> T7,\nX5 -> T8,\nT2 -> s(T8),\nT3 -> T10,\nX6 -> T10,\nT9 -> T10"
            },
            {
                "from": 5,
                "to": 26,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 25,
                "to": 28,
                "label": "CASE"
            },
            {
                "from": 28,
                "to": 30,
                "label": "BACKTRACK\nfor clause: le(0, Y, true)because of non-unification"
            },
            {
                "from": 30,
                "to": 33,
                "label": "PARALLEL"
            },
            {
                "from": 30,
                "to": 34,
                "label": "PARALLEL"
            },
            {
                "from": 33,
                "to": 37,
                "label": "EVAL with clause\nle(s(X13), 0, false).\nand substitutionT8 -> T15,\nX13 -> T15,\nT7 -> 0,\nX7 -> false"
            },
            {
                "from": 33,
                "to": 38,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 34,
                "to": 56,
                "label": "EVAL with clause\nle(s(X39), s(X40), X41) :- le(X39, X40, X41).\nand substitutionT8 -> T27,\nX39 -> T27,\nX40 -> T28,\nT7 -> s(T28),\nX7 -> X42,\nX41 -> X42"
            },
            {
                "from": 34,
                "to": 57,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 37,
                "to": 41,
                "label": "CASE"
            },
            {
                "from": 41,
                "to": 44,
                "label": "PARALLEL"
            },
            {
                "from": 41,
                "to": 45,
                "label": "PARALLEL"
            },
            {
                "from": 44,
                "to": 49,
                "label": "EVAL with clause\nif(false, X26, s(X27), 0).\nand substitutionX26 -> 0,\nT15 -> T22,\nX27 -> T22,\nT10 -> 0"
            },
            {
                "from": 44,
                "to": 50,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 45,
                "to": 52,
                "label": "BACKTRACK\nfor clause: if(true, X, s(Y), s(Z)) :- ','(minus(X, Y, U), div(U, s(Y), Z))because of non-unification"
            },
            {
                "from": 49,
                "to": 51,
                "label": "SUCCESS"
            },
            {
                "from": 56,
                "to": 60,
                "label": "SPLIT 1"
            },
            {
                "from": 56,
                "to": 62,
                "label": "SPLIT 2\nnew knowledge:\nT27 is ground\nT28 is ground\nT31 is ground\nreplacements:X42 -> T31"
            },
            {
                "from": 60,
                "to": 75,
                "label": "CASE"
            },
            {
                "from": 62,
                "to": 404,
                "label": "CASE"
            },
            {
                "from": 75,
                "to": 76,
                "label": "PARALLEL"
            },
            {
                "from": 75,
                "to": 77,
                "label": "PARALLEL"
            },
            {
                "from": 76,
                "to": 80,
                "label": "EVAL with clause\nle(0, X51, true).\nand substitutionT27 -> 0,\nT28 -> T38,\nX51 -> T38,\nX42 -> true"
            },
            {
                "from": 76,
                "to": 81,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 77,
                "to": 129,
                "label": "PARALLEL"
            },
            {
                "from": 77,
                "to": 130,
                "label": "PARALLEL"
            },
            {
                "from": 80,
                "to": 82,
                "label": "SUCCESS"
            },
            {
                "from": 129,
                "to": 194,
                "label": "EVAL with clause\nle(s(X56), 0, false).\nand substitutionX56 -> T43,\nT27 -> s(T43),\nT28 -> 0,\nX42 -> false"
            },
            {
                "from": 129,
                "to": 195,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 130,
                "to": 227,
                "label": "EVAL with clause\nle(s(X65), s(X66), X67) :- le(X65, X66, X67).\nand substitutionX65 -> T48,\nT27 -> s(T48),\nX66 -> T49,\nT28 -> s(T49),\nX42 -> X68,\nX67 -> X68"
            },
            {
                "from": 130,
                "to": 228,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 194,
                "to": 196,
                "label": "SUCCESS"
            },
            {
                "from": 227,
                "to": 60,
                "label": "INSTANCE with matching:\nT27 -> T48\nT28 -> T49\nX42 -> X68"
            },
            {
                "from": 404,
                "to": 405,
                "label": "PARALLEL"
            },
            {
                "from": 404,
                "to": 406,
                "label": "PARALLEL"
            },
            {
                "from": 405,
                "to": 407,
                "label": "EVAL with clause\nif(false, X83, s(X84), 0).\nand substitutionT31 -> false,\nT28 -> T64,\nX83 -> s(T64),\nT27 -> T65,\nX84 -> T65,\nT10 -> 0"
            },
            {
                "from": 405,
                "to": 408,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 406,
                "to": 410,
                "label": "EVAL with clause\nif(true, X92, s(X93), s(X94)) :- ','(minus(X92, X93, X95), div(X95, s(X93), X94)).\nand substitutionT31 -> true,\nT28 -> T72,\nX92 -> s(T72),\nT27 -> T73,\nX93 -> T73,\nX94 -> T75,\nT10 -> s(T75),\nT74 -> T75"
            },
            {
                "from": 406,
                "to": 411,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 407,
                "to": 409,
                "label": "SUCCESS"
            },
            {
                "from": 410,
                "to": 412,
                "label": "SPLIT 1"
            },
            {
                "from": 410,
                "to": 413,
                "label": "SPLIT 2\nnew knowledge:\nT72 is ground\nT73 is ground\nT78 is ground\nreplacements:X95 -> T78"
            },
            {
                "from": 412,
                "to": 414,
                "label": "CASE"
            },
            {
                "from": 413,
                "to": 2,
                "label": "INSTANCE with matching:\nT1 -> T78\nT2 -> s(T73)\nT3 -> T75"
            },
            {
                "from": 414,
                "to": 415,
                "label": "PARALLEL"
            },
            {
                "from": 414,
                "to": 416,
                "label": "PARALLEL"
            },
            {
                "from": 415,
                "to": 417,
                "label": "EVAL with clause\nminus(X104, 0, X104).\nand substitutionT72 -> T85,\nX104 -> s(T85),\nT73 -> 0,\nX95 -> s(T85)"
            },
            {
                "from": 415,
                "to": 418,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 416,
                "to": 429,
                "label": "EVAL with clause\nminus(s(X113), s(X114), X115) :- minus(X113, X114, X115).\nand substitutionT72 -> T90,\nX113 -> T90,\nX114 -> T91,\nT73 -> s(T91),\nX95 -> X116,\nX115 -> X116"
            },
            {
                "from": 416,
                "to": 430,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 417,
                "to": 419,
                "label": "SUCCESS"
            },
            {
                "from": 429,
                "to": 449,
                "label": "CASE"
            },
            {
                "from": 449,
                "to": 450,
                "label": "PARALLEL"
            },
            {
                "from": 449,
                "to": 451,
                "label": "PARALLEL"
            },
            {
                "from": 450,
                "to": 452,
                "label": "EVAL with clause\nminus(X123, 0, X123).\nand substitutionT90 -> T98,\nX123 -> T98,\nT91 -> 0,\nX116 -> T98"
            },
            {
                "from": 450,
                "to": 453,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 451,
                "to": 455,
                "label": "EVAL with clause\nminus(s(X132), s(X133), X134) :- minus(X132, X133, X134).\nand substitutionX132 -> T103,\nT90 -> s(T103),\nX133 -> T104,\nT91 -> s(T104),\nX116 -> X135,\nX134 -> X135"
            },
            {
                "from": 451,
                "to": 456,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 452,
                "to": 454,
                "label": "SUCCESS"
            },
            {
                "from": 455,
                "to": 429,
                "label": "INSTANCE with matching:\nT90 -> T103\nT91 -> T104\nX116 -> X135"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(165)
Obligation:
Triples:

leA(s(X1), s(X2), X3) :- leA(X1, X2, X3).
minusD(s(X1), s(X2), X3) :- minusD(X1, X2, X3).
divB(s(X1), s(X2), X3) :- leA(X2, X1, X4).
divB(s(X1), s(s(X2)), s(X3)) :- ','(lecA(s(X2), X1, true), minusD(X1, X2, X4)).
divB(s(X1), s(X2), s(X3)) :- ','(lecA(X2, X1, true), ','(minuscC(X1, X2, X4), divB(X4, s(X2), X3))).

Clauses:

lecA(0, X1, true).
lecA(s(X1), 0, false).
lecA(s(X1), s(X2), X3) :- lecA(X1, X2, X3).
divcB(0, s(X1), 0).
divcB(s(X1), s(X2), 0) :- lecA(X2, X1, false).
divcB(s(X1), s(X2), s(X3)) :- ','(lecA(X2, X1, true), ','(minuscC(X1, X2, X4), divcB(X4, s(X2), X3))).
minuscD(X1, 0, X1).
minuscD(s(X1), s(X2), X3) :- minuscD(X1, X2, X3).
minuscC(X1, 0, s(X1)).
minuscC(X1, s(X2), X3) :- minuscD(X1, X2, X3).

Afs:

divB(x1, x2, x3)  =  divB(x1, x2)


----------------------------------------

(166) TriplesToPiDPProof (SOUND)
We use the technique of [DT09]. With regard to the inferred argument filtering the predicates were used in the following modes:

divB_in_3: (b,b,f)

leA_in_3: (b,b,f)

lecA_in_3: (b,b,b)

minusD_in_3: (b,b,f)

minuscC_in_3: (b,b,f)

minuscD_in_3: (b,b,f)

Transforming TRIPLES into the following Term Rewriting System:

Pi DP problem:
The TRS P consists of the following rules:

   DIVB_IN_GGA(s(X1), s(X2), X3) -> U3_GGA(X1, X2, X3, leA_in_gga(X2, X1, X4))
   DIVB_IN_GGA(s(X1), s(X2), X3) -> LEA_IN_GGA(X2, X1, X4)
   LEA_IN_GGA(s(X1), s(X2), X3) -> U1_GGA(X1, X2, X3, leA_in_gga(X1, X2, X3))
   LEA_IN_GGA(s(X1), s(X2), X3) -> LEA_IN_GGA(X1, X2, X3)
   DIVB_IN_GGA(s(X1), s(s(X2)), s(X3)) -> U4_GGA(X1, X2, X3, lecA_in_ggg(s(X2), X1, true))
   U4_GGA(X1, X2, X3, lecA_out_ggg(s(X2), X1, true)) -> U5_GGA(X1, X2, X3, minusD_in_gga(X1, X2, X4))
   U4_GGA(X1, X2, X3, lecA_out_ggg(s(X2), X1, true)) -> MINUSD_IN_GGA(X1, X2, X4)
   MINUSD_IN_GGA(s(X1), s(X2), X3) -> U2_GGA(X1, X2, X3, minusD_in_gga(X1, X2, X3))
   MINUSD_IN_GGA(s(X1), s(X2), X3) -> MINUSD_IN_GGA(X1, X2, X3)
   DIVB_IN_GGA(s(X1), s(X2), s(X3)) -> U6_GGA(X1, X2, X3, lecA_in_ggg(X2, X1, true))
   U6_GGA(X1, X2, X3, lecA_out_ggg(X2, X1, true)) -> U7_GGA(X1, X2, X3, minuscC_in_gga(X1, X2, X4))
   U7_GGA(X1, X2, X3, minuscC_out_gga(X1, X2, X4)) -> U8_GGA(X1, X2, X3, divB_in_gga(X4, s(X2), X3))
   U7_GGA(X1, X2, X3, minuscC_out_gga(X1, X2, X4)) -> DIVB_IN_GGA(X4, s(X2), X3)

The TRS R consists of the following rules:

   lecA_in_ggg(0, X1, true) -> lecA_out_ggg(0, X1, true)
   lecA_in_ggg(s(X1), 0, false) -> lecA_out_ggg(s(X1), 0, false)
   lecA_in_ggg(s(X1), s(X2), X3) -> U10_ggg(X1, X2, X3, lecA_in_ggg(X1, X2, X3))
   U10_ggg(X1, X2, X3, lecA_out_ggg(X1, X2, X3)) -> lecA_out_ggg(s(X1), s(X2), X3)
   minuscC_in_gga(X1, 0, s(X1)) -> minuscC_out_gga(X1, 0, s(X1))
   minuscC_in_gga(X1, s(X2), X3) -> U16_gga(X1, X2, X3, minuscD_in_gga(X1, X2, X3))
   minuscD_in_gga(X1, 0, X1) -> minuscD_out_gga(X1, 0, X1)
   minuscD_in_gga(s(X1), s(X2), X3) -> U15_gga(X1, X2, X3, minuscD_in_gga(X1, X2, X3))
   U15_gga(X1, X2, X3, minuscD_out_gga(X1, X2, X3)) -> minuscD_out_gga(s(X1), s(X2), X3)
   U16_gga(X1, X2, X3, minuscD_out_gga(X1, X2, X3)) -> minuscC_out_gga(X1, s(X2), X3)

The argument filtering Pi contains the following mapping:
divB_in_gga(x1, x2, x3)  =  divB_in_gga(x1, x2)

s(x1)  =  s(x1)

leA_in_gga(x1, x2, x3)  =  leA_in_gga(x1, x2)

lecA_in_ggg(x1, x2, x3)  =  lecA_in_ggg(x1, x2, x3)

0  =  0

true  =  true

lecA_out_ggg(x1, x2, x3)  =  lecA_out_ggg(x1, x2, x3)

false  =  false

U10_ggg(x1, x2, x3, x4)  =  U10_ggg(x1, x2, x3, x4)

minusD_in_gga(x1, x2, x3)  =  minusD_in_gga(x1, x2)

minuscC_in_gga(x1, x2, x3)  =  minuscC_in_gga(x1, x2)

minuscC_out_gga(x1, x2, x3)  =  minuscC_out_gga(x1, x2, x3)

U16_gga(x1, x2, x3, x4)  =  U16_gga(x1, x2, x4)

minuscD_in_gga(x1, x2, x3)  =  minuscD_in_gga(x1, x2)

minuscD_out_gga(x1, x2, x3)  =  minuscD_out_gga(x1, x2, x3)

U15_gga(x1, x2, x3, x4)  =  U15_gga(x1, x2, x4)

DIVB_IN_GGA(x1, x2, x3)  =  DIVB_IN_GGA(x1, x2)

U3_GGA(x1, x2, x3, x4)  =  U3_GGA(x1, x2, x4)

LEA_IN_GGA(x1, x2, x3)  =  LEA_IN_GGA(x1, x2)

U1_GGA(x1, x2, x3, x4)  =  U1_GGA(x1, x2, x4)

U4_GGA(x1, x2, x3, x4)  =  U4_GGA(x1, x2, x4)

U5_GGA(x1, x2, x3, x4)  =  U5_GGA(x1, x2, x4)

MINUSD_IN_GGA(x1, x2, x3)  =  MINUSD_IN_GGA(x1, x2)

U2_GGA(x1, x2, x3, x4)  =  U2_GGA(x1, x2, x4)

U6_GGA(x1, x2, x3, x4)  =  U6_GGA(x1, x2, x4)

U7_GGA(x1, x2, x3, x4)  =  U7_GGA(x1, x2, x4)

U8_GGA(x1, x2, x3, x4)  =  U8_GGA(x1, x2, x4)


We have to consider all (P,R,Pi)-chains


Infinitary Constructor Rewriting Termination of PiDP implies Termination of TRIPLES



----------------------------------------

(167)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   DIVB_IN_GGA(s(X1), s(X2), X3) -> U3_GGA(X1, X2, X3, leA_in_gga(X2, X1, X4))
   DIVB_IN_GGA(s(X1), s(X2), X3) -> LEA_IN_GGA(X2, X1, X4)
   LEA_IN_GGA(s(X1), s(X2), X3) -> U1_GGA(X1, X2, X3, leA_in_gga(X1, X2, X3))
   LEA_IN_GGA(s(X1), s(X2), X3) -> LEA_IN_GGA(X1, X2, X3)
   DIVB_IN_GGA(s(X1), s(s(X2)), s(X3)) -> U4_GGA(X1, X2, X3, lecA_in_ggg(s(X2), X1, true))
   U4_GGA(X1, X2, X3, lecA_out_ggg(s(X2), X1, true)) -> U5_GGA(X1, X2, X3, minusD_in_gga(X1, X2, X4))
   U4_GGA(X1, X2, X3, lecA_out_ggg(s(X2), X1, true)) -> MINUSD_IN_GGA(X1, X2, X4)
   MINUSD_IN_GGA(s(X1), s(X2), X3) -> U2_GGA(X1, X2, X3, minusD_in_gga(X1, X2, X3))
   MINUSD_IN_GGA(s(X1), s(X2), X3) -> MINUSD_IN_GGA(X1, X2, X3)
   DIVB_IN_GGA(s(X1), s(X2), s(X3)) -> U6_GGA(X1, X2, X3, lecA_in_ggg(X2, X1, true))
   U6_GGA(X1, X2, X3, lecA_out_ggg(X2, X1, true)) -> U7_GGA(X1, X2, X3, minuscC_in_gga(X1, X2, X4))
   U7_GGA(X1, X2, X3, minuscC_out_gga(X1, X2, X4)) -> U8_GGA(X1, X2, X3, divB_in_gga(X4, s(X2), X3))
   U7_GGA(X1, X2, X3, minuscC_out_gga(X1, X2, X4)) -> DIVB_IN_GGA(X4, s(X2), X3)

The TRS R consists of the following rules:

   lecA_in_ggg(0, X1, true) -> lecA_out_ggg(0, X1, true)
   lecA_in_ggg(s(X1), 0, false) -> lecA_out_ggg(s(X1), 0, false)
   lecA_in_ggg(s(X1), s(X2), X3) -> U10_ggg(X1, X2, X3, lecA_in_ggg(X1, X2, X3))
   U10_ggg(X1, X2, X3, lecA_out_ggg(X1, X2, X3)) -> lecA_out_ggg(s(X1), s(X2), X3)
   minuscC_in_gga(X1, 0, s(X1)) -> minuscC_out_gga(X1, 0, s(X1))
   minuscC_in_gga(X1, s(X2), X3) -> U16_gga(X1, X2, X3, minuscD_in_gga(X1, X2, X3))
   minuscD_in_gga(X1, 0, X1) -> minuscD_out_gga(X1, 0, X1)
   minuscD_in_gga(s(X1), s(X2), X3) -> U15_gga(X1, X2, X3, minuscD_in_gga(X1, X2, X3))
   U15_gga(X1, X2, X3, minuscD_out_gga(X1, X2, X3)) -> minuscD_out_gga(s(X1), s(X2), X3)
   U16_gga(X1, X2, X3, minuscD_out_gga(X1, X2, X3)) -> minuscC_out_gga(X1, s(X2), X3)

The argument filtering Pi contains the following mapping:
divB_in_gga(x1, x2, x3)  =  divB_in_gga(x1, x2)

s(x1)  =  s(x1)

leA_in_gga(x1, x2, x3)  =  leA_in_gga(x1, x2)

lecA_in_ggg(x1, x2, x3)  =  lecA_in_ggg(x1, x2, x3)

0  =  0

true  =  true

lecA_out_ggg(x1, x2, x3)  =  lecA_out_ggg(x1, x2, x3)

false  =  false

U10_ggg(x1, x2, x3, x4)  =  U10_ggg(x1, x2, x3, x4)

minusD_in_gga(x1, x2, x3)  =  minusD_in_gga(x1, x2)

minuscC_in_gga(x1, x2, x3)  =  minuscC_in_gga(x1, x2)

minuscC_out_gga(x1, x2, x3)  =  minuscC_out_gga(x1, x2, x3)

U16_gga(x1, x2, x3, x4)  =  U16_gga(x1, x2, x4)

minuscD_in_gga(x1, x2, x3)  =  minuscD_in_gga(x1, x2)

minuscD_out_gga(x1, x2, x3)  =  minuscD_out_gga(x1, x2, x3)

U15_gga(x1, x2, x3, x4)  =  U15_gga(x1, x2, x4)

DIVB_IN_GGA(x1, x2, x3)  =  DIVB_IN_GGA(x1, x2)

U3_GGA(x1, x2, x3, x4)  =  U3_GGA(x1, x2, x4)

LEA_IN_GGA(x1, x2, x3)  =  LEA_IN_GGA(x1, x2)

U1_GGA(x1, x2, x3, x4)  =  U1_GGA(x1, x2, x4)

U4_GGA(x1, x2, x3, x4)  =  U4_GGA(x1, x2, x4)

U5_GGA(x1, x2, x3, x4)  =  U5_GGA(x1, x2, x4)

MINUSD_IN_GGA(x1, x2, x3)  =  MINUSD_IN_GGA(x1, x2)

U2_GGA(x1, x2, x3, x4)  =  U2_GGA(x1, x2, x4)

U6_GGA(x1, x2, x3, x4)  =  U6_GGA(x1, x2, x4)

U7_GGA(x1, x2, x3, x4)  =  U7_GGA(x1, x2, x4)

U8_GGA(x1, x2, x3, x4)  =  U8_GGA(x1, x2, x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(168) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 3 SCCs with 8 less nodes.
----------------------------------------

(169)
Complex Obligation (AND)

----------------------------------------

(170)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MINUSD_IN_GGA(s(X1), s(X2), X3) -> MINUSD_IN_GGA(X1, X2, X3)

The TRS R consists of the following rules:

   lecA_in_ggg(0, X1, true) -> lecA_out_ggg(0, X1, true)
   lecA_in_ggg(s(X1), 0, false) -> lecA_out_ggg(s(X1), 0, false)
   lecA_in_ggg(s(X1), s(X2), X3) -> U10_ggg(X1, X2, X3, lecA_in_ggg(X1, X2, X3))
   U10_ggg(X1, X2, X3, lecA_out_ggg(X1, X2, X3)) -> lecA_out_ggg(s(X1), s(X2), X3)
   minuscC_in_gga(X1, 0, s(X1)) -> minuscC_out_gga(X1, 0, s(X1))
   minuscC_in_gga(X1, s(X2), X3) -> U16_gga(X1, X2, X3, minuscD_in_gga(X1, X2, X3))
   minuscD_in_gga(X1, 0, X1) -> minuscD_out_gga(X1, 0, X1)
   minuscD_in_gga(s(X1), s(X2), X3) -> U15_gga(X1, X2, X3, minuscD_in_gga(X1, X2, X3))
   U15_gga(X1, X2, X3, minuscD_out_gga(X1, X2, X3)) -> minuscD_out_gga(s(X1), s(X2), X3)
   U16_gga(X1, X2, X3, minuscD_out_gga(X1, X2, X3)) -> minuscC_out_gga(X1, s(X2), X3)

The argument filtering Pi contains the following mapping:
s(x1)  =  s(x1)

lecA_in_ggg(x1, x2, x3)  =  lecA_in_ggg(x1, x2, x3)

0  =  0

true  =  true

lecA_out_ggg(x1, x2, x3)  =  lecA_out_ggg(x1, x2, x3)

false  =  false

U10_ggg(x1, x2, x3, x4)  =  U10_ggg(x1, x2, x3, x4)

minuscC_in_gga(x1, x2, x3)  =  minuscC_in_gga(x1, x2)

minuscC_out_gga(x1, x2, x3)  =  minuscC_out_gga(x1, x2, x3)

U16_gga(x1, x2, x3, x4)  =  U16_gga(x1, x2, x4)

minuscD_in_gga(x1, x2, x3)  =  minuscD_in_gga(x1, x2)

minuscD_out_gga(x1, x2, x3)  =  minuscD_out_gga(x1, x2, x3)

U15_gga(x1, x2, x3, x4)  =  U15_gga(x1, x2, x4)

MINUSD_IN_GGA(x1, x2, x3)  =  MINUSD_IN_GGA(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(171) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(172)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MINUSD_IN_GGA(s(X1), s(X2), X3) -> MINUSD_IN_GGA(X1, X2, X3)

R is empty.
The argument filtering Pi contains the following mapping:
s(x1)  =  s(x1)

MINUSD_IN_GGA(x1, x2, x3)  =  MINUSD_IN_GGA(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(173) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(174)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MINUSD_IN_GGA(s(X1), s(X2)) -> MINUSD_IN_GGA(X1, X2)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(175) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*MINUSD_IN_GGA(s(X1), s(X2)) -> MINUSD_IN_GGA(X1, X2)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(176)
YES

----------------------------------------

(177)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   LEA_IN_GGA(s(X1), s(X2), X3) -> LEA_IN_GGA(X1, X2, X3)

The TRS R consists of the following rules:

   lecA_in_ggg(0, X1, true) -> lecA_out_ggg(0, X1, true)
   lecA_in_ggg(s(X1), 0, false) -> lecA_out_ggg(s(X1), 0, false)
   lecA_in_ggg(s(X1), s(X2), X3) -> U10_ggg(X1, X2, X3, lecA_in_ggg(X1, X2, X3))
   U10_ggg(X1, X2, X3, lecA_out_ggg(X1, X2, X3)) -> lecA_out_ggg(s(X1), s(X2), X3)
   minuscC_in_gga(X1, 0, s(X1)) -> minuscC_out_gga(X1, 0, s(X1))
   minuscC_in_gga(X1, s(X2), X3) -> U16_gga(X1, X2, X3, minuscD_in_gga(X1, X2, X3))
   minuscD_in_gga(X1, 0, X1) -> minuscD_out_gga(X1, 0, X1)
   minuscD_in_gga(s(X1), s(X2), X3) -> U15_gga(X1, X2, X3, minuscD_in_gga(X1, X2, X3))
   U15_gga(X1, X2, X3, minuscD_out_gga(X1, X2, X3)) -> minuscD_out_gga(s(X1), s(X2), X3)
   U16_gga(X1, X2, X3, minuscD_out_gga(X1, X2, X3)) -> minuscC_out_gga(X1, s(X2), X3)

The argument filtering Pi contains the following mapping:
s(x1)  =  s(x1)

lecA_in_ggg(x1, x2, x3)  =  lecA_in_ggg(x1, x2, x3)

0  =  0

true  =  true

lecA_out_ggg(x1, x2, x3)  =  lecA_out_ggg(x1, x2, x3)

false  =  false

U10_ggg(x1, x2, x3, x4)  =  U10_ggg(x1, x2, x3, x4)

minuscC_in_gga(x1, x2, x3)  =  minuscC_in_gga(x1, x2)

minuscC_out_gga(x1, x2, x3)  =  minuscC_out_gga(x1, x2, x3)

U16_gga(x1, x2, x3, x4)  =  U16_gga(x1, x2, x4)

minuscD_in_gga(x1, x2, x3)  =  minuscD_in_gga(x1, x2)

minuscD_out_gga(x1, x2, x3)  =  minuscD_out_gga(x1, x2, x3)

U15_gga(x1, x2, x3, x4)  =  U15_gga(x1, x2, x4)

LEA_IN_GGA(x1, x2, x3)  =  LEA_IN_GGA(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(178) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(179)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   LEA_IN_GGA(s(X1), s(X2), X3) -> LEA_IN_GGA(X1, X2, X3)

R is empty.
The argument filtering Pi contains the following mapping:
s(x1)  =  s(x1)

LEA_IN_GGA(x1, x2, x3)  =  LEA_IN_GGA(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(180) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(181)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LEA_IN_GGA(s(X1), s(X2)) -> LEA_IN_GGA(X1, X2)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(182) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*LEA_IN_GGA(s(X1), s(X2)) -> LEA_IN_GGA(X1, X2)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(183)
YES

----------------------------------------

(184)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   DIVB_IN_GGA(s(X1), s(X2), s(X3)) -> U6_GGA(X1, X2, X3, lecA_in_ggg(X2, X1, true))
   U6_GGA(X1, X2, X3, lecA_out_ggg(X2, X1, true)) -> U7_GGA(X1, X2, X3, minuscC_in_gga(X1, X2, X4))
   U7_GGA(X1, X2, X3, minuscC_out_gga(X1, X2, X4)) -> DIVB_IN_GGA(X4, s(X2), X3)

The TRS R consists of the following rules:

   lecA_in_ggg(0, X1, true) -> lecA_out_ggg(0, X1, true)
   lecA_in_ggg(s(X1), 0, false) -> lecA_out_ggg(s(X1), 0, false)
   lecA_in_ggg(s(X1), s(X2), X3) -> U10_ggg(X1, X2, X3, lecA_in_ggg(X1, X2, X3))
   U10_ggg(X1, X2, X3, lecA_out_ggg(X1, X2, X3)) -> lecA_out_ggg(s(X1), s(X2), X3)
   minuscC_in_gga(X1, 0, s(X1)) -> minuscC_out_gga(X1, 0, s(X1))
   minuscC_in_gga(X1, s(X2), X3) -> U16_gga(X1, X2, X3, minuscD_in_gga(X1, X2, X3))
   minuscD_in_gga(X1, 0, X1) -> minuscD_out_gga(X1, 0, X1)
   minuscD_in_gga(s(X1), s(X2), X3) -> U15_gga(X1, X2, X3, minuscD_in_gga(X1, X2, X3))
   U15_gga(X1, X2, X3, minuscD_out_gga(X1, X2, X3)) -> minuscD_out_gga(s(X1), s(X2), X3)
   U16_gga(X1, X2, X3, minuscD_out_gga(X1, X2, X3)) -> minuscC_out_gga(X1, s(X2), X3)

The argument filtering Pi contains the following mapping:
s(x1)  =  s(x1)

lecA_in_ggg(x1, x2, x3)  =  lecA_in_ggg(x1, x2, x3)

0  =  0

true  =  true

lecA_out_ggg(x1, x2, x3)  =  lecA_out_ggg(x1, x2, x3)

false  =  false

U10_ggg(x1, x2, x3, x4)  =  U10_ggg(x1, x2, x3, x4)

minuscC_in_gga(x1, x2, x3)  =  minuscC_in_gga(x1, x2)

minuscC_out_gga(x1, x2, x3)  =  minuscC_out_gga(x1, x2, x3)

U16_gga(x1, x2, x3, x4)  =  U16_gga(x1, x2, x4)

minuscD_in_gga(x1, x2, x3)  =  minuscD_in_gga(x1, x2)

minuscD_out_gga(x1, x2, x3)  =  minuscD_out_gga(x1, x2, x3)

U15_gga(x1, x2, x3, x4)  =  U15_gga(x1, x2, x4)

DIVB_IN_GGA(x1, x2, x3)  =  DIVB_IN_GGA(x1, x2)

U6_GGA(x1, x2, x3, x4)  =  U6_GGA(x1, x2, x4)

U7_GGA(x1, x2, x3, x4)  =  U7_GGA(x1, x2, x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(185) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(186)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   DIVB_IN_GGA(s(X1), s(X2)) -> U6_GGA(X1, X2, lecA_in_ggg(X2, X1, true))
   U6_GGA(X1, X2, lecA_out_ggg(X2, X1, true)) -> U7_GGA(X1, X2, minuscC_in_gga(X1, X2))
   U7_GGA(X1, X2, minuscC_out_gga(X1, X2, X4)) -> DIVB_IN_GGA(X4, s(X2))

The TRS R consists of the following rules:

   lecA_in_ggg(0, X1, true) -> lecA_out_ggg(0, X1, true)
   lecA_in_ggg(s(X1), 0, false) -> lecA_out_ggg(s(X1), 0, false)
   lecA_in_ggg(s(X1), s(X2), X3) -> U10_ggg(X1, X2, X3, lecA_in_ggg(X1, X2, X3))
   U10_ggg(X1, X2, X3, lecA_out_ggg(X1, X2, X3)) -> lecA_out_ggg(s(X1), s(X2), X3)
   minuscC_in_gga(X1, 0) -> minuscC_out_gga(X1, 0, s(X1))
   minuscC_in_gga(X1, s(X2)) -> U16_gga(X1, X2, minuscD_in_gga(X1, X2))
   minuscD_in_gga(X1, 0) -> minuscD_out_gga(X1, 0, X1)
   minuscD_in_gga(s(X1), s(X2)) -> U15_gga(X1, X2, minuscD_in_gga(X1, X2))
   U15_gga(X1, X2, minuscD_out_gga(X1, X2, X3)) -> minuscD_out_gga(s(X1), s(X2), X3)
   U16_gga(X1, X2, minuscD_out_gga(X1, X2, X3)) -> minuscC_out_gga(X1, s(X2), X3)

The set Q consists of the following terms:

   lecA_in_ggg(x0, x1, x2)
   U10_ggg(x0, x1, x2, x3)
   minuscC_in_gga(x0, x1)
   minuscD_in_gga(x0, x1)
   U15_gga(x0, x1, x2)
   U16_gga(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(187) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.


Strictly oriented rules of the TRS R:

   lecA_in_ggg(s(X1), 0, false) -> lecA_out_ggg(s(X1), 0, false)

Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(DIVB_IN_GGA(x_1, x_2)) = 0
   POL(U10_ggg(x_1, x_2, x_3, x_4)) = x_4
   POL(U15_gga(x_1, x_2, x_3)) = 0
   POL(U16_gga(x_1, x_2, x_3)) = 1
   POL(U6_GGA(x_1, x_2, x_3)) = 2*x_3
   POL(U7_GGA(x_1, x_2, x_3)) = 0
   POL(false) = 1
   POL(lecA_in_ggg(x_1, x_2, x_3)) = 2*x_3
   POL(lecA_out_ggg(x_1, x_2, x_3)) = 0
   POL(minuscC_in_gga(x_1, x_2)) = 2
   POL(minuscC_out_gga(x_1, x_2, x_3)) = 0
   POL(minuscD_in_gga(x_1, x_2)) = 0
   POL(minuscD_out_gga(x_1, x_2, x_3)) = 0
   POL(s(x_1)) = 0
   POL(true) = 0


----------------------------------------

(188)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   DIVB_IN_GGA(s(X1), s(X2)) -> U6_GGA(X1, X2, lecA_in_ggg(X2, X1, true))
   U6_GGA(X1, X2, lecA_out_ggg(X2, X1, true)) -> U7_GGA(X1, X2, minuscC_in_gga(X1, X2))
   U7_GGA(X1, X2, minuscC_out_gga(X1, X2, X4)) -> DIVB_IN_GGA(X4, s(X2))

The TRS R consists of the following rules:

   lecA_in_ggg(0, X1, true) -> lecA_out_ggg(0, X1, true)
   lecA_in_ggg(s(X1), s(X2), X3) -> U10_ggg(X1, X2, X3, lecA_in_ggg(X1, X2, X3))
   U10_ggg(X1, X2, X3, lecA_out_ggg(X1, X2, X3)) -> lecA_out_ggg(s(X1), s(X2), X3)
   minuscC_in_gga(X1, 0) -> minuscC_out_gga(X1, 0, s(X1))
   minuscC_in_gga(X1, s(X2)) -> U16_gga(X1, X2, minuscD_in_gga(X1, X2))
   minuscD_in_gga(X1, 0) -> minuscD_out_gga(X1, 0, X1)
   minuscD_in_gga(s(X1), s(X2)) -> U15_gga(X1, X2, minuscD_in_gga(X1, X2))
   U15_gga(X1, X2, minuscD_out_gga(X1, X2, X3)) -> minuscD_out_gga(s(X1), s(X2), X3)
   U16_gga(X1, X2, minuscD_out_gga(X1, X2, X3)) -> minuscC_out_gga(X1, s(X2), X3)

The set Q consists of the following terms:

   lecA_in_ggg(x0, x1, x2)
   U10_ggg(x0, x1, x2, x3)
   minuscC_in_gga(x0, x1)
   minuscD_in_gga(x0, x1)
   U15_gga(x0, x1, x2)
   U16_gga(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(189) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.


Strictly oriented rules of the TRS R:

   minuscC_in_gga(X1, s(X2)) -> U16_gga(X1, X2, minuscD_in_gga(X1, X2))
   minuscD_in_gga(s(X1), s(X2)) -> U15_gga(X1, X2, minuscD_in_gga(X1, X2))

Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(DIVB_IN_GGA(x_1, x_2)) = 2*x_1
   POL(U10_ggg(x_1, x_2, x_3, x_4)) = 0
   POL(U15_gga(x_1, x_2, x_3)) = x_3
   POL(U16_gga(x_1, x_2, x_3)) = x_3
   POL(U6_GGA(x_1, x_2, x_3)) = 2 + 2*x_1
   POL(U7_GGA(x_1, x_2, x_3)) = 2*x_3
   POL(lecA_in_ggg(x_1, x_2, x_3)) = 0
   POL(lecA_out_ggg(x_1, x_2, x_3)) = 0
   POL(minuscC_in_gga(x_1, x_2)) = 1 + x_1
   POL(minuscC_out_gga(x_1, x_2, x_3)) = x_3
   POL(minuscD_in_gga(x_1, x_2)) = x_1
   POL(minuscD_out_gga(x_1, x_2, x_3)) = x_3
   POL(s(x_1)) = 1 + x_1
   POL(true) = 0


----------------------------------------

(190)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   DIVB_IN_GGA(s(X1), s(X2)) -> U6_GGA(X1, X2, lecA_in_ggg(X2, X1, true))
   U6_GGA(X1, X2, lecA_out_ggg(X2, X1, true)) -> U7_GGA(X1, X2, minuscC_in_gga(X1, X2))
   U7_GGA(X1, X2, minuscC_out_gga(X1, X2, X4)) -> DIVB_IN_GGA(X4, s(X2))

The TRS R consists of the following rules:

   lecA_in_ggg(0, X1, true) -> lecA_out_ggg(0, X1, true)
   lecA_in_ggg(s(X1), s(X2), X3) -> U10_ggg(X1, X2, X3, lecA_in_ggg(X1, X2, X3))
   U10_ggg(X1, X2, X3, lecA_out_ggg(X1, X2, X3)) -> lecA_out_ggg(s(X1), s(X2), X3)
   minuscC_in_gga(X1, 0) -> minuscC_out_gga(X1, 0, s(X1))
   minuscD_in_gga(X1, 0) -> minuscD_out_gga(X1, 0, X1)
   U15_gga(X1, X2, minuscD_out_gga(X1, X2, X3)) -> minuscD_out_gga(s(X1), s(X2), X3)
   U16_gga(X1, X2, minuscD_out_gga(X1, X2, X3)) -> minuscC_out_gga(X1, s(X2), X3)

The set Q consists of the following terms:

   lecA_in_ggg(x0, x1, x2)
   U10_ggg(x0, x1, x2, x3)
   minuscC_in_gga(x0, x1)
   minuscD_in_gga(x0, x1)
   U15_gga(x0, x1, x2)
   U16_gga(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(191) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(192)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   DIVB_IN_GGA(s(X1), s(X2)) -> U6_GGA(X1, X2, lecA_in_ggg(X2, X1, true))
   U6_GGA(X1, X2, lecA_out_ggg(X2, X1, true)) -> U7_GGA(X1, X2, minuscC_in_gga(X1, X2))
   U7_GGA(X1, X2, minuscC_out_gga(X1, X2, X4)) -> DIVB_IN_GGA(X4, s(X2))

The TRS R consists of the following rules:

   minuscC_in_gga(X1, 0) -> minuscC_out_gga(X1, 0, s(X1))
   lecA_in_ggg(0, X1, true) -> lecA_out_ggg(0, X1, true)
   lecA_in_ggg(s(X1), s(X2), X3) -> U10_ggg(X1, X2, X3, lecA_in_ggg(X1, X2, X3))
   U10_ggg(X1, X2, X3, lecA_out_ggg(X1, X2, X3)) -> lecA_out_ggg(s(X1), s(X2), X3)

The set Q consists of the following terms:

   lecA_in_ggg(x0, x1, x2)
   U10_ggg(x0, x1, x2, x3)
   minuscC_in_gga(x0, x1)
   minuscD_in_gga(x0, x1)
   U15_gga(x0, x1, x2)
   U16_gga(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(193) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   minuscD_in_gga(x0, x1)
   U15_gga(x0, x1, x2)
   U16_gga(x0, x1, x2)


----------------------------------------

(194)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   DIVB_IN_GGA(s(X1), s(X2)) -> U6_GGA(X1, X2, lecA_in_ggg(X2, X1, true))
   U6_GGA(X1, X2, lecA_out_ggg(X2, X1, true)) -> U7_GGA(X1, X2, minuscC_in_gga(X1, X2))
   U7_GGA(X1, X2, minuscC_out_gga(X1, X2, X4)) -> DIVB_IN_GGA(X4, s(X2))

The TRS R consists of the following rules:

   minuscC_in_gga(X1, 0) -> minuscC_out_gga(X1, 0, s(X1))
   lecA_in_ggg(0, X1, true) -> lecA_out_ggg(0, X1, true)
   lecA_in_ggg(s(X1), s(X2), X3) -> U10_ggg(X1, X2, X3, lecA_in_ggg(X1, X2, X3))
   U10_ggg(X1, X2, X3, lecA_out_ggg(X1, X2, X3)) -> lecA_out_ggg(s(X1), s(X2), X3)

The set Q consists of the following terms:

   lecA_in_ggg(x0, x1, x2)
   U10_ggg(x0, x1, x2, x3)
   minuscC_in_gga(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(195) TransformationProof (SOUND)
By narrowing [LPAR04] the rule U6_GGA(X1, X2, lecA_out_ggg(X2, X1, true)) -> U7_GGA(X1, X2, minuscC_in_gga(X1, X2)) at position [2] we obtained the following new rules [LPAR04]:

   (U6_GGA(x0, 0, lecA_out_ggg(0, x0, true)) -> U7_GGA(x0, 0, minuscC_out_gga(x0, 0, s(x0))),U6_GGA(x0, 0, lecA_out_ggg(0, x0, true)) -> U7_GGA(x0, 0, minuscC_out_gga(x0, 0, s(x0))))


----------------------------------------

(196)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   DIVB_IN_GGA(s(X1), s(X2)) -> U6_GGA(X1, X2, lecA_in_ggg(X2, X1, true))
   U7_GGA(X1, X2, minuscC_out_gga(X1, X2, X4)) -> DIVB_IN_GGA(X4, s(X2))
   U6_GGA(x0, 0, lecA_out_ggg(0, x0, true)) -> U7_GGA(x0, 0, minuscC_out_gga(x0, 0, s(x0)))

The TRS R consists of the following rules:

   minuscC_in_gga(X1, 0) -> minuscC_out_gga(X1, 0, s(X1))
   lecA_in_ggg(0, X1, true) -> lecA_out_ggg(0, X1, true)
   lecA_in_ggg(s(X1), s(X2), X3) -> U10_ggg(X1, X2, X3, lecA_in_ggg(X1, X2, X3))
   U10_ggg(X1, X2, X3, lecA_out_ggg(X1, X2, X3)) -> lecA_out_ggg(s(X1), s(X2), X3)

The set Q consists of the following terms:

   lecA_in_ggg(x0, x1, x2)
   U10_ggg(x0, x1, x2, x3)
   minuscC_in_gga(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(197) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(198)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   DIVB_IN_GGA(s(X1), s(X2)) -> U6_GGA(X1, X2, lecA_in_ggg(X2, X1, true))
   U7_GGA(X1, X2, minuscC_out_gga(X1, X2, X4)) -> DIVB_IN_GGA(X4, s(X2))
   U6_GGA(x0, 0, lecA_out_ggg(0, x0, true)) -> U7_GGA(x0, 0, minuscC_out_gga(x0, 0, s(x0)))

The TRS R consists of the following rules:

   lecA_in_ggg(0, X1, true) -> lecA_out_ggg(0, X1, true)
   lecA_in_ggg(s(X1), s(X2), X3) -> U10_ggg(X1, X2, X3, lecA_in_ggg(X1, X2, X3))
   U10_ggg(X1, X2, X3, lecA_out_ggg(X1, X2, X3)) -> lecA_out_ggg(s(X1), s(X2), X3)

The set Q consists of the following terms:

   lecA_in_ggg(x0, x1, x2)
   U10_ggg(x0, x1, x2, x3)
   minuscC_in_gga(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(199) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   minuscC_in_gga(x0, x1)


----------------------------------------

(200)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   DIVB_IN_GGA(s(X1), s(X2)) -> U6_GGA(X1, X2, lecA_in_ggg(X2, X1, true))
   U7_GGA(X1, X2, minuscC_out_gga(X1, X2, X4)) -> DIVB_IN_GGA(X4, s(X2))
   U6_GGA(x0, 0, lecA_out_ggg(0, x0, true)) -> U7_GGA(x0, 0, minuscC_out_gga(x0, 0, s(x0)))

The TRS R consists of the following rules:

   lecA_in_ggg(0, X1, true) -> lecA_out_ggg(0, X1, true)
   lecA_in_ggg(s(X1), s(X2), X3) -> U10_ggg(X1, X2, X3, lecA_in_ggg(X1, X2, X3))
   U10_ggg(X1, X2, X3, lecA_out_ggg(X1, X2, X3)) -> lecA_out_ggg(s(X1), s(X2), X3)

The set Q consists of the following terms:

   lecA_in_ggg(x0, x1, x2)
   U10_ggg(x0, x1, x2, x3)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(201) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U7_GGA(X1, X2, minuscC_out_gga(X1, X2, X4)) -> DIVB_IN_GGA(X4, s(X2)) we obtained the following new rules [LPAR04]:

   (U7_GGA(z0, 0, minuscC_out_gga(z0, 0, s(z0))) -> DIVB_IN_GGA(s(z0), s(0)),U7_GGA(z0, 0, minuscC_out_gga(z0, 0, s(z0))) -> DIVB_IN_GGA(s(z0), s(0)))


----------------------------------------

(202)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   DIVB_IN_GGA(s(X1), s(X2)) -> U6_GGA(X1, X2, lecA_in_ggg(X2, X1, true))
   U6_GGA(x0, 0, lecA_out_ggg(0, x0, true)) -> U7_GGA(x0, 0, minuscC_out_gga(x0, 0, s(x0)))
   U7_GGA(z0, 0, minuscC_out_gga(z0, 0, s(z0))) -> DIVB_IN_GGA(s(z0), s(0))

The TRS R consists of the following rules:

   lecA_in_ggg(0, X1, true) -> lecA_out_ggg(0, X1, true)
   lecA_in_ggg(s(X1), s(X2), X3) -> U10_ggg(X1, X2, X3, lecA_in_ggg(X1, X2, X3))
   U10_ggg(X1, X2, X3, lecA_out_ggg(X1, X2, X3)) -> lecA_out_ggg(s(X1), s(X2), X3)

The set Q consists of the following terms:

   lecA_in_ggg(x0, x1, x2)
   U10_ggg(x0, x1, x2, x3)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(203) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule DIVB_IN_GGA(s(X1), s(X2)) -> U6_GGA(X1, X2, lecA_in_ggg(X2, X1, true)) we obtained the following new rules [LPAR04]:

   (DIVB_IN_GGA(s(z0), s(0)) -> U6_GGA(z0, 0, lecA_in_ggg(0, z0, true)),DIVB_IN_GGA(s(z0), s(0)) -> U6_GGA(z0, 0, lecA_in_ggg(0, z0, true)))


----------------------------------------

(204)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_GGA(x0, 0, lecA_out_ggg(0, x0, true)) -> U7_GGA(x0, 0, minuscC_out_gga(x0, 0, s(x0)))
   U7_GGA(z0, 0, minuscC_out_gga(z0, 0, s(z0))) -> DIVB_IN_GGA(s(z0), s(0))
   DIVB_IN_GGA(s(z0), s(0)) -> U6_GGA(z0, 0, lecA_in_ggg(0, z0, true))

The TRS R consists of the following rules:

   lecA_in_ggg(0, X1, true) -> lecA_out_ggg(0, X1, true)
   lecA_in_ggg(s(X1), s(X2), X3) -> U10_ggg(X1, X2, X3, lecA_in_ggg(X1, X2, X3))
   U10_ggg(X1, X2, X3, lecA_out_ggg(X1, X2, X3)) -> lecA_out_ggg(s(X1), s(X2), X3)

The set Q consists of the following terms:

   lecA_in_ggg(x0, x1, x2)
   U10_ggg(x0, x1, x2, x3)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(205) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(206)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_GGA(x0, 0, lecA_out_ggg(0, x0, true)) -> U7_GGA(x0, 0, minuscC_out_gga(x0, 0, s(x0)))
   U7_GGA(z0, 0, minuscC_out_gga(z0, 0, s(z0))) -> DIVB_IN_GGA(s(z0), s(0))
   DIVB_IN_GGA(s(z0), s(0)) -> U6_GGA(z0, 0, lecA_in_ggg(0, z0, true))

The TRS R consists of the following rules:

   lecA_in_ggg(0, X1, true) -> lecA_out_ggg(0, X1, true)

The set Q consists of the following terms:

   lecA_in_ggg(x0, x1, x2)
   U10_ggg(x0, x1, x2, x3)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(207) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   U10_ggg(x0, x1, x2, x3)


----------------------------------------

(208)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_GGA(x0, 0, lecA_out_ggg(0, x0, true)) -> U7_GGA(x0, 0, minuscC_out_gga(x0, 0, s(x0)))
   U7_GGA(z0, 0, minuscC_out_gga(z0, 0, s(z0))) -> DIVB_IN_GGA(s(z0), s(0))
   DIVB_IN_GGA(s(z0), s(0)) -> U6_GGA(z0, 0, lecA_in_ggg(0, z0, true))

The TRS R consists of the following rules:

   lecA_in_ggg(0, X1, true) -> lecA_out_ggg(0, X1, true)

The set Q consists of the following terms:

   lecA_in_ggg(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(209) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule DIVB_IN_GGA(s(z0), s(0)) -> U6_GGA(z0, 0, lecA_in_ggg(0, z0, true)) at position [2] we obtained the following new rules [LPAR04]:

   (DIVB_IN_GGA(s(z0), s(0)) -> U6_GGA(z0, 0, lecA_out_ggg(0, z0, true)),DIVB_IN_GGA(s(z0), s(0)) -> U6_GGA(z0, 0, lecA_out_ggg(0, z0, true)))


----------------------------------------

(210)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_GGA(x0, 0, lecA_out_ggg(0, x0, true)) -> U7_GGA(x0, 0, minuscC_out_gga(x0, 0, s(x0)))
   U7_GGA(z0, 0, minuscC_out_gga(z0, 0, s(z0))) -> DIVB_IN_GGA(s(z0), s(0))
   DIVB_IN_GGA(s(z0), s(0)) -> U6_GGA(z0, 0, lecA_out_ggg(0, z0, true))

The TRS R consists of the following rules:

   lecA_in_ggg(0, X1, true) -> lecA_out_ggg(0, X1, true)

The set Q consists of the following terms:

   lecA_in_ggg(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(211) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(212)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_GGA(x0, 0, lecA_out_ggg(0, x0, true)) -> U7_GGA(x0, 0, minuscC_out_gga(x0, 0, s(x0)))
   U7_GGA(z0, 0, minuscC_out_gga(z0, 0, s(z0))) -> DIVB_IN_GGA(s(z0), s(0))
   DIVB_IN_GGA(s(z0), s(0)) -> U6_GGA(z0, 0, lecA_out_ggg(0, z0, true))

R is empty.
The set Q consists of the following terms:

   lecA_in_ggg(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(213) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   lecA_in_ggg(x0, x1, x2)


----------------------------------------

(214)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_GGA(x0, 0, lecA_out_ggg(0, x0, true)) -> U7_GGA(x0, 0, minuscC_out_gga(x0, 0, s(x0)))
   U7_GGA(z0, 0, minuscC_out_gga(z0, 0, s(z0))) -> DIVB_IN_GGA(s(z0), s(0))
   DIVB_IN_GGA(s(z0), s(0)) -> U6_GGA(z0, 0, lecA_out_ggg(0, z0, true))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(215) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = U7_GGA(z0', 0, minuscC_out_gga(z0', 0, s(z0'))) evaluates to  t =U7_GGA(z0', 0, minuscC_out_gga(z0', 0, s(z0')))

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

U7_GGA(z0', 0, minuscC_out_gga(z0', 0, s(z0'))) -> DIVB_IN_GGA(s(z0'), s(0))
with rule U7_GGA(z0'', 0, minuscC_out_gga(z0'', 0, s(z0''))) -> DIVB_IN_GGA(s(z0''), s(0)) at position [] and matcher [z0'' / z0']

DIVB_IN_GGA(s(z0'), s(0)) -> U6_GGA(z0', 0, lecA_out_ggg(0, z0', true))
with rule DIVB_IN_GGA(s(z0), s(0)) -> U6_GGA(z0, 0, lecA_out_ggg(0, z0, true)) at position [] and matcher [z0 / z0']

U6_GGA(z0', 0, lecA_out_ggg(0, z0', true)) -> U7_GGA(z0', 0, minuscC_out_gga(z0', 0, s(z0')))
with rule U6_GGA(x0, 0, lecA_out_ggg(0, x0, true)) -> U7_GGA(x0, 0, minuscC_out_gga(x0, 0, s(x0)))

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(216)
NO

----------------------------------------

(217) PrologToIRSwTTransformerProof (SOUND)
Transformed Prolog program to IRSwT according to method in Master Thesis of A. Weinert

{
    "root": 1,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(le (0) Y (true))",
                null
            ],
            [
                "(le (s X) (0) (false))",
                null
            ],
            [
                "(le (s X) (s Y) B)",
                "(le X Y B)"
            ],
            [
                "(minus X (0) X)",
                null
            ],
            [
                "(minus (s X) (s Y) Z)",
                "(minus X Y Z)"
            ],
            [
                "(div X (s Y) Z)",
                "(',' (le (s Y) X B) (if B X (s Y) Z))"
            ],
            [
                "(if (false) X (s Y) (0))",
                null
            ],
            [
                "(if (true) X (s Y) (s Z))",
                "(',' (minus X Y U) (div U (s Y) Z))"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "46": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "47": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "48": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "191": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "192": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "193": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "370": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "373": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "431": {
                "goal": [
                    {
                        "clause": 3,
                        "scope": 5,
                        "term": "(minus T66 T67 X84)"
                    },
                    {
                        "clause": 4,
                        "scope": 5,
                        "term": "(minus T66 T67 X84)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T66",
                        "T67"
                    ],
                    "free": ["X84"],
                    "exprvars": []
                }
            },
            "432": {
                "goal": [{
                    "clause": 3,
                    "scope": 5,
                    "term": "(minus T66 T67 X84)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T66",
                        "T67"
                    ],
                    "free": ["X84"],
                    "exprvars": []
                }
            },
            "433": {
                "goal": [{
                    "clause": 4,
                    "scope": 5,
                    "term": "(minus T66 T67 X84)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T66",
                        "T67"
                    ],
                    "free": ["X84"],
                    "exprvars": []
                }
            },
            "434": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "435": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "238": {
                "goal": [
                    {
                        "clause": 6,
                        "scope": 4,
                        "term": "(if T14 T10 (s T11) T13)"
                    },
                    {
                        "clause": 7,
                        "scope": 4,
                        "term": "(if T14 T10 (s T11) T13)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T10",
                        "T11",
                        "T14"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "436": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "31": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (le (s T11) T10 X11) (if X11 T10 (s T11) T13))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T10",
                        "T11"
                    ],
                    "free": ["X11"],
                    "exprvars": []
                }
            },
            "53": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(le T24 T25 X33)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T24",
                        "T25"
                    ],
                    "free": ["X33"],
                    "exprvars": []
                }
            },
            "32": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "54": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "55": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 3,
                        "term": "(le T24 T25 X33)"
                    },
                    {
                        "clause": 1,
                        "scope": 3,
                        "term": "(le T24 T25 X33)"
                    },
                    {
                        "clause": 2,
                        "scope": 3,
                        "term": "(le T24 T25 X33)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T24",
                        "T25"
                    ],
                    "free": ["X33"],
                    "exprvars": []
                }
            },
            "78": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "35": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(le (s T11) T10 X11)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T10",
                        "T11"
                    ],
                    "free": ["X11"],
                    "exprvars": []
                }
            },
            "79": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "36": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(if T14 T10 (s T11) T13)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T10",
                        "T11",
                        "T14"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "58": {
                "goal": [{
                    "clause": 0,
                    "scope": 3,
                    "term": "(le T24 T25 X33)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T24",
                        "T25"
                    ],
                    "free": ["X33"],
                    "exprvars": []
                }
            },
            "59": {
                "goal": [
                    {
                        "clause": 1,
                        "scope": 3,
                        "term": "(le T24 T25 X33)"
                    },
                    {
                        "clause": 2,
                        "scope": 3,
                        "term": "(le T24 T25 X33)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T24",
                        "T25"
                    ],
                    "free": ["X33"],
                    "exprvars": []
                }
            },
            "39": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 2,
                        "term": "(le (s T11) T10 X11)"
                    },
                    {
                        "clause": 1,
                        "scope": 2,
                        "term": "(le (s T11) T10 X11)"
                    },
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(le (s T11) T10 X11)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T10",
                        "T11"
                    ],
                    "free": ["X11"],
                    "exprvars": []
                }
            },
            "241": {
                "goal": [{
                    "clause": 6,
                    "scope": 4,
                    "term": "(if T14 T10 (s T11) T13)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T10",
                        "T11",
                        "T14"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "242": {
                "goal": [{
                    "clause": 7,
                    "scope": 4,
                    "term": "(if T14 T10 (s T11) T13)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T10",
                        "T11",
                        "T14"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "440": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(minus T84 T85 X105)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T84",
                        "T85"
                    ],
                    "free": ["X105"],
                    "exprvars": []
                }
            },
            "1": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(div T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "441": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "367": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "422": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (minus T66 T67 X84) (div X84 (s T67) T69))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T66",
                        "T67"
                    ],
                    "free": ["X84"],
                    "exprvars": []
                }
            },
            "225": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(le T42 T43 X57)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T42",
                        "T43"
                    ],
                    "free": ["X57"],
                    "exprvars": []
                }
            },
            "226": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "424": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "9": {
                "goal": [{
                    "clause": 5,
                    "scope": 1,
                    "term": "(div T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "427": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(minus T66 T67 X84)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T66",
                        "T67"
                    ],
                    "free": ["X84"],
                    "exprvars": []
                }
            },
            "428": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(div T72 (s T67) T69)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T67",
                        "T72"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "61": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "83": {
                "goal": [{
                    "clause": 1,
                    "scope": 3,
                    "term": "(le T24 T25 X33)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T24",
                        "T25"
                    ],
                    "free": ["X33"],
                    "exprvars": []
                }
            },
            "40": {
                "goal": [
                    {
                        "clause": 1,
                        "scope": 2,
                        "term": "(le (s T11) T10 X11)"
                    },
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(le (s T11) T10 X11)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T10",
                        "T11"
                    ],
                    "free": ["X11"],
                    "exprvars": []
                }
            },
            "84": {
                "goal": [{
                    "clause": 2,
                    "scope": 3,
                    "term": "(le T24 T25 X33)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T24",
                        "T25"
                    ],
                    "free": ["X33"],
                    "exprvars": []
                }
            },
            "42": {
                "goal": [{
                    "clause": 1,
                    "scope": 2,
                    "term": "(le (s T11) T10 X11)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T10",
                        "T11"
                    ],
                    "free": ["X11"],
                    "exprvars": []
                }
            },
            "43": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(le (s T11) T10 X11)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T10",
                        "T11"
                    ],
                    "free": ["X11"],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 1,
                "to": 9,
                "label": "CASE"
            },
            {
                "from": 9,
                "to": 31,
                "label": "EVAL with clause\ndiv(X8, s(X9), X10) :- ','(le(s(X9), X8, X11), if(X11, X8, s(X9), X10)).\nand substitutionT1 -> T10,\nX8 -> T10,\nX9 -> T11,\nT2 -> s(T11),\nT3 -> T13,\nX10 -> T13,\nT12 -> T13"
            },
            {
                "from": 9,
                "to": 32,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 31,
                "to": 35,
                "label": "SPLIT 1"
            },
            {
                "from": 31,
                "to": 36,
                "label": "SPLIT 2\nnew knowledge:\nT11 is ground\nT10 is ground\nT14 is ground\nreplacements:X11 -> T14"
            },
            {
                "from": 35,
                "to": 39,
                "label": "CASE"
            },
            {
                "from": 36,
                "to": 238,
                "label": "CASE"
            },
            {
                "from": 39,
                "to": 40,
                "label": "BACKTRACK\nfor clause: le(0, Y, true)because of non-unification"
            },
            {
                "from": 40,
                "to": 42,
                "label": "PARALLEL"
            },
            {
                "from": 40,
                "to": 43,
                "label": "PARALLEL"
            },
            {
                "from": 42,
                "to": 46,
                "label": "EVAL with clause\nle(s(X21), 0, false).\nand substitutionT11 -> T19,\nX21 -> T19,\nT10 -> 0,\nX11 -> false"
            },
            {
                "from": 42,
                "to": 47,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 43,
                "to": 53,
                "label": "EVAL with clause\nle(s(X30), s(X31), X32) :- le(X30, X31, X32).\nand substitutionT11 -> T24,\nX30 -> T24,\nX31 -> T25,\nT10 -> s(T25),\nX11 -> X33,\nX32 -> X33"
            },
            {
                "from": 43,
                "to": 54,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 46,
                "to": 48,
                "label": "SUCCESS"
            },
            {
                "from": 53,
                "to": 55,
                "label": "CASE"
            },
            {
                "from": 55,
                "to": 58,
                "label": "PARALLEL"
            },
            {
                "from": 55,
                "to": 59,
                "label": "PARALLEL"
            },
            {
                "from": 58,
                "to": 61,
                "label": "EVAL with clause\nle(0, X40, true).\nand substitutionT24 -> 0,\nT25 -> T32,\nX40 -> T32,\nX33 -> true"
            },
            {
                "from": 58,
                "to": 78,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 59,
                "to": 83,
                "label": "PARALLEL"
            },
            {
                "from": 59,
                "to": 84,
                "label": "PARALLEL"
            },
            {
                "from": 61,
                "to": 79,
                "label": "SUCCESS"
            },
            {
                "from": 83,
                "to": 191,
                "label": "EVAL with clause\nle(s(X45), 0, false).\nand substitutionX45 -> T37,\nT24 -> s(T37),\nT25 -> 0,\nX33 -> false"
            },
            {
                "from": 83,
                "to": 192,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 84,
                "to": 225,
                "label": "EVAL with clause\nle(s(X54), s(X55), X56) :- le(X54, X55, X56).\nand substitutionX54 -> T42,\nT24 -> s(T42),\nX55 -> T43,\nT25 -> s(T43),\nX33 -> X57,\nX56 -> X57"
            },
            {
                "from": 84,
                "to": 226,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 191,
                "to": 193,
                "label": "SUCCESS"
            },
            {
                "from": 225,
                "to": 53,
                "label": "INSTANCE with matching:\nT24 -> T42\nT25 -> T43\nX33 -> X57"
            },
            {
                "from": 238,
                "to": 241,
                "label": "PARALLEL"
            },
            {
                "from": 238,
                "to": 242,
                "label": "PARALLEL"
            },
            {
                "from": 241,
                "to": 367,
                "label": "EVAL with clause\nif(false, X72, s(X73), 0).\nand substitutionT14 -> false,\nT10 -> T58,\nX72 -> T58,\nT11 -> T59,\nX73 -> T59,\nT13 -> 0"
            },
            {
                "from": 241,
                "to": 370,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 242,
                "to": 422,
                "label": "EVAL with clause\nif(true, X81, s(X82), s(X83)) :- ','(minus(X81, X82, X84), div(X84, s(X82), X83)).\nand substitutionT14 -> true,\nT10 -> T66,\nX81 -> T66,\nT11 -> T67,\nX82 -> T67,\nX83 -> T69,\nT13 -> s(T69),\nT68 -> T69"
            },
            {
                "from": 242,
                "to": 424,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 367,
                "to": 373,
                "label": "SUCCESS"
            },
            {
                "from": 422,
                "to": 427,
                "label": "SPLIT 1"
            },
            {
                "from": 422,
                "to": 428,
                "label": "SPLIT 2\nnew knowledge:\nT66 is ground\nT67 is ground\nT72 is ground\nreplacements:X84 -> T72"
            },
            {
                "from": 427,
                "to": 431,
                "label": "CASE"
            },
            {
                "from": 428,
                "to": 1,
                "label": "INSTANCE with matching:\nT1 -> T72\nT2 -> s(T67)\nT3 -> T69"
            },
            {
                "from": 431,
                "to": 432,
                "label": "PARALLEL"
            },
            {
                "from": 431,
                "to": 433,
                "label": "PARALLEL"
            },
            {
                "from": 432,
                "to": 434,
                "label": "EVAL with clause\nminus(X93, 0, X93).\nand substitutionT66 -> T79,\nX93 -> T79,\nT67 -> 0,\nX84 -> T79"
            },
            {
                "from": 432,
                "to": 435,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 433,
                "to": 440,
                "label": "EVAL with clause\nminus(s(X102), s(X103), X104) :- minus(X102, X103, X104).\nand substitutionX102 -> T84,\nT66 -> s(T84),\nX103 -> T85,\nT67 -> s(T85),\nX84 -> X105,\nX104 -> X105"
            },
            {
                "from": 433,
                "to": 441,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 434,
                "to": 436,
                "label": "SUCCESS"
            },
            {
                "from": 440,
                "to": 427,
                "label": "INSTANCE with matching:\nT66 -> T84\nT67 -> T85\nX84 -> X105"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(218)
Complex Obligation (AND)

----------------------------------------

(219)
Obligation:
Rules:
f431_in(T66, T67) -> f432_in(T66, T67) :|: TRUE
f433_out(x, x1) -> f431_out(x, x1) :|: TRUE
f431_in(x2, x3) -> f433_in(x2, x3) :|: TRUE
f432_out(x4, x5) -> f431_out(x4, x5) :|: TRUE
f433_in(x6, x7) -> f441_in :|: TRUE
f433_in(s(T84), s(T85)) -> f440_in(T84, T85) :|: TRUE
f441_out -> f433_out(x8, x9) :|: TRUE
f440_out(x10, x11) -> f433_out(s(x10), s(x11)) :|: TRUE
f440_in(x12, x13) -> f427_in(x12, x13) :|: TRUE
f427_out(x14, x15) -> f440_out(x14, x15) :|: TRUE
f427_in(x16, x17) -> f431_in(x16, x17) :|: TRUE
f431_out(x18, x19) -> f427_out(x18, x19) :|: TRUE
f1_in(T1, T2) -> f9_in(T1, T2) :|: TRUE
f9_out(x20, x21) -> f1_out(x20, x21) :|: TRUE
f31_out(T11, T10) -> f9_out(T10, s(T11)) :|: TRUE
f9_in(x22, s(x23)) -> f31_in(x23, x22) :|: TRUE
f32_out -> f9_out(x24, x25) :|: TRUE
f9_in(x26, x27) -> f32_in :|: TRUE
f36_out(x28, x29, x30) -> f31_out(x30, x29) :|: TRUE
f31_in(x31, x32) -> f35_in(x31, x32) :|: TRUE
f35_out(x33, x34) -> f36_in(x35, x34, x33) :|: TRUE
f238_out(x36, x37, x38) -> f36_out(x36, x37, x38) :|: TRUE
f36_in(x39, x40, x41) -> f238_in(x39, x40, x41) :|: TRUE
f238_in(x42, x43, x44) -> f242_in(x42, x43, x44) :|: TRUE
f241_out(x45, x46, x47) -> f238_out(x45, x46, x47) :|: TRUE
f238_in(x48, x49, x50) -> f241_in(x48, x49, x50) :|: TRUE
f242_out(x51, x52, x53) -> f238_out(x51, x52, x53) :|: TRUE
f422_out(x54, x55) -> f242_out(true, x54, x55) :|: TRUE
f242_in(true, x56, x57) -> f422_in(x56, x57) :|: TRUE
f424_out -> f242_out(x58, x59, x60) :|: TRUE
f242_in(x61, x62, x63) -> f424_in :|: TRUE
f427_out(x64, x65) -> f428_in(x66, x65) :|: TRUE
f422_in(x67, x68) -> f427_in(x67, x68) :|: TRUE
f428_out(x69, x70) -> f422_out(x71, x70) :|: TRUE
Start term: f1_in(T1, T2)

----------------------------------------

(220) IRSwTSimpleDependencyGraphProof (EQUIVALENT)
Constructed simple dependency graph.

Simplified to the following IRSwTs:


----------------------------------------

(221)
TRUE

----------------------------------------

(222)
Obligation:
Rules:
f53_out(T42, T43) -> f225_out(T42, T43) :|: TRUE
f225_in(x, x1) -> f53_in(x, x1) :|: TRUE
f55_in(T24, T25) -> f59_in(T24, T25) :|: TRUE
f58_out(x2, x3) -> f55_out(x2, x3) :|: TRUE
f55_in(x4, x5) -> f58_in(x4, x5) :|: TRUE
f59_out(x6, x7) -> f55_out(x6, x7) :|: TRUE
f84_out(x8, x9) -> f59_out(x8, x9) :|: TRUE
f59_in(x10, x11) -> f83_in(x10, x11) :|: TRUE
f83_out(x12, x13) -> f59_out(x12, x13) :|: TRUE
f59_in(x14, x15) -> f84_in(x14, x15) :|: TRUE
f55_out(x16, x17) -> f53_out(x16, x17) :|: TRUE
f53_in(x18, x19) -> f55_in(x18, x19) :|: TRUE
f226_out -> f84_out(x20, x21) :|: TRUE
f84_in(s(x22), s(x23)) -> f225_in(x22, x23) :|: TRUE
f225_out(x24, x25) -> f84_out(s(x24), s(x25)) :|: TRUE
f84_in(x26, x27) -> f226_in :|: TRUE
f1_in(T1, T2) -> f9_in(T1, T2) :|: TRUE
f9_out(x28, x29) -> f1_out(x28, x29) :|: TRUE
f31_out(T11, T10) -> f9_out(T10, s(T11)) :|: TRUE
f9_in(x30, s(x31)) -> f31_in(x31, x30) :|: TRUE
f32_out -> f9_out(x32, x33) :|: TRUE
f9_in(x34, x35) -> f32_in :|: TRUE
f36_out(x36, x37, x38) -> f31_out(x38, x37) :|: TRUE
f31_in(x39, x40) -> f35_in(x39, x40) :|: TRUE
f35_out(x41, x42) -> f36_in(x43, x42, x41) :|: TRUE
f35_in(x44, x45) -> f39_in(x44, x45) :|: TRUE
f39_out(x46, x47) -> f35_out(x46, x47) :|: TRUE
f40_out(x48, x49) -> f39_out(x48, x49) :|: TRUE
f39_in(x50, x51) -> f40_in(x50, x51) :|: TRUE
f40_in(x52, x53) -> f42_in(x52, x53) :|: TRUE
f42_out(x54, x55) -> f40_out(x54, x55) :|: TRUE
f40_in(x56, x57) -> f43_in(x56, x57) :|: TRUE
f43_out(x58, x59) -> f40_out(x58, x59) :|: TRUE
f43_in(x60, s(x61)) -> f53_in(x60, x61) :|: TRUE
f54_out -> f43_out(x62, x63) :|: TRUE
f43_in(x64, x65) -> f54_in :|: TRUE
f53_out(x66, x67) -> f43_out(x66, s(x67)) :|: TRUE
Start term: f1_in(T1, T2)

----------------------------------------

(223) IRSwTSimpleDependencyGraphProof (EQUIVALENT)
Constructed simple dependency graph.

Simplified to the following IRSwTs:

intTRSProblem:
f225_in(x, x1) -> f53_in(x, x1) :|: TRUE
f55_in(T24, T25) -> f59_in(T24, T25) :|: TRUE
f59_in(x14, x15) -> f84_in(x14, x15) :|: TRUE
f53_in(x18, x19) -> f55_in(x18, x19) :|: TRUE
f84_in(s(x22), s(x23)) -> f225_in(x22, x23) :|: TRUE


----------------------------------------

(224)
Obligation:
Rules:
f225_in(x, x1) -> f53_in(x, x1) :|: TRUE
f55_in(T24, T25) -> f59_in(T24, T25) :|: TRUE
f59_in(x14, x15) -> f84_in(x14, x15) :|: TRUE
f53_in(x18, x19) -> f55_in(x18, x19) :|: TRUE
f84_in(s(x22), s(x23)) -> f225_in(x22, x23) :|: TRUE

----------------------------------------

(225) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(226)
Obligation:
Rules:
f225_in(s(x22:0), s(x23:0)) -> f225_in(x22:0, x23:0) :|: TRUE

----------------------------------------

(227) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(228)
Obligation:
Rules:
f225_in(s(x22:0), s(x23:0)) -> f225_in(x22:0, x23:0) :|: TRUE

----------------------------------------

(229) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f225_in(s(x22:0), s(x23:0)) -> f225_in(x22:0, x23:0) :|: TRUE

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(230)
Obligation:

Termination digraph:
Nodes:
(1) f225_in(s(x22:0), s(x23:0)) -> f225_in(x22:0, x23:0) :|: TRUE

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(231) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f225_in(VARIABLE, VARIABLE)
s(VARIABLE)
Removed predefined arithmetic.
----------------------------------------

(232)
Obligation:
Rules:
f225_in(s(x22:0), s(x23:0)) -> f225_in(x22:0, x23:0)

----------------------------------------

(233) IRSwTToQDPProof (SOUND)
Removed the integers and created a QDP-Problem.
----------------------------------------

(234)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   f225_in(s(x22:0), s(x23:0)) -> f225_in(x22:0, x23:0)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(235) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*f225_in(s(x22:0), s(x23:0)) -> f225_in(x22:0, x23:0)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(236)
YES

----------------------------------------

(237)
Obligation:
Rules:
f55_in(T24, T25) -> f59_in(T24, T25) :|: TRUE
f58_out(x, x1) -> f55_out(x, x1) :|: TRUE
f55_in(x2, x3) -> f58_in(x2, x3) :|: TRUE
f59_out(x4, x5) -> f55_out(x4, x5) :|: TRUE
f84_out(x6, x7) -> f59_out(x6, x7) :|: TRUE
f59_in(x8, x9) -> f83_in(x8, x9) :|: TRUE
f83_out(x10, x11) -> f59_out(x10, x11) :|: TRUE
f59_in(x12, x13) -> f84_in(x12, x13) :|: TRUE
f434_in -> f434_out :|: TRUE
f1_out(T72, s(T67)) -> f428_out(T72, T67) :|: TRUE
f428_in(x14, x15) -> f1_in(x14, s(x15)) :|: TRUE
f47_out -> f42_out(T11, T10) :|: TRUE
f42_in(T19, 0) -> f46_in :|: TRUE
f46_out -> f42_out(x16, 0) :|: TRUE
f42_in(x17, x18) -> f47_in :|: TRUE
f238_out(x19, x20, x21) -> f36_out(x19, x20, x21) :|: TRUE
f36_in(x22, x23, x24) -> f238_in(x22, x23, x24) :|: TRUE
f31_out(x25, x26) -> f9_out(x26, s(x25)) :|: TRUE
f9_in(x27, s(x28)) -> f31_in(x28, x27) :|: TRUE
f32_out -> f9_out(T1, T2) :|: TRUE
f9_in(x29, x30) -> f32_in :|: TRUE
f433_in(x31, x32) -> f441_in :|: TRUE
f433_in(s(T84), s(T85)) -> f440_in(T84, T85) :|: TRUE
f441_out -> f433_out(x33, x34) :|: TRUE
f440_out(x35, x36) -> f433_out(s(x35), s(x36)) :|: TRUE
f238_in(x37, x38, x39) -> f242_in(x37, x38, x39) :|: TRUE
f241_out(x40, x41, x42) -> f238_out(x40, x41, x42) :|: TRUE
f238_in(x43, x44, x45) -> f241_in(x43, x44, x45) :|: TRUE
f242_out(x46, x47, x48) -> f238_out(x46, x47, x48) :|: TRUE
f431_in(x49, x50) -> f432_in(x49, x50) :|: TRUE
f433_out(x51, x52) -> f431_out(x51, x52) :|: TRUE
f431_in(x53, x54) -> f433_in(x53, x54) :|: TRUE
f432_out(x55, x56) -> f431_out(x55, x56) :|: TRUE
f191_in -> f191_out :|: TRUE
f53_out(T42, T43) -> f225_out(T42, T43) :|: TRUE
f225_in(x57, x58) -> f53_in(x57, x58) :|: TRUE
f61_in -> f61_out :|: TRUE
f78_out -> f58_out(x59, x60) :|: TRUE
f58_in(0, T32) -> f61_in :|: TRUE
f61_out -> f58_out(0, x61) :|: TRUE
f58_in(x62, x63) -> f78_in :|: TRUE
f422_out(x64, x65) -> f242_out(true, x64, x65) :|: TRUE
f242_in(true, x66, x67) -> f422_in(x66, x67) :|: TRUE
f424_out -> f242_out(x68, x69, x70) :|: TRUE
f242_in(x71, x72, x73) -> f424_in :|: TRUE
f55_out(x74, x75) -> f53_out(x74, x75) :|: TRUE
f53_in(x76, x77) -> f55_in(x76, x77) :|: TRUE
f83_in(s(T37), 0) -> f191_in :|: TRUE
f191_out -> f83_out(s(x78), 0) :|: TRUE
f83_in(x79, x80) -> f192_in :|: TRUE
f192_out -> f83_out(x81, x82) :|: TRUE
f427_out(x83, x84) -> f428_in(x85, x84) :|: TRUE
f422_in(x86, x87) -> f427_in(x86, x87) :|: TRUE
f428_out(x88, x89) -> f422_out(x90, x89) :|: TRUE
f46_in -> f46_out :|: TRUE
f35_in(x91, x92) -> f39_in(x91, x92) :|: TRUE
f39_out(x93, x94) -> f35_out(x93, x94) :|: TRUE
f43_in(x95, s(x96)) -> f53_in(x95, x96) :|: TRUE
f54_out -> f43_out(x97, x98) :|: TRUE
f43_in(x99, x100) -> f54_in :|: TRUE
f53_out(x101, x102) -> f43_out(x101, s(x102)) :|: TRUE
f427_in(x103, x104) -> f431_in(x103, x104) :|: TRUE
f431_out(x105, x106) -> f427_out(x105, x106) :|: TRUE
f440_in(x107, x108) -> f427_in(x107, x108) :|: TRUE
f427_out(x109, x110) -> f440_out(x109, x110) :|: TRUE
f1_in(x111, x112) -> f9_in(x111, x112) :|: TRUE
f9_out(x113, x114) -> f1_out(x113, x114) :|: TRUE
f40_out(x115, x116) -> f39_out(x115, x116) :|: TRUE
f39_in(x117, x118) -> f40_in(x117, x118) :|: TRUE
f36_out(x119, x120, x121) -> f31_out(x121, x120) :|: TRUE
f31_in(x122, x123) -> f35_in(x122, x123) :|: TRUE
f35_out(x124, x125) -> f36_in(x126, x125, x124) :|: TRUE
f434_out -> f432_out(T79, 0) :|: TRUE
f432_in(x127, 0) -> f434_in :|: TRUE
f435_out -> f432_out(x128, x129) :|: TRUE
f432_in(x130, x131) -> f435_in :|: TRUE
f226_out -> f84_out(x132, x133) :|: TRUE
f84_in(s(x134), s(x135)) -> f225_in(x134, x135) :|: TRUE
f225_out(x136, x137) -> f84_out(s(x136), s(x137)) :|: TRUE
f84_in(x138, x139) -> f226_in :|: TRUE
f40_in(x140, x141) -> f42_in(x140, x141) :|: TRUE
f42_out(x142, x143) -> f40_out(x142, x143) :|: TRUE
f40_in(x144, x145) -> f43_in(x144, x145) :|: TRUE
f43_out(x146, x147) -> f40_out(x146, x147) :|: TRUE
Start term: f1_in(T1, T2)

----------------------------------------

(238) IRSwTSimpleDependencyGraphProof (EQUIVALENT)
Constructed simple dependency graph.

Simplified to the following IRSwTs:

intTRSProblem:
f55_in(T24, T25) -> f59_in(T24, T25) :|: TRUE
f58_out(x, x1) -> f55_out(x, x1) :|: TRUE
f55_in(x2, x3) -> f58_in(x2, x3) :|: TRUE
f59_out(x4, x5) -> f55_out(x4, x5) :|: TRUE
f84_out(x6, x7) -> f59_out(x6, x7) :|: TRUE
f59_in(x8, x9) -> f83_in(x8, x9) :|: TRUE
f83_out(x10, x11) -> f59_out(x10, x11) :|: TRUE
f59_in(x12, x13) -> f84_in(x12, x13) :|: TRUE
f434_in -> f434_out :|: TRUE
f428_in(x14, x15) -> f1_in(x14, s(x15)) :|: TRUE
f42_in(T19, 0) -> f46_in :|: TRUE
f46_out -> f42_out(x16, 0) :|: TRUE
f36_in(x22, x23, x24) -> f238_in(x22, x23, x24) :|: TRUE
f9_in(x27, s(x28)) -> f31_in(x28, x27) :|: TRUE
f433_in(s(T84), s(T85)) -> f440_in(T84, T85) :|: TRUE
f440_out(x35, x36) -> f433_out(s(x35), s(x36)) :|: TRUE
f238_in(x37, x38, x39) -> f242_in(x37, x38, x39) :|: TRUE
f431_in(x49, x50) -> f432_in(x49, x50) :|: TRUE
f433_out(x51, x52) -> f431_out(x51, x52) :|: TRUE
f431_in(x53, x54) -> f433_in(x53, x54) :|: TRUE
f432_out(x55, x56) -> f431_out(x55, x56) :|: TRUE
f191_in -> f191_out :|: TRUE
f53_out(T42, T43) -> f225_out(T42, T43) :|: TRUE
f225_in(x57, x58) -> f53_in(x57, x58) :|: TRUE
f61_in -> f61_out :|: TRUE
f58_in(0, T32) -> f61_in :|: TRUE
f61_out -> f58_out(0, x61) :|: TRUE
f242_in(true, x66, x67) -> f422_in(x66, x67) :|: TRUE
f55_out(x74, x75) -> f53_out(x74, x75) :|: TRUE
f53_in(x76, x77) -> f55_in(x76, x77) :|: TRUE
f83_in(s(T37), 0) -> f191_in :|: TRUE
f191_out -> f83_out(s(x78), 0) :|: TRUE
f427_out(x83, x84) -> f428_in(x85, x84) :|: TRUE
f422_in(x86, x87) -> f427_in(x86, x87) :|: TRUE
f46_in -> f46_out :|: TRUE
f35_in(x91, x92) -> f39_in(x91, x92) :|: TRUE
f39_out(x93, x94) -> f35_out(x93, x94) :|: TRUE
f43_in(x95, s(x96)) -> f53_in(x95, x96) :|: TRUE
f53_out(x101, x102) -> f43_out(x101, s(x102)) :|: TRUE
f427_in(x103, x104) -> f431_in(x103, x104) :|: TRUE
f431_out(x105, x106) -> f427_out(x105, x106) :|: TRUE
f440_in(x107, x108) -> f427_in(x107, x108) :|: TRUE
f427_out(x109, x110) -> f440_out(x109, x110) :|: TRUE
f1_in(x111, x112) -> f9_in(x111, x112) :|: TRUE
f40_out(x115, x116) -> f39_out(x115, x116) :|: TRUE
f39_in(x117, x118) -> f40_in(x117, x118) :|: TRUE
f31_in(x122, x123) -> f35_in(x122, x123) :|: TRUE
f35_out(x124, x125) -> f36_in(x126, x125, x124) :|: TRUE
f434_out -> f432_out(T79, 0) :|: TRUE
f432_in(x127, 0) -> f434_in :|: TRUE
f84_in(s(x134), s(x135)) -> f225_in(x134, x135) :|: TRUE
f225_out(x136, x137) -> f84_out(s(x136), s(x137)) :|: TRUE
f40_in(x140, x141) -> f42_in(x140, x141) :|: TRUE
f42_out(x142, x143) -> f40_out(x142, x143) :|: TRUE
f40_in(x144, x145) -> f43_in(x144, x145) :|: TRUE
f43_out(x146, x147) -> f40_out(x146, x147) :|: TRUE


----------------------------------------

(239)
Obligation:
Rules:
f55_in(T24, T25) -> f59_in(T24, T25) :|: TRUE
f58_out(x, x1) -> f55_out(x, x1) :|: TRUE
f55_in(x2, x3) -> f58_in(x2, x3) :|: TRUE
f59_out(x4, x5) -> f55_out(x4, x5) :|: TRUE
f84_out(x6, x7) -> f59_out(x6, x7) :|: TRUE
f59_in(x8, x9) -> f83_in(x8, x9) :|: TRUE
f83_out(x10, x11) -> f59_out(x10, x11) :|: TRUE
f59_in(x12, x13) -> f84_in(x12, x13) :|: TRUE
f434_in -> f434_out :|: TRUE
f428_in(x14, x15) -> f1_in(x14, s(x15)) :|: TRUE
f42_in(T19, 0) -> f46_in :|: TRUE
f46_out -> f42_out(x16, 0) :|: TRUE
f36_in(x22, x23, x24) -> f238_in(x22, x23, x24) :|: TRUE
f9_in(x27, s(x28)) -> f31_in(x28, x27) :|: TRUE
f433_in(s(T84), s(T85)) -> f440_in(T84, T85) :|: TRUE
f440_out(x35, x36) -> f433_out(s(x35), s(x36)) :|: TRUE
f238_in(x37, x38, x39) -> f242_in(x37, x38, x39) :|: TRUE
f431_in(x49, x50) -> f432_in(x49, x50) :|: TRUE
f433_out(x51, x52) -> f431_out(x51, x52) :|: TRUE
f431_in(x53, x54) -> f433_in(x53, x54) :|: TRUE
f432_out(x55, x56) -> f431_out(x55, x56) :|: TRUE
f191_in -> f191_out :|: TRUE
f53_out(T42, T43) -> f225_out(T42, T43) :|: TRUE
f225_in(x57, x58) -> f53_in(x57, x58) :|: TRUE
f61_in -> f61_out :|: TRUE
f58_in(0, T32) -> f61_in :|: TRUE
f61_out -> f58_out(0, x61) :|: TRUE
f242_in(true, x66, x67) -> f422_in(x66, x67) :|: TRUE
f55_out(x74, x75) -> f53_out(x74, x75) :|: TRUE
f53_in(x76, x77) -> f55_in(x76, x77) :|: TRUE
f83_in(s(T37), 0) -> f191_in :|: TRUE
f191_out -> f83_out(s(x78), 0) :|: TRUE
f427_out(x83, x84) -> f428_in(x85, x84) :|: TRUE
f422_in(x86, x87) -> f427_in(x86, x87) :|: TRUE
f46_in -> f46_out :|: TRUE
f35_in(x91, x92) -> f39_in(x91, x92) :|: TRUE
f39_out(x93, x94) -> f35_out(x93, x94) :|: TRUE
f43_in(x95, s(x96)) -> f53_in(x95, x96) :|: TRUE
f53_out(x101, x102) -> f43_out(x101, s(x102)) :|: TRUE
f427_in(x103, x104) -> f431_in(x103, x104) :|: TRUE
f431_out(x105, x106) -> f427_out(x105, x106) :|: TRUE
f440_in(x107, x108) -> f427_in(x107, x108) :|: TRUE
f427_out(x109, x110) -> f440_out(x109, x110) :|: TRUE
f1_in(x111, x112) -> f9_in(x111, x112) :|: TRUE
f40_out(x115, x116) -> f39_out(x115, x116) :|: TRUE
f39_in(x117, x118) -> f40_in(x117, x118) :|: TRUE
f31_in(x122, x123) -> f35_in(x122, x123) :|: TRUE
f35_out(x124, x125) -> f36_in(x126, x125, x124) :|: TRUE
f434_out -> f432_out(T79, 0) :|: TRUE
f432_in(x127, 0) -> f434_in :|: TRUE
f84_in(s(x134), s(x135)) -> f225_in(x134, x135) :|: TRUE
f225_out(x136, x137) -> f84_out(s(x136), s(x137)) :|: TRUE
f40_in(x140, x141) -> f42_in(x140, x141) :|: TRUE
f42_out(x142, x143) -> f40_out(x142, x143) :|: TRUE
f40_in(x144, x145) -> f43_in(x144, x145) :|: TRUE
f43_out(x146, x147) -> f40_out(x146, x147) :|: TRUE

----------------------------------------

(240) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(241)
Obligation:
Rules:
f55_in(cons_0, x3:0) -> f53_out(0, x61:0) :|: TRUE && cons_0 = 0
f427_out(x83:0, x84:0) -> f55_in(x84:0, x96:0) :|: TRUE
f431_in(x, x1) -> f427_out(x2, 0) :|: TRUE && x1 = 0
f55_in(s(x3), x4) -> f53_out(s(x5), 0) :|: TRUE && x4 = 0
f55_in(s(x134:0), s(x135:0)) -> f55_in(x134:0, x135:0) :|: TRUE
f53_out(x101:0, x102:0) -> f431_in(s(x102:0), x101:0) :|: TRUE
f427_out(x109:0, x110:0) -> f427_out(s(x109:0), s(x110:0)) :|: TRUE
f427_out(x6, x7) -> f431_in(0, x8) :|: TRUE
f53_out(T42:0, T43:0) -> f53_out(s(T42:0), s(T43:0)) :|: TRUE
f431_in(s(T84:0), s(T85:0)) -> f431_in(T84:0, T85:0) :|: TRUE

----------------------------------------

(242) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(243)
Obligation:
Rules:
f55_in(cons_0, x3:0) -> f53_out(0, x61:0) :|: TRUE && cons_0 = 0
f427_out(x83:0, x84:0) -> f55_in(x84:0, x96:0) :|: TRUE
f431_in(x, x1) -> f427_out(x2, 0) :|: TRUE && x1 = 0
f55_in(s(x3), x4) -> f53_out(s(x5), 0) :|: TRUE && x4 = 0
f55_in(s(x134:0), s(x135:0)) -> f55_in(x134:0, x135:0) :|: TRUE
f53_out(x101:0, x102:0) -> f431_in(s(x102:0), x101:0) :|: TRUE
f427_out(x109:0, x110:0) -> f427_out(s(x109:0), s(x110:0)) :|: TRUE
f427_out(x6, x7) -> f431_in(0, x8) :|: TRUE
f53_out(T42:0, T43:0) -> f53_out(s(T42:0), s(T43:0)) :|: TRUE
f431_in(s(T84:0), s(T85:0)) -> f431_in(T84:0, T85:0) :|: TRUE

----------------------------------------

(244) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f55_in(cons_0, x3:0) -> f53_out(0, x61:0) :|: TRUE && cons_0 = 0
(2) f427_out(x83:0, x84:0) -> f55_in(x84:0, x96:0) :|: TRUE
(3) f431_in(x, x1) -> f427_out(x2, 0) :|: TRUE && x1 = 0
(4) f55_in(s(x3), x4) -> f53_out(s(x5), 0) :|: TRUE && x4 = 0
(5) f55_in(s(x134:0), s(x135:0)) -> f55_in(x134:0, x135:0) :|: TRUE
(6) f53_out(x101:0, x102:0) -> f431_in(s(x102:0), x101:0) :|: TRUE
(7) f427_out(x109:0, x110:0) -> f427_out(s(x109:0), s(x110:0)) :|: TRUE
(8) f427_out(x6, x7) -> f431_in(0, x8) :|: TRUE
(9) f53_out(T42:0, T43:0) -> f53_out(s(T42:0), s(T43:0)) :|: TRUE
(10) f431_in(s(T84:0), s(T85:0)) -> f431_in(T84:0, T85:0) :|: TRUE

Arcs:
(1) -> (6), (9)
(2) -> (1), (4), (5)
(3) -> (2), (7), (8)
(4) -> (6), (9)
(5) -> (1), (4), (5)
(6) -> (3), (10)
(7) -> (2), (7), (8)
(8) -> (3)
(9) -> (6), (9)
(10) -> (3), (10)

This digraph is fully evaluated!
----------------------------------------

(245)
Obligation:

Termination digraph:
Nodes:
(1) f55_in(cons_0, x3:0) -> f53_out(0, x61:0) :|: TRUE && cons_0 = 0
(2) f427_out(x83:0, x84:0) -> f55_in(x84:0, x96:0) :|: TRUE
(3) f431_in(x, x1) -> f427_out(x2, 0) :|: TRUE && x1 = 0
(4) f431_in(s(T84:0), s(T85:0)) -> f431_in(T84:0, T85:0) :|: TRUE
(5) f427_out(x6, x7) -> f431_in(0, x8) :|: TRUE
(6) f427_out(x109:0, x110:0) -> f427_out(s(x109:0), s(x110:0)) :|: TRUE
(7) f53_out(x101:0, x102:0) -> f431_in(s(x102:0), x101:0) :|: TRUE
(8) f53_out(T42:0, T43:0) -> f53_out(s(T42:0), s(T43:0)) :|: TRUE
(9) f55_in(s(x3), x4) -> f53_out(s(x5), 0) :|: TRUE && x4 = 0
(10) f55_in(s(x134:0), s(x135:0)) -> f55_in(x134:0, x135:0) :|: TRUE

Arcs:
(1) -> (7), (8)
(2) -> (1), (9), (10)
(3) -> (2), (5), (6)
(4) -> (3), (4)
(5) -> (3)
(6) -> (2), (5), (6)
(7) -> (3), (4)
(8) -> (7), (8)
(9) -> (7), (8)
(10) -> (1), (9), (10)

This digraph is fully evaluated!

----------------------------------------

(246) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(247)
Obligation:
Rules:
f53_out(T42:0:0, T43:0:0) -> f53_out(s(T42:0:0), s(T43:0:0)) :|: TRUE
f53_out(x101:0:0, x102:0:0) -> f431_in(s(x102:0:0), x101:0:0) :|: TRUE
f431_in(x:0, cons_0) -> f427_out(x2:0, 0) :|: TRUE && cons_0 = 0
f427_out(x83:0:0, x84:0:0) -> f55_in(x84:0:0, x96:0:0) :|: TRUE
f427_out(x6:0, x7:0) -> f431_in(0, x8:0) :|: TRUE
f427_out(x109:0:0, x110:0:0) -> f427_out(s(x109:0:0), s(x110:0:0)) :|: TRUE
f55_in(x, x1) -> f53_out(0, x2) :|: TRUE && x = 0
f55_in(s(x134:0:0), s(x135:0:0)) -> f55_in(x134:0:0, x135:0:0) :|: TRUE
f55_in(s(x3), x4) -> f53_out(s(x5), 0) :|: TRUE && x4 = 0
f431_in(s(T84:0:0), s(T85:0:0)) -> f431_in(T84:0:0, T85:0:0) :|: TRUE

----------------------------------------

(248) IntTRSUnneededArgumentFilterProof (EQUIVALENT)
Some arguments are removed because they cannot influence termination. We removed arguments according to the following replacements:

   f427_out(x1, x2) -> f427_out(x2)

----------------------------------------

(249)
Obligation:
Rules:
f53_out(T42:0:0, T43:0:0) -> f53_out(s(T42:0:0), s(T43:0:0)) :|: TRUE
f53_out(x101:0:0, x102:0:0) -> f431_in(s(x102:0:0), x101:0:0) :|: TRUE
f431_in(x:0, cons_0) -> f427_out(0) :|: TRUE && cons_0 = 0
f427_out(x84:0:0) -> f55_in(x84:0:0, x96:0:0) :|: TRUE
f427_out(x7:0) -> f431_in(0, x8:0) :|: TRUE
f427_out(x110:0:0) -> f427_out(s(x110:0:0)) :|: TRUE
f55_in(x, x1) -> f53_out(0, x2) :|: TRUE && x = 0
f55_in(s(x134:0:0), s(x135:0:0)) -> f55_in(x134:0:0, x135:0:0) :|: TRUE
f55_in(s(x3), x4) -> f53_out(s(x5), 0) :|: TRUE && x4 = 0
f431_in(s(T84:0:0), s(T85:0:0)) -> f431_in(T84:0:0, T85:0:0) :|: TRUE

----------------------------------------

(250) IRSwTToIntTRSProof (SOUND)
Applied path-length measure to transform intTRS with terms to intTRS.
----------------------------------------

(251)
Obligation:
Rules:
f53_out(x, x1) -> f53_out(s(x), s(x1)) :|: TRUE
f53_out(x2, x3) -> f431_in(s(x3), x2) :|: TRUE
f431_in(x4, cons_0) -> f427_out(0) :|: TRUE && cons_0 = 0
f427_out(x6) -> f55_in(x6, x7) :|: TRUE
f427_out(x8) -> f431_in(0, x9) :|: TRUE
f427_out(x10) -> f427_out(s(x10)) :|: TRUE
f55_in(x5, x11) -> f53_out(0, x17) :|: TRUE && x5 = 0
f55_in(s(x14), s(x15)) -> f55_in(x14, x15) :|: TRUE
f55_in(s(x21), x22) -> f53_out(s(x23), 0) :|: TRUE && x22 = 0
f431_in(s(x19), s(x20)) -> f431_in(x19, x20) :|: TRUE

----------------------------------------

(252) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(253)
Obligation:
Rules:
f53_out(x:0, x1:0) -> f53_out(s(x:0), s(x1:0)) :|: TRUE
f53_out(x2:0, x3:0) -> f431_in(s(x3:0), x2:0) :|: TRUE
f427_out(x8:0) -> f431_in(0, x9:0) :|: TRUE
f427_out(x10:0) -> f427_out(s(x10:0)) :|: TRUE
f431_in(x4:0, cons_0) -> f427_out(0) :|: TRUE && cons_0 = 0
f427_out(x6:0) -> f55_in(x6:0, x7:0) :|: TRUE
f55_in(x, x1) -> f53_out(0, x2) :|: TRUE && x = 0
f55_in(s(x14:0), s(x15:0)) -> f55_in(x14:0, x15:0) :|: TRUE
f55_in(s(x3), x4) -> f53_out(s(x5), 0) :|: TRUE && x4 = 0
f431_in(s(x19:0), s(x20:0)) -> f431_in(x19:0, x20:0) :|: TRUE
