MAYBE
proof of /hpcwork/ff862203/termcomp25/benchmarks/Ba718.pl
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Left Termination of the query pattern

reach(g,g,g)

w.r.t. the given Prolog program could not be shown:

(0) Prolog
(1) PrologToPiTRSProof [SOUND, 0 ms]
(2) PiTRS
    (3) DependencyPairsProof [EQUIVALENT, 0 ms]
    (4) PiDP
    (5) DependencyGraphProof [EQUIVALENT, 0 ms]
    (6) AND
        (7) PiDP
            (8) UsableRulesProof [EQUIVALENT, 0 ms]
            (9) PiDP
            (10) PiDPToQDPProof [SOUND, 0 ms]
            (11) QDP
            (12) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (13) YES
        (14) PiDP
            (15) UsableRulesProof [EQUIVALENT, 0 ms]
            (16) PiDP
            (17) PiDPToQDPProof [EQUIVALENT, 0 ms]
            (18) QDP
            (19) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (20) YES
        (21) PiDP
            (22) UsableRulesProof [EQUIVALENT, 0 ms]
            (23) PiDP
            (24) PiDPToQDPProof [SOUND, 0 ms]
            (25) QDP
            (26) TransformationProof [SOUND, 0 ms]
            (27) QDP
            (28) TransformationProof [EQUIVALENT, 0 ms]
            (29) QDP
            (30) TransformationProof [EQUIVALENT, 0 ms]
            (31) QDP
(32) PrologToPiTRSProof [SOUND, 0 ms]
(33) PiTRS
    (34) DependencyPairsProof [EQUIVALENT, 0 ms]
    (35) PiDP
    (36) DependencyGraphProof [EQUIVALENT, 0 ms]
    (37) AND
        (38) PiDP
            (39) UsableRulesProof [EQUIVALENT, 0 ms]
            (40) PiDP
            (41) PiDPToQDPProof [SOUND, 0 ms]
            (42) QDP
            (43) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (44) YES
        (45) PiDP
            (46) UsableRulesProof [EQUIVALENT, 0 ms]
            (47) PiDP
            (48) PiDPToQDPProof [EQUIVALENT, 0 ms]
            (49) QDP
            (50) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (51) YES
        (52) PiDP
            (53) UsableRulesProof [EQUIVALENT, 0 ms]
            (54) PiDP
            (55) PiDPToQDPProof [SOUND, 1 ms]
            (56) QDP
            (57) TransformationProof [SOUND, 0 ms]
            (58) QDP
            (59) TransformationProof [EQUIVALENT, 0 ms]
            (60) QDP
            (61) TransformationProof [EQUIVALENT, 0 ms]
            (62) QDP
(63) PrologToDTProblemTransformerProof [SOUND, 0 ms]
(64) TRIPLES
    (65) TriplesToPiDPProof [SOUND, 0 ms]
    (66) PiDP
    (67) DependencyGraphProof [EQUIVALENT, 0 ms]
    (68) AND
        (69) PiDP
            (70) UsableRulesProof [EQUIVALENT, 0 ms]
            (71) PiDP
            (72) PiDPToQDPProof [SOUND, 0 ms]
            (73) QDP
            (74) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (75) YES
        (76) PiDP
            (77) UsableRulesProof [EQUIVALENT, 0 ms]
            (78) PiDP
            (79) PiDPToQDPProof [EQUIVALENT, 0 ms]
            (80) QDP
            (81) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (82) YES
        (83) PiDP
            (84) PiDPToQDPProof [SOUND, 2 ms]
            (85) QDP
            (86) TransformationProof [SOUND, 0 ms]
            (87) QDP
            (88) TransformationProof [EQUIVALENT, 0 ms]
            (89) QDP
(90) PrologToTRSTransformerProof [SOUND, 0 ms]
(91) QTRS
    (92) DependencyPairsProof [EQUIVALENT, 0 ms]
    (93) QDP
    (94) DependencyGraphProof [EQUIVALENT, 0 ms]
    (95) AND
        (96) QDP
            (97) UsableRulesProof [EQUIVALENT, 0 ms]
            (98) QDP
            (99) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (100) YES
        (101) QDP
            (102) UsableRulesProof [EQUIVALENT, 0 ms]
            (103) QDP
            (104) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (105) YES
        (106) QDP
            (107) NonTerminationLoopProof [COMPLETE, 233 ms]
            (108) NO
(109) PrologToIRSwTTransformerProof [SOUND, 0 ms]
(110) AND
    (111) IRSwT
        (112) IRSwTSimpleDependencyGraphProof [EQUIVALENT, 0 ms]
        (113) IRSwT
        (114) IntTRSCompressionProof [EQUIVALENT, 9 ms]
        (115) IRSwT
        (116) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
        (117) IRSwT
        (118) IRSwTTerminationDigraphProof [EQUIVALENT, 2 ms]
        (119) IRSwT
        (120) IntTRSUnneededArgumentFilterProof [EQUIVALENT, 10 ms]
        (121) IRSwT
        (122) TempFilterProof [SOUND, 1 ms]
        (123) IRSwT
        (124) IRSwTToQDPProof [SOUND, 0 ms]
        (125) QDP
        (126) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (127) YES
    (128) IRSwT
        (129) IRSwTSimpleDependencyGraphProof [EQUIVALENT, 0 ms]
        (130) IRSwT
        (131) IntTRSCompressionProof [EQUIVALENT, 1 ms]
        (132) IRSwT
        (133) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
        (134) IRSwT
        (135) IRSwTTerminationDigraphProof [EQUIVALENT, 0 ms]
        (136) IRSwT
        (137) IntTRSUnneededArgumentFilterProof [EQUIVALENT, 0 ms]
        (138) IRSwT
        (139) TempFilterProof [SOUND, 1 ms]
        (140) IRSwT
        (141) IRSwTToQDPProof [SOUND, 0 ms]
        (142) QDP
        (143) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (144) YES
    (145) IRSwT
        (146) IRSwTSimpleDependencyGraphProof [EQUIVALENT, 0 ms]
        (147) IRSwT
        (148) IntTRSCompressionProof [EQUIVALENT, 6 ms]
        (149) IRSwT
        (150) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
        (151) IRSwT


----------------------------------------

(0)
Obligation:
Clauses:

reach(X, Y, Edges) :- member(.(X, .(Y, [])), Edges).
reach(X, Z, Edges) :- ','(member1(.(X, .(Y, [])), Edges), reach(Y, Z, Edges)).
member(H, .(H, L)).
member(X, .(H, L)) :- member(X, L).
member1(H, .(H, L)).
member1(X, .(H, L)) :- member1(X, L).


Query: reach(g,g,g)
----------------------------------------

(1) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

reach_in_3: (b,b,b)

member_in_2: (b,b)

member1_in_2: (f,b)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   reach_in_ggg(X, Y, Edges) -> U1_ggg(X, Y, Edges, member_in_gg(.(X, .(Y, [])), Edges))
   member_in_gg(H, .(H, L)) -> member_out_gg(H, .(H, L))
   member_in_gg(X, .(H, L)) -> U4_gg(X, H, L, member_in_gg(X, L))
   U4_gg(X, H, L, member_out_gg(X, L)) -> member_out_gg(X, .(H, L))
   U1_ggg(X, Y, Edges, member_out_gg(.(X, .(Y, [])), Edges)) -> reach_out_ggg(X, Y, Edges)
   reach_in_ggg(X, Z, Edges) -> U2_ggg(X, Z, Edges, member1_in_ag(.(X, .(Y, [])), Edges))
   member1_in_ag(H, .(H, L)) -> member1_out_ag(H, .(H, L))
   member1_in_ag(X, .(H, L)) -> U5_ag(X, H, L, member1_in_ag(X, L))
   U5_ag(X, H, L, member1_out_ag(X, L)) -> member1_out_ag(X, .(H, L))
   U2_ggg(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> U3_ggg(X, Z, Edges, reach_in_ggg(Y, Z, Edges))
   U3_ggg(X, Z, Edges, reach_out_ggg(Y, Z, Edges)) -> reach_out_ggg(X, Z, Edges)

The argument filtering Pi contains the following mapping:
reach_in_ggg(x1, x2, x3)  =  reach_in_ggg(x1, x2, x3)

U1_ggg(x1, x2, x3, x4)  =  U1_ggg(x4)

member_in_gg(x1, x2)  =  member_in_gg(x1, x2)

.(x1, x2)  =  .(x1, x2)

member_out_gg(x1, x2)  =  member_out_gg

U4_gg(x1, x2, x3, x4)  =  U4_gg(x4)

[]  =  []

reach_out_ggg(x1, x2, x3)  =  reach_out_ggg

U2_ggg(x1, x2, x3, x4)  =  U2_ggg(x2, x3, x4)

member1_in_ag(x1, x2)  =  member1_in_ag(x2)

member1_out_ag(x1, x2)  =  member1_out_ag(x1)

U5_ag(x1, x2, x3, x4)  =  U5_ag(x4)

U3_ggg(x1, x2, x3, x4)  =  U3_ggg(x4)





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(2)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   reach_in_ggg(X, Y, Edges) -> U1_ggg(X, Y, Edges, member_in_gg(.(X, .(Y, [])), Edges))
   member_in_gg(H, .(H, L)) -> member_out_gg(H, .(H, L))
   member_in_gg(X, .(H, L)) -> U4_gg(X, H, L, member_in_gg(X, L))
   U4_gg(X, H, L, member_out_gg(X, L)) -> member_out_gg(X, .(H, L))
   U1_ggg(X, Y, Edges, member_out_gg(.(X, .(Y, [])), Edges)) -> reach_out_ggg(X, Y, Edges)
   reach_in_ggg(X, Z, Edges) -> U2_ggg(X, Z, Edges, member1_in_ag(.(X, .(Y, [])), Edges))
   member1_in_ag(H, .(H, L)) -> member1_out_ag(H, .(H, L))
   member1_in_ag(X, .(H, L)) -> U5_ag(X, H, L, member1_in_ag(X, L))
   U5_ag(X, H, L, member1_out_ag(X, L)) -> member1_out_ag(X, .(H, L))
   U2_ggg(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> U3_ggg(X, Z, Edges, reach_in_ggg(Y, Z, Edges))
   U3_ggg(X, Z, Edges, reach_out_ggg(Y, Z, Edges)) -> reach_out_ggg(X, Z, Edges)

The argument filtering Pi contains the following mapping:
reach_in_ggg(x1, x2, x3)  =  reach_in_ggg(x1, x2, x3)

U1_ggg(x1, x2, x3, x4)  =  U1_ggg(x4)

member_in_gg(x1, x2)  =  member_in_gg(x1, x2)

.(x1, x2)  =  .(x1, x2)

member_out_gg(x1, x2)  =  member_out_gg

U4_gg(x1, x2, x3, x4)  =  U4_gg(x4)

[]  =  []

reach_out_ggg(x1, x2, x3)  =  reach_out_ggg

U2_ggg(x1, x2, x3, x4)  =  U2_ggg(x2, x3, x4)

member1_in_ag(x1, x2)  =  member1_in_ag(x2)

member1_out_ag(x1, x2)  =  member1_out_ag(x1)

U5_ag(x1, x2, x3, x4)  =  U5_ag(x4)

U3_ggg(x1, x2, x3, x4)  =  U3_ggg(x4)



----------------------------------------

(3) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   REACH_IN_GGG(X, Y, Edges) -> U1_GGG(X, Y, Edges, member_in_gg(.(X, .(Y, [])), Edges))
   REACH_IN_GGG(X, Y, Edges) -> MEMBER_IN_GG(.(X, .(Y, [])), Edges)
   MEMBER_IN_GG(X, .(H, L)) -> U4_GG(X, H, L, member_in_gg(X, L))
   MEMBER_IN_GG(X, .(H, L)) -> MEMBER_IN_GG(X, L)
   REACH_IN_GGG(X, Z, Edges) -> U2_GGG(X, Z, Edges, member1_in_ag(.(X, .(Y, [])), Edges))
   REACH_IN_GGG(X, Z, Edges) -> MEMBER1_IN_AG(.(X, .(Y, [])), Edges)
   MEMBER1_IN_AG(X, .(H, L)) -> U5_AG(X, H, L, member1_in_ag(X, L))
   MEMBER1_IN_AG(X, .(H, L)) -> MEMBER1_IN_AG(X, L)
   U2_GGG(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> U3_GGG(X, Z, Edges, reach_in_ggg(Y, Z, Edges))
   U2_GGG(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> REACH_IN_GGG(Y, Z, Edges)

The TRS R consists of the following rules:

   reach_in_ggg(X, Y, Edges) -> U1_ggg(X, Y, Edges, member_in_gg(.(X, .(Y, [])), Edges))
   member_in_gg(H, .(H, L)) -> member_out_gg(H, .(H, L))
   member_in_gg(X, .(H, L)) -> U4_gg(X, H, L, member_in_gg(X, L))
   U4_gg(X, H, L, member_out_gg(X, L)) -> member_out_gg(X, .(H, L))
   U1_ggg(X, Y, Edges, member_out_gg(.(X, .(Y, [])), Edges)) -> reach_out_ggg(X, Y, Edges)
   reach_in_ggg(X, Z, Edges) -> U2_ggg(X, Z, Edges, member1_in_ag(.(X, .(Y, [])), Edges))
   member1_in_ag(H, .(H, L)) -> member1_out_ag(H, .(H, L))
   member1_in_ag(X, .(H, L)) -> U5_ag(X, H, L, member1_in_ag(X, L))
   U5_ag(X, H, L, member1_out_ag(X, L)) -> member1_out_ag(X, .(H, L))
   U2_ggg(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> U3_ggg(X, Z, Edges, reach_in_ggg(Y, Z, Edges))
   U3_ggg(X, Z, Edges, reach_out_ggg(Y, Z, Edges)) -> reach_out_ggg(X, Z, Edges)

The argument filtering Pi contains the following mapping:
reach_in_ggg(x1, x2, x3)  =  reach_in_ggg(x1, x2, x3)

U1_ggg(x1, x2, x3, x4)  =  U1_ggg(x4)

member_in_gg(x1, x2)  =  member_in_gg(x1, x2)

.(x1, x2)  =  .(x1, x2)

member_out_gg(x1, x2)  =  member_out_gg

U4_gg(x1, x2, x3, x4)  =  U4_gg(x4)

[]  =  []

reach_out_ggg(x1, x2, x3)  =  reach_out_ggg

U2_ggg(x1, x2, x3, x4)  =  U2_ggg(x2, x3, x4)

member1_in_ag(x1, x2)  =  member1_in_ag(x2)

member1_out_ag(x1, x2)  =  member1_out_ag(x1)

U5_ag(x1, x2, x3, x4)  =  U5_ag(x4)

U3_ggg(x1, x2, x3, x4)  =  U3_ggg(x4)

REACH_IN_GGG(x1, x2, x3)  =  REACH_IN_GGG(x1, x2, x3)

U1_GGG(x1, x2, x3, x4)  =  U1_GGG(x4)

MEMBER_IN_GG(x1, x2)  =  MEMBER_IN_GG(x1, x2)

U4_GG(x1, x2, x3, x4)  =  U4_GG(x4)

U2_GGG(x1, x2, x3, x4)  =  U2_GGG(x2, x3, x4)

MEMBER1_IN_AG(x1, x2)  =  MEMBER1_IN_AG(x2)

U5_AG(x1, x2, x3, x4)  =  U5_AG(x4)

U3_GGG(x1, x2, x3, x4)  =  U3_GGG(x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(4)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   REACH_IN_GGG(X, Y, Edges) -> U1_GGG(X, Y, Edges, member_in_gg(.(X, .(Y, [])), Edges))
   REACH_IN_GGG(X, Y, Edges) -> MEMBER_IN_GG(.(X, .(Y, [])), Edges)
   MEMBER_IN_GG(X, .(H, L)) -> U4_GG(X, H, L, member_in_gg(X, L))
   MEMBER_IN_GG(X, .(H, L)) -> MEMBER_IN_GG(X, L)
   REACH_IN_GGG(X, Z, Edges) -> U2_GGG(X, Z, Edges, member1_in_ag(.(X, .(Y, [])), Edges))
   REACH_IN_GGG(X, Z, Edges) -> MEMBER1_IN_AG(.(X, .(Y, [])), Edges)
   MEMBER1_IN_AG(X, .(H, L)) -> U5_AG(X, H, L, member1_in_ag(X, L))
   MEMBER1_IN_AG(X, .(H, L)) -> MEMBER1_IN_AG(X, L)
   U2_GGG(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> U3_GGG(X, Z, Edges, reach_in_ggg(Y, Z, Edges))
   U2_GGG(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> REACH_IN_GGG(Y, Z, Edges)

The TRS R consists of the following rules:

   reach_in_ggg(X, Y, Edges) -> U1_ggg(X, Y, Edges, member_in_gg(.(X, .(Y, [])), Edges))
   member_in_gg(H, .(H, L)) -> member_out_gg(H, .(H, L))
   member_in_gg(X, .(H, L)) -> U4_gg(X, H, L, member_in_gg(X, L))
   U4_gg(X, H, L, member_out_gg(X, L)) -> member_out_gg(X, .(H, L))
   U1_ggg(X, Y, Edges, member_out_gg(.(X, .(Y, [])), Edges)) -> reach_out_ggg(X, Y, Edges)
   reach_in_ggg(X, Z, Edges) -> U2_ggg(X, Z, Edges, member1_in_ag(.(X, .(Y, [])), Edges))
   member1_in_ag(H, .(H, L)) -> member1_out_ag(H, .(H, L))
   member1_in_ag(X, .(H, L)) -> U5_ag(X, H, L, member1_in_ag(X, L))
   U5_ag(X, H, L, member1_out_ag(X, L)) -> member1_out_ag(X, .(H, L))
   U2_ggg(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> U3_ggg(X, Z, Edges, reach_in_ggg(Y, Z, Edges))
   U3_ggg(X, Z, Edges, reach_out_ggg(Y, Z, Edges)) -> reach_out_ggg(X, Z, Edges)

The argument filtering Pi contains the following mapping:
reach_in_ggg(x1, x2, x3)  =  reach_in_ggg(x1, x2, x3)

U1_ggg(x1, x2, x3, x4)  =  U1_ggg(x4)

member_in_gg(x1, x2)  =  member_in_gg(x1, x2)

.(x1, x2)  =  .(x1, x2)

member_out_gg(x1, x2)  =  member_out_gg

U4_gg(x1, x2, x3, x4)  =  U4_gg(x4)

[]  =  []

reach_out_ggg(x1, x2, x3)  =  reach_out_ggg

U2_ggg(x1, x2, x3, x4)  =  U2_ggg(x2, x3, x4)

member1_in_ag(x1, x2)  =  member1_in_ag(x2)

member1_out_ag(x1, x2)  =  member1_out_ag(x1)

U5_ag(x1, x2, x3, x4)  =  U5_ag(x4)

U3_ggg(x1, x2, x3, x4)  =  U3_ggg(x4)

REACH_IN_GGG(x1, x2, x3)  =  REACH_IN_GGG(x1, x2, x3)

U1_GGG(x1, x2, x3, x4)  =  U1_GGG(x4)

MEMBER_IN_GG(x1, x2)  =  MEMBER_IN_GG(x1, x2)

U4_GG(x1, x2, x3, x4)  =  U4_GG(x4)

U2_GGG(x1, x2, x3, x4)  =  U2_GGG(x2, x3, x4)

MEMBER1_IN_AG(x1, x2)  =  MEMBER1_IN_AG(x2)

U5_AG(x1, x2, x3, x4)  =  U5_AG(x4)

U3_GGG(x1, x2, x3, x4)  =  U3_GGG(x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(5) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 3 SCCs with 6 less nodes.
----------------------------------------

(6)
Complex Obligation (AND)

----------------------------------------

(7)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MEMBER1_IN_AG(X, .(H, L)) -> MEMBER1_IN_AG(X, L)

The TRS R consists of the following rules:

   reach_in_ggg(X, Y, Edges) -> U1_ggg(X, Y, Edges, member_in_gg(.(X, .(Y, [])), Edges))
   member_in_gg(H, .(H, L)) -> member_out_gg(H, .(H, L))
   member_in_gg(X, .(H, L)) -> U4_gg(X, H, L, member_in_gg(X, L))
   U4_gg(X, H, L, member_out_gg(X, L)) -> member_out_gg(X, .(H, L))
   U1_ggg(X, Y, Edges, member_out_gg(.(X, .(Y, [])), Edges)) -> reach_out_ggg(X, Y, Edges)
   reach_in_ggg(X, Z, Edges) -> U2_ggg(X, Z, Edges, member1_in_ag(.(X, .(Y, [])), Edges))
   member1_in_ag(H, .(H, L)) -> member1_out_ag(H, .(H, L))
   member1_in_ag(X, .(H, L)) -> U5_ag(X, H, L, member1_in_ag(X, L))
   U5_ag(X, H, L, member1_out_ag(X, L)) -> member1_out_ag(X, .(H, L))
   U2_ggg(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> U3_ggg(X, Z, Edges, reach_in_ggg(Y, Z, Edges))
   U3_ggg(X, Z, Edges, reach_out_ggg(Y, Z, Edges)) -> reach_out_ggg(X, Z, Edges)

The argument filtering Pi contains the following mapping:
reach_in_ggg(x1, x2, x3)  =  reach_in_ggg(x1, x2, x3)

U1_ggg(x1, x2, x3, x4)  =  U1_ggg(x4)

member_in_gg(x1, x2)  =  member_in_gg(x1, x2)

.(x1, x2)  =  .(x1, x2)

member_out_gg(x1, x2)  =  member_out_gg

U4_gg(x1, x2, x3, x4)  =  U4_gg(x4)

[]  =  []

reach_out_ggg(x1, x2, x3)  =  reach_out_ggg

U2_ggg(x1, x2, x3, x4)  =  U2_ggg(x2, x3, x4)

member1_in_ag(x1, x2)  =  member1_in_ag(x2)

member1_out_ag(x1, x2)  =  member1_out_ag(x1)

U5_ag(x1, x2, x3, x4)  =  U5_ag(x4)

U3_ggg(x1, x2, x3, x4)  =  U3_ggg(x4)

MEMBER1_IN_AG(x1, x2)  =  MEMBER1_IN_AG(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(8) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(9)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MEMBER1_IN_AG(X, .(H, L)) -> MEMBER1_IN_AG(X, L)

R is empty.
The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x1, x2)

MEMBER1_IN_AG(x1, x2)  =  MEMBER1_IN_AG(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(10) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(11)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MEMBER1_IN_AG(.(H, L)) -> MEMBER1_IN_AG(L)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(12) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*MEMBER1_IN_AG(.(H, L)) -> MEMBER1_IN_AG(L)
The graph contains the following edges 1 > 1


----------------------------------------

(13)
YES

----------------------------------------

(14)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MEMBER_IN_GG(X, .(H, L)) -> MEMBER_IN_GG(X, L)

The TRS R consists of the following rules:

   reach_in_ggg(X, Y, Edges) -> U1_ggg(X, Y, Edges, member_in_gg(.(X, .(Y, [])), Edges))
   member_in_gg(H, .(H, L)) -> member_out_gg(H, .(H, L))
   member_in_gg(X, .(H, L)) -> U4_gg(X, H, L, member_in_gg(X, L))
   U4_gg(X, H, L, member_out_gg(X, L)) -> member_out_gg(X, .(H, L))
   U1_ggg(X, Y, Edges, member_out_gg(.(X, .(Y, [])), Edges)) -> reach_out_ggg(X, Y, Edges)
   reach_in_ggg(X, Z, Edges) -> U2_ggg(X, Z, Edges, member1_in_ag(.(X, .(Y, [])), Edges))
   member1_in_ag(H, .(H, L)) -> member1_out_ag(H, .(H, L))
   member1_in_ag(X, .(H, L)) -> U5_ag(X, H, L, member1_in_ag(X, L))
   U5_ag(X, H, L, member1_out_ag(X, L)) -> member1_out_ag(X, .(H, L))
   U2_ggg(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> U3_ggg(X, Z, Edges, reach_in_ggg(Y, Z, Edges))
   U3_ggg(X, Z, Edges, reach_out_ggg(Y, Z, Edges)) -> reach_out_ggg(X, Z, Edges)

The argument filtering Pi contains the following mapping:
reach_in_ggg(x1, x2, x3)  =  reach_in_ggg(x1, x2, x3)

U1_ggg(x1, x2, x3, x4)  =  U1_ggg(x4)

member_in_gg(x1, x2)  =  member_in_gg(x1, x2)

.(x1, x2)  =  .(x1, x2)

member_out_gg(x1, x2)  =  member_out_gg

U4_gg(x1, x2, x3, x4)  =  U4_gg(x4)

[]  =  []

reach_out_ggg(x1, x2, x3)  =  reach_out_ggg

U2_ggg(x1, x2, x3, x4)  =  U2_ggg(x2, x3, x4)

member1_in_ag(x1, x2)  =  member1_in_ag(x2)

member1_out_ag(x1, x2)  =  member1_out_ag(x1)

U5_ag(x1, x2, x3, x4)  =  U5_ag(x4)

U3_ggg(x1, x2, x3, x4)  =  U3_ggg(x4)

MEMBER_IN_GG(x1, x2)  =  MEMBER_IN_GG(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(15) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(16)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MEMBER_IN_GG(X, .(H, L)) -> MEMBER_IN_GG(X, L)

R is empty.
Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(17) PiDPToQDPProof (EQUIVALENT)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(18)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MEMBER_IN_GG(X, .(H, L)) -> MEMBER_IN_GG(X, L)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(19) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*MEMBER_IN_GG(X, .(H, L)) -> MEMBER_IN_GG(X, L)
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(20)
YES

----------------------------------------

(21)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   REACH_IN_GGG(X, Z, Edges) -> U2_GGG(X, Z, Edges, member1_in_ag(.(X, .(Y, [])), Edges))
   U2_GGG(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> REACH_IN_GGG(Y, Z, Edges)

The TRS R consists of the following rules:

   reach_in_ggg(X, Y, Edges) -> U1_ggg(X, Y, Edges, member_in_gg(.(X, .(Y, [])), Edges))
   member_in_gg(H, .(H, L)) -> member_out_gg(H, .(H, L))
   member_in_gg(X, .(H, L)) -> U4_gg(X, H, L, member_in_gg(X, L))
   U4_gg(X, H, L, member_out_gg(X, L)) -> member_out_gg(X, .(H, L))
   U1_ggg(X, Y, Edges, member_out_gg(.(X, .(Y, [])), Edges)) -> reach_out_ggg(X, Y, Edges)
   reach_in_ggg(X, Z, Edges) -> U2_ggg(X, Z, Edges, member1_in_ag(.(X, .(Y, [])), Edges))
   member1_in_ag(H, .(H, L)) -> member1_out_ag(H, .(H, L))
   member1_in_ag(X, .(H, L)) -> U5_ag(X, H, L, member1_in_ag(X, L))
   U5_ag(X, H, L, member1_out_ag(X, L)) -> member1_out_ag(X, .(H, L))
   U2_ggg(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> U3_ggg(X, Z, Edges, reach_in_ggg(Y, Z, Edges))
   U3_ggg(X, Z, Edges, reach_out_ggg(Y, Z, Edges)) -> reach_out_ggg(X, Z, Edges)

The argument filtering Pi contains the following mapping:
reach_in_ggg(x1, x2, x3)  =  reach_in_ggg(x1, x2, x3)

U1_ggg(x1, x2, x3, x4)  =  U1_ggg(x4)

member_in_gg(x1, x2)  =  member_in_gg(x1, x2)

.(x1, x2)  =  .(x1, x2)

member_out_gg(x1, x2)  =  member_out_gg

U4_gg(x1, x2, x3, x4)  =  U4_gg(x4)

[]  =  []

reach_out_ggg(x1, x2, x3)  =  reach_out_ggg

U2_ggg(x1, x2, x3, x4)  =  U2_ggg(x2, x3, x4)

member1_in_ag(x1, x2)  =  member1_in_ag(x2)

member1_out_ag(x1, x2)  =  member1_out_ag(x1)

U5_ag(x1, x2, x3, x4)  =  U5_ag(x4)

U3_ggg(x1, x2, x3, x4)  =  U3_ggg(x4)

REACH_IN_GGG(x1, x2, x3)  =  REACH_IN_GGG(x1, x2, x3)

U2_GGG(x1, x2, x3, x4)  =  U2_GGG(x2, x3, x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(22) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(23)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   REACH_IN_GGG(X, Z, Edges) -> U2_GGG(X, Z, Edges, member1_in_ag(.(X, .(Y, [])), Edges))
   U2_GGG(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> REACH_IN_GGG(Y, Z, Edges)

The TRS R consists of the following rules:

   member1_in_ag(H, .(H, L)) -> member1_out_ag(H, .(H, L))
   member1_in_ag(X, .(H, L)) -> U5_ag(X, H, L, member1_in_ag(X, L))
   U5_ag(X, H, L, member1_out_ag(X, L)) -> member1_out_ag(X, .(H, L))

The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x1, x2)

[]  =  []

member1_in_ag(x1, x2)  =  member1_in_ag(x2)

member1_out_ag(x1, x2)  =  member1_out_ag(x1)

U5_ag(x1, x2, x3, x4)  =  U5_ag(x4)

REACH_IN_GGG(x1, x2, x3)  =  REACH_IN_GGG(x1, x2, x3)

U2_GGG(x1, x2, x3, x4)  =  U2_GGG(x2, x3, x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(24) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(25)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH_IN_GGG(X, Z, Edges) -> U2_GGG(Z, Edges, member1_in_ag(Edges))
   U2_GGG(Z, Edges, member1_out_ag(.(X, .(Y, [])))) -> REACH_IN_GGG(Y, Z, Edges)

The TRS R consists of the following rules:

   member1_in_ag(.(H, L)) -> member1_out_ag(H)
   member1_in_ag(.(H, L)) -> U5_ag(member1_in_ag(L))
   U5_ag(member1_out_ag(X)) -> member1_out_ag(X)

The set Q consists of the following terms:

   member1_in_ag(x0)
   U5_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(26) TransformationProof (SOUND)
By narrowing [LPAR04] the rule REACH_IN_GGG(X, Z, Edges) -> U2_GGG(Z, Edges, member1_in_ag(Edges)) at position [2] we obtained the following new rules [LPAR04]:

   (REACH_IN_GGG(y0, y1, .(x0, x1)) -> U2_GGG(y1, .(x0, x1), member1_out_ag(x0)),REACH_IN_GGG(y0, y1, .(x0, x1)) -> U2_GGG(y1, .(x0, x1), member1_out_ag(x0)))
   (REACH_IN_GGG(y0, y1, .(x0, x1)) -> U2_GGG(y1, .(x0, x1), U5_ag(member1_in_ag(x1))),REACH_IN_GGG(y0, y1, .(x0, x1)) -> U2_GGG(y1, .(x0, x1), U5_ag(member1_in_ag(x1))))


----------------------------------------

(27)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U2_GGG(Z, Edges, member1_out_ag(.(X, .(Y, [])))) -> REACH_IN_GGG(Y, Z, Edges)
   REACH_IN_GGG(y0, y1, .(x0, x1)) -> U2_GGG(y1, .(x0, x1), member1_out_ag(x0))
   REACH_IN_GGG(y0, y1, .(x0, x1)) -> U2_GGG(y1, .(x0, x1), U5_ag(member1_in_ag(x1)))

The TRS R consists of the following rules:

   member1_in_ag(.(H, L)) -> member1_out_ag(H)
   member1_in_ag(.(H, L)) -> U5_ag(member1_in_ag(L))
   U5_ag(member1_out_ag(X)) -> member1_out_ag(X)

The set Q consists of the following terms:

   member1_in_ag(x0)
   U5_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(28) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U2_GGG(Z, Edges, member1_out_ag(.(X, .(Y, [])))) -> REACH_IN_GGG(Y, Z, Edges) we obtained the following new rules [LPAR04]:

   (U2_GGG(z1, .(.(x2, .(x3, [])), z3), member1_out_ag(.(x2, .(x3, [])))) -> REACH_IN_GGG(x3, z1, .(.(x2, .(x3, [])), z3)),U2_GGG(z1, .(.(x2, .(x3, [])), z3), member1_out_ag(.(x2, .(x3, [])))) -> REACH_IN_GGG(x3, z1, .(.(x2, .(x3, [])), z3)))
   (U2_GGG(z1, .(z2, z3), member1_out_ag(.(x2, .(x3, [])))) -> REACH_IN_GGG(x3, z1, .(z2, z3)),U2_GGG(z1, .(z2, z3), member1_out_ag(.(x2, .(x3, [])))) -> REACH_IN_GGG(x3, z1, .(z2, z3)))


----------------------------------------

(29)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH_IN_GGG(y0, y1, .(x0, x1)) -> U2_GGG(y1, .(x0, x1), member1_out_ag(x0))
   REACH_IN_GGG(y0, y1, .(x0, x1)) -> U2_GGG(y1, .(x0, x1), U5_ag(member1_in_ag(x1)))
   U2_GGG(z1, .(.(x2, .(x3, [])), z3), member1_out_ag(.(x2, .(x3, [])))) -> REACH_IN_GGG(x3, z1, .(.(x2, .(x3, [])), z3))
   U2_GGG(z1, .(z2, z3), member1_out_ag(.(x2, .(x3, [])))) -> REACH_IN_GGG(x3, z1, .(z2, z3))

The TRS R consists of the following rules:

   member1_in_ag(.(H, L)) -> member1_out_ag(H)
   member1_in_ag(.(H, L)) -> U5_ag(member1_in_ag(L))
   U5_ag(member1_out_ag(X)) -> member1_out_ag(X)

The set Q consists of the following terms:

   member1_in_ag(x0)
   U5_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(30) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule REACH_IN_GGG(y0, y1, .(x0, x1)) -> U2_GGG(y1, .(x0, x1), member1_out_ag(x0)) we obtained the following new rules [LPAR04]:

   (REACH_IN_GGG(x0, x1, .(.(y_1, .(y_2, [])), x3)) -> U2_GGG(x1, .(.(y_1, .(y_2, [])), x3), member1_out_ag(.(y_1, .(y_2, [])))),REACH_IN_GGG(x0, x1, .(.(y_1, .(y_2, [])), x3)) -> U2_GGG(x1, .(.(y_1, .(y_2, [])), x3), member1_out_ag(.(y_1, .(y_2, [])))))


----------------------------------------

(31)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH_IN_GGG(y0, y1, .(x0, x1)) -> U2_GGG(y1, .(x0, x1), U5_ag(member1_in_ag(x1)))
   U2_GGG(z1, .(.(x2, .(x3, [])), z3), member1_out_ag(.(x2, .(x3, [])))) -> REACH_IN_GGG(x3, z1, .(.(x2, .(x3, [])), z3))
   U2_GGG(z1, .(z2, z3), member1_out_ag(.(x2, .(x3, [])))) -> REACH_IN_GGG(x3, z1, .(z2, z3))
   REACH_IN_GGG(x0, x1, .(.(y_1, .(y_2, [])), x3)) -> U2_GGG(x1, .(.(y_1, .(y_2, [])), x3), member1_out_ag(.(y_1, .(y_2, []))))

The TRS R consists of the following rules:

   member1_in_ag(.(H, L)) -> member1_out_ag(H)
   member1_in_ag(.(H, L)) -> U5_ag(member1_in_ag(L))
   U5_ag(member1_out_ag(X)) -> member1_out_ag(X)

The set Q consists of the following terms:

   member1_in_ag(x0)
   U5_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(32) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

reach_in_3: (b,b,b)

member_in_2: (b,b)

member1_in_2: (f,b)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   reach_in_ggg(X, Y, Edges) -> U1_ggg(X, Y, Edges, member_in_gg(.(X, .(Y, [])), Edges))
   member_in_gg(H, .(H, L)) -> member_out_gg(H, .(H, L))
   member_in_gg(X, .(H, L)) -> U4_gg(X, H, L, member_in_gg(X, L))
   U4_gg(X, H, L, member_out_gg(X, L)) -> member_out_gg(X, .(H, L))
   U1_ggg(X, Y, Edges, member_out_gg(.(X, .(Y, [])), Edges)) -> reach_out_ggg(X, Y, Edges)
   reach_in_ggg(X, Z, Edges) -> U2_ggg(X, Z, Edges, member1_in_ag(.(X, .(Y, [])), Edges))
   member1_in_ag(H, .(H, L)) -> member1_out_ag(H, .(H, L))
   member1_in_ag(X, .(H, L)) -> U5_ag(X, H, L, member1_in_ag(X, L))
   U5_ag(X, H, L, member1_out_ag(X, L)) -> member1_out_ag(X, .(H, L))
   U2_ggg(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> U3_ggg(X, Z, Edges, reach_in_ggg(Y, Z, Edges))
   U3_ggg(X, Z, Edges, reach_out_ggg(Y, Z, Edges)) -> reach_out_ggg(X, Z, Edges)

The argument filtering Pi contains the following mapping:
reach_in_ggg(x1, x2, x3)  =  reach_in_ggg(x1, x2, x3)

U1_ggg(x1, x2, x3, x4)  =  U1_ggg(x1, x2, x3, x4)

member_in_gg(x1, x2)  =  member_in_gg(x1, x2)

.(x1, x2)  =  .(x1, x2)

member_out_gg(x1, x2)  =  member_out_gg(x1, x2)

U4_gg(x1, x2, x3, x4)  =  U4_gg(x1, x2, x3, x4)

[]  =  []

reach_out_ggg(x1, x2, x3)  =  reach_out_ggg(x1, x2, x3)

U2_ggg(x1, x2, x3, x4)  =  U2_ggg(x1, x2, x3, x4)

member1_in_ag(x1, x2)  =  member1_in_ag(x2)

member1_out_ag(x1, x2)  =  member1_out_ag(x1, x2)

U5_ag(x1, x2, x3, x4)  =  U5_ag(x2, x3, x4)

U3_ggg(x1, x2, x3, x4)  =  U3_ggg(x1, x2, x3, x4)





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(33)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   reach_in_ggg(X, Y, Edges) -> U1_ggg(X, Y, Edges, member_in_gg(.(X, .(Y, [])), Edges))
   member_in_gg(H, .(H, L)) -> member_out_gg(H, .(H, L))
   member_in_gg(X, .(H, L)) -> U4_gg(X, H, L, member_in_gg(X, L))
   U4_gg(X, H, L, member_out_gg(X, L)) -> member_out_gg(X, .(H, L))
   U1_ggg(X, Y, Edges, member_out_gg(.(X, .(Y, [])), Edges)) -> reach_out_ggg(X, Y, Edges)
   reach_in_ggg(X, Z, Edges) -> U2_ggg(X, Z, Edges, member1_in_ag(.(X, .(Y, [])), Edges))
   member1_in_ag(H, .(H, L)) -> member1_out_ag(H, .(H, L))
   member1_in_ag(X, .(H, L)) -> U5_ag(X, H, L, member1_in_ag(X, L))
   U5_ag(X, H, L, member1_out_ag(X, L)) -> member1_out_ag(X, .(H, L))
   U2_ggg(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> U3_ggg(X, Z, Edges, reach_in_ggg(Y, Z, Edges))
   U3_ggg(X, Z, Edges, reach_out_ggg(Y, Z, Edges)) -> reach_out_ggg(X, Z, Edges)

The argument filtering Pi contains the following mapping:
reach_in_ggg(x1, x2, x3)  =  reach_in_ggg(x1, x2, x3)

U1_ggg(x1, x2, x3, x4)  =  U1_ggg(x1, x2, x3, x4)

member_in_gg(x1, x2)  =  member_in_gg(x1, x2)

.(x1, x2)  =  .(x1, x2)

member_out_gg(x1, x2)  =  member_out_gg(x1, x2)

U4_gg(x1, x2, x3, x4)  =  U4_gg(x1, x2, x3, x4)

[]  =  []

reach_out_ggg(x1, x2, x3)  =  reach_out_ggg(x1, x2, x3)

U2_ggg(x1, x2, x3, x4)  =  U2_ggg(x1, x2, x3, x4)

member1_in_ag(x1, x2)  =  member1_in_ag(x2)

member1_out_ag(x1, x2)  =  member1_out_ag(x1, x2)

U5_ag(x1, x2, x3, x4)  =  U5_ag(x2, x3, x4)

U3_ggg(x1, x2, x3, x4)  =  U3_ggg(x1, x2, x3, x4)



----------------------------------------

(34) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   REACH_IN_GGG(X, Y, Edges) -> U1_GGG(X, Y, Edges, member_in_gg(.(X, .(Y, [])), Edges))
   REACH_IN_GGG(X, Y, Edges) -> MEMBER_IN_GG(.(X, .(Y, [])), Edges)
   MEMBER_IN_GG(X, .(H, L)) -> U4_GG(X, H, L, member_in_gg(X, L))
   MEMBER_IN_GG(X, .(H, L)) -> MEMBER_IN_GG(X, L)
   REACH_IN_GGG(X, Z, Edges) -> U2_GGG(X, Z, Edges, member1_in_ag(.(X, .(Y, [])), Edges))
   REACH_IN_GGG(X, Z, Edges) -> MEMBER1_IN_AG(.(X, .(Y, [])), Edges)
   MEMBER1_IN_AG(X, .(H, L)) -> U5_AG(X, H, L, member1_in_ag(X, L))
   MEMBER1_IN_AG(X, .(H, L)) -> MEMBER1_IN_AG(X, L)
   U2_GGG(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> U3_GGG(X, Z, Edges, reach_in_ggg(Y, Z, Edges))
   U2_GGG(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> REACH_IN_GGG(Y, Z, Edges)

The TRS R consists of the following rules:

   reach_in_ggg(X, Y, Edges) -> U1_ggg(X, Y, Edges, member_in_gg(.(X, .(Y, [])), Edges))
   member_in_gg(H, .(H, L)) -> member_out_gg(H, .(H, L))
   member_in_gg(X, .(H, L)) -> U4_gg(X, H, L, member_in_gg(X, L))
   U4_gg(X, H, L, member_out_gg(X, L)) -> member_out_gg(X, .(H, L))
   U1_ggg(X, Y, Edges, member_out_gg(.(X, .(Y, [])), Edges)) -> reach_out_ggg(X, Y, Edges)
   reach_in_ggg(X, Z, Edges) -> U2_ggg(X, Z, Edges, member1_in_ag(.(X, .(Y, [])), Edges))
   member1_in_ag(H, .(H, L)) -> member1_out_ag(H, .(H, L))
   member1_in_ag(X, .(H, L)) -> U5_ag(X, H, L, member1_in_ag(X, L))
   U5_ag(X, H, L, member1_out_ag(X, L)) -> member1_out_ag(X, .(H, L))
   U2_ggg(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> U3_ggg(X, Z, Edges, reach_in_ggg(Y, Z, Edges))
   U3_ggg(X, Z, Edges, reach_out_ggg(Y, Z, Edges)) -> reach_out_ggg(X, Z, Edges)

The argument filtering Pi contains the following mapping:
reach_in_ggg(x1, x2, x3)  =  reach_in_ggg(x1, x2, x3)

U1_ggg(x1, x2, x3, x4)  =  U1_ggg(x1, x2, x3, x4)

member_in_gg(x1, x2)  =  member_in_gg(x1, x2)

.(x1, x2)  =  .(x1, x2)

member_out_gg(x1, x2)  =  member_out_gg(x1, x2)

U4_gg(x1, x2, x3, x4)  =  U4_gg(x1, x2, x3, x4)

[]  =  []

reach_out_ggg(x1, x2, x3)  =  reach_out_ggg(x1, x2, x3)

U2_ggg(x1, x2, x3, x4)  =  U2_ggg(x1, x2, x3, x4)

member1_in_ag(x1, x2)  =  member1_in_ag(x2)

member1_out_ag(x1, x2)  =  member1_out_ag(x1, x2)

U5_ag(x1, x2, x3, x4)  =  U5_ag(x2, x3, x4)

U3_ggg(x1, x2, x3, x4)  =  U3_ggg(x1, x2, x3, x4)

REACH_IN_GGG(x1, x2, x3)  =  REACH_IN_GGG(x1, x2, x3)

U1_GGG(x1, x2, x3, x4)  =  U1_GGG(x1, x2, x3, x4)

MEMBER_IN_GG(x1, x2)  =  MEMBER_IN_GG(x1, x2)

U4_GG(x1, x2, x3, x4)  =  U4_GG(x1, x2, x3, x4)

U2_GGG(x1, x2, x3, x4)  =  U2_GGG(x1, x2, x3, x4)

MEMBER1_IN_AG(x1, x2)  =  MEMBER1_IN_AG(x2)

U5_AG(x1, x2, x3, x4)  =  U5_AG(x2, x3, x4)

U3_GGG(x1, x2, x3, x4)  =  U3_GGG(x1, x2, x3, x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(35)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   REACH_IN_GGG(X, Y, Edges) -> U1_GGG(X, Y, Edges, member_in_gg(.(X, .(Y, [])), Edges))
   REACH_IN_GGG(X, Y, Edges) -> MEMBER_IN_GG(.(X, .(Y, [])), Edges)
   MEMBER_IN_GG(X, .(H, L)) -> U4_GG(X, H, L, member_in_gg(X, L))
   MEMBER_IN_GG(X, .(H, L)) -> MEMBER_IN_GG(X, L)
   REACH_IN_GGG(X, Z, Edges) -> U2_GGG(X, Z, Edges, member1_in_ag(.(X, .(Y, [])), Edges))
   REACH_IN_GGG(X, Z, Edges) -> MEMBER1_IN_AG(.(X, .(Y, [])), Edges)
   MEMBER1_IN_AG(X, .(H, L)) -> U5_AG(X, H, L, member1_in_ag(X, L))
   MEMBER1_IN_AG(X, .(H, L)) -> MEMBER1_IN_AG(X, L)
   U2_GGG(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> U3_GGG(X, Z, Edges, reach_in_ggg(Y, Z, Edges))
   U2_GGG(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> REACH_IN_GGG(Y, Z, Edges)

The TRS R consists of the following rules:

   reach_in_ggg(X, Y, Edges) -> U1_ggg(X, Y, Edges, member_in_gg(.(X, .(Y, [])), Edges))
   member_in_gg(H, .(H, L)) -> member_out_gg(H, .(H, L))
   member_in_gg(X, .(H, L)) -> U4_gg(X, H, L, member_in_gg(X, L))
   U4_gg(X, H, L, member_out_gg(X, L)) -> member_out_gg(X, .(H, L))
   U1_ggg(X, Y, Edges, member_out_gg(.(X, .(Y, [])), Edges)) -> reach_out_ggg(X, Y, Edges)
   reach_in_ggg(X, Z, Edges) -> U2_ggg(X, Z, Edges, member1_in_ag(.(X, .(Y, [])), Edges))
   member1_in_ag(H, .(H, L)) -> member1_out_ag(H, .(H, L))
   member1_in_ag(X, .(H, L)) -> U5_ag(X, H, L, member1_in_ag(X, L))
   U5_ag(X, H, L, member1_out_ag(X, L)) -> member1_out_ag(X, .(H, L))
   U2_ggg(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> U3_ggg(X, Z, Edges, reach_in_ggg(Y, Z, Edges))
   U3_ggg(X, Z, Edges, reach_out_ggg(Y, Z, Edges)) -> reach_out_ggg(X, Z, Edges)

The argument filtering Pi contains the following mapping:
reach_in_ggg(x1, x2, x3)  =  reach_in_ggg(x1, x2, x3)

U1_ggg(x1, x2, x3, x4)  =  U1_ggg(x1, x2, x3, x4)

member_in_gg(x1, x2)  =  member_in_gg(x1, x2)

.(x1, x2)  =  .(x1, x2)

member_out_gg(x1, x2)  =  member_out_gg(x1, x2)

U4_gg(x1, x2, x3, x4)  =  U4_gg(x1, x2, x3, x4)

[]  =  []

reach_out_ggg(x1, x2, x3)  =  reach_out_ggg(x1, x2, x3)

U2_ggg(x1, x2, x3, x4)  =  U2_ggg(x1, x2, x3, x4)

member1_in_ag(x1, x2)  =  member1_in_ag(x2)

member1_out_ag(x1, x2)  =  member1_out_ag(x1, x2)

U5_ag(x1, x2, x3, x4)  =  U5_ag(x2, x3, x4)

U3_ggg(x1, x2, x3, x4)  =  U3_ggg(x1, x2, x3, x4)

REACH_IN_GGG(x1, x2, x3)  =  REACH_IN_GGG(x1, x2, x3)

U1_GGG(x1, x2, x3, x4)  =  U1_GGG(x1, x2, x3, x4)

MEMBER_IN_GG(x1, x2)  =  MEMBER_IN_GG(x1, x2)

U4_GG(x1, x2, x3, x4)  =  U4_GG(x1, x2, x3, x4)

U2_GGG(x1, x2, x3, x4)  =  U2_GGG(x1, x2, x3, x4)

MEMBER1_IN_AG(x1, x2)  =  MEMBER1_IN_AG(x2)

U5_AG(x1, x2, x3, x4)  =  U5_AG(x2, x3, x4)

U3_GGG(x1, x2, x3, x4)  =  U3_GGG(x1, x2, x3, x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(36) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 3 SCCs with 6 less nodes.
----------------------------------------

(37)
Complex Obligation (AND)

----------------------------------------

(38)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MEMBER1_IN_AG(X, .(H, L)) -> MEMBER1_IN_AG(X, L)

The TRS R consists of the following rules:

   reach_in_ggg(X, Y, Edges) -> U1_ggg(X, Y, Edges, member_in_gg(.(X, .(Y, [])), Edges))
   member_in_gg(H, .(H, L)) -> member_out_gg(H, .(H, L))
   member_in_gg(X, .(H, L)) -> U4_gg(X, H, L, member_in_gg(X, L))
   U4_gg(X, H, L, member_out_gg(X, L)) -> member_out_gg(X, .(H, L))
   U1_ggg(X, Y, Edges, member_out_gg(.(X, .(Y, [])), Edges)) -> reach_out_ggg(X, Y, Edges)
   reach_in_ggg(X, Z, Edges) -> U2_ggg(X, Z, Edges, member1_in_ag(.(X, .(Y, [])), Edges))
   member1_in_ag(H, .(H, L)) -> member1_out_ag(H, .(H, L))
   member1_in_ag(X, .(H, L)) -> U5_ag(X, H, L, member1_in_ag(X, L))
   U5_ag(X, H, L, member1_out_ag(X, L)) -> member1_out_ag(X, .(H, L))
   U2_ggg(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> U3_ggg(X, Z, Edges, reach_in_ggg(Y, Z, Edges))
   U3_ggg(X, Z, Edges, reach_out_ggg(Y, Z, Edges)) -> reach_out_ggg(X, Z, Edges)

The argument filtering Pi contains the following mapping:
reach_in_ggg(x1, x2, x3)  =  reach_in_ggg(x1, x2, x3)

U1_ggg(x1, x2, x3, x4)  =  U1_ggg(x1, x2, x3, x4)

member_in_gg(x1, x2)  =  member_in_gg(x1, x2)

.(x1, x2)  =  .(x1, x2)

member_out_gg(x1, x2)  =  member_out_gg(x1, x2)

U4_gg(x1, x2, x3, x4)  =  U4_gg(x1, x2, x3, x4)

[]  =  []

reach_out_ggg(x1, x2, x3)  =  reach_out_ggg(x1, x2, x3)

U2_ggg(x1, x2, x3, x4)  =  U2_ggg(x1, x2, x3, x4)

member1_in_ag(x1, x2)  =  member1_in_ag(x2)

member1_out_ag(x1, x2)  =  member1_out_ag(x1, x2)

U5_ag(x1, x2, x3, x4)  =  U5_ag(x2, x3, x4)

U3_ggg(x1, x2, x3, x4)  =  U3_ggg(x1, x2, x3, x4)

MEMBER1_IN_AG(x1, x2)  =  MEMBER1_IN_AG(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(39) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(40)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MEMBER1_IN_AG(X, .(H, L)) -> MEMBER1_IN_AG(X, L)

R is empty.
The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x1, x2)

MEMBER1_IN_AG(x1, x2)  =  MEMBER1_IN_AG(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(41) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(42)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MEMBER1_IN_AG(.(H, L)) -> MEMBER1_IN_AG(L)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(43) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*MEMBER1_IN_AG(.(H, L)) -> MEMBER1_IN_AG(L)
The graph contains the following edges 1 > 1


----------------------------------------

(44)
YES

----------------------------------------

(45)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MEMBER_IN_GG(X, .(H, L)) -> MEMBER_IN_GG(X, L)

The TRS R consists of the following rules:

   reach_in_ggg(X, Y, Edges) -> U1_ggg(X, Y, Edges, member_in_gg(.(X, .(Y, [])), Edges))
   member_in_gg(H, .(H, L)) -> member_out_gg(H, .(H, L))
   member_in_gg(X, .(H, L)) -> U4_gg(X, H, L, member_in_gg(X, L))
   U4_gg(X, H, L, member_out_gg(X, L)) -> member_out_gg(X, .(H, L))
   U1_ggg(X, Y, Edges, member_out_gg(.(X, .(Y, [])), Edges)) -> reach_out_ggg(X, Y, Edges)
   reach_in_ggg(X, Z, Edges) -> U2_ggg(X, Z, Edges, member1_in_ag(.(X, .(Y, [])), Edges))
   member1_in_ag(H, .(H, L)) -> member1_out_ag(H, .(H, L))
   member1_in_ag(X, .(H, L)) -> U5_ag(X, H, L, member1_in_ag(X, L))
   U5_ag(X, H, L, member1_out_ag(X, L)) -> member1_out_ag(X, .(H, L))
   U2_ggg(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> U3_ggg(X, Z, Edges, reach_in_ggg(Y, Z, Edges))
   U3_ggg(X, Z, Edges, reach_out_ggg(Y, Z, Edges)) -> reach_out_ggg(X, Z, Edges)

The argument filtering Pi contains the following mapping:
reach_in_ggg(x1, x2, x3)  =  reach_in_ggg(x1, x2, x3)

U1_ggg(x1, x2, x3, x4)  =  U1_ggg(x1, x2, x3, x4)

member_in_gg(x1, x2)  =  member_in_gg(x1, x2)

.(x1, x2)  =  .(x1, x2)

member_out_gg(x1, x2)  =  member_out_gg(x1, x2)

U4_gg(x1, x2, x3, x4)  =  U4_gg(x1, x2, x3, x4)

[]  =  []

reach_out_ggg(x1, x2, x3)  =  reach_out_ggg(x1, x2, x3)

U2_ggg(x1, x2, x3, x4)  =  U2_ggg(x1, x2, x3, x4)

member1_in_ag(x1, x2)  =  member1_in_ag(x2)

member1_out_ag(x1, x2)  =  member1_out_ag(x1, x2)

U5_ag(x1, x2, x3, x4)  =  U5_ag(x2, x3, x4)

U3_ggg(x1, x2, x3, x4)  =  U3_ggg(x1, x2, x3, x4)

MEMBER_IN_GG(x1, x2)  =  MEMBER_IN_GG(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(46) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(47)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MEMBER_IN_GG(X, .(H, L)) -> MEMBER_IN_GG(X, L)

R is empty.
Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(48) PiDPToQDPProof (EQUIVALENT)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(49)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MEMBER_IN_GG(X, .(H, L)) -> MEMBER_IN_GG(X, L)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(50) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*MEMBER_IN_GG(X, .(H, L)) -> MEMBER_IN_GG(X, L)
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(51)
YES

----------------------------------------

(52)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   REACH_IN_GGG(X, Z, Edges) -> U2_GGG(X, Z, Edges, member1_in_ag(.(X, .(Y, [])), Edges))
   U2_GGG(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> REACH_IN_GGG(Y, Z, Edges)

The TRS R consists of the following rules:

   reach_in_ggg(X, Y, Edges) -> U1_ggg(X, Y, Edges, member_in_gg(.(X, .(Y, [])), Edges))
   member_in_gg(H, .(H, L)) -> member_out_gg(H, .(H, L))
   member_in_gg(X, .(H, L)) -> U4_gg(X, H, L, member_in_gg(X, L))
   U4_gg(X, H, L, member_out_gg(X, L)) -> member_out_gg(X, .(H, L))
   U1_ggg(X, Y, Edges, member_out_gg(.(X, .(Y, [])), Edges)) -> reach_out_ggg(X, Y, Edges)
   reach_in_ggg(X, Z, Edges) -> U2_ggg(X, Z, Edges, member1_in_ag(.(X, .(Y, [])), Edges))
   member1_in_ag(H, .(H, L)) -> member1_out_ag(H, .(H, L))
   member1_in_ag(X, .(H, L)) -> U5_ag(X, H, L, member1_in_ag(X, L))
   U5_ag(X, H, L, member1_out_ag(X, L)) -> member1_out_ag(X, .(H, L))
   U2_ggg(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> U3_ggg(X, Z, Edges, reach_in_ggg(Y, Z, Edges))
   U3_ggg(X, Z, Edges, reach_out_ggg(Y, Z, Edges)) -> reach_out_ggg(X, Z, Edges)

The argument filtering Pi contains the following mapping:
reach_in_ggg(x1, x2, x3)  =  reach_in_ggg(x1, x2, x3)

U1_ggg(x1, x2, x3, x4)  =  U1_ggg(x1, x2, x3, x4)

member_in_gg(x1, x2)  =  member_in_gg(x1, x2)

.(x1, x2)  =  .(x1, x2)

member_out_gg(x1, x2)  =  member_out_gg(x1, x2)

U4_gg(x1, x2, x3, x4)  =  U4_gg(x1, x2, x3, x4)

[]  =  []

reach_out_ggg(x1, x2, x3)  =  reach_out_ggg(x1, x2, x3)

U2_ggg(x1, x2, x3, x4)  =  U2_ggg(x1, x2, x3, x4)

member1_in_ag(x1, x2)  =  member1_in_ag(x2)

member1_out_ag(x1, x2)  =  member1_out_ag(x1, x2)

U5_ag(x1, x2, x3, x4)  =  U5_ag(x2, x3, x4)

U3_ggg(x1, x2, x3, x4)  =  U3_ggg(x1, x2, x3, x4)

REACH_IN_GGG(x1, x2, x3)  =  REACH_IN_GGG(x1, x2, x3)

U2_GGG(x1, x2, x3, x4)  =  U2_GGG(x1, x2, x3, x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(53) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(54)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   REACH_IN_GGG(X, Z, Edges) -> U2_GGG(X, Z, Edges, member1_in_ag(.(X, .(Y, [])), Edges))
   U2_GGG(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> REACH_IN_GGG(Y, Z, Edges)

The TRS R consists of the following rules:

   member1_in_ag(H, .(H, L)) -> member1_out_ag(H, .(H, L))
   member1_in_ag(X, .(H, L)) -> U5_ag(X, H, L, member1_in_ag(X, L))
   U5_ag(X, H, L, member1_out_ag(X, L)) -> member1_out_ag(X, .(H, L))

The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x1, x2)

[]  =  []

member1_in_ag(x1, x2)  =  member1_in_ag(x2)

member1_out_ag(x1, x2)  =  member1_out_ag(x1, x2)

U5_ag(x1, x2, x3, x4)  =  U5_ag(x2, x3, x4)

REACH_IN_GGG(x1, x2, x3)  =  REACH_IN_GGG(x1, x2, x3)

U2_GGG(x1, x2, x3, x4)  =  U2_GGG(x1, x2, x3, x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(55) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(56)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH_IN_GGG(X, Z, Edges) -> U2_GGG(X, Z, Edges, member1_in_ag(Edges))
   U2_GGG(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> REACH_IN_GGG(Y, Z, Edges)

The TRS R consists of the following rules:

   member1_in_ag(.(H, L)) -> member1_out_ag(H, .(H, L))
   member1_in_ag(.(H, L)) -> U5_ag(H, L, member1_in_ag(L))
   U5_ag(H, L, member1_out_ag(X, L)) -> member1_out_ag(X, .(H, L))

The set Q consists of the following terms:

   member1_in_ag(x0)
   U5_ag(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(57) TransformationProof (SOUND)
By narrowing [LPAR04] the rule REACH_IN_GGG(X, Z, Edges) -> U2_GGG(X, Z, Edges, member1_in_ag(Edges)) at position [3] we obtained the following new rules [LPAR04]:

   (REACH_IN_GGG(y0, y1, .(x0, x1)) -> U2_GGG(y0, y1, .(x0, x1), member1_out_ag(x0, .(x0, x1))),REACH_IN_GGG(y0, y1, .(x0, x1)) -> U2_GGG(y0, y1, .(x0, x1), member1_out_ag(x0, .(x0, x1))))
   (REACH_IN_GGG(y0, y1, .(x0, x1)) -> U2_GGG(y0, y1, .(x0, x1), U5_ag(x0, x1, member1_in_ag(x1))),REACH_IN_GGG(y0, y1, .(x0, x1)) -> U2_GGG(y0, y1, .(x0, x1), U5_ag(x0, x1, member1_in_ag(x1))))


----------------------------------------

(58)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U2_GGG(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> REACH_IN_GGG(Y, Z, Edges)
   REACH_IN_GGG(y0, y1, .(x0, x1)) -> U2_GGG(y0, y1, .(x0, x1), member1_out_ag(x0, .(x0, x1)))
   REACH_IN_GGG(y0, y1, .(x0, x1)) -> U2_GGG(y0, y1, .(x0, x1), U5_ag(x0, x1, member1_in_ag(x1)))

The TRS R consists of the following rules:

   member1_in_ag(.(H, L)) -> member1_out_ag(H, .(H, L))
   member1_in_ag(.(H, L)) -> U5_ag(H, L, member1_in_ag(L))
   U5_ag(H, L, member1_out_ag(X, L)) -> member1_out_ag(X, .(H, L))

The set Q consists of the following terms:

   member1_in_ag(x0)
   U5_ag(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(59) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U2_GGG(X, Z, Edges, member1_out_ag(.(X, .(Y, [])), Edges)) -> REACH_IN_GGG(Y, Z, Edges) we obtained the following new rules [LPAR04]:

   (U2_GGG(z0, z1, .(.(z0, .(x3, [])), z3), member1_out_ag(.(z0, .(x3, [])), .(.(z0, .(x3, [])), z3))) -> REACH_IN_GGG(x3, z1, .(.(z0, .(x3, [])), z3)),U2_GGG(z0, z1, .(.(z0, .(x3, [])), z3), member1_out_ag(.(z0, .(x3, [])), .(.(z0, .(x3, [])), z3))) -> REACH_IN_GGG(x3, z1, .(.(z0, .(x3, [])), z3)))
   (U2_GGG(z0, z1, .(z2, z3), member1_out_ag(.(z0, .(x3, [])), .(z2, z3))) -> REACH_IN_GGG(x3, z1, .(z2, z3)),U2_GGG(z0, z1, .(z2, z3), member1_out_ag(.(z0, .(x3, [])), .(z2, z3))) -> REACH_IN_GGG(x3, z1, .(z2, z3)))


----------------------------------------

(60)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH_IN_GGG(y0, y1, .(x0, x1)) -> U2_GGG(y0, y1, .(x0, x1), member1_out_ag(x0, .(x0, x1)))
   REACH_IN_GGG(y0, y1, .(x0, x1)) -> U2_GGG(y0, y1, .(x0, x1), U5_ag(x0, x1, member1_in_ag(x1)))
   U2_GGG(z0, z1, .(.(z0, .(x3, [])), z3), member1_out_ag(.(z0, .(x3, [])), .(.(z0, .(x3, [])), z3))) -> REACH_IN_GGG(x3, z1, .(.(z0, .(x3, [])), z3))
   U2_GGG(z0, z1, .(z2, z3), member1_out_ag(.(z0, .(x3, [])), .(z2, z3))) -> REACH_IN_GGG(x3, z1, .(z2, z3))

The TRS R consists of the following rules:

   member1_in_ag(.(H, L)) -> member1_out_ag(H, .(H, L))
   member1_in_ag(.(H, L)) -> U5_ag(H, L, member1_in_ag(L))
   U5_ag(H, L, member1_out_ag(X, L)) -> member1_out_ag(X, .(H, L))

The set Q consists of the following terms:

   member1_in_ag(x0)
   U5_ag(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(61) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule REACH_IN_GGG(y0, y1, .(x0, x1)) -> U2_GGG(y0, y1, .(x0, x1), member1_out_ag(x0, .(x0, x1))) we obtained the following new rules [LPAR04]:

   (REACH_IN_GGG(x0, x1, .(.(y_2, .(y_3, [])), x3)) -> U2_GGG(x0, x1, .(.(y_2, .(y_3, [])), x3), member1_out_ag(.(y_2, .(y_3, [])), .(.(y_2, .(y_3, [])), x3))),REACH_IN_GGG(x0, x1, .(.(y_2, .(y_3, [])), x3)) -> U2_GGG(x0, x1, .(.(y_2, .(y_3, [])), x3), member1_out_ag(.(y_2, .(y_3, [])), .(.(y_2, .(y_3, [])), x3))))


----------------------------------------

(62)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH_IN_GGG(y0, y1, .(x0, x1)) -> U2_GGG(y0, y1, .(x0, x1), U5_ag(x0, x1, member1_in_ag(x1)))
   U2_GGG(z0, z1, .(.(z0, .(x3, [])), z3), member1_out_ag(.(z0, .(x3, [])), .(.(z0, .(x3, [])), z3))) -> REACH_IN_GGG(x3, z1, .(.(z0, .(x3, [])), z3))
   U2_GGG(z0, z1, .(z2, z3), member1_out_ag(.(z0, .(x3, [])), .(z2, z3))) -> REACH_IN_GGG(x3, z1, .(z2, z3))
   REACH_IN_GGG(x0, x1, .(.(y_2, .(y_3, [])), x3)) -> U2_GGG(x0, x1, .(.(y_2, .(y_3, [])), x3), member1_out_ag(.(y_2, .(y_3, [])), .(.(y_2, .(y_3, [])), x3)))

The TRS R consists of the following rules:

   member1_in_ag(.(H, L)) -> member1_out_ag(H, .(H, L))
   member1_in_ag(.(H, L)) -> U5_ag(H, L, member1_in_ag(L))
   U5_ag(H, L, member1_out_ag(X, L)) -> member1_out_ag(X, .(H, L))

The set Q consists of the following terms:

   member1_in_ag(x0)
   U5_ag(x0, x1, x2)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(63) PrologToDTProblemTransformerProof (SOUND)
Built DT problem from termination graph DT10.

{
    "root": 3,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(reach X Y Edges)",
                "(member (. X (. Y ([]))) Edges)"
            ],
            [
                "(reach X Z Edges)",
                "(',' (member1 (. X (. Y ([]))) Edges) (reach Y Z Edges))"
            ],
            [
                "(member H (. H L))",
                null
            ],
            [
                "(member X (. H L))",
                "(member X L)"
            ],
            [
                "(member1 H (. H L))",
                null
            ],
            [
                "(member1 X (. H L))",
                "(member1 X L)"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "type": "Nodes",
            "196": {
                "goal": [
                    {
                        "clause": -1,
                        "scope": -1,
                        "term": "(member (. T7 (. T8 ([]))) T9)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(reach T7 T8 T9)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T7",
                        "T8",
                        "T9"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "210": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "211": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "299": {
                "goal": [
                    {
                        "clause": 4,
                        "scope": 4,
                        "term": "(member1 (. T96 (. X75 ([]))) T98)"
                    },
                    {
                        "clause": 5,
                        "scope": 4,
                        "term": "(member1 (. T96 (. X75 ([]))) T98)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T96",
                        "T98"
                    ],
                    "free": ["X75"],
                    "exprvars": []
                }
            },
            "310": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "212": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "311": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "213": {
                "goal": [{
                    "clause": 3,
                    "scope": 2,
                    "term": "(member (. T7 (. T8 ([]))) T9)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T7",
                        "T8",
                        "T9"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "312": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "214": {
                "goal": [
                    {
                        "clause": -1,
                        "scope": 2,
                        "term": null
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(reach T7 T8 T9)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T7",
                        "T8",
                        "T9"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "313": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(member1 (. T133 (. X114 ([]))) T135)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T133",
                        "T135"
                    ],
                    "free": ["X114"],
                    "exprvars": []
                }
            },
            "215": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(member (. T41 (. T42 ([]))) T44)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T41",
                        "T42",
                        "T44"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "314": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "216": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "217": {
                "goal": [
                    {
                        "clause": 2,
                        "scope": 3,
                        "term": "(member (. T41 (. T42 ([]))) T44)"
                    },
                    {
                        "clause": 3,
                        "scope": 3,
                        "term": "(member (. T41 (. T42 ([]))) T44)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T41",
                        "T42",
                        "T44"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "218": {
                "goal": [{
                    "clause": 2,
                    "scope": 3,
                    "term": "(member (. T41 (. T42 ([]))) T44)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T41",
                        "T42",
                        "T44"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "219": {
                "goal": [{
                    "clause": 3,
                    "scope": 3,
                    "term": "(member (. T41 (. T42 ([]))) T44)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T41",
                        "T42",
                        "T44"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "280": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (member1 (. T96 (. X75 ([]))) T98) (reach X75 T97 T98))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T96",
                        "T97",
                        "T98"
                    ],
                    "free": ["X75"],
                    "exprvars": []
                }
            },
            "284": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(member1 (. T96 (. X75 ([]))) T98)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T96",
                        "T98"
                    ],
                    "free": ["X75"],
                    "exprvars": []
                }
            },
            "285": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(reach T105 T97 T98)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T97",
                        "T98",
                        "T105"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "220": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "264": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(reach T7 T8 T9)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T7",
                        "T8",
                        "T9"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "221": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "200": {
                "goal": [
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(member (. T7 (. T8 ([]))) T9)"
                    },
                    {
                        "clause": 3,
                        "scope": 2,
                        "term": "(member (. T7 (. T8 ([]))) T9)"
                    },
                    {
                        "clause": -1,
                        "scope": 2,
                        "term": null
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(reach T7 T8 T9)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T7",
                        "T8",
                        "T9"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "222": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "3": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(reach T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2",
                        "T3"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "223": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(member (. T74 (. T75 ([]))) T77)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T74",
                        "T75",
                        "T77"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "4": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 1,
                        "term": "(reach T1 T2 T3)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(reach T1 T2 T3)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2",
                        "T3"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "224": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "208": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(member (. T7 (. T8 ([]))) T9)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T7",
                        "T8",
                        "T9"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "209": {
                "goal": [
                    {
                        "clause": 3,
                        "scope": 2,
                        "term": "(member (. T7 (. T8 ([]))) T9)"
                    },
                    {
                        "clause": -1,
                        "scope": 2,
                        "term": null
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(reach T7 T8 T9)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T7",
                        "T8",
                        "T9"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "308": {
                "goal": [{
                    "clause": 4,
                    "scope": 4,
                    "term": "(member1 (. T96 (. X75 ([]))) T98)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T96",
                        "T98"
                    ],
                    "free": ["X75"],
                    "exprvars": []
                }
            },
            "309": {
                "goal": [{
                    "clause": 5,
                    "scope": 4,
                    "term": "(member1 (. T96 (. X75 ([]))) T98)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T96",
                        "T98"
                    ],
                    "free": ["X75"],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 3,
                "to": 4,
                "label": "CASE"
            },
            {
                "from": 4,
                "to": 196,
                "label": "ONLY EVAL with clause\nreach(X4, X5, X6) :- member(.(X4, .(X5, [])), X6).\nand substitutionT1 -> T7,\nX4 -> T7,\nT2 -> T8,\nX5 -> T8,\nT3 -> T9,\nX6 -> T9"
            },
            {
                "from": 196,
                "to": 200,
                "label": "CASE"
            },
            {
                "from": 200,
                "to": 208,
                "label": "PARALLEL"
            },
            {
                "from": 200,
                "to": 209,
                "label": "PARALLEL"
            },
            {
                "from": 208,
                "to": 210,
                "label": "EVAL with clause\nmember(X15, .(X15, X16)).\nand substitutionT7 -> T22,\nT8 -> T23,\nX15 -> .(T22, .(T23, [])),\nX16 -> T24,\nT9 -> .(.(T22, .(T23, [])), T24)"
            },
            {
                "from": 208,
                "to": 211,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 209,
                "to": 213,
                "label": "PARALLEL"
            },
            {
                "from": 209,
                "to": 214,
                "label": "PARALLEL"
            },
            {
                "from": 210,
                "to": 212,
                "label": "SUCCESS"
            },
            {
                "from": 213,
                "to": 215,
                "label": "EVAL with clause\nmember(X29, .(X30, X31)) :- member(X29, X31).\nand substitutionT7 -> T41,\nT8 -> T42,\nX29 -> .(T41, .(T42, [])),\nX30 -> T43,\nX31 -> T44,\nT9 -> .(T43, T44)"
            },
            {
                "from": 213,
                "to": 216,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 214,
                "to": 264,
                "label": "FAILURE"
            },
            {
                "from": 215,
                "to": 217,
                "label": "CASE"
            },
            {
                "from": 217,
                "to": 218,
                "label": "PARALLEL"
            },
            {
                "from": 217,
                "to": 219,
                "label": "PARALLEL"
            },
            {
                "from": 218,
                "to": 220,
                "label": "EVAL with clause\nmember(X44, .(X44, X45)).\nand substitutionT41 -> T63,\nT42 -> T64,\nX44 -> .(T63, .(T64, [])),\nX45 -> T65,\nT44 -> .(.(T63, .(T64, [])), T65)"
            },
            {
                "from": 218,
                "to": 221,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 219,
                "to": 223,
                "label": "EVAL with clause\nmember(X52, .(X53, X54)) :- member(X52, X54).\nand substitutionT41 -> T74,\nT42 -> T75,\nX52 -> .(T74, .(T75, [])),\nX53 -> T76,\nX54 -> T77,\nT44 -> .(T76, T77)"
            },
            {
                "from": 219,
                "to": 224,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 220,
                "to": 222,
                "label": "SUCCESS"
            },
            {
                "from": 223,
                "to": 215,
                "label": "INSTANCE with matching:\nT41 -> T74\nT42 -> T75\nT44 -> T77"
            },
            {
                "from": 264,
                "to": 280,
                "label": "ONLY EVAL with clause\nreach(X72, X73, X74) :- ','(member1(.(X72, .(X75, [])), X74), reach(X75, X73, X74)).\nand substitutionT7 -> T96,\nX72 -> T96,\nT8 -> T97,\nX73 -> T97,\nT9 -> T98,\nX74 -> T98"
            },
            {
                "from": 280,
                "to": 284,
                "label": "SPLIT 1"
            },
            {
                "from": 280,
                "to": 285,
                "label": "SPLIT 2\nnew knowledge:\nT96 is ground\nT105 is ground\nT98 is ground\nreplacements:X75 -> T105"
            },
            {
                "from": 284,
                "to": 299,
                "label": "CASE"
            },
            {
                "from": 285,
                "to": 3,
                "label": "INSTANCE with matching:\nT1 -> T105\nT2 -> T97\nT3 -> T98"
            },
            {
                "from": 299,
                "to": 308,
                "label": "PARALLEL"
            },
            {
                "from": 299,
                "to": 309,
                "label": "PARALLEL"
            },
            {
                "from": 308,
                "to": 310,
                "label": "EVAL with clause\nmember1(X100, .(X100, X101)).\nand substitutionT96 -> T124,\nX75 -> T125,\nX100 -> .(T124, .(T125, [])),\nX102 -> T125,\nX101 -> T126,\nT98 -> .(.(T124, .(T125, [])), T126)"
            },
            {
                "from": 308,
                "to": 311,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 309,
                "to": 313,
                "label": "EVAL with clause\nmember1(X111, .(X112, X113)) :- member1(X111, X113).\nand substitutionT96 -> T133,\nX75 -> X114,\nX111 -> .(T133, .(X114, [])),\nX112 -> T134,\nX113 -> T135,\nT98 -> .(T134, T135)"
            },
            {
                "from": 309,
                "to": 314,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 310,
                "to": 312,
                "label": "SUCCESS"
            },
            {
                "from": 313,
                "to": 284,
                "label": "INSTANCE with matching:\nT96 -> T133\nX75 -> X114\nT98 -> T135"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(64)
Obligation:
Triples:

memberA(X1, X2, .(X3, X4)) :- memberA(X1, X2, X4).
member1C(X1, X2, .(X3, X4)) :- member1C(X1, X2, X4).
reachB(X1, X2, .(X3, X4)) :- memberA(X1, X2, X4).
reachB(X1, X2, X3) :- member1C(X1, X4, X3).
reachB(X1, X2, X3) :- ','(member1cC(X1, X4, X3), reachB(X4, X2, X3)).

Clauses:

membercA(X1, X2, .(.(X1, .(X2, [])), X3)).
membercA(X1, X2, .(X3, X4)) :- membercA(X1, X2, X4).
reachcB(X1, X2, .(.(X1, .(X2, [])), X3)).
reachcB(X1, X2, .(X3, X4)) :- membercA(X1, X2, X4).
reachcB(X1, X2, X3) :- ','(member1cC(X1, X4, X3), reachcB(X4, X2, X3)).
member1cC(X1, X2, .(.(X1, .(X2, [])), X3)).
member1cC(X1, X2, .(X3, X4)) :- member1cC(X1, X2, X4).

Afs:

reachB(x1, x2, x3)  =  reachB(x1, x2, x3)


----------------------------------------

(65) TriplesToPiDPProof (SOUND)
We use the technique of [DT09]. With regard to the inferred argument filtering the predicates were used in the following modes:

reachB_in_3: (b,b,b)

memberA_in_3: (b,b,b)

member1C_in_3: (b,f,b)

member1cC_in_3: (b,f,b)

Transforming TRIPLES into the following Term Rewriting System:

Pi DP problem:
The TRS P consists of the following rules:

   REACHB_IN_GGG(X1, X2, .(X3, X4)) -> U3_GGG(X1, X2, X3, X4, memberA_in_ggg(X1, X2, X4))
   REACHB_IN_GGG(X1, X2, .(X3, X4)) -> MEMBERA_IN_GGG(X1, X2, X4)
   MEMBERA_IN_GGG(X1, X2, .(X3, X4)) -> U1_GGG(X1, X2, X3, X4, memberA_in_ggg(X1, X2, X4))
   MEMBERA_IN_GGG(X1, X2, .(X3, X4)) -> MEMBERA_IN_GGG(X1, X2, X4)
   REACHB_IN_GGG(X1, X2, X3) -> U4_GGG(X1, X2, X3, member1C_in_gag(X1, X4, X3))
   REACHB_IN_GGG(X1, X2, X3) -> MEMBER1C_IN_GAG(X1, X4, X3)
   MEMBER1C_IN_GAG(X1, X2, .(X3, X4)) -> U2_GAG(X1, X2, X3, X4, member1C_in_gag(X1, X2, X4))
   MEMBER1C_IN_GAG(X1, X2, .(X3, X4)) -> MEMBER1C_IN_GAG(X1, X2, X4)
   REACHB_IN_GGG(X1, X2, X3) -> U5_GGG(X1, X2, X3, member1cC_in_gag(X1, X4, X3))
   U5_GGG(X1, X2, X3, member1cC_out_gag(X1, X4, X3)) -> U6_GGG(X1, X2, X3, reachB_in_ggg(X4, X2, X3))
   U5_GGG(X1, X2, X3, member1cC_out_gag(X1, X4, X3)) -> REACHB_IN_GGG(X4, X2, X3)

The TRS R consists of the following rules:

   member1cC_in_gag(X1, X2, .(.(X1, .(X2, [])), X3)) -> member1cC_out_gag(X1, X2, .(.(X1, .(X2, [])), X3))
   member1cC_in_gag(X1, X2, .(X3, X4)) -> U12_gag(X1, X2, X3, X4, member1cC_in_gag(X1, X2, X4))
   U12_gag(X1, X2, X3, X4, member1cC_out_gag(X1, X2, X4)) -> member1cC_out_gag(X1, X2, .(X3, X4))

The argument filtering Pi contains the following mapping:
reachB_in_ggg(x1, x2, x3)  =  reachB_in_ggg(x1, x2, x3)

.(x1, x2)  =  .(x1, x2)

memberA_in_ggg(x1, x2, x3)  =  memberA_in_ggg(x1, x2, x3)

member1C_in_gag(x1, x2, x3)  =  member1C_in_gag(x1, x3)

member1cC_in_gag(x1, x2, x3)  =  member1cC_in_gag(x1, x3)

[]  =  []

member1cC_out_gag(x1, x2, x3)  =  member1cC_out_gag(x1, x2, x3)

U12_gag(x1, x2, x3, x4, x5)  =  U12_gag(x1, x3, x4, x5)

REACHB_IN_GGG(x1, x2, x3)  =  REACHB_IN_GGG(x1, x2, x3)

U3_GGG(x1, x2, x3, x4, x5)  =  U3_GGG(x1, x2, x3, x4, x5)

MEMBERA_IN_GGG(x1, x2, x3)  =  MEMBERA_IN_GGG(x1, x2, x3)

U1_GGG(x1, x2, x3, x4, x5)  =  U1_GGG(x1, x2, x3, x4, x5)

U4_GGG(x1, x2, x3, x4)  =  U4_GGG(x1, x2, x3, x4)

MEMBER1C_IN_GAG(x1, x2, x3)  =  MEMBER1C_IN_GAG(x1, x3)

U2_GAG(x1, x2, x3, x4, x5)  =  U2_GAG(x1, x3, x4, x5)

U5_GGG(x1, x2, x3, x4)  =  U5_GGG(x1, x2, x3, x4)

U6_GGG(x1, x2, x3, x4)  =  U6_GGG(x1, x2, x3, x4)


We have to consider all (P,R,Pi)-chains


Infinitary Constructor Rewriting Termination of PiDP implies Termination of TRIPLES



----------------------------------------

(66)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   REACHB_IN_GGG(X1, X2, .(X3, X4)) -> U3_GGG(X1, X2, X3, X4, memberA_in_ggg(X1, X2, X4))
   REACHB_IN_GGG(X1, X2, .(X3, X4)) -> MEMBERA_IN_GGG(X1, X2, X4)
   MEMBERA_IN_GGG(X1, X2, .(X3, X4)) -> U1_GGG(X1, X2, X3, X4, memberA_in_ggg(X1, X2, X4))
   MEMBERA_IN_GGG(X1, X2, .(X3, X4)) -> MEMBERA_IN_GGG(X1, X2, X4)
   REACHB_IN_GGG(X1, X2, X3) -> U4_GGG(X1, X2, X3, member1C_in_gag(X1, X4, X3))
   REACHB_IN_GGG(X1, X2, X3) -> MEMBER1C_IN_GAG(X1, X4, X3)
   MEMBER1C_IN_GAG(X1, X2, .(X3, X4)) -> U2_GAG(X1, X2, X3, X4, member1C_in_gag(X1, X2, X4))
   MEMBER1C_IN_GAG(X1, X2, .(X3, X4)) -> MEMBER1C_IN_GAG(X1, X2, X4)
   REACHB_IN_GGG(X1, X2, X3) -> U5_GGG(X1, X2, X3, member1cC_in_gag(X1, X4, X3))
   U5_GGG(X1, X2, X3, member1cC_out_gag(X1, X4, X3)) -> U6_GGG(X1, X2, X3, reachB_in_ggg(X4, X2, X3))
   U5_GGG(X1, X2, X3, member1cC_out_gag(X1, X4, X3)) -> REACHB_IN_GGG(X4, X2, X3)

The TRS R consists of the following rules:

   member1cC_in_gag(X1, X2, .(.(X1, .(X2, [])), X3)) -> member1cC_out_gag(X1, X2, .(.(X1, .(X2, [])), X3))
   member1cC_in_gag(X1, X2, .(X3, X4)) -> U12_gag(X1, X2, X3, X4, member1cC_in_gag(X1, X2, X4))
   U12_gag(X1, X2, X3, X4, member1cC_out_gag(X1, X2, X4)) -> member1cC_out_gag(X1, X2, .(X3, X4))

The argument filtering Pi contains the following mapping:
reachB_in_ggg(x1, x2, x3)  =  reachB_in_ggg(x1, x2, x3)

.(x1, x2)  =  .(x1, x2)

memberA_in_ggg(x1, x2, x3)  =  memberA_in_ggg(x1, x2, x3)

member1C_in_gag(x1, x2, x3)  =  member1C_in_gag(x1, x3)

member1cC_in_gag(x1, x2, x3)  =  member1cC_in_gag(x1, x3)

[]  =  []

member1cC_out_gag(x1, x2, x3)  =  member1cC_out_gag(x1, x2, x3)

U12_gag(x1, x2, x3, x4, x5)  =  U12_gag(x1, x3, x4, x5)

REACHB_IN_GGG(x1, x2, x3)  =  REACHB_IN_GGG(x1, x2, x3)

U3_GGG(x1, x2, x3, x4, x5)  =  U3_GGG(x1, x2, x3, x4, x5)

MEMBERA_IN_GGG(x1, x2, x3)  =  MEMBERA_IN_GGG(x1, x2, x3)

U1_GGG(x1, x2, x3, x4, x5)  =  U1_GGG(x1, x2, x3, x4, x5)

U4_GGG(x1, x2, x3, x4)  =  U4_GGG(x1, x2, x3, x4)

MEMBER1C_IN_GAG(x1, x2, x3)  =  MEMBER1C_IN_GAG(x1, x3)

U2_GAG(x1, x2, x3, x4, x5)  =  U2_GAG(x1, x3, x4, x5)

U5_GGG(x1, x2, x3, x4)  =  U5_GGG(x1, x2, x3, x4)

U6_GGG(x1, x2, x3, x4)  =  U6_GGG(x1, x2, x3, x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(67) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 3 SCCs with 7 less nodes.
----------------------------------------

(68)
Complex Obligation (AND)

----------------------------------------

(69)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MEMBER1C_IN_GAG(X1, X2, .(X3, X4)) -> MEMBER1C_IN_GAG(X1, X2, X4)

The TRS R consists of the following rules:

   member1cC_in_gag(X1, X2, .(.(X1, .(X2, [])), X3)) -> member1cC_out_gag(X1, X2, .(.(X1, .(X2, [])), X3))
   member1cC_in_gag(X1, X2, .(X3, X4)) -> U12_gag(X1, X2, X3, X4, member1cC_in_gag(X1, X2, X4))
   U12_gag(X1, X2, X3, X4, member1cC_out_gag(X1, X2, X4)) -> member1cC_out_gag(X1, X2, .(X3, X4))

The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x1, x2)

member1cC_in_gag(x1, x2, x3)  =  member1cC_in_gag(x1, x3)

[]  =  []

member1cC_out_gag(x1, x2, x3)  =  member1cC_out_gag(x1, x2, x3)

U12_gag(x1, x2, x3, x4, x5)  =  U12_gag(x1, x3, x4, x5)

MEMBER1C_IN_GAG(x1, x2, x3)  =  MEMBER1C_IN_GAG(x1, x3)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(70) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(71)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MEMBER1C_IN_GAG(X1, X2, .(X3, X4)) -> MEMBER1C_IN_GAG(X1, X2, X4)

R is empty.
The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x1, x2)

MEMBER1C_IN_GAG(x1, x2, x3)  =  MEMBER1C_IN_GAG(x1, x3)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(72) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(73)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MEMBER1C_IN_GAG(X1, .(X3, X4)) -> MEMBER1C_IN_GAG(X1, X4)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(74) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*MEMBER1C_IN_GAG(X1, .(X3, X4)) -> MEMBER1C_IN_GAG(X1, X4)
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(75)
YES

----------------------------------------

(76)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MEMBERA_IN_GGG(X1, X2, .(X3, X4)) -> MEMBERA_IN_GGG(X1, X2, X4)

The TRS R consists of the following rules:

   member1cC_in_gag(X1, X2, .(.(X1, .(X2, [])), X3)) -> member1cC_out_gag(X1, X2, .(.(X1, .(X2, [])), X3))
   member1cC_in_gag(X1, X2, .(X3, X4)) -> U12_gag(X1, X2, X3, X4, member1cC_in_gag(X1, X2, X4))
   U12_gag(X1, X2, X3, X4, member1cC_out_gag(X1, X2, X4)) -> member1cC_out_gag(X1, X2, .(X3, X4))

The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x1, x2)

member1cC_in_gag(x1, x2, x3)  =  member1cC_in_gag(x1, x3)

[]  =  []

member1cC_out_gag(x1, x2, x3)  =  member1cC_out_gag(x1, x2, x3)

U12_gag(x1, x2, x3, x4, x5)  =  U12_gag(x1, x3, x4, x5)

MEMBERA_IN_GGG(x1, x2, x3)  =  MEMBERA_IN_GGG(x1, x2, x3)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(77) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(78)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MEMBERA_IN_GGG(X1, X2, .(X3, X4)) -> MEMBERA_IN_GGG(X1, X2, X4)

R is empty.
Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(79) PiDPToQDPProof (EQUIVALENT)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(80)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MEMBERA_IN_GGG(X1, X2, .(X3, X4)) -> MEMBERA_IN_GGG(X1, X2, X4)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(81) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*MEMBERA_IN_GGG(X1, X2, .(X3, X4)) -> MEMBERA_IN_GGG(X1, X2, X4)
The graph contains the following edges 1 >= 1, 2 >= 2, 3 > 3


----------------------------------------

(82)
YES

----------------------------------------

(83)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   REACHB_IN_GGG(X1, X2, X3) -> U5_GGG(X1, X2, X3, member1cC_in_gag(X1, X4, X3))
   U5_GGG(X1, X2, X3, member1cC_out_gag(X1, X4, X3)) -> REACHB_IN_GGG(X4, X2, X3)

The TRS R consists of the following rules:

   member1cC_in_gag(X1, X2, .(.(X1, .(X2, [])), X3)) -> member1cC_out_gag(X1, X2, .(.(X1, .(X2, [])), X3))
   member1cC_in_gag(X1, X2, .(X3, X4)) -> U12_gag(X1, X2, X3, X4, member1cC_in_gag(X1, X2, X4))
   U12_gag(X1, X2, X3, X4, member1cC_out_gag(X1, X2, X4)) -> member1cC_out_gag(X1, X2, .(X3, X4))

The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x1, x2)

member1cC_in_gag(x1, x2, x3)  =  member1cC_in_gag(x1, x3)

[]  =  []

member1cC_out_gag(x1, x2, x3)  =  member1cC_out_gag(x1, x2, x3)

U12_gag(x1, x2, x3, x4, x5)  =  U12_gag(x1, x3, x4, x5)

REACHB_IN_GGG(x1, x2, x3)  =  REACHB_IN_GGG(x1, x2, x3)

U5_GGG(x1, x2, x3, x4)  =  U5_GGG(x1, x2, x3, x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(84) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(85)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACHB_IN_GGG(X1, X2, X3) -> U5_GGG(X1, X2, X3, member1cC_in_gag(X1, X3))
   U5_GGG(X1, X2, X3, member1cC_out_gag(X1, X4, X3)) -> REACHB_IN_GGG(X4, X2, X3)

The TRS R consists of the following rules:

   member1cC_in_gag(X1, .(.(X1, .(X2, [])), X3)) -> member1cC_out_gag(X1, X2, .(.(X1, .(X2, [])), X3))
   member1cC_in_gag(X1, .(X3, X4)) -> U12_gag(X1, X3, X4, member1cC_in_gag(X1, X4))
   U12_gag(X1, X3, X4, member1cC_out_gag(X1, X2, X4)) -> member1cC_out_gag(X1, X2, .(X3, X4))

The set Q consists of the following terms:

   member1cC_in_gag(x0, x1)
   U12_gag(x0, x1, x2, x3)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(86) TransformationProof (SOUND)
By narrowing [LPAR04] the rule REACHB_IN_GGG(X1, X2, X3) -> U5_GGG(X1, X2, X3, member1cC_in_gag(X1, X3)) at position [3] we obtained the following new rules [LPAR04]:

   (REACHB_IN_GGG(x0, y1, .(.(x0, .(x1, [])), x2)) -> U5_GGG(x0, y1, .(.(x0, .(x1, [])), x2), member1cC_out_gag(x0, x1, .(.(x0, .(x1, [])), x2))),REACHB_IN_GGG(x0, y1, .(.(x0, .(x1, [])), x2)) -> U5_GGG(x0, y1, .(.(x0, .(x1, [])), x2), member1cC_out_gag(x0, x1, .(.(x0, .(x1, [])), x2))))
   (REACHB_IN_GGG(x0, y1, .(x1, x2)) -> U5_GGG(x0, y1, .(x1, x2), U12_gag(x0, x1, x2, member1cC_in_gag(x0, x2))),REACHB_IN_GGG(x0, y1, .(x1, x2)) -> U5_GGG(x0, y1, .(x1, x2), U12_gag(x0, x1, x2, member1cC_in_gag(x0, x2))))


----------------------------------------

(87)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U5_GGG(X1, X2, X3, member1cC_out_gag(X1, X4, X3)) -> REACHB_IN_GGG(X4, X2, X3)
   REACHB_IN_GGG(x0, y1, .(.(x0, .(x1, [])), x2)) -> U5_GGG(x0, y1, .(.(x0, .(x1, [])), x2), member1cC_out_gag(x0, x1, .(.(x0, .(x1, [])), x2)))
   REACHB_IN_GGG(x0, y1, .(x1, x2)) -> U5_GGG(x0, y1, .(x1, x2), U12_gag(x0, x1, x2, member1cC_in_gag(x0, x2)))

The TRS R consists of the following rules:

   member1cC_in_gag(X1, .(.(X1, .(X2, [])), X3)) -> member1cC_out_gag(X1, X2, .(.(X1, .(X2, [])), X3))
   member1cC_in_gag(X1, .(X3, X4)) -> U12_gag(X1, X3, X4, member1cC_in_gag(X1, X4))
   U12_gag(X1, X3, X4, member1cC_out_gag(X1, X2, X4)) -> member1cC_out_gag(X1, X2, .(X3, X4))

The set Q consists of the following terms:

   member1cC_in_gag(x0, x1)
   U12_gag(x0, x1, x2, x3)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(88) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U5_GGG(X1, X2, X3, member1cC_out_gag(X1, X4, X3)) -> REACHB_IN_GGG(X4, X2, X3) we obtained the following new rules [LPAR04]:

   (U5_GGG(z0, z1, .(.(z0, .(z2, [])), z3), member1cC_out_gag(z0, z2, .(.(z0, .(z2, [])), z3))) -> REACHB_IN_GGG(z2, z1, .(.(z0, .(z2, [])), z3)),U5_GGG(z0, z1, .(.(z0, .(z2, [])), z3), member1cC_out_gag(z0, z2, .(.(z0, .(z2, [])), z3))) -> REACHB_IN_GGG(z2, z1, .(.(z0, .(z2, [])), z3)))
   (U5_GGG(z0, z1, .(z2, z3), member1cC_out_gag(z0, x3, .(z2, z3))) -> REACHB_IN_GGG(x3, z1, .(z2, z3)),U5_GGG(z0, z1, .(z2, z3), member1cC_out_gag(z0, x3, .(z2, z3))) -> REACHB_IN_GGG(x3, z1, .(z2, z3)))


----------------------------------------

(89)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACHB_IN_GGG(x0, y1, .(.(x0, .(x1, [])), x2)) -> U5_GGG(x0, y1, .(.(x0, .(x1, [])), x2), member1cC_out_gag(x0, x1, .(.(x0, .(x1, [])), x2)))
   REACHB_IN_GGG(x0, y1, .(x1, x2)) -> U5_GGG(x0, y1, .(x1, x2), U12_gag(x0, x1, x2, member1cC_in_gag(x0, x2)))
   U5_GGG(z0, z1, .(.(z0, .(z2, [])), z3), member1cC_out_gag(z0, z2, .(.(z0, .(z2, [])), z3))) -> REACHB_IN_GGG(z2, z1, .(.(z0, .(z2, [])), z3))
   U5_GGG(z0, z1, .(z2, z3), member1cC_out_gag(z0, x3, .(z2, z3))) -> REACHB_IN_GGG(x3, z1, .(z2, z3))

The TRS R consists of the following rules:

   member1cC_in_gag(X1, .(.(X1, .(X2, [])), X3)) -> member1cC_out_gag(X1, X2, .(.(X1, .(X2, [])), X3))
   member1cC_in_gag(X1, .(X3, X4)) -> U12_gag(X1, X3, X4, member1cC_in_gag(X1, X4))
   U12_gag(X1, X3, X4, member1cC_out_gag(X1, X2, X4)) -> member1cC_out_gag(X1, X2, .(X3, X4))

The set Q consists of the following terms:

   member1cC_in_gag(x0, x1)
   U12_gag(x0, x1, x2, x3)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(90) PrologToTRSTransformerProof (SOUND)
Transformed Prolog program to TRS.

{
    "root": 1,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(reach X Y Edges)",
                "(member (. X (. Y ([]))) Edges)"
            ],
            [
                "(reach X Z Edges)",
                "(',' (member1 (. X (. Y ([]))) Edges) (reach Y Z Edges))"
            ],
            [
                "(member H (. H L))",
                null
            ],
            [
                "(member X (. H L))",
                "(member X L)"
            ],
            [
                "(member1 H (. H L))",
                null
            ],
            [
                "(member1 X (. H L))",
                "(member1 X L)"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "type": "Nodes",
            "179": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(member (. T28 (. T29 ([]))) T30)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T28",
                        "T29",
                        "T30"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "180": {
                "goal": [{
                    "clause": 3,
                    "scope": 2,
                    "term": "(member (. T28 (. T29 ([]))) T30)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T28",
                        "T29",
                        "T30"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "181": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "182": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "183": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "283": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (member1 (. T82 (. X67 ([]))) T84) (reach X67 T83 T84))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T82",
                        "T83",
                        "T84"
                    ],
                    "free": ["X67"],
                    "exprvars": []
                }
            },
            "262": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(member (. T60 (. T61 ([]))) T63)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T60",
                        "T61",
                        "T63"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "263": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "286": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(member1 (. T82 (. X67 ([]))) T84)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T82",
                        "T84"
                    ],
                    "free": ["X67"],
                    "exprvars": []
                }
            },
            "1": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(reach T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2",
                        "T3"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "166": {
                "goal": [
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(member (. T28 (. T29 ([]))) T30)"
                    },
                    {
                        "clause": 3,
                        "scope": 2,
                        "term": "(member (. T28 (. T29 ([]))) T30)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T28",
                        "T29",
                        "T30"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "287": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(reach T91 T83 T84)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T83",
                        "T84",
                        "T91"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "300": {
                "goal": [
                    {
                        "clause": 4,
                        "scope": 3,
                        "term": "(member1 (. T82 (. X67 ([]))) T84)"
                    },
                    {
                        "clause": 5,
                        "scope": 3,
                        "term": "(member1 (. T82 (. X67 ([]))) T84)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T82",
                        "T84"
                    ],
                    "free": ["X67"],
                    "exprvars": []
                }
            },
            "301": {
                "goal": [{
                    "clause": 4,
                    "scope": 3,
                    "term": "(member1 (. T82 (. X67 ([]))) T84)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T82",
                        "T84"
                    ],
                    "free": ["X67"],
                    "exprvars": []
                }
            },
            "5": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 1,
                        "term": "(reach T1 T2 T3)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(reach T1 T2 T3)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2",
                        "T3"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "302": {
                "goal": [{
                    "clause": 5,
                    "scope": 3,
                    "term": "(member1 (. T82 (. X67 ([]))) T84)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T82",
                        "T84"
                    ],
                    "free": ["X67"],
                    "exprvars": []
                }
            },
            "303": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "304": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "8": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(reach T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2",
                        "T3"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "305": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "9": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(reach T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2",
                        "T3"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "306": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(member1 (. T119 (. X106 ([]))) T121)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T119",
                        "T121"
                    ],
                    "free": ["X106"],
                    "exprvars": []
                }
            },
            "307": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "21": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(member (. T28 (. T29 ([]))) T30)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T28",
                        "T29",
                        "T30"
                    ],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 1,
                "to": 5,
                "label": "CASE"
            },
            {
                "from": 5,
                "to": 8,
                "label": "PARALLEL"
            },
            {
                "from": 5,
                "to": 9,
                "label": "PARALLEL"
            },
            {
                "from": 8,
                "to": 21,
                "label": "ONLY EVAL with clause\nreach(X21, X22, X23) :- member(.(X21, .(X22, [])), X23).\nand substitutionT1 -> T28,\nX21 -> T28,\nT2 -> T29,\nX22 -> T29,\nT3 -> T30,\nX23 -> T30"
            },
            {
                "from": 9,
                "to": 283,
                "label": "ONLY EVAL with clause\nreach(X64, X65, X66) :- ','(member1(.(X64, .(X67, [])), X66), reach(X67, X65, X66)).\nand substitutionT1 -> T82,\nX64 -> T82,\nT2 -> T83,\nX65 -> T83,\nT3 -> T84,\nX66 -> T84"
            },
            {
                "from": 21,
                "to": 166,
                "label": "CASE"
            },
            {
                "from": 166,
                "to": 179,
                "label": "PARALLEL"
            },
            {
                "from": 166,
                "to": 180,
                "label": "PARALLEL"
            },
            {
                "from": 179,
                "to": 181,
                "label": "EVAL with clause\nmember(X36, .(X36, X37)).\nand substitutionT28 -> T49,\nT29 -> T50,\nX36 -> .(T49, .(T50, [])),\nX37 -> T51,\nT30 -> .(.(T49, .(T50, [])), T51)"
            },
            {
                "from": 179,
                "to": 182,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 180,
                "to": 262,
                "label": "EVAL with clause\nmember(X44, .(X45, X46)) :- member(X44, X46).\nand substitutionT28 -> T60,\nT29 -> T61,\nX44 -> .(T60, .(T61, [])),\nX45 -> T62,\nX46 -> T63,\nT30 -> .(T62, T63)"
            },
            {
                "from": 180,
                "to": 263,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 181,
                "to": 183,
                "label": "SUCCESS"
            },
            {
                "from": 262,
                "to": 21,
                "label": "INSTANCE with matching:\nT28 -> T60\nT29 -> T61\nT30 -> T63"
            },
            {
                "from": 283,
                "to": 286,
                "label": "SPLIT 1"
            },
            {
                "from": 283,
                "to": 287,
                "label": "SPLIT 2\nnew knowledge:\nT82 is ground\nT91 is ground\nT84 is ground\nreplacements:X67 -> T91"
            },
            {
                "from": 286,
                "to": 300,
                "label": "CASE"
            },
            {
                "from": 287,
                "to": 1,
                "label": "INSTANCE with matching:\nT1 -> T91\nT2 -> T83\nT3 -> T84"
            },
            {
                "from": 300,
                "to": 301,
                "label": "PARALLEL"
            },
            {
                "from": 300,
                "to": 302,
                "label": "PARALLEL"
            },
            {
                "from": 301,
                "to": 303,
                "label": "EVAL with clause\nmember1(X92, .(X92, X93)).\nand substitutionT82 -> T110,\nX67 -> T111,\nX92 -> .(T110, .(T111, [])),\nX94 -> T111,\nX93 -> T112,\nT84 -> .(.(T110, .(T111, [])), T112)"
            },
            {
                "from": 301,
                "to": 304,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 302,
                "to": 306,
                "label": "EVAL with clause\nmember1(X103, .(X104, X105)) :- member1(X103, X105).\nand substitutionT82 -> T119,\nX67 -> X106,\nX103 -> .(T119, .(X106, [])),\nX104 -> T120,\nX105 -> T121,\nT84 -> .(T120, T121)"
            },
            {
                "from": 302,
                "to": 307,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 303,
                "to": 305,
                "label": "SUCCESS"
            },
            {
                "from": 306,
                "to": 286,
                "label": "INSTANCE with matching:\nT82 -> T119\nX67 -> X106\nT84 -> T121"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(91)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f1_in(T28, T29, T30) -> U1(f21_in(T28, T29, T30), T28, T29, T30)
   U1(f21_out1, T28, T29, T30) -> f1_out1
   f1_in(T82, T83, T84) -> U2(f283_in(T82, T84, T83), T82, T83, T84)
   U2(f283_out1(X67), T82, T83, T84) -> f1_out1
   f21_in(T49, T50, .(.(T49, .(T50, [])), T51)) -> f21_out1
   f21_in(T60, T61, .(T62, T63)) -> U3(f21_in(T60, T61, T63), T60, T61, .(T62, T63))
   U3(f21_out1, T60, T61, .(T62, T63)) -> f21_out1
   f286_in(T110, .(.(T110, .(T111, [])), T112)) -> f286_out1(T111)
   f286_in(T119, .(T120, T121)) -> U4(f286_in(T119, T121), T119, .(T120, T121))
   U4(f286_out1(X106), T119, .(T120, T121)) -> f286_out1(X106)
   f283_in(T82, T84, T83) -> U5(f286_in(T82, T84), T82, T84, T83)
   U5(f286_out1(T91), T82, T84, T83) -> U6(f1_in(T91, T83, T84), T82, T84, T83, T91)
   U6(f1_out1, T82, T84, T83, T91) -> f283_out1(T91)

Q is empty.

----------------------------------------

(92) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(93)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(T28, T29, T30) -> U1^1(f21_in(T28, T29, T30), T28, T29, T30)
   F1_IN(T28, T29, T30) -> F21_IN(T28, T29, T30)
   F1_IN(T82, T83, T84) -> U2^1(f283_in(T82, T84, T83), T82, T83, T84)
   F1_IN(T82, T83, T84) -> F283_IN(T82, T84, T83)
   F21_IN(T60, T61, .(T62, T63)) -> U3^1(f21_in(T60, T61, T63), T60, T61, .(T62, T63))
   F21_IN(T60, T61, .(T62, T63)) -> F21_IN(T60, T61, T63)
   F286_IN(T119, .(T120, T121)) -> U4^1(f286_in(T119, T121), T119, .(T120, T121))
   F286_IN(T119, .(T120, T121)) -> F286_IN(T119, T121)
   F283_IN(T82, T84, T83) -> U5^1(f286_in(T82, T84), T82, T84, T83)
   F283_IN(T82, T84, T83) -> F286_IN(T82, T84)
   U5^1(f286_out1(T91), T82, T84, T83) -> U6^1(f1_in(T91, T83, T84), T82, T84, T83, T91)
   U5^1(f286_out1(T91), T82, T84, T83) -> F1_IN(T91, T83, T84)

The TRS R consists of the following rules:

   f1_in(T28, T29, T30) -> U1(f21_in(T28, T29, T30), T28, T29, T30)
   U1(f21_out1, T28, T29, T30) -> f1_out1
   f1_in(T82, T83, T84) -> U2(f283_in(T82, T84, T83), T82, T83, T84)
   U2(f283_out1(X67), T82, T83, T84) -> f1_out1
   f21_in(T49, T50, .(.(T49, .(T50, [])), T51)) -> f21_out1
   f21_in(T60, T61, .(T62, T63)) -> U3(f21_in(T60, T61, T63), T60, T61, .(T62, T63))
   U3(f21_out1, T60, T61, .(T62, T63)) -> f21_out1
   f286_in(T110, .(.(T110, .(T111, [])), T112)) -> f286_out1(T111)
   f286_in(T119, .(T120, T121)) -> U4(f286_in(T119, T121), T119, .(T120, T121))
   U4(f286_out1(X106), T119, .(T120, T121)) -> f286_out1(X106)
   f283_in(T82, T84, T83) -> U5(f286_in(T82, T84), T82, T84, T83)
   U5(f286_out1(T91), T82, T84, T83) -> U6(f1_in(T91, T83, T84), T82, T84, T83, T91)
   U6(f1_out1, T82, T84, T83, T91) -> f283_out1(T91)

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(94) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 3 SCCs with 7 less nodes.
----------------------------------------

(95)
Complex Obligation (AND)

----------------------------------------

(96)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F286_IN(T119, .(T120, T121)) -> F286_IN(T119, T121)

The TRS R consists of the following rules:

   f1_in(T28, T29, T30) -> U1(f21_in(T28, T29, T30), T28, T29, T30)
   U1(f21_out1, T28, T29, T30) -> f1_out1
   f1_in(T82, T83, T84) -> U2(f283_in(T82, T84, T83), T82, T83, T84)
   U2(f283_out1(X67), T82, T83, T84) -> f1_out1
   f21_in(T49, T50, .(.(T49, .(T50, [])), T51)) -> f21_out1
   f21_in(T60, T61, .(T62, T63)) -> U3(f21_in(T60, T61, T63), T60, T61, .(T62, T63))
   U3(f21_out1, T60, T61, .(T62, T63)) -> f21_out1
   f286_in(T110, .(.(T110, .(T111, [])), T112)) -> f286_out1(T111)
   f286_in(T119, .(T120, T121)) -> U4(f286_in(T119, T121), T119, .(T120, T121))
   U4(f286_out1(X106), T119, .(T120, T121)) -> f286_out1(X106)
   f283_in(T82, T84, T83) -> U5(f286_in(T82, T84), T82, T84, T83)
   U5(f286_out1(T91), T82, T84, T83) -> U6(f1_in(T91, T83, T84), T82, T84, T83, T91)
   U6(f1_out1, T82, T84, T83, T91) -> f283_out1(T91)

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(97) UsableRulesProof (EQUIVALENT)
We can use the usable rules and reduction pair processor [LPAR04] with the Ce-compatible extension of the polynomial order that maps every function symbol to the sum of its arguments. Then, we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(98)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F286_IN(T119, .(T120, T121)) -> F286_IN(T119, T121)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(99) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*F286_IN(T119, .(T120, T121)) -> F286_IN(T119, T121)
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(100)
YES

----------------------------------------

(101)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F21_IN(T60, T61, .(T62, T63)) -> F21_IN(T60, T61, T63)

The TRS R consists of the following rules:

   f1_in(T28, T29, T30) -> U1(f21_in(T28, T29, T30), T28, T29, T30)
   U1(f21_out1, T28, T29, T30) -> f1_out1
   f1_in(T82, T83, T84) -> U2(f283_in(T82, T84, T83), T82, T83, T84)
   U2(f283_out1(X67), T82, T83, T84) -> f1_out1
   f21_in(T49, T50, .(.(T49, .(T50, [])), T51)) -> f21_out1
   f21_in(T60, T61, .(T62, T63)) -> U3(f21_in(T60, T61, T63), T60, T61, .(T62, T63))
   U3(f21_out1, T60, T61, .(T62, T63)) -> f21_out1
   f286_in(T110, .(.(T110, .(T111, [])), T112)) -> f286_out1(T111)
   f286_in(T119, .(T120, T121)) -> U4(f286_in(T119, T121), T119, .(T120, T121))
   U4(f286_out1(X106), T119, .(T120, T121)) -> f286_out1(X106)
   f283_in(T82, T84, T83) -> U5(f286_in(T82, T84), T82, T84, T83)
   U5(f286_out1(T91), T82, T84, T83) -> U6(f1_in(T91, T83, T84), T82, T84, T83, T91)
   U6(f1_out1, T82, T84, T83, T91) -> f283_out1(T91)

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(102) UsableRulesProof (EQUIVALENT)
We can use the usable rules and reduction pair processor [LPAR04] with the Ce-compatible extension of the polynomial order that maps every function symbol to the sum of its arguments. Then, we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(103)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F21_IN(T60, T61, .(T62, T63)) -> F21_IN(T60, T61, T63)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(104) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*F21_IN(T60, T61, .(T62, T63)) -> F21_IN(T60, T61, T63)
The graph contains the following edges 1 >= 1, 2 >= 2, 3 > 3


----------------------------------------

(105)
YES

----------------------------------------

(106)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(T82, T83, T84) -> F283_IN(T82, T84, T83)
   F283_IN(T82, T84, T83) -> U5^1(f286_in(T82, T84), T82, T84, T83)
   U5^1(f286_out1(T91), T82, T84, T83) -> F1_IN(T91, T83, T84)

The TRS R consists of the following rules:

   f1_in(T28, T29, T30) -> U1(f21_in(T28, T29, T30), T28, T29, T30)
   U1(f21_out1, T28, T29, T30) -> f1_out1
   f1_in(T82, T83, T84) -> U2(f283_in(T82, T84, T83), T82, T83, T84)
   U2(f283_out1(X67), T82, T83, T84) -> f1_out1
   f21_in(T49, T50, .(.(T49, .(T50, [])), T51)) -> f21_out1
   f21_in(T60, T61, .(T62, T63)) -> U3(f21_in(T60, T61, T63), T60, T61, .(T62, T63))
   U3(f21_out1, T60, T61, .(T62, T63)) -> f21_out1
   f286_in(T110, .(.(T110, .(T111, [])), T112)) -> f286_out1(T111)
   f286_in(T119, .(T120, T121)) -> U4(f286_in(T119, T121), T119, .(T120, T121))
   U4(f286_out1(X106), T119, .(T120, T121)) -> f286_out1(X106)
   f283_in(T82, T84, T83) -> U5(f286_in(T82, T84), T82, T84, T83)
   U5(f286_out1(T91), T82, T84, T83) -> U6(f1_in(T91, T83, T84), T82, T84, T83, T91)
   U6(f1_out1, T82, T84, T83, T91) -> f283_out1(T91)

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(107) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = F283_IN(T82, .(.(T82, .(T111, [])), T112), T83) evaluates to  t =F283_IN(T111, .(.(T82, .(T111, [])), T112), T83)

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [T111 / T82]

--------------------------------------------------------------------------------
Rewriting sequence

F283_IN(T82, .(.(T82, .(T82, [])), T112), T83) -> U5^1(f286_in(T82, .(.(T82, .(T82, [])), T112)), T82, .(.(T82, .(T82, [])), T112), T83)
with rule F283_IN(T82', T84, T83') -> U5^1(f286_in(T82', T84), T82', T84, T83') at position [] and matcher [T82' / T82, T84 / .(.(T82, .(T82, [])), T112), T83' / T83]

U5^1(f286_in(T82, .(.(T82, .(T82, [])), T112)), T82, .(.(T82, .(T82, [])), T112), T83) -> U5^1(f286_out1(T82), T82, .(.(T82, .(T82, [])), T112), T83)
with rule f286_in(T110, .(.(T110, .(T111, [])), T112')) -> f286_out1(T111) at position [0] and matcher [T110 / T82, T111 / T82, T112' / T112]

U5^1(f286_out1(T82), T82, .(.(T82, .(T82, [])), T112), T83) -> F1_IN(T82, T83, .(.(T82, .(T82, [])), T112))
with rule U5^1(f286_out1(T91), T82', T84', T83') -> F1_IN(T91, T83', T84') at position [] and matcher [T91 / T82, T82' / T82, T84' / .(.(T82, .(T82, [])), T112), T83' / T83]

F1_IN(T82, T83, .(.(T82, .(T82, [])), T112)) -> F283_IN(T82, .(.(T82, .(T82, [])), T112), T83)
with rule F1_IN(T82, T83, T84) -> F283_IN(T82, T84, T83)

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(108)
NO

----------------------------------------

(109) PrologToIRSwTTransformerProof (SOUND)
Transformed Prolog program to IRSwT according to method in Master Thesis of A. Weinert

{
    "root": 2,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(reach X Y Edges)",
                "(member (. X (. Y ([]))) Edges)"
            ],
            [
                "(reach X Z Edges)",
                "(',' (member1 (. X (. Y ([]))) Edges) (reach Y Z Edges))"
            ],
            [
                "(member H (. H L))",
                null
            ],
            [
                "(member X (. H L))",
                "(member X L)"
            ],
            [
                "(member1 H (. H L))",
                null
            ],
            [
                "(member1 X (. H L))",
                "(member1 X L)"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "290": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(reach T91 T83 T84)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T83",
                        "T84",
                        "T91"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "291": {
                "goal": [
                    {
                        "clause": 4,
                        "scope": 3,
                        "term": "(member1 (. T82 (. X67 ([]))) T84)"
                    },
                    {
                        "clause": 5,
                        "scope": 3,
                        "term": "(member1 (. T82 (. X67 ([]))) T84)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T82",
                        "T84"
                    ],
                    "free": ["X67"],
                    "exprvars": []
                }
            },
            "292": {
                "goal": [{
                    "clause": 4,
                    "scope": 3,
                    "term": "(member1 (. T82 (. X67 ([]))) T84)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T82",
                        "T84"
                    ],
                    "free": ["X67"],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "293": {
                "goal": [{
                    "clause": 5,
                    "scope": 3,
                    "term": "(member1 (. T82 (. X67 ([]))) T84)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T82",
                        "T84"
                    ],
                    "free": ["X67"],
                    "exprvars": []
                }
            },
            "294": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "295": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "296": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "275": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(member (. T28 (. T29 ([]))) T30)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T28",
                        "T29",
                        "T30"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "297": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(member1 (. T119 (. X106 ([]))) T121)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T119",
                        "T121"
                    ],
                    "free": ["X106"],
                    "exprvars": []
                }
            },
            "276": {
                "goal": [{
                    "clause": 3,
                    "scope": 2,
                    "term": "(member (. T28 (. T29 ([]))) T30)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T28",
                        "T29",
                        "T30"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "298": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "277": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "278": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "279": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "258": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(reach T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2",
                        "T3"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "259": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(reach T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2",
                        "T3"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "281": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(member (. T60 (. T61 ([]))) T63)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T60",
                        "T61",
                        "T63"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "260": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(member (. T28 (. T29 ([]))) T30)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T28",
                        "T29",
                        "T30"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "282": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "261": {
                "goal": [
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(member (. T28 (. T29 ([]))) T30)"
                    },
                    {
                        "clause": 3,
                        "scope": 2,
                        "term": "(member (. T28 (. T29 ([]))) T30)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T28",
                        "T29",
                        "T30"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "2": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(reach T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2",
                        "T3"
                    ],
                    "free": [],
                    "exprvars": []
                }
            },
            "288": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (member1 (. T82 (. X67 ([]))) T84) (reach X67 T83 T84))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T82",
                        "T83",
                        "T84"
                    ],
                    "free": ["X67"],
                    "exprvars": []
                }
            },
            "289": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(member1 (. T82 (. X67 ([]))) T84)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T82",
                        "T84"
                    ],
                    "free": ["X67"],
                    "exprvars": []
                }
            },
            "6": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 1,
                        "term": "(reach T1 T2 T3)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(reach T1 T2 T3)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [
                        "T1",
                        "T2",
                        "T3"
                    ],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 2,
                "to": 6,
                "label": "CASE"
            },
            {
                "from": 6,
                "to": 258,
                "label": "PARALLEL"
            },
            {
                "from": 6,
                "to": 259,
                "label": "PARALLEL"
            },
            {
                "from": 258,
                "to": 260,
                "label": "ONLY EVAL with clause\nreach(X21, X22, X23) :- member(.(X21, .(X22, [])), X23).\nand substitutionT1 -> T28,\nX21 -> T28,\nT2 -> T29,\nX22 -> T29,\nT3 -> T30,\nX23 -> T30"
            },
            {
                "from": 259,
                "to": 288,
                "label": "ONLY EVAL with clause\nreach(X64, X65, X66) :- ','(member1(.(X64, .(X67, [])), X66), reach(X67, X65, X66)).\nand substitutionT1 -> T82,\nX64 -> T82,\nT2 -> T83,\nX65 -> T83,\nT3 -> T84,\nX66 -> T84"
            },
            {
                "from": 260,
                "to": 261,
                "label": "CASE"
            },
            {
                "from": 261,
                "to": 275,
                "label": "PARALLEL"
            },
            {
                "from": 261,
                "to": 276,
                "label": "PARALLEL"
            },
            {
                "from": 275,
                "to": 277,
                "label": "EVAL with clause\nmember(X36, .(X36, X37)).\nand substitutionT28 -> T49,\nT29 -> T50,\nX36 -> .(T49, .(T50, [])),\nX37 -> T51,\nT30 -> .(.(T49, .(T50, [])), T51)"
            },
            {
                "from": 275,
                "to": 278,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 276,
                "to": 281,
                "label": "EVAL with clause\nmember(X44, .(X45, X46)) :- member(X44, X46).\nand substitutionT28 -> T60,\nT29 -> T61,\nX44 -> .(T60, .(T61, [])),\nX45 -> T62,\nX46 -> T63,\nT30 -> .(T62, T63)"
            },
            {
                "from": 276,
                "to": 282,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 277,
                "to": 279,
                "label": "SUCCESS"
            },
            {
                "from": 281,
                "to": 260,
                "label": "INSTANCE with matching:\nT28 -> T60\nT29 -> T61\nT30 -> T63"
            },
            {
                "from": 288,
                "to": 289,
                "label": "SPLIT 1"
            },
            {
                "from": 288,
                "to": 290,
                "label": "SPLIT 2\nnew knowledge:\nT82 is ground\nT91 is ground\nT84 is ground\nreplacements:X67 -> T91"
            },
            {
                "from": 289,
                "to": 291,
                "label": "CASE"
            },
            {
                "from": 290,
                "to": 2,
                "label": "INSTANCE with matching:\nT1 -> T91\nT2 -> T83\nT3 -> T84"
            },
            {
                "from": 291,
                "to": 292,
                "label": "PARALLEL"
            },
            {
                "from": 291,
                "to": 293,
                "label": "PARALLEL"
            },
            {
                "from": 292,
                "to": 294,
                "label": "EVAL with clause\nmember1(X92, .(X92, X93)).\nand substitutionT82 -> T110,\nX67 -> T111,\nX92 -> .(T110, .(T111, [])),\nX94 -> T111,\nX93 -> T112,\nT84 -> .(.(T110, .(T111, [])), T112)"
            },
            {
                "from": 292,
                "to": 295,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 293,
                "to": 297,
                "label": "EVAL with clause\nmember1(X103, .(X104, X105)) :- member1(X103, X105).\nand substitutionT82 -> T119,\nX67 -> X106,\nX103 -> .(T119, .(X106, [])),\nX104 -> T120,\nX105 -> T121,\nT84 -> .(T120, T121)"
            },
            {
                "from": 293,
                "to": 298,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 294,
                "to": 296,
                "label": "SUCCESS"
            },
            {
                "from": 297,
                "to": 289,
                "label": "INSTANCE with matching:\nT82 -> T119\nX67 -> X106\nT84 -> T121"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(110)
Complex Obligation (AND)

----------------------------------------

(111)
Obligation:
Rules:
f297_out(T119, T121) -> f293_out(T119, .(T120, T121)) :|: TRUE
f293_in(T82, T84) -> f298_in :|: TRUE
f293_in(x, .(x1, x2)) -> f297_in(x, x2) :|: TRUE
f298_out -> f293_out(x3, x4) :|: TRUE
f289_out(x5, x6) -> f297_out(x5, x6) :|: TRUE
f297_in(x7, x8) -> f289_in(x7, x8) :|: TRUE
f291_in(x9, x10) -> f292_in(x9, x10) :|: TRUE
f293_out(x11, x12) -> f291_out(x11, x12) :|: TRUE
f292_out(x13, x14) -> f291_out(x13, x14) :|: TRUE
f291_in(x15, x16) -> f293_in(x15, x16) :|: TRUE
f289_in(x17, x18) -> f291_in(x17, x18) :|: TRUE
f291_out(x19, x20) -> f289_out(x19, x20) :|: TRUE
f6_out(T1, T2, T3) -> f2_out(T1, T2, T3) :|: TRUE
f2_in(x21, x22, x23) -> f6_in(x21, x22, x23) :|: TRUE
f6_in(x24, x25, x26) -> f259_in(x24, x25, x26) :|: TRUE
f258_out(x27, x28, x29) -> f6_out(x27, x28, x29) :|: TRUE
f259_out(x30, x31, x32) -> f6_out(x30, x31, x32) :|: TRUE
f6_in(x33, x34, x35) -> f258_in(x33, x34, x35) :|: TRUE
f259_in(x36, x37, x38) -> f288_in(x36, x38, x37) :|: TRUE
f288_out(x39, x40, x41) -> f259_out(x39, x41, x40) :|: TRUE
f288_in(x42, x43, x44) -> f289_in(x42, x43) :|: TRUE
f290_out(x45, x46, x47) -> f288_out(x48, x47, x46) :|: TRUE
f289_out(x49, x50) -> f290_in(x51, x52, x50) :|: TRUE
Start term: f2_in(T1, T2, T3)

----------------------------------------

(112) IRSwTSimpleDependencyGraphProof (EQUIVALENT)
Constructed simple dependency graph.

Simplified to the following IRSwTs:

intTRSProblem:
f293_in(x, .(x1, x2)) -> f297_in(x, x2) :|: TRUE
f297_in(x7, x8) -> f289_in(x7, x8) :|: TRUE
f291_in(x15, x16) -> f293_in(x15, x16) :|: TRUE
f289_in(x17, x18) -> f291_in(x17, x18) :|: TRUE


----------------------------------------

(113)
Obligation:
Rules:
f293_in(x, .(x1, x2)) -> f297_in(x, x2) :|: TRUE
f297_in(x7, x8) -> f289_in(x7, x8) :|: TRUE
f291_in(x15, x16) -> f293_in(x15, x16) :|: TRUE
f289_in(x17, x18) -> f291_in(x17, x18) :|: TRUE

----------------------------------------

(114) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(115)
Obligation:
Rules:
f291_in(x15:0, .(x1:0, x2:0)) -> f291_in(x15:0, x2:0) :|: TRUE

----------------------------------------

(116) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(117)
Obligation:
Rules:
f291_in(x15:0, .(x1:0, x2:0)) -> f291_in(x15:0, x2:0) :|: TRUE

----------------------------------------

(118) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f291_in(x15:0, .(x1:0, x2:0)) -> f291_in(x15:0, x2:0) :|: TRUE

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(119)
Obligation:

Termination digraph:
Nodes:
(1) f291_in(x15:0, .(x1:0, x2:0)) -> f291_in(x15:0, x2:0) :|: TRUE

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(120) IntTRSUnneededArgumentFilterProof (EQUIVALENT)
Some arguments are removed because they cannot influence termination. We removed arguments according to the following replacements:

   f291_in(x1, x2) -> f291_in(x2)
   .(x1, x2) -> .(x2)

----------------------------------------

(121)
Obligation:
Rules:
f291_in(.(x2:0)) -> f291_in(x2:0) :|: TRUE

----------------------------------------

(122) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f291_in(VARIABLE)
.(VARIABLE)
Removed predefined arithmetic.
----------------------------------------

(123)
Obligation:
Rules:
f291_in(.(x2:0)) -> f291_in(x2:0)

----------------------------------------

(124) IRSwTToQDPProof (SOUND)
Removed the integers and created a QDP-Problem.
----------------------------------------

(125)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   f291_in(.(x2:0)) -> f291_in(x2:0)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(126) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*f291_in(.(x2:0)) -> f291_in(x2:0)
The graph contains the following edges 1 > 1


----------------------------------------

(127)
YES

----------------------------------------

(128)
Obligation:
Rules:
f276_in(T28, T29, T30) -> f282_in :|: TRUE
f281_out(T60, T61, T63) -> f276_out(T60, T61, .(T62, T63)) :|: TRUE
f282_out -> f276_out(x, x1, x2) :|: TRUE
f276_in(x3, x4, .(x5, x6)) -> f281_in(x3, x4, x6) :|: TRUE
f275_out(x7, x8, x9) -> f261_out(x7, x8, x9) :|: TRUE
f276_out(x10, x11, x12) -> f261_out(x10, x11, x12) :|: TRUE
f261_in(x13, x14, x15) -> f275_in(x13, x14, x15) :|: TRUE
f261_in(x16, x17, x18) -> f276_in(x16, x17, x18) :|: TRUE
f281_in(x19, x20, x21) -> f260_in(x19, x20, x21) :|: TRUE
f260_out(x22, x23, x24) -> f281_out(x22, x23, x24) :|: TRUE
f261_out(x25, x26, x27) -> f260_out(x25, x26, x27) :|: TRUE
f260_in(x28, x29, x30) -> f261_in(x28, x29, x30) :|: TRUE
f6_out(T1, T2, T3) -> f2_out(T1, T2, T3) :|: TRUE
f2_in(x31, x32, x33) -> f6_in(x31, x32, x33) :|: TRUE
f6_in(x34, x35, x36) -> f259_in(x34, x35, x36) :|: TRUE
f258_out(x37, x38, x39) -> f6_out(x37, x38, x39) :|: TRUE
f259_out(x40, x41, x42) -> f6_out(x40, x41, x42) :|: TRUE
f6_in(x43, x44, x45) -> f258_in(x43, x44, x45) :|: TRUE
f258_in(x46, x47, x48) -> f260_in(x46, x47, x48) :|: TRUE
f260_out(x49, x50, x51) -> f258_out(x49, x50, x51) :|: TRUE
Start term: f2_in(T1, T2, T3)

----------------------------------------

(129) IRSwTSimpleDependencyGraphProof (EQUIVALENT)
Constructed simple dependency graph.

Simplified to the following IRSwTs:

intTRSProblem:
f276_in(x3, x4, .(x5, x6)) -> f281_in(x3, x4, x6) :|: TRUE
f261_in(x16, x17, x18) -> f276_in(x16, x17, x18) :|: TRUE
f281_in(x19, x20, x21) -> f260_in(x19, x20, x21) :|: TRUE
f260_in(x28, x29, x30) -> f261_in(x28, x29, x30) :|: TRUE


----------------------------------------

(130)
Obligation:
Rules:
f276_in(x3, x4, .(x5, x6)) -> f281_in(x3, x4, x6) :|: TRUE
f261_in(x16, x17, x18) -> f276_in(x16, x17, x18) :|: TRUE
f281_in(x19, x20, x21) -> f260_in(x19, x20, x21) :|: TRUE
f260_in(x28, x29, x30) -> f261_in(x28, x29, x30) :|: TRUE

----------------------------------------

(131) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(132)
Obligation:
Rules:
f261_in(x16:0, x17:0, .(x5:0, x6:0)) -> f261_in(x16:0, x17:0, x6:0) :|: TRUE

----------------------------------------

(133) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(134)
Obligation:
Rules:
f261_in(x16:0, x17:0, .(x5:0, x6:0)) -> f261_in(x16:0, x17:0, x6:0) :|: TRUE

----------------------------------------

(135) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f261_in(x16:0, x17:0, .(x5:0, x6:0)) -> f261_in(x16:0, x17:0, x6:0) :|: TRUE

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(136)
Obligation:

Termination digraph:
Nodes:
(1) f261_in(x16:0, x17:0, .(x5:0, x6:0)) -> f261_in(x16:0, x17:0, x6:0) :|: TRUE

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(137) IntTRSUnneededArgumentFilterProof (EQUIVALENT)
Some arguments are removed because they cannot influence termination. We removed arguments according to the following replacements:

   f261_in(x1, x2, x3) -> f261_in(x3)
   .(x1, x2) -> .(x2)

----------------------------------------

(138)
Obligation:
Rules:
f261_in(.(x6:0)) -> f261_in(x6:0) :|: TRUE

----------------------------------------

(139) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f261_in(VARIABLE)
.(VARIABLE)
Removed predefined arithmetic.
----------------------------------------

(140)
Obligation:
Rules:
f261_in(.(x6:0)) -> f261_in(x6:0)

----------------------------------------

(141) IRSwTToQDPProof (SOUND)
Removed the integers and created a QDP-Problem.
----------------------------------------

(142)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   f261_in(.(x6:0)) -> f261_in(x6:0)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(143) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*f261_in(.(x6:0)) -> f261_in(x6:0)
The graph contains the following edges 1 > 1


----------------------------------------

(144)
YES

----------------------------------------

(145)
Obligation:
Rules:
f6_out(T1, T2, T3) -> f2_out(T1, T2, T3) :|: TRUE
f2_in(x, x1, x2) -> f6_in(x, x1, x2) :|: TRUE
f288_in(T82, T84, T83) -> f289_in(T82, T84) :|: TRUE
f290_out(x3, x4, x5) -> f288_out(x6, x5, x4) :|: TRUE
f289_out(x7, x8) -> f290_in(x9, x10, x8) :|: TRUE
f289_in(x11, x12) -> f291_in(x11, x12) :|: TRUE
f291_out(x13, x14) -> f289_out(x13, x14) :|: TRUE
f259_in(x15, x16, x17) -> f288_in(x15, x17, x16) :|: TRUE
f288_out(x18, x19, x20) -> f259_out(x18, x20, x19) :|: TRUE
f297_out(T119, T121) -> f293_out(T119, .(T120, T121)) :|: TRUE
f293_in(x21, x22) -> f298_in :|: TRUE
f293_in(x23, .(x24, x25)) -> f297_in(x23, x25) :|: TRUE
f298_out -> f293_out(x26, x27) :|: TRUE
f289_out(x28, x29) -> f297_out(x28, x29) :|: TRUE
f297_in(x30, x31) -> f289_in(x30, x31) :|: TRUE
f6_in(x32, x33, x34) -> f259_in(x32, x33, x34) :|: TRUE
f258_out(x35, x36, x37) -> f6_out(x35, x36, x37) :|: TRUE
f259_out(x38, x39, x40) -> f6_out(x38, x39, x40) :|: TRUE
f6_in(x41, x42, x43) -> f258_in(x41, x42, x43) :|: TRUE
f295_out -> f292_out(x44, x45) :|: TRUE
f292_in(T110, .(.(T110, .(T111, [])), T112)) -> f294_in :|: TRUE
f292_in(x46, x47) -> f295_in :|: TRUE
f294_out -> f292_out(x48, .(.(x48, .(x49, [])), x50)) :|: TRUE
f291_in(x51, x52) -> f292_in(x51, x52) :|: TRUE
f293_out(x53, x54) -> f291_out(x53, x54) :|: TRUE
f292_out(x55, x56) -> f291_out(x55, x56) :|: TRUE
f291_in(x57, x58) -> f293_in(x57, x58) :|: TRUE
f294_in -> f294_out :|: TRUE
f2_out(x59, x60, x61) -> f290_out(x59, x60, x61) :|: TRUE
f290_in(x62, x63, x64) -> f2_in(x62, x63, x64) :|: TRUE
Start term: f2_in(T1, T2, T3)

----------------------------------------

(146) IRSwTSimpleDependencyGraphProof (EQUIVALENT)
Constructed simple dependency graph.

Simplified to the following IRSwTs:

intTRSProblem:
f2_in(x, x1, x2) -> f6_in(x, x1, x2) :|: TRUE
f288_in(T82, T84, T83) -> f289_in(T82, T84) :|: TRUE
f289_out(x7, x8) -> f290_in(x9, x10, x8) :|: TRUE
f289_in(x11, x12) -> f291_in(x11, x12) :|: TRUE
f291_out(x13, x14) -> f289_out(x13, x14) :|: TRUE
f259_in(x15, x16, x17) -> f288_in(x15, x17, x16) :|: TRUE
f297_out(T119, T121) -> f293_out(T119, .(T120, T121)) :|: TRUE
f293_in(x23, .(x24, x25)) -> f297_in(x23, x25) :|: TRUE
f289_out(x28, x29) -> f297_out(x28, x29) :|: TRUE
f297_in(x30, x31) -> f289_in(x30, x31) :|: TRUE
f6_in(x32, x33, x34) -> f259_in(x32, x33, x34) :|: TRUE
f292_in(T110, .(.(T110, .(T111, [])), T112)) -> f294_in :|: TRUE
f294_out -> f292_out(x48, .(.(x48, .(x49, [])), x50)) :|: TRUE
f291_in(x51, x52) -> f292_in(x51, x52) :|: TRUE
f293_out(x53, x54) -> f291_out(x53, x54) :|: TRUE
f292_out(x55, x56) -> f291_out(x55, x56) :|: TRUE
f291_in(x57, x58) -> f293_in(x57, x58) :|: TRUE
f294_in -> f294_out :|: TRUE
f290_in(x62, x63, x64) -> f2_in(x62, x63, x64) :|: TRUE


----------------------------------------

(147)
Obligation:
Rules:
f2_in(x, x1, x2) -> f6_in(x, x1, x2) :|: TRUE
f288_in(T82, T84, T83) -> f289_in(T82, T84) :|: TRUE
f289_out(x7, x8) -> f290_in(x9, x10, x8) :|: TRUE
f289_in(x11, x12) -> f291_in(x11, x12) :|: TRUE
f291_out(x13, x14) -> f289_out(x13, x14) :|: TRUE
f259_in(x15, x16, x17) -> f288_in(x15, x17, x16) :|: TRUE
f297_out(T119, T121) -> f293_out(T119, .(T120, T121)) :|: TRUE
f293_in(x23, .(x24, x25)) -> f297_in(x23, x25) :|: TRUE
f289_out(x28, x29) -> f297_out(x28, x29) :|: TRUE
f297_in(x30, x31) -> f289_in(x30, x31) :|: TRUE
f6_in(x32, x33, x34) -> f259_in(x32, x33, x34) :|: TRUE
f292_in(T110, .(.(T110, .(T111, [])), T112)) -> f294_in :|: TRUE
f294_out -> f292_out(x48, .(.(x48, .(x49, [])), x50)) :|: TRUE
f291_in(x51, x52) -> f292_in(x51, x52) :|: TRUE
f293_out(x53, x54) -> f291_out(x53, x54) :|: TRUE
f292_out(x55, x56) -> f291_out(x55, x56) :|: TRUE
f291_in(x57, x58) -> f293_in(x57, x58) :|: TRUE
f294_in -> f294_out :|: TRUE
f290_in(x62, x63, x64) -> f2_in(x62, x63, x64) :|: TRUE

----------------------------------------

(148) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(149)
Obligation:
Rules:
f291_in(x57:0, .(x24:0, x25:0)) -> f291_in(x57:0, x25:0) :|: TRUE
f291_in(x51:0, .(.(x51:0, .(T111:0, [])), T112:0)) -> f291_out(x48:0, .(.(x48:0, .(x49:0, [])), x50:0)) :|: TRUE
f291_out(x13:0, x14:0) -> f291_in(x9:0, x14:0) :|: TRUE
f291_out(x, x1) -> f291_out(x, .(x2, x1)) :|: TRUE

----------------------------------------

(150) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(151)
Obligation:
Rules:
f291_in(x57:0, .(x24:0, x25:0)) -> f291_in(x57:0, x25:0) :|: TRUE
f291_in(x51:0, .(.(x51:0, .(T111:0, [])), T112:0)) -> f291_out(x48:0, .(.(x48:0, .(x49:0, [])), x50:0)) :|: TRUE
f291_out(x13:0, x14:0) -> f291_in(x9:0, x14:0) :|: TRUE
f291_out(x, x1) -> f291_out(x, .(x2, x1)) :|: TRUE
