YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/KtIjR.pl
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Left Termination of the query pattern

mergesort(g,a,a)

w.r.t. the given Prolog program could successfully be proven:

(0) Prolog
(1) PrologToPiTRSProof [SOUND, 0 ms]
(2) PiTRS
(3) DependencyPairsProof [EQUIVALENT, 0 ms]
(4) PiDP
(5) DependencyGraphProof [EQUIVALENT, 0 ms]
(6) AND
    (7) PiDP
        (8) UsableRulesProof [EQUIVALENT, 0 ms]
        (9) PiDP
        (10) PiDPToQDPProof [EQUIVALENT, 0 ms]
        (11) QDP
        (12) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (13) YES
    (14) PiDP
        (15) UsableRulesProof [EQUIVALENT, 0 ms]
        (16) PiDP
        (17) PiDPToQDPProof [EQUIVALENT, 0 ms]
        (18) QDP
        (19) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (20) YES
    (21) PiDP
        (22) UsableRulesProof [EQUIVALENT, 0 ms]
        (23) PiDP
        (24) PiDPToQDPProof [SOUND, 0 ms]
        (25) QDP
        (26) QDPOrderProof [EQUIVALENT, 14 ms]
        (27) QDP
        (28) UsableRulesProof [EQUIVALENT, 0 ms]
        (29) QDP
        (30) QReductionProof [EQUIVALENT, 0 ms]
        (31) QDP
        (32) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (33) YES
    (34) PiDP
        (35) UsableRulesProof [EQUIVALENT, 0 ms]
        (36) PiDP
        (37) PiDPToQDPProof [SOUND, 0 ms]
        (38) QDP
        (39) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (40) YES
    (41) PiDP
        (42) PiDPToQDPProof [SOUND, 0 ms]
        (43) QDP
        (44) TransformationProof [EQUIVALENT, 0 ms]
        (45) QDP
        (46) TransformationProof [EQUIVALENT, 0 ms]
        (47) QDP
        (48) QDPQMonotonicMRRProof [EQUIVALENT, 50 ms]
        (49) QDP
        (50) QDPOrderProof [EQUIVALENT, 20 ms]
        (51) QDP
        (52) DependencyGraphProof [EQUIVALENT, 0 ms]
        (53) QDP
        (54) UsableRulesProof [EQUIVALENT, 0 ms]
        (55) QDP
        (56) QReductionProof [EQUIVALENT, 0 ms]
        (57) QDP
        (58) QDPOrderProof [EQUIVALENT, 27 ms]
        (59) QDP
        (60) DependencyGraphProof [EQUIVALENT, 0 ms]
        (61) TRUE


----------------------------------------

(0)
Obligation:
Clauses:

mergesort([], [], Ls).
mergesort(.(X, []), .(X, []), Ls).
mergesort(.(X, .(Y, Xs)), Ys, .(H, Ls)) :- ','(split(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls)), ','(mergesort(X1s, Y1s, Ls), ','(mergesort(X2s, Y2s, Ls), merge(Y1s, Y2s, Ys, .(H, Ls))))).
split([], [], [], Ls).
split(.(X, Xs), .(X, Ys), Zs, .(H, Ls)) :- split(Xs, Zs, Ys, Ls).
merge([], Xs, Xs, Ls).
merge(Xs, [], Xs, Ls).
merge(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls)) :- ','(le(X, Y), merge(Xs, .(Y, Ys), Zs, Ls)).
merge(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls)) :- ','(gt(X, Y), merge(.(X, Xs), Ys, Zs, Ls)).
gt(s(X), s(Y)) :- gt(X, Y).
gt(s(0), 0).
le(s(X), s(Y)) :- le(X, Y).
le(0, s(0)).
le(0, 0).


Query: mergesort(g,a,a)
----------------------------------------

(1) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

mergesort_in_3: (b,f,f)

split_in_4: (b,f,f,f)

merge_in_4: (b,b,f,f)

le_in_2: (b,b)

gt_in_2: (b,b)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   mergesort_in_gaa([], [], Ls) -> mergesort_out_gaa([], [], Ls)
   mergesort_in_gaa(.(X, []), .(X, []), Ls) -> mergesort_out_gaa(.(X, []), .(X, []), Ls)
   mergesort_in_gaa(.(X, .(Y, Xs)), Ys, .(H, Ls)) -> U1_gaa(X, Y, Xs, Ys, H, Ls, split_in_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls)))
   split_in_gaaa([], [], [], Ls) -> split_out_gaaa([], [], [], Ls)
   split_in_gaaa(.(X, Xs), .(X, Ys), Zs, .(H, Ls)) -> U5_gaaa(X, Xs, Ys, Zs, H, Ls, split_in_gaaa(Xs, Zs, Ys, Ls))
   U5_gaaa(X, Xs, Ys, Zs, H, Ls, split_out_gaaa(Xs, Zs, Ys, Ls)) -> split_out_gaaa(.(X, Xs), .(X, Ys), Zs, .(H, Ls))
   U1_gaa(X, Y, Xs, Ys, H, Ls, split_out_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls))) -> U2_gaa(X, Y, Xs, Ys, H, Ls, X2s, mergesort_in_gaa(X1s, Y1s, Ls))
   U2_gaa(X, Y, Xs, Ys, H, Ls, X2s, mergesort_out_gaa(X1s, Y1s, Ls)) -> U3_gaa(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_in_gaa(X2s, Y2s, Ls))
   U3_gaa(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_out_gaa(X2s, Y2s, Ls)) -> U4_gaa(X, Y, Xs, Ys, H, Ls, merge_in_ggaa(Y1s, Y2s, Ys, .(H, Ls)))
   merge_in_ggaa([], Xs, Xs, Ls) -> merge_out_ggaa([], Xs, Xs, Ls)
   merge_in_ggaa(Xs, [], Xs, Ls) -> merge_out_ggaa(Xs, [], Xs, Ls)
   merge_in_ggaa(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls)) -> U6_ggaa(X, Xs, Y, Ys, Zs, H, Ls, le_in_gg(X, Y))
   le_in_gg(s(X), s(Y)) -> U11_gg(X, Y, le_in_gg(X, Y))
   le_in_gg(0, s(0)) -> le_out_gg(0, s(0))
   le_in_gg(0, 0) -> le_out_gg(0, 0)
   U11_gg(X, Y, le_out_gg(X, Y)) -> le_out_gg(s(X), s(Y))
   U6_ggaa(X, Xs, Y, Ys, Zs, H, Ls, le_out_gg(X, Y)) -> U7_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_in_ggaa(Xs, .(Y, Ys), Zs, Ls))
   merge_in_ggaa(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls)) -> U8_ggaa(X, Xs, Y, Ys, Zs, H, Ls, gt_in_gg(X, Y))
   gt_in_gg(s(X), s(Y)) -> U10_gg(X, Y, gt_in_gg(X, Y))
   gt_in_gg(s(0), 0) -> gt_out_gg(s(0), 0)
   U10_gg(X, Y, gt_out_gg(X, Y)) -> gt_out_gg(s(X), s(Y))
   U8_ggaa(X, Xs, Y, Ys, Zs, H, Ls, gt_out_gg(X, Y)) -> U9_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_in_ggaa(.(X, Xs), Ys, Zs, Ls))
   U9_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_out_ggaa(.(X, Xs), Ys, Zs, Ls)) -> merge_out_ggaa(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls))
   U7_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_out_ggaa(Xs, .(Y, Ys), Zs, Ls)) -> merge_out_ggaa(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls))
   U4_gaa(X, Y, Xs, Ys, H, Ls, merge_out_ggaa(Y1s, Y2s, Ys, .(H, Ls))) -> mergesort_out_gaa(.(X, .(Y, Xs)), Ys, .(H, Ls))

The argument filtering Pi contains the following mapping:
mergesort_in_gaa(x1, x2, x3)  =  mergesort_in_gaa(x1)

[]  =  []

mergesort_out_gaa(x1, x2, x3)  =  mergesort_out_gaa(x2)

.(x1, x2)  =  .(x1, x2)

U1_gaa(x1, x2, x3, x4, x5, x6, x7)  =  U1_gaa(x7)

split_in_gaaa(x1, x2, x3, x4)  =  split_in_gaaa(x1)

split_out_gaaa(x1, x2, x3, x4)  =  split_out_gaaa(x2, x3)

U5_gaaa(x1, x2, x3, x4, x5, x6, x7)  =  U5_gaaa(x1, x7)

U2_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_gaa(x7, x8)

U3_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_gaa(x7, x8)

U4_gaa(x1, x2, x3, x4, x5, x6, x7)  =  U4_gaa(x7)

merge_in_ggaa(x1, x2, x3, x4)  =  merge_in_ggaa(x1, x2)

merge_out_ggaa(x1, x2, x3, x4)  =  merge_out_ggaa(x3)

U6_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U6_ggaa(x1, x2, x3, x4, x8)

le_in_gg(x1, x2)  =  le_in_gg(x1, x2)

s(x1)  =  s(x1)

U11_gg(x1, x2, x3)  =  U11_gg(x3)

0  =  0

le_out_gg(x1, x2)  =  le_out_gg

U7_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U7_ggaa(x1, x8)

U8_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U8_ggaa(x1, x2, x3, x4, x8)

gt_in_gg(x1, x2)  =  gt_in_gg(x1, x2)

U10_gg(x1, x2, x3)  =  U10_gg(x3)

gt_out_gg(x1, x2)  =  gt_out_gg

U9_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U9_ggaa(x3, x8)





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(2)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   mergesort_in_gaa([], [], Ls) -> mergesort_out_gaa([], [], Ls)
   mergesort_in_gaa(.(X, []), .(X, []), Ls) -> mergesort_out_gaa(.(X, []), .(X, []), Ls)
   mergesort_in_gaa(.(X, .(Y, Xs)), Ys, .(H, Ls)) -> U1_gaa(X, Y, Xs, Ys, H, Ls, split_in_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls)))
   split_in_gaaa([], [], [], Ls) -> split_out_gaaa([], [], [], Ls)
   split_in_gaaa(.(X, Xs), .(X, Ys), Zs, .(H, Ls)) -> U5_gaaa(X, Xs, Ys, Zs, H, Ls, split_in_gaaa(Xs, Zs, Ys, Ls))
   U5_gaaa(X, Xs, Ys, Zs, H, Ls, split_out_gaaa(Xs, Zs, Ys, Ls)) -> split_out_gaaa(.(X, Xs), .(X, Ys), Zs, .(H, Ls))
   U1_gaa(X, Y, Xs, Ys, H, Ls, split_out_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls))) -> U2_gaa(X, Y, Xs, Ys, H, Ls, X2s, mergesort_in_gaa(X1s, Y1s, Ls))
   U2_gaa(X, Y, Xs, Ys, H, Ls, X2s, mergesort_out_gaa(X1s, Y1s, Ls)) -> U3_gaa(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_in_gaa(X2s, Y2s, Ls))
   U3_gaa(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_out_gaa(X2s, Y2s, Ls)) -> U4_gaa(X, Y, Xs, Ys, H, Ls, merge_in_ggaa(Y1s, Y2s, Ys, .(H, Ls)))
   merge_in_ggaa([], Xs, Xs, Ls) -> merge_out_ggaa([], Xs, Xs, Ls)
   merge_in_ggaa(Xs, [], Xs, Ls) -> merge_out_ggaa(Xs, [], Xs, Ls)
   merge_in_ggaa(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls)) -> U6_ggaa(X, Xs, Y, Ys, Zs, H, Ls, le_in_gg(X, Y))
   le_in_gg(s(X), s(Y)) -> U11_gg(X, Y, le_in_gg(X, Y))
   le_in_gg(0, s(0)) -> le_out_gg(0, s(0))
   le_in_gg(0, 0) -> le_out_gg(0, 0)
   U11_gg(X, Y, le_out_gg(X, Y)) -> le_out_gg(s(X), s(Y))
   U6_ggaa(X, Xs, Y, Ys, Zs, H, Ls, le_out_gg(X, Y)) -> U7_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_in_ggaa(Xs, .(Y, Ys), Zs, Ls))
   merge_in_ggaa(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls)) -> U8_ggaa(X, Xs, Y, Ys, Zs, H, Ls, gt_in_gg(X, Y))
   gt_in_gg(s(X), s(Y)) -> U10_gg(X, Y, gt_in_gg(X, Y))
   gt_in_gg(s(0), 0) -> gt_out_gg(s(0), 0)
   U10_gg(X, Y, gt_out_gg(X, Y)) -> gt_out_gg(s(X), s(Y))
   U8_ggaa(X, Xs, Y, Ys, Zs, H, Ls, gt_out_gg(X, Y)) -> U9_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_in_ggaa(.(X, Xs), Ys, Zs, Ls))
   U9_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_out_ggaa(.(X, Xs), Ys, Zs, Ls)) -> merge_out_ggaa(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls))
   U7_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_out_ggaa(Xs, .(Y, Ys), Zs, Ls)) -> merge_out_ggaa(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls))
   U4_gaa(X, Y, Xs, Ys, H, Ls, merge_out_ggaa(Y1s, Y2s, Ys, .(H, Ls))) -> mergesort_out_gaa(.(X, .(Y, Xs)), Ys, .(H, Ls))

The argument filtering Pi contains the following mapping:
mergesort_in_gaa(x1, x2, x3)  =  mergesort_in_gaa(x1)

[]  =  []

mergesort_out_gaa(x1, x2, x3)  =  mergesort_out_gaa(x2)

.(x1, x2)  =  .(x1, x2)

U1_gaa(x1, x2, x3, x4, x5, x6, x7)  =  U1_gaa(x7)

split_in_gaaa(x1, x2, x3, x4)  =  split_in_gaaa(x1)

split_out_gaaa(x1, x2, x3, x4)  =  split_out_gaaa(x2, x3)

U5_gaaa(x1, x2, x3, x4, x5, x6, x7)  =  U5_gaaa(x1, x7)

U2_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_gaa(x7, x8)

U3_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_gaa(x7, x8)

U4_gaa(x1, x2, x3, x4, x5, x6, x7)  =  U4_gaa(x7)

merge_in_ggaa(x1, x2, x3, x4)  =  merge_in_ggaa(x1, x2)

merge_out_ggaa(x1, x2, x3, x4)  =  merge_out_ggaa(x3)

U6_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U6_ggaa(x1, x2, x3, x4, x8)

le_in_gg(x1, x2)  =  le_in_gg(x1, x2)

s(x1)  =  s(x1)

U11_gg(x1, x2, x3)  =  U11_gg(x3)

0  =  0

le_out_gg(x1, x2)  =  le_out_gg

U7_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U7_ggaa(x1, x8)

U8_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U8_ggaa(x1, x2, x3, x4, x8)

gt_in_gg(x1, x2)  =  gt_in_gg(x1, x2)

U10_gg(x1, x2, x3)  =  U10_gg(x3)

gt_out_gg(x1, x2)  =  gt_out_gg

U9_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U9_ggaa(x3, x8)



----------------------------------------

(3) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   MERGESORT_IN_GAA(.(X, .(Y, Xs)), Ys, .(H, Ls)) -> U1_GAA(X, Y, Xs, Ys, H, Ls, split_in_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls)))
   MERGESORT_IN_GAA(.(X, .(Y, Xs)), Ys, .(H, Ls)) -> SPLIT_IN_GAAA(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls))
   SPLIT_IN_GAAA(.(X, Xs), .(X, Ys), Zs, .(H, Ls)) -> U5_GAAA(X, Xs, Ys, Zs, H, Ls, split_in_gaaa(Xs, Zs, Ys, Ls))
   SPLIT_IN_GAAA(.(X, Xs), .(X, Ys), Zs, .(H, Ls)) -> SPLIT_IN_GAAA(Xs, Zs, Ys, Ls)
   U1_GAA(X, Y, Xs, Ys, H, Ls, split_out_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls))) -> U2_GAA(X, Y, Xs, Ys, H, Ls, X2s, mergesort_in_gaa(X1s, Y1s, Ls))
   U1_GAA(X, Y, Xs, Ys, H, Ls, split_out_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls))) -> MERGESORT_IN_GAA(X1s, Y1s, Ls)
   U2_GAA(X, Y, Xs, Ys, H, Ls, X2s, mergesort_out_gaa(X1s, Y1s, Ls)) -> U3_GAA(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_in_gaa(X2s, Y2s, Ls))
   U2_GAA(X, Y, Xs, Ys, H, Ls, X2s, mergesort_out_gaa(X1s, Y1s, Ls)) -> MERGESORT_IN_GAA(X2s, Y2s, Ls)
   U3_GAA(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_out_gaa(X2s, Y2s, Ls)) -> U4_GAA(X, Y, Xs, Ys, H, Ls, merge_in_ggaa(Y1s, Y2s, Ys, .(H, Ls)))
   U3_GAA(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_out_gaa(X2s, Y2s, Ls)) -> MERGE_IN_GGAA(Y1s, Y2s, Ys, .(H, Ls))
   MERGE_IN_GGAA(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls)) -> U6_GGAA(X, Xs, Y, Ys, Zs, H, Ls, le_in_gg(X, Y))
   MERGE_IN_GGAA(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls)) -> LE_IN_GG(X, Y)
   LE_IN_GG(s(X), s(Y)) -> U11_GG(X, Y, le_in_gg(X, Y))
   LE_IN_GG(s(X), s(Y)) -> LE_IN_GG(X, Y)
   U6_GGAA(X, Xs, Y, Ys, Zs, H, Ls, le_out_gg(X, Y)) -> U7_GGAA(X, Xs, Y, Ys, Zs, H, Ls, merge_in_ggaa(Xs, .(Y, Ys), Zs, Ls))
   U6_GGAA(X, Xs, Y, Ys, Zs, H, Ls, le_out_gg(X, Y)) -> MERGE_IN_GGAA(Xs, .(Y, Ys), Zs, Ls)
   MERGE_IN_GGAA(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls)) -> U8_GGAA(X, Xs, Y, Ys, Zs, H, Ls, gt_in_gg(X, Y))
   MERGE_IN_GGAA(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls)) -> GT_IN_GG(X, Y)
   GT_IN_GG(s(X), s(Y)) -> U10_GG(X, Y, gt_in_gg(X, Y))
   GT_IN_GG(s(X), s(Y)) -> GT_IN_GG(X, Y)
   U8_GGAA(X, Xs, Y, Ys, Zs, H, Ls, gt_out_gg(X, Y)) -> U9_GGAA(X, Xs, Y, Ys, Zs, H, Ls, merge_in_ggaa(.(X, Xs), Ys, Zs, Ls))
   U8_GGAA(X, Xs, Y, Ys, Zs, H, Ls, gt_out_gg(X, Y)) -> MERGE_IN_GGAA(.(X, Xs), Ys, Zs, Ls)

The TRS R consists of the following rules:

   mergesort_in_gaa([], [], Ls) -> mergesort_out_gaa([], [], Ls)
   mergesort_in_gaa(.(X, []), .(X, []), Ls) -> mergesort_out_gaa(.(X, []), .(X, []), Ls)
   mergesort_in_gaa(.(X, .(Y, Xs)), Ys, .(H, Ls)) -> U1_gaa(X, Y, Xs, Ys, H, Ls, split_in_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls)))
   split_in_gaaa([], [], [], Ls) -> split_out_gaaa([], [], [], Ls)
   split_in_gaaa(.(X, Xs), .(X, Ys), Zs, .(H, Ls)) -> U5_gaaa(X, Xs, Ys, Zs, H, Ls, split_in_gaaa(Xs, Zs, Ys, Ls))
   U5_gaaa(X, Xs, Ys, Zs, H, Ls, split_out_gaaa(Xs, Zs, Ys, Ls)) -> split_out_gaaa(.(X, Xs), .(X, Ys), Zs, .(H, Ls))
   U1_gaa(X, Y, Xs, Ys, H, Ls, split_out_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls))) -> U2_gaa(X, Y, Xs, Ys, H, Ls, X2s, mergesort_in_gaa(X1s, Y1s, Ls))
   U2_gaa(X, Y, Xs, Ys, H, Ls, X2s, mergesort_out_gaa(X1s, Y1s, Ls)) -> U3_gaa(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_in_gaa(X2s, Y2s, Ls))
   U3_gaa(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_out_gaa(X2s, Y2s, Ls)) -> U4_gaa(X, Y, Xs, Ys, H, Ls, merge_in_ggaa(Y1s, Y2s, Ys, .(H, Ls)))
   merge_in_ggaa([], Xs, Xs, Ls) -> merge_out_ggaa([], Xs, Xs, Ls)
   merge_in_ggaa(Xs, [], Xs, Ls) -> merge_out_ggaa(Xs, [], Xs, Ls)
   merge_in_ggaa(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls)) -> U6_ggaa(X, Xs, Y, Ys, Zs, H, Ls, le_in_gg(X, Y))
   le_in_gg(s(X), s(Y)) -> U11_gg(X, Y, le_in_gg(X, Y))
   le_in_gg(0, s(0)) -> le_out_gg(0, s(0))
   le_in_gg(0, 0) -> le_out_gg(0, 0)
   U11_gg(X, Y, le_out_gg(X, Y)) -> le_out_gg(s(X), s(Y))
   U6_ggaa(X, Xs, Y, Ys, Zs, H, Ls, le_out_gg(X, Y)) -> U7_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_in_ggaa(Xs, .(Y, Ys), Zs, Ls))
   merge_in_ggaa(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls)) -> U8_ggaa(X, Xs, Y, Ys, Zs, H, Ls, gt_in_gg(X, Y))
   gt_in_gg(s(X), s(Y)) -> U10_gg(X, Y, gt_in_gg(X, Y))
   gt_in_gg(s(0), 0) -> gt_out_gg(s(0), 0)
   U10_gg(X, Y, gt_out_gg(X, Y)) -> gt_out_gg(s(X), s(Y))
   U8_ggaa(X, Xs, Y, Ys, Zs, H, Ls, gt_out_gg(X, Y)) -> U9_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_in_ggaa(.(X, Xs), Ys, Zs, Ls))
   U9_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_out_ggaa(.(X, Xs), Ys, Zs, Ls)) -> merge_out_ggaa(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls))
   U7_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_out_ggaa(Xs, .(Y, Ys), Zs, Ls)) -> merge_out_ggaa(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls))
   U4_gaa(X, Y, Xs, Ys, H, Ls, merge_out_ggaa(Y1s, Y2s, Ys, .(H, Ls))) -> mergesort_out_gaa(.(X, .(Y, Xs)), Ys, .(H, Ls))

The argument filtering Pi contains the following mapping:
mergesort_in_gaa(x1, x2, x3)  =  mergesort_in_gaa(x1)

[]  =  []

mergesort_out_gaa(x1, x2, x3)  =  mergesort_out_gaa(x2)

.(x1, x2)  =  .(x1, x2)

U1_gaa(x1, x2, x3, x4, x5, x6, x7)  =  U1_gaa(x7)

split_in_gaaa(x1, x2, x3, x4)  =  split_in_gaaa(x1)

split_out_gaaa(x1, x2, x3, x4)  =  split_out_gaaa(x2, x3)

U5_gaaa(x1, x2, x3, x4, x5, x6, x7)  =  U5_gaaa(x1, x7)

U2_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_gaa(x7, x8)

U3_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_gaa(x7, x8)

U4_gaa(x1, x2, x3, x4, x5, x6, x7)  =  U4_gaa(x7)

merge_in_ggaa(x1, x2, x3, x4)  =  merge_in_ggaa(x1, x2)

merge_out_ggaa(x1, x2, x3, x4)  =  merge_out_ggaa(x3)

U6_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U6_ggaa(x1, x2, x3, x4, x8)

le_in_gg(x1, x2)  =  le_in_gg(x1, x2)

s(x1)  =  s(x1)

U11_gg(x1, x2, x3)  =  U11_gg(x3)

0  =  0

le_out_gg(x1, x2)  =  le_out_gg

U7_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U7_ggaa(x1, x8)

U8_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U8_ggaa(x1, x2, x3, x4, x8)

gt_in_gg(x1, x2)  =  gt_in_gg(x1, x2)

U10_gg(x1, x2, x3)  =  U10_gg(x3)

gt_out_gg(x1, x2)  =  gt_out_gg

U9_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U9_ggaa(x3, x8)

MERGESORT_IN_GAA(x1, x2, x3)  =  MERGESORT_IN_GAA(x1)

U1_GAA(x1, x2, x3, x4, x5, x6, x7)  =  U1_GAA(x7)

SPLIT_IN_GAAA(x1, x2, x3, x4)  =  SPLIT_IN_GAAA(x1)

U5_GAAA(x1, x2, x3, x4, x5, x6, x7)  =  U5_GAAA(x1, x7)

U2_GAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_GAA(x7, x8)

U3_GAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_GAA(x7, x8)

U4_GAA(x1, x2, x3, x4, x5, x6, x7)  =  U4_GAA(x7)

MERGE_IN_GGAA(x1, x2, x3, x4)  =  MERGE_IN_GGAA(x1, x2)

U6_GGAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U6_GGAA(x1, x2, x3, x4, x8)

LE_IN_GG(x1, x2)  =  LE_IN_GG(x1, x2)

U11_GG(x1, x2, x3)  =  U11_GG(x3)

U7_GGAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U7_GGAA(x1, x8)

U8_GGAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U8_GGAA(x1, x2, x3, x4, x8)

GT_IN_GG(x1, x2)  =  GT_IN_GG(x1, x2)

U10_GG(x1, x2, x3)  =  U10_GG(x3)

U9_GGAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U9_GGAA(x3, x8)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(4)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MERGESORT_IN_GAA(.(X, .(Y, Xs)), Ys, .(H, Ls)) -> U1_GAA(X, Y, Xs, Ys, H, Ls, split_in_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls)))
   MERGESORT_IN_GAA(.(X, .(Y, Xs)), Ys, .(H, Ls)) -> SPLIT_IN_GAAA(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls))
   SPLIT_IN_GAAA(.(X, Xs), .(X, Ys), Zs, .(H, Ls)) -> U5_GAAA(X, Xs, Ys, Zs, H, Ls, split_in_gaaa(Xs, Zs, Ys, Ls))
   SPLIT_IN_GAAA(.(X, Xs), .(X, Ys), Zs, .(H, Ls)) -> SPLIT_IN_GAAA(Xs, Zs, Ys, Ls)
   U1_GAA(X, Y, Xs, Ys, H, Ls, split_out_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls))) -> U2_GAA(X, Y, Xs, Ys, H, Ls, X2s, mergesort_in_gaa(X1s, Y1s, Ls))
   U1_GAA(X, Y, Xs, Ys, H, Ls, split_out_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls))) -> MERGESORT_IN_GAA(X1s, Y1s, Ls)
   U2_GAA(X, Y, Xs, Ys, H, Ls, X2s, mergesort_out_gaa(X1s, Y1s, Ls)) -> U3_GAA(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_in_gaa(X2s, Y2s, Ls))
   U2_GAA(X, Y, Xs, Ys, H, Ls, X2s, mergesort_out_gaa(X1s, Y1s, Ls)) -> MERGESORT_IN_GAA(X2s, Y2s, Ls)
   U3_GAA(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_out_gaa(X2s, Y2s, Ls)) -> U4_GAA(X, Y, Xs, Ys, H, Ls, merge_in_ggaa(Y1s, Y2s, Ys, .(H, Ls)))
   U3_GAA(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_out_gaa(X2s, Y2s, Ls)) -> MERGE_IN_GGAA(Y1s, Y2s, Ys, .(H, Ls))
   MERGE_IN_GGAA(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls)) -> U6_GGAA(X, Xs, Y, Ys, Zs, H, Ls, le_in_gg(X, Y))
   MERGE_IN_GGAA(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls)) -> LE_IN_GG(X, Y)
   LE_IN_GG(s(X), s(Y)) -> U11_GG(X, Y, le_in_gg(X, Y))
   LE_IN_GG(s(X), s(Y)) -> LE_IN_GG(X, Y)
   U6_GGAA(X, Xs, Y, Ys, Zs, H, Ls, le_out_gg(X, Y)) -> U7_GGAA(X, Xs, Y, Ys, Zs, H, Ls, merge_in_ggaa(Xs, .(Y, Ys), Zs, Ls))
   U6_GGAA(X, Xs, Y, Ys, Zs, H, Ls, le_out_gg(X, Y)) -> MERGE_IN_GGAA(Xs, .(Y, Ys), Zs, Ls)
   MERGE_IN_GGAA(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls)) -> U8_GGAA(X, Xs, Y, Ys, Zs, H, Ls, gt_in_gg(X, Y))
   MERGE_IN_GGAA(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls)) -> GT_IN_GG(X, Y)
   GT_IN_GG(s(X), s(Y)) -> U10_GG(X, Y, gt_in_gg(X, Y))
   GT_IN_GG(s(X), s(Y)) -> GT_IN_GG(X, Y)
   U8_GGAA(X, Xs, Y, Ys, Zs, H, Ls, gt_out_gg(X, Y)) -> U9_GGAA(X, Xs, Y, Ys, Zs, H, Ls, merge_in_ggaa(.(X, Xs), Ys, Zs, Ls))
   U8_GGAA(X, Xs, Y, Ys, Zs, H, Ls, gt_out_gg(X, Y)) -> MERGE_IN_GGAA(.(X, Xs), Ys, Zs, Ls)

The TRS R consists of the following rules:

   mergesort_in_gaa([], [], Ls) -> mergesort_out_gaa([], [], Ls)
   mergesort_in_gaa(.(X, []), .(X, []), Ls) -> mergesort_out_gaa(.(X, []), .(X, []), Ls)
   mergesort_in_gaa(.(X, .(Y, Xs)), Ys, .(H, Ls)) -> U1_gaa(X, Y, Xs, Ys, H, Ls, split_in_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls)))
   split_in_gaaa([], [], [], Ls) -> split_out_gaaa([], [], [], Ls)
   split_in_gaaa(.(X, Xs), .(X, Ys), Zs, .(H, Ls)) -> U5_gaaa(X, Xs, Ys, Zs, H, Ls, split_in_gaaa(Xs, Zs, Ys, Ls))
   U5_gaaa(X, Xs, Ys, Zs, H, Ls, split_out_gaaa(Xs, Zs, Ys, Ls)) -> split_out_gaaa(.(X, Xs), .(X, Ys), Zs, .(H, Ls))
   U1_gaa(X, Y, Xs, Ys, H, Ls, split_out_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls))) -> U2_gaa(X, Y, Xs, Ys, H, Ls, X2s, mergesort_in_gaa(X1s, Y1s, Ls))
   U2_gaa(X, Y, Xs, Ys, H, Ls, X2s, mergesort_out_gaa(X1s, Y1s, Ls)) -> U3_gaa(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_in_gaa(X2s, Y2s, Ls))
   U3_gaa(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_out_gaa(X2s, Y2s, Ls)) -> U4_gaa(X, Y, Xs, Ys, H, Ls, merge_in_ggaa(Y1s, Y2s, Ys, .(H, Ls)))
   merge_in_ggaa([], Xs, Xs, Ls) -> merge_out_ggaa([], Xs, Xs, Ls)
   merge_in_ggaa(Xs, [], Xs, Ls) -> merge_out_ggaa(Xs, [], Xs, Ls)
   merge_in_ggaa(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls)) -> U6_ggaa(X, Xs, Y, Ys, Zs, H, Ls, le_in_gg(X, Y))
   le_in_gg(s(X), s(Y)) -> U11_gg(X, Y, le_in_gg(X, Y))
   le_in_gg(0, s(0)) -> le_out_gg(0, s(0))
   le_in_gg(0, 0) -> le_out_gg(0, 0)
   U11_gg(X, Y, le_out_gg(X, Y)) -> le_out_gg(s(X), s(Y))
   U6_ggaa(X, Xs, Y, Ys, Zs, H, Ls, le_out_gg(X, Y)) -> U7_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_in_ggaa(Xs, .(Y, Ys), Zs, Ls))
   merge_in_ggaa(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls)) -> U8_ggaa(X, Xs, Y, Ys, Zs, H, Ls, gt_in_gg(X, Y))
   gt_in_gg(s(X), s(Y)) -> U10_gg(X, Y, gt_in_gg(X, Y))
   gt_in_gg(s(0), 0) -> gt_out_gg(s(0), 0)
   U10_gg(X, Y, gt_out_gg(X, Y)) -> gt_out_gg(s(X), s(Y))
   U8_ggaa(X, Xs, Y, Ys, Zs, H, Ls, gt_out_gg(X, Y)) -> U9_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_in_ggaa(.(X, Xs), Ys, Zs, Ls))
   U9_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_out_ggaa(.(X, Xs), Ys, Zs, Ls)) -> merge_out_ggaa(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls))
   U7_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_out_ggaa(Xs, .(Y, Ys), Zs, Ls)) -> merge_out_ggaa(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls))
   U4_gaa(X, Y, Xs, Ys, H, Ls, merge_out_ggaa(Y1s, Y2s, Ys, .(H, Ls))) -> mergesort_out_gaa(.(X, .(Y, Xs)), Ys, .(H, Ls))

The argument filtering Pi contains the following mapping:
mergesort_in_gaa(x1, x2, x3)  =  mergesort_in_gaa(x1)

[]  =  []

mergesort_out_gaa(x1, x2, x3)  =  mergesort_out_gaa(x2)

.(x1, x2)  =  .(x1, x2)

U1_gaa(x1, x2, x3, x4, x5, x6, x7)  =  U1_gaa(x7)

split_in_gaaa(x1, x2, x3, x4)  =  split_in_gaaa(x1)

split_out_gaaa(x1, x2, x3, x4)  =  split_out_gaaa(x2, x3)

U5_gaaa(x1, x2, x3, x4, x5, x6, x7)  =  U5_gaaa(x1, x7)

U2_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_gaa(x7, x8)

U3_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_gaa(x7, x8)

U4_gaa(x1, x2, x3, x4, x5, x6, x7)  =  U4_gaa(x7)

merge_in_ggaa(x1, x2, x3, x4)  =  merge_in_ggaa(x1, x2)

merge_out_ggaa(x1, x2, x3, x4)  =  merge_out_ggaa(x3)

U6_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U6_ggaa(x1, x2, x3, x4, x8)

le_in_gg(x1, x2)  =  le_in_gg(x1, x2)

s(x1)  =  s(x1)

U11_gg(x1, x2, x3)  =  U11_gg(x3)

0  =  0

le_out_gg(x1, x2)  =  le_out_gg

U7_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U7_ggaa(x1, x8)

U8_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U8_ggaa(x1, x2, x3, x4, x8)

gt_in_gg(x1, x2)  =  gt_in_gg(x1, x2)

U10_gg(x1, x2, x3)  =  U10_gg(x3)

gt_out_gg(x1, x2)  =  gt_out_gg

U9_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U9_ggaa(x3, x8)

MERGESORT_IN_GAA(x1, x2, x3)  =  MERGESORT_IN_GAA(x1)

U1_GAA(x1, x2, x3, x4, x5, x6, x7)  =  U1_GAA(x7)

SPLIT_IN_GAAA(x1, x2, x3, x4)  =  SPLIT_IN_GAAA(x1)

U5_GAAA(x1, x2, x3, x4, x5, x6, x7)  =  U5_GAAA(x1, x7)

U2_GAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_GAA(x7, x8)

U3_GAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_GAA(x7, x8)

U4_GAA(x1, x2, x3, x4, x5, x6, x7)  =  U4_GAA(x7)

MERGE_IN_GGAA(x1, x2, x3, x4)  =  MERGE_IN_GGAA(x1, x2)

U6_GGAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U6_GGAA(x1, x2, x3, x4, x8)

LE_IN_GG(x1, x2)  =  LE_IN_GG(x1, x2)

U11_GG(x1, x2, x3)  =  U11_GG(x3)

U7_GGAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U7_GGAA(x1, x8)

U8_GGAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U8_GGAA(x1, x2, x3, x4, x8)

GT_IN_GG(x1, x2)  =  GT_IN_GG(x1, x2)

U10_GG(x1, x2, x3)  =  U10_GG(x3)

U9_GGAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U9_GGAA(x3, x8)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(5) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 5 SCCs with 11 less nodes.
----------------------------------------

(6)
Complex Obligation (AND)

----------------------------------------

(7)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   GT_IN_GG(s(X), s(Y)) -> GT_IN_GG(X, Y)

The TRS R consists of the following rules:

   mergesort_in_gaa([], [], Ls) -> mergesort_out_gaa([], [], Ls)
   mergesort_in_gaa(.(X, []), .(X, []), Ls) -> mergesort_out_gaa(.(X, []), .(X, []), Ls)
   mergesort_in_gaa(.(X, .(Y, Xs)), Ys, .(H, Ls)) -> U1_gaa(X, Y, Xs, Ys, H, Ls, split_in_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls)))
   split_in_gaaa([], [], [], Ls) -> split_out_gaaa([], [], [], Ls)
   split_in_gaaa(.(X, Xs), .(X, Ys), Zs, .(H, Ls)) -> U5_gaaa(X, Xs, Ys, Zs, H, Ls, split_in_gaaa(Xs, Zs, Ys, Ls))
   U5_gaaa(X, Xs, Ys, Zs, H, Ls, split_out_gaaa(Xs, Zs, Ys, Ls)) -> split_out_gaaa(.(X, Xs), .(X, Ys), Zs, .(H, Ls))
   U1_gaa(X, Y, Xs, Ys, H, Ls, split_out_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls))) -> U2_gaa(X, Y, Xs, Ys, H, Ls, X2s, mergesort_in_gaa(X1s, Y1s, Ls))
   U2_gaa(X, Y, Xs, Ys, H, Ls, X2s, mergesort_out_gaa(X1s, Y1s, Ls)) -> U3_gaa(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_in_gaa(X2s, Y2s, Ls))
   U3_gaa(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_out_gaa(X2s, Y2s, Ls)) -> U4_gaa(X, Y, Xs, Ys, H, Ls, merge_in_ggaa(Y1s, Y2s, Ys, .(H, Ls)))
   merge_in_ggaa([], Xs, Xs, Ls) -> merge_out_ggaa([], Xs, Xs, Ls)
   merge_in_ggaa(Xs, [], Xs, Ls) -> merge_out_ggaa(Xs, [], Xs, Ls)
   merge_in_ggaa(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls)) -> U6_ggaa(X, Xs, Y, Ys, Zs, H, Ls, le_in_gg(X, Y))
   le_in_gg(s(X), s(Y)) -> U11_gg(X, Y, le_in_gg(X, Y))
   le_in_gg(0, s(0)) -> le_out_gg(0, s(0))
   le_in_gg(0, 0) -> le_out_gg(0, 0)
   U11_gg(X, Y, le_out_gg(X, Y)) -> le_out_gg(s(X), s(Y))
   U6_ggaa(X, Xs, Y, Ys, Zs, H, Ls, le_out_gg(X, Y)) -> U7_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_in_ggaa(Xs, .(Y, Ys), Zs, Ls))
   merge_in_ggaa(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls)) -> U8_ggaa(X, Xs, Y, Ys, Zs, H, Ls, gt_in_gg(X, Y))
   gt_in_gg(s(X), s(Y)) -> U10_gg(X, Y, gt_in_gg(X, Y))
   gt_in_gg(s(0), 0) -> gt_out_gg(s(0), 0)
   U10_gg(X, Y, gt_out_gg(X, Y)) -> gt_out_gg(s(X), s(Y))
   U8_ggaa(X, Xs, Y, Ys, Zs, H, Ls, gt_out_gg(X, Y)) -> U9_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_in_ggaa(.(X, Xs), Ys, Zs, Ls))
   U9_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_out_ggaa(.(X, Xs), Ys, Zs, Ls)) -> merge_out_ggaa(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls))
   U7_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_out_ggaa(Xs, .(Y, Ys), Zs, Ls)) -> merge_out_ggaa(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls))
   U4_gaa(X, Y, Xs, Ys, H, Ls, merge_out_ggaa(Y1s, Y2s, Ys, .(H, Ls))) -> mergesort_out_gaa(.(X, .(Y, Xs)), Ys, .(H, Ls))

The argument filtering Pi contains the following mapping:
mergesort_in_gaa(x1, x2, x3)  =  mergesort_in_gaa(x1)

[]  =  []

mergesort_out_gaa(x1, x2, x3)  =  mergesort_out_gaa(x2)

.(x1, x2)  =  .(x1, x2)

U1_gaa(x1, x2, x3, x4, x5, x6, x7)  =  U1_gaa(x7)

split_in_gaaa(x1, x2, x3, x4)  =  split_in_gaaa(x1)

split_out_gaaa(x1, x2, x3, x4)  =  split_out_gaaa(x2, x3)

U5_gaaa(x1, x2, x3, x4, x5, x6, x7)  =  U5_gaaa(x1, x7)

U2_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_gaa(x7, x8)

U3_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_gaa(x7, x8)

U4_gaa(x1, x2, x3, x4, x5, x6, x7)  =  U4_gaa(x7)

merge_in_ggaa(x1, x2, x3, x4)  =  merge_in_ggaa(x1, x2)

merge_out_ggaa(x1, x2, x3, x4)  =  merge_out_ggaa(x3)

U6_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U6_ggaa(x1, x2, x3, x4, x8)

le_in_gg(x1, x2)  =  le_in_gg(x1, x2)

s(x1)  =  s(x1)

U11_gg(x1, x2, x3)  =  U11_gg(x3)

0  =  0

le_out_gg(x1, x2)  =  le_out_gg

U7_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U7_ggaa(x1, x8)

U8_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U8_ggaa(x1, x2, x3, x4, x8)

gt_in_gg(x1, x2)  =  gt_in_gg(x1, x2)

U10_gg(x1, x2, x3)  =  U10_gg(x3)

gt_out_gg(x1, x2)  =  gt_out_gg

U9_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U9_ggaa(x3, x8)

GT_IN_GG(x1, x2)  =  GT_IN_GG(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(8) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(9)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   GT_IN_GG(s(X), s(Y)) -> GT_IN_GG(X, Y)

R is empty.
Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(10) PiDPToQDPProof (EQUIVALENT)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(11)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   GT_IN_GG(s(X), s(Y)) -> GT_IN_GG(X, Y)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(12) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*GT_IN_GG(s(X), s(Y)) -> GT_IN_GG(X, Y)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(13)
YES

----------------------------------------

(14)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   LE_IN_GG(s(X), s(Y)) -> LE_IN_GG(X, Y)

The TRS R consists of the following rules:

   mergesort_in_gaa([], [], Ls) -> mergesort_out_gaa([], [], Ls)
   mergesort_in_gaa(.(X, []), .(X, []), Ls) -> mergesort_out_gaa(.(X, []), .(X, []), Ls)
   mergesort_in_gaa(.(X, .(Y, Xs)), Ys, .(H, Ls)) -> U1_gaa(X, Y, Xs, Ys, H, Ls, split_in_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls)))
   split_in_gaaa([], [], [], Ls) -> split_out_gaaa([], [], [], Ls)
   split_in_gaaa(.(X, Xs), .(X, Ys), Zs, .(H, Ls)) -> U5_gaaa(X, Xs, Ys, Zs, H, Ls, split_in_gaaa(Xs, Zs, Ys, Ls))
   U5_gaaa(X, Xs, Ys, Zs, H, Ls, split_out_gaaa(Xs, Zs, Ys, Ls)) -> split_out_gaaa(.(X, Xs), .(X, Ys), Zs, .(H, Ls))
   U1_gaa(X, Y, Xs, Ys, H, Ls, split_out_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls))) -> U2_gaa(X, Y, Xs, Ys, H, Ls, X2s, mergesort_in_gaa(X1s, Y1s, Ls))
   U2_gaa(X, Y, Xs, Ys, H, Ls, X2s, mergesort_out_gaa(X1s, Y1s, Ls)) -> U3_gaa(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_in_gaa(X2s, Y2s, Ls))
   U3_gaa(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_out_gaa(X2s, Y2s, Ls)) -> U4_gaa(X, Y, Xs, Ys, H, Ls, merge_in_ggaa(Y1s, Y2s, Ys, .(H, Ls)))
   merge_in_ggaa([], Xs, Xs, Ls) -> merge_out_ggaa([], Xs, Xs, Ls)
   merge_in_ggaa(Xs, [], Xs, Ls) -> merge_out_ggaa(Xs, [], Xs, Ls)
   merge_in_ggaa(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls)) -> U6_ggaa(X, Xs, Y, Ys, Zs, H, Ls, le_in_gg(X, Y))
   le_in_gg(s(X), s(Y)) -> U11_gg(X, Y, le_in_gg(X, Y))
   le_in_gg(0, s(0)) -> le_out_gg(0, s(0))
   le_in_gg(0, 0) -> le_out_gg(0, 0)
   U11_gg(X, Y, le_out_gg(X, Y)) -> le_out_gg(s(X), s(Y))
   U6_ggaa(X, Xs, Y, Ys, Zs, H, Ls, le_out_gg(X, Y)) -> U7_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_in_ggaa(Xs, .(Y, Ys), Zs, Ls))
   merge_in_ggaa(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls)) -> U8_ggaa(X, Xs, Y, Ys, Zs, H, Ls, gt_in_gg(X, Y))
   gt_in_gg(s(X), s(Y)) -> U10_gg(X, Y, gt_in_gg(X, Y))
   gt_in_gg(s(0), 0) -> gt_out_gg(s(0), 0)
   U10_gg(X, Y, gt_out_gg(X, Y)) -> gt_out_gg(s(X), s(Y))
   U8_ggaa(X, Xs, Y, Ys, Zs, H, Ls, gt_out_gg(X, Y)) -> U9_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_in_ggaa(.(X, Xs), Ys, Zs, Ls))
   U9_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_out_ggaa(.(X, Xs), Ys, Zs, Ls)) -> merge_out_ggaa(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls))
   U7_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_out_ggaa(Xs, .(Y, Ys), Zs, Ls)) -> merge_out_ggaa(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls))
   U4_gaa(X, Y, Xs, Ys, H, Ls, merge_out_ggaa(Y1s, Y2s, Ys, .(H, Ls))) -> mergesort_out_gaa(.(X, .(Y, Xs)), Ys, .(H, Ls))

The argument filtering Pi contains the following mapping:
mergesort_in_gaa(x1, x2, x3)  =  mergesort_in_gaa(x1)

[]  =  []

mergesort_out_gaa(x1, x2, x3)  =  mergesort_out_gaa(x2)

.(x1, x2)  =  .(x1, x2)

U1_gaa(x1, x2, x3, x4, x5, x6, x7)  =  U1_gaa(x7)

split_in_gaaa(x1, x2, x3, x4)  =  split_in_gaaa(x1)

split_out_gaaa(x1, x2, x3, x4)  =  split_out_gaaa(x2, x3)

U5_gaaa(x1, x2, x3, x4, x5, x6, x7)  =  U5_gaaa(x1, x7)

U2_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_gaa(x7, x8)

U3_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_gaa(x7, x8)

U4_gaa(x1, x2, x3, x4, x5, x6, x7)  =  U4_gaa(x7)

merge_in_ggaa(x1, x2, x3, x4)  =  merge_in_ggaa(x1, x2)

merge_out_ggaa(x1, x2, x3, x4)  =  merge_out_ggaa(x3)

U6_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U6_ggaa(x1, x2, x3, x4, x8)

le_in_gg(x1, x2)  =  le_in_gg(x1, x2)

s(x1)  =  s(x1)

U11_gg(x1, x2, x3)  =  U11_gg(x3)

0  =  0

le_out_gg(x1, x2)  =  le_out_gg

U7_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U7_ggaa(x1, x8)

U8_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U8_ggaa(x1, x2, x3, x4, x8)

gt_in_gg(x1, x2)  =  gt_in_gg(x1, x2)

U10_gg(x1, x2, x3)  =  U10_gg(x3)

gt_out_gg(x1, x2)  =  gt_out_gg

U9_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U9_ggaa(x3, x8)

LE_IN_GG(x1, x2)  =  LE_IN_GG(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(15) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(16)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   LE_IN_GG(s(X), s(Y)) -> LE_IN_GG(X, Y)

R is empty.
Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(17) PiDPToQDPProof (EQUIVALENT)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(18)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LE_IN_GG(s(X), s(Y)) -> LE_IN_GG(X, Y)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(19) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*LE_IN_GG(s(X), s(Y)) -> LE_IN_GG(X, Y)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(20)
YES

----------------------------------------

(21)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U6_GGAA(X, Xs, Y, Ys, Zs, H, Ls, le_out_gg(X, Y)) -> MERGE_IN_GGAA(Xs, .(Y, Ys), Zs, Ls)
   MERGE_IN_GGAA(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls)) -> U6_GGAA(X, Xs, Y, Ys, Zs, H, Ls, le_in_gg(X, Y))
   MERGE_IN_GGAA(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls)) -> U8_GGAA(X, Xs, Y, Ys, Zs, H, Ls, gt_in_gg(X, Y))
   U8_GGAA(X, Xs, Y, Ys, Zs, H, Ls, gt_out_gg(X, Y)) -> MERGE_IN_GGAA(.(X, Xs), Ys, Zs, Ls)

The TRS R consists of the following rules:

   mergesort_in_gaa([], [], Ls) -> mergesort_out_gaa([], [], Ls)
   mergesort_in_gaa(.(X, []), .(X, []), Ls) -> mergesort_out_gaa(.(X, []), .(X, []), Ls)
   mergesort_in_gaa(.(X, .(Y, Xs)), Ys, .(H, Ls)) -> U1_gaa(X, Y, Xs, Ys, H, Ls, split_in_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls)))
   split_in_gaaa([], [], [], Ls) -> split_out_gaaa([], [], [], Ls)
   split_in_gaaa(.(X, Xs), .(X, Ys), Zs, .(H, Ls)) -> U5_gaaa(X, Xs, Ys, Zs, H, Ls, split_in_gaaa(Xs, Zs, Ys, Ls))
   U5_gaaa(X, Xs, Ys, Zs, H, Ls, split_out_gaaa(Xs, Zs, Ys, Ls)) -> split_out_gaaa(.(X, Xs), .(X, Ys), Zs, .(H, Ls))
   U1_gaa(X, Y, Xs, Ys, H, Ls, split_out_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls))) -> U2_gaa(X, Y, Xs, Ys, H, Ls, X2s, mergesort_in_gaa(X1s, Y1s, Ls))
   U2_gaa(X, Y, Xs, Ys, H, Ls, X2s, mergesort_out_gaa(X1s, Y1s, Ls)) -> U3_gaa(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_in_gaa(X2s, Y2s, Ls))
   U3_gaa(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_out_gaa(X2s, Y2s, Ls)) -> U4_gaa(X, Y, Xs, Ys, H, Ls, merge_in_ggaa(Y1s, Y2s, Ys, .(H, Ls)))
   merge_in_ggaa([], Xs, Xs, Ls) -> merge_out_ggaa([], Xs, Xs, Ls)
   merge_in_ggaa(Xs, [], Xs, Ls) -> merge_out_ggaa(Xs, [], Xs, Ls)
   merge_in_ggaa(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls)) -> U6_ggaa(X, Xs, Y, Ys, Zs, H, Ls, le_in_gg(X, Y))
   le_in_gg(s(X), s(Y)) -> U11_gg(X, Y, le_in_gg(X, Y))
   le_in_gg(0, s(0)) -> le_out_gg(0, s(0))
   le_in_gg(0, 0) -> le_out_gg(0, 0)
   U11_gg(X, Y, le_out_gg(X, Y)) -> le_out_gg(s(X), s(Y))
   U6_ggaa(X, Xs, Y, Ys, Zs, H, Ls, le_out_gg(X, Y)) -> U7_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_in_ggaa(Xs, .(Y, Ys), Zs, Ls))
   merge_in_ggaa(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls)) -> U8_ggaa(X, Xs, Y, Ys, Zs, H, Ls, gt_in_gg(X, Y))
   gt_in_gg(s(X), s(Y)) -> U10_gg(X, Y, gt_in_gg(X, Y))
   gt_in_gg(s(0), 0) -> gt_out_gg(s(0), 0)
   U10_gg(X, Y, gt_out_gg(X, Y)) -> gt_out_gg(s(X), s(Y))
   U8_ggaa(X, Xs, Y, Ys, Zs, H, Ls, gt_out_gg(X, Y)) -> U9_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_in_ggaa(.(X, Xs), Ys, Zs, Ls))
   U9_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_out_ggaa(.(X, Xs), Ys, Zs, Ls)) -> merge_out_ggaa(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls))
   U7_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_out_ggaa(Xs, .(Y, Ys), Zs, Ls)) -> merge_out_ggaa(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls))
   U4_gaa(X, Y, Xs, Ys, H, Ls, merge_out_ggaa(Y1s, Y2s, Ys, .(H, Ls))) -> mergesort_out_gaa(.(X, .(Y, Xs)), Ys, .(H, Ls))

The argument filtering Pi contains the following mapping:
mergesort_in_gaa(x1, x2, x3)  =  mergesort_in_gaa(x1)

[]  =  []

mergesort_out_gaa(x1, x2, x3)  =  mergesort_out_gaa(x2)

.(x1, x2)  =  .(x1, x2)

U1_gaa(x1, x2, x3, x4, x5, x6, x7)  =  U1_gaa(x7)

split_in_gaaa(x1, x2, x3, x4)  =  split_in_gaaa(x1)

split_out_gaaa(x1, x2, x3, x4)  =  split_out_gaaa(x2, x3)

U5_gaaa(x1, x2, x3, x4, x5, x6, x7)  =  U5_gaaa(x1, x7)

U2_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_gaa(x7, x8)

U3_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_gaa(x7, x8)

U4_gaa(x1, x2, x3, x4, x5, x6, x7)  =  U4_gaa(x7)

merge_in_ggaa(x1, x2, x3, x4)  =  merge_in_ggaa(x1, x2)

merge_out_ggaa(x1, x2, x3, x4)  =  merge_out_ggaa(x3)

U6_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U6_ggaa(x1, x2, x3, x4, x8)

le_in_gg(x1, x2)  =  le_in_gg(x1, x2)

s(x1)  =  s(x1)

U11_gg(x1, x2, x3)  =  U11_gg(x3)

0  =  0

le_out_gg(x1, x2)  =  le_out_gg

U7_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U7_ggaa(x1, x8)

U8_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U8_ggaa(x1, x2, x3, x4, x8)

gt_in_gg(x1, x2)  =  gt_in_gg(x1, x2)

U10_gg(x1, x2, x3)  =  U10_gg(x3)

gt_out_gg(x1, x2)  =  gt_out_gg

U9_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U9_ggaa(x3, x8)

MERGE_IN_GGAA(x1, x2, x3, x4)  =  MERGE_IN_GGAA(x1, x2)

U6_GGAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U6_GGAA(x1, x2, x3, x4, x8)

U8_GGAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U8_GGAA(x1, x2, x3, x4, x8)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(22) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(23)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U6_GGAA(X, Xs, Y, Ys, Zs, H, Ls, le_out_gg(X, Y)) -> MERGE_IN_GGAA(Xs, .(Y, Ys), Zs, Ls)
   MERGE_IN_GGAA(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls)) -> U6_GGAA(X, Xs, Y, Ys, Zs, H, Ls, le_in_gg(X, Y))
   MERGE_IN_GGAA(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls)) -> U8_GGAA(X, Xs, Y, Ys, Zs, H, Ls, gt_in_gg(X, Y))
   U8_GGAA(X, Xs, Y, Ys, Zs, H, Ls, gt_out_gg(X, Y)) -> MERGE_IN_GGAA(.(X, Xs), Ys, Zs, Ls)

The TRS R consists of the following rules:

   le_in_gg(s(X), s(Y)) -> U11_gg(X, Y, le_in_gg(X, Y))
   le_in_gg(0, s(0)) -> le_out_gg(0, s(0))
   le_in_gg(0, 0) -> le_out_gg(0, 0)
   gt_in_gg(s(X), s(Y)) -> U10_gg(X, Y, gt_in_gg(X, Y))
   gt_in_gg(s(0), 0) -> gt_out_gg(s(0), 0)
   U11_gg(X, Y, le_out_gg(X, Y)) -> le_out_gg(s(X), s(Y))
   U10_gg(X, Y, gt_out_gg(X, Y)) -> gt_out_gg(s(X), s(Y))

The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x1, x2)

le_in_gg(x1, x2)  =  le_in_gg(x1, x2)

s(x1)  =  s(x1)

U11_gg(x1, x2, x3)  =  U11_gg(x3)

0  =  0

le_out_gg(x1, x2)  =  le_out_gg

gt_in_gg(x1, x2)  =  gt_in_gg(x1, x2)

U10_gg(x1, x2, x3)  =  U10_gg(x3)

gt_out_gg(x1, x2)  =  gt_out_gg

MERGE_IN_GGAA(x1, x2, x3, x4)  =  MERGE_IN_GGAA(x1, x2)

U6_GGAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U6_GGAA(x1, x2, x3, x4, x8)

U8_GGAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U8_GGAA(x1, x2, x3, x4, x8)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(24) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(25)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_GGAA(X, Xs, Y, Ys, le_out_gg) -> MERGE_IN_GGAA(Xs, .(Y, Ys))
   MERGE_IN_GGAA(.(X, Xs), .(Y, Ys)) -> U6_GGAA(X, Xs, Y, Ys, le_in_gg(X, Y))
   MERGE_IN_GGAA(.(X, Xs), .(Y, Ys)) -> U8_GGAA(X, Xs, Y, Ys, gt_in_gg(X, Y))
   U8_GGAA(X, Xs, Y, Ys, gt_out_gg) -> MERGE_IN_GGAA(.(X, Xs), Ys)

The TRS R consists of the following rules:

   le_in_gg(s(X), s(Y)) -> U11_gg(le_in_gg(X, Y))
   le_in_gg(0, s(0)) -> le_out_gg
   le_in_gg(0, 0) -> le_out_gg
   gt_in_gg(s(X), s(Y)) -> U10_gg(gt_in_gg(X, Y))
   gt_in_gg(s(0), 0) -> gt_out_gg
   U11_gg(le_out_gg) -> le_out_gg
   U10_gg(gt_out_gg) -> gt_out_gg

The set Q consists of the following terms:

   le_in_gg(x0, x1)
   gt_in_gg(x0, x1)
   U11_gg(x0)
   U10_gg(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(26) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MERGE_IN_GGAA(.(X, Xs), .(Y, Ys)) -> U8_GGAA(X, Xs, Y, Ys, gt_in_gg(X, Y))
   U8_GGAA(X, Xs, Y, Ys, gt_out_gg) -> MERGE_IN_GGAA(.(X, Xs), Ys)
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( U6_GGAA_5(x_1, ..., x_5) ) = 2x_3 + 2x_4 + 1
POL( le_in_gg_2(x_1, x_2) ) = 0
POL( s_1(x_1) ) = 2
POL( U11_gg_1(x_1) ) = 2
POL( 0 ) = 2
POL( le_out_gg ) = 0
POL( U8_GGAA_5(x_1, ..., x_5) ) = max{0, x_4 + 2x_5 - 2}
POL( gt_in_gg_2(x_1, x_2) ) = x_2
POL( U10_gg_1(x_1) ) = 2
POL( gt_out_gg ) = 2
POL( MERGE_IN_GGAA_2(x_1, x_2) ) = max{0, x_2 - 1}
POL( ._2(x_1, x_2) ) = 2x_1 + 2x_2 + 2

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   gt_in_gg(s(X), s(Y)) -> U10_gg(gt_in_gg(X, Y))
   gt_in_gg(s(0), 0) -> gt_out_gg
   U10_gg(gt_out_gg) -> gt_out_gg


----------------------------------------

(27)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_GGAA(X, Xs, Y, Ys, le_out_gg) -> MERGE_IN_GGAA(Xs, .(Y, Ys))
   MERGE_IN_GGAA(.(X, Xs), .(Y, Ys)) -> U6_GGAA(X, Xs, Y, Ys, le_in_gg(X, Y))

The TRS R consists of the following rules:

   le_in_gg(s(X), s(Y)) -> U11_gg(le_in_gg(X, Y))
   le_in_gg(0, s(0)) -> le_out_gg
   le_in_gg(0, 0) -> le_out_gg
   gt_in_gg(s(X), s(Y)) -> U10_gg(gt_in_gg(X, Y))
   gt_in_gg(s(0), 0) -> gt_out_gg
   U11_gg(le_out_gg) -> le_out_gg
   U10_gg(gt_out_gg) -> gt_out_gg

The set Q consists of the following terms:

   le_in_gg(x0, x1)
   gt_in_gg(x0, x1)
   U11_gg(x0)
   U10_gg(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(28) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(29)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_GGAA(X, Xs, Y, Ys, le_out_gg) -> MERGE_IN_GGAA(Xs, .(Y, Ys))
   MERGE_IN_GGAA(.(X, Xs), .(Y, Ys)) -> U6_GGAA(X, Xs, Y, Ys, le_in_gg(X, Y))

The TRS R consists of the following rules:

   le_in_gg(s(X), s(Y)) -> U11_gg(le_in_gg(X, Y))
   le_in_gg(0, s(0)) -> le_out_gg
   le_in_gg(0, 0) -> le_out_gg
   U11_gg(le_out_gg) -> le_out_gg

The set Q consists of the following terms:

   le_in_gg(x0, x1)
   gt_in_gg(x0, x1)
   U11_gg(x0)
   U10_gg(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(30) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   gt_in_gg(x0, x1)
   U10_gg(x0)


----------------------------------------

(31)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U6_GGAA(X, Xs, Y, Ys, le_out_gg) -> MERGE_IN_GGAA(Xs, .(Y, Ys))
   MERGE_IN_GGAA(.(X, Xs), .(Y, Ys)) -> U6_GGAA(X, Xs, Y, Ys, le_in_gg(X, Y))

The TRS R consists of the following rules:

   le_in_gg(s(X), s(Y)) -> U11_gg(le_in_gg(X, Y))
   le_in_gg(0, s(0)) -> le_out_gg
   le_in_gg(0, 0) -> le_out_gg
   U11_gg(le_out_gg) -> le_out_gg

The set Q consists of the following terms:

   le_in_gg(x0, x1)
   U11_gg(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(32) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*MERGE_IN_GGAA(.(X, Xs), .(Y, Ys)) -> U6_GGAA(X, Xs, Y, Ys, le_in_gg(X, Y))
The graph contains the following edges 1 > 1, 1 > 2, 2 > 3, 2 > 4


*U6_GGAA(X, Xs, Y, Ys, le_out_gg) -> MERGE_IN_GGAA(Xs, .(Y, Ys))
The graph contains the following edges 2 >= 1


----------------------------------------

(33)
YES

----------------------------------------

(34)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   SPLIT_IN_GAAA(.(X, Xs), .(X, Ys), Zs, .(H, Ls)) -> SPLIT_IN_GAAA(Xs, Zs, Ys, Ls)

The TRS R consists of the following rules:

   mergesort_in_gaa([], [], Ls) -> mergesort_out_gaa([], [], Ls)
   mergesort_in_gaa(.(X, []), .(X, []), Ls) -> mergesort_out_gaa(.(X, []), .(X, []), Ls)
   mergesort_in_gaa(.(X, .(Y, Xs)), Ys, .(H, Ls)) -> U1_gaa(X, Y, Xs, Ys, H, Ls, split_in_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls)))
   split_in_gaaa([], [], [], Ls) -> split_out_gaaa([], [], [], Ls)
   split_in_gaaa(.(X, Xs), .(X, Ys), Zs, .(H, Ls)) -> U5_gaaa(X, Xs, Ys, Zs, H, Ls, split_in_gaaa(Xs, Zs, Ys, Ls))
   U5_gaaa(X, Xs, Ys, Zs, H, Ls, split_out_gaaa(Xs, Zs, Ys, Ls)) -> split_out_gaaa(.(X, Xs), .(X, Ys), Zs, .(H, Ls))
   U1_gaa(X, Y, Xs, Ys, H, Ls, split_out_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls))) -> U2_gaa(X, Y, Xs, Ys, H, Ls, X2s, mergesort_in_gaa(X1s, Y1s, Ls))
   U2_gaa(X, Y, Xs, Ys, H, Ls, X2s, mergesort_out_gaa(X1s, Y1s, Ls)) -> U3_gaa(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_in_gaa(X2s, Y2s, Ls))
   U3_gaa(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_out_gaa(X2s, Y2s, Ls)) -> U4_gaa(X, Y, Xs, Ys, H, Ls, merge_in_ggaa(Y1s, Y2s, Ys, .(H, Ls)))
   merge_in_ggaa([], Xs, Xs, Ls) -> merge_out_ggaa([], Xs, Xs, Ls)
   merge_in_ggaa(Xs, [], Xs, Ls) -> merge_out_ggaa(Xs, [], Xs, Ls)
   merge_in_ggaa(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls)) -> U6_ggaa(X, Xs, Y, Ys, Zs, H, Ls, le_in_gg(X, Y))
   le_in_gg(s(X), s(Y)) -> U11_gg(X, Y, le_in_gg(X, Y))
   le_in_gg(0, s(0)) -> le_out_gg(0, s(0))
   le_in_gg(0, 0) -> le_out_gg(0, 0)
   U11_gg(X, Y, le_out_gg(X, Y)) -> le_out_gg(s(X), s(Y))
   U6_ggaa(X, Xs, Y, Ys, Zs, H, Ls, le_out_gg(X, Y)) -> U7_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_in_ggaa(Xs, .(Y, Ys), Zs, Ls))
   merge_in_ggaa(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls)) -> U8_ggaa(X, Xs, Y, Ys, Zs, H, Ls, gt_in_gg(X, Y))
   gt_in_gg(s(X), s(Y)) -> U10_gg(X, Y, gt_in_gg(X, Y))
   gt_in_gg(s(0), 0) -> gt_out_gg(s(0), 0)
   U10_gg(X, Y, gt_out_gg(X, Y)) -> gt_out_gg(s(X), s(Y))
   U8_ggaa(X, Xs, Y, Ys, Zs, H, Ls, gt_out_gg(X, Y)) -> U9_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_in_ggaa(.(X, Xs), Ys, Zs, Ls))
   U9_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_out_ggaa(.(X, Xs), Ys, Zs, Ls)) -> merge_out_ggaa(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls))
   U7_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_out_ggaa(Xs, .(Y, Ys), Zs, Ls)) -> merge_out_ggaa(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls))
   U4_gaa(X, Y, Xs, Ys, H, Ls, merge_out_ggaa(Y1s, Y2s, Ys, .(H, Ls))) -> mergesort_out_gaa(.(X, .(Y, Xs)), Ys, .(H, Ls))

The argument filtering Pi contains the following mapping:
mergesort_in_gaa(x1, x2, x3)  =  mergesort_in_gaa(x1)

[]  =  []

mergesort_out_gaa(x1, x2, x3)  =  mergesort_out_gaa(x2)

.(x1, x2)  =  .(x1, x2)

U1_gaa(x1, x2, x3, x4, x5, x6, x7)  =  U1_gaa(x7)

split_in_gaaa(x1, x2, x3, x4)  =  split_in_gaaa(x1)

split_out_gaaa(x1, x2, x3, x4)  =  split_out_gaaa(x2, x3)

U5_gaaa(x1, x2, x3, x4, x5, x6, x7)  =  U5_gaaa(x1, x7)

U2_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_gaa(x7, x8)

U3_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_gaa(x7, x8)

U4_gaa(x1, x2, x3, x4, x5, x6, x7)  =  U4_gaa(x7)

merge_in_ggaa(x1, x2, x3, x4)  =  merge_in_ggaa(x1, x2)

merge_out_ggaa(x1, x2, x3, x4)  =  merge_out_ggaa(x3)

U6_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U6_ggaa(x1, x2, x3, x4, x8)

le_in_gg(x1, x2)  =  le_in_gg(x1, x2)

s(x1)  =  s(x1)

U11_gg(x1, x2, x3)  =  U11_gg(x3)

0  =  0

le_out_gg(x1, x2)  =  le_out_gg

U7_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U7_ggaa(x1, x8)

U8_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U8_ggaa(x1, x2, x3, x4, x8)

gt_in_gg(x1, x2)  =  gt_in_gg(x1, x2)

U10_gg(x1, x2, x3)  =  U10_gg(x3)

gt_out_gg(x1, x2)  =  gt_out_gg

U9_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U9_ggaa(x3, x8)

SPLIT_IN_GAAA(x1, x2, x3, x4)  =  SPLIT_IN_GAAA(x1)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(35) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(36)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   SPLIT_IN_GAAA(.(X, Xs), .(X, Ys), Zs, .(H, Ls)) -> SPLIT_IN_GAAA(Xs, Zs, Ys, Ls)

R is empty.
The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x1, x2)

SPLIT_IN_GAAA(x1, x2, x3, x4)  =  SPLIT_IN_GAAA(x1)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(37) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(38)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   SPLIT_IN_GAAA(.(X, Xs)) -> SPLIT_IN_GAAA(Xs)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(39) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*SPLIT_IN_GAAA(.(X, Xs)) -> SPLIT_IN_GAAA(Xs)
The graph contains the following edges 1 > 1


----------------------------------------

(40)
YES

----------------------------------------

(41)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_GAA(X, Y, Xs, Ys, H, Ls, split_out_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls))) -> U2_GAA(X, Y, Xs, Ys, H, Ls, X2s, mergesort_in_gaa(X1s, Y1s, Ls))
   U2_GAA(X, Y, Xs, Ys, H, Ls, X2s, mergesort_out_gaa(X1s, Y1s, Ls)) -> MERGESORT_IN_GAA(X2s, Y2s, Ls)
   MERGESORT_IN_GAA(.(X, .(Y, Xs)), Ys, .(H, Ls)) -> U1_GAA(X, Y, Xs, Ys, H, Ls, split_in_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls)))
   U1_GAA(X, Y, Xs, Ys, H, Ls, split_out_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls))) -> MERGESORT_IN_GAA(X1s, Y1s, Ls)

The TRS R consists of the following rules:

   mergesort_in_gaa([], [], Ls) -> mergesort_out_gaa([], [], Ls)
   mergesort_in_gaa(.(X, []), .(X, []), Ls) -> mergesort_out_gaa(.(X, []), .(X, []), Ls)
   mergesort_in_gaa(.(X, .(Y, Xs)), Ys, .(H, Ls)) -> U1_gaa(X, Y, Xs, Ys, H, Ls, split_in_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls)))
   split_in_gaaa([], [], [], Ls) -> split_out_gaaa([], [], [], Ls)
   split_in_gaaa(.(X, Xs), .(X, Ys), Zs, .(H, Ls)) -> U5_gaaa(X, Xs, Ys, Zs, H, Ls, split_in_gaaa(Xs, Zs, Ys, Ls))
   U5_gaaa(X, Xs, Ys, Zs, H, Ls, split_out_gaaa(Xs, Zs, Ys, Ls)) -> split_out_gaaa(.(X, Xs), .(X, Ys), Zs, .(H, Ls))
   U1_gaa(X, Y, Xs, Ys, H, Ls, split_out_gaaa(.(X, .(Y, Xs)), X1s, X2s, .(H, Ls))) -> U2_gaa(X, Y, Xs, Ys, H, Ls, X2s, mergesort_in_gaa(X1s, Y1s, Ls))
   U2_gaa(X, Y, Xs, Ys, H, Ls, X2s, mergesort_out_gaa(X1s, Y1s, Ls)) -> U3_gaa(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_in_gaa(X2s, Y2s, Ls))
   U3_gaa(X, Y, Xs, Ys, H, Ls, Y1s, mergesort_out_gaa(X2s, Y2s, Ls)) -> U4_gaa(X, Y, Xs, Ys, H, Ls, merge_in_ggaa(Y1s, Y2s, Ys, .(H, Ls)))
   merge_in_ggaa([], Xs, Xs, Ls) -> merge_out_ggaa([], Xs, Xs, Ls)
   merge_in_ggaa(Xs, [], Xs, Ls) -> merge_out_ggaa(Xs, [], Xs, Ls)
   merge_in_ggaa(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls)) -> U6_ggaa(X, Xs, Y, Ys, Zs, H, Ls, le_in_gg(X, Y))
   le_in_gg(s(X), s(Y)) -> U11_gg(X, Y, le_in_gg(X, Y))
   le_in_gg(0, s(0)) -> le_out_gg(0, s(0))
   le_in_gg(0, 0) -> le_out_gg(0, 0)
   U11_gg(X, Y, le_out_gg(X, Y)) -> le_out_gg(s(X), s(Y))
   U6_ggaa(X, Xs, Y, Ys, Zs, H, Ls, le_out_gg(X, Y)) -> U7_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_in_ggaa(Xs, .(Y, Ys), Zs, Ls))
   merge_in_ggaa(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls)) -> U8_ggaa(X, Xs, Y, Ys, Zs, H, Ls, gt_in_gg(X, Y))
   gt_in_gg(s(X), s(Y)) -> U10_gg(X, Y, gt_in_gg(X, Y))
   gt_in_gg(s(0), 0) -> gt_out_gg(s(0), 0)
   U10_gg(X, Y, gt_out_gg(X, Y)) -> gt_out_gg(s(X), s(Y))
   U8_ggaa(X, Xs, Y, Ys, Zs, H, Ls, gt_out_gg(X, Y)) -> U9_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_in_ggaa(.(X, Xs), Ys, Zs, Ls))
   U9_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_out_ggaa(.(X, Xs), Ys, Zs, Ls)) -> merge_out_ggaa(.(X, Xs), .(Y, Ys), .(Y, Zs), .(H, Ls))
   U7_ggaa(X, Xs, Y, Ys, Zs, H, Ls, merge_out_ggaa(Xs, .(Y, Ys), Zs, Ls)) -> merge_out_ggaa(.(X, Xs), .(Y, Ys), .(X, Zs), .(H, Ls))
   U4_gaa(X, Y, Xs, Ys, H, Ls, merge_out_ggaa(Y1s, Y2s, Ys, .(H, Ls))) -> mergesort_out_gaa(.(X, .(Y, Xs)), Ys, .(H, Ls))

The argument filtering Pi contains the following mapping:
mergesort_in_gaa(x1, x2, x3)  =  mergesort_in_gaa(x1)

[]  =  []

mergesort_out_gaa(x1, x2, x3)  =  mergesort_out_gaa(x2)

.(x1, x2)  =  .(x1, x2)

U1_gaa(x1, x2, x3, x4, x5, x6, x7)  =  U1_gaa(x7)

split_in_gaaa(x1, x2, x3, x4)  =  split_in_gaaa(x1)

split_out_gaaa(x1, x2, x3, x4)  =  split_out_gaaa(x2, x3)

U5_gaaa(x1, x2, x3, x4, x5, x6, x7)  =  U5_gaaa(x1, x7)

U2_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_gaa(x7, x8)

U3_gaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U3_gaa(x7, x8)

U4_gaa(x1, x2, x3, x4, x5, x6, x7)  =  U4_gaa(x7)

merge_in_ggaa(x1, x2, x3, x4)  =  merge_in_ggaa(x1, x2)

merge_out_ggaa(x1, x2, x3, x4)  =  merge_out_ggaa(x3)

U6_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U6_ggaa(x1, x2, x3, x4, x8)

le_in_gg(x1, x2)  =  le_in_gg(x1, x2)

s(x1)  =  s(x1)

U11_gg(x1, x2, x3)  =  U11_gg(x3)

0  =  0

le_out_gg(x1, x2)  =  le_out_gg

U7_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U7_ggaa(x1, x8)

U8_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U8_ggaa(x1, x2, x3, x4, x8)

gt_in_gg(x1, x2)  =  gt_in_gg(x1, x2)

U10_gg(x1, x2, x3)  =  U10_gg(x3)

gt_out_gg(x1, x2)  =  gt_out_gg

U9_ggaa(x1, x2, x3, x4, x5, x6, x7, x8)  =  U9_ggaa(x3, x8)

MERGESORT_IN_GAA(x1, x2, x3)  =  MERGESORT_IN_GAA(x1)

U1_GAA(x1, x2, x3, x4, x5, x6, x7)  =  U1_GAA(x7)

U2_GAA(x1, x2, x3, x4, x5, x6, x7, x8)  =  U2_GAA(x7, x8)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(42) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(43)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_GAA(split_out_gaaa(X1s, X2s)) -> U2_GAA(X2s, mergesort_in_gaa(X1s))
   U2_GAA(X2s, mergesort_out_gaa(Y1s)) -> MERGESORT_IN_GAA(X2s)
   MERGESORT_IN_GAA(.(X, .(Y, Xs))) -> U1_GAA(split_in_gaaa(.(X, .(Y, Xs))))
   U1_GAA(split_out_gaaa(X1s, X2s)) -> MERGESORT_IN_GAA(X1s)

The TRS R consists of the following rules:

   mergesort_in_gaa([]) -> mergesort_out_gaa([])
   mergesort_in_gaa(.(X, [])) -> mergesort_out_gaa(.(X, []))
   mergesort_in_gaa(.(X, .(Y, Xs))) -> U1_gaa(split_in_gaaa(.(X, .(Y, Xs))))
   split_in_gaaa([]) -> split_out_gaaa([], [])
   split_in_gaaa(.(X, Xs)) -> U5_gaaa(X, split_in_gaaa(Xs))
   U5_gaaa(X, split_out_gaaa(Zs, Ys)) -> split_out_gaaa(.(X, Ys), Zs)
   U1_gaa(split_out_gaaa(X1s, X2s)) -> U2_gaa(X2s, mergesort_in_gaa(X1s))
   U2_gaa(X2s, mergesort_out_gaa(Y1s)) -> U3_gaa(Y1s, mergesort_in_gaa(X2s))
   U3_gaa(Y1s, mergesort_out_gaa(Y2s)) -> U4_gaa(merge_in_ggaa(Y1s, Y2s))
   merge_in_ggaa([], Xs) -> merge_out_ggaa(Xs)
   merge_in_ggaa(Xs, []) -> merge_out_ggaa(Xs)
   merge_in_ggaa(.(X, Xs), .(Y, Ys)) -> U6_ggaa(X, Xs, Y, Ys, le_in_gg(X, Y))
   le_in_gg(s(X), s(Y)) -> U11_gg(le_in_gg(X, Y))
   le_in_gg(0, s(0)) -> le_out_gg
   le_in_gg(0, 0) -> le_out_gg
   U11_gg(le_out_gg) -> le_out_gg
   U6_ggaa(X, Xs, Y, Ys, le_out_gg) -> U7_ggaa(X, merge_in_ggaa(Xs, .(Y, Ys)))
   merge_in_ggaa(.(X, Xs), .(Y, Ys)) -> U8_ggaa(X, Xs, Y, Ys, gt_in_gg(X, Y))
   gt_in_gg(s(X), s(Y)) -> U10_gg(gt_in_gg(X, Y))
   gt_in_gg(s(0), 0) -> gt_out_gg
   U10_gg(gt_out_gg) -> gt_out_gg
   U8_ggaa(X, Xs, Y, Ys, gt_out_gg) -> U9_ggaa(Y, merge_in_ggaa(.(X, Xs), Ys))
   U9_ggaa(Y, merge_out_ggaa(Zs)) -> merge_out_ggaa(.(Y, Zs))
   U7_ggaa(X, merge_out_ggaa(Zs)) -> merge_out_ggaa(.(X, Zs))
   U4_gaa(merge_out_ggaa(Ys)) -> mergesort_out_gaa(Ys)

The set Q consists of the following terms:

   mergesort_in_gaa(x0)
   split_in_gaaa(x0)
   U5_gaaa(x0, x1)
   U1_gaa(x0)
   U2_gaa(x0, x1)
   U3_gaa(x0, x1)
   merge_in_ggaa(x0, x1)
   le_in_gg(x0, x1)
   U11_gg(x0)
   U6_ggaa(x0, x1, x2, x3, x4)
   gt_in_gg(x0, x1)
   U10_gg(x0)
   U8_ggaa(x0, x1, x2, x3, x4)
   U9_ggaa(x0, x1)
   U7_ggaa(x0, x1)
   U4_gaa(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(44) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule MERGESORT_IN_GAA(.(X, .(Y, Xs))) -> U1_GAA(split_in_gaaa(.(X, .(Y, Xs)))) at position [0] we obtained the following new rules [LPAR04]:

   (MERGESORT_IN_GAA(.(X, .(Y, Xs))) -> U1_GAA(U5_gaaa(X, split_in_gaaa(.(Y, Xs)))),MERGESORT_IN_GAA(.(X, .(Y, Xs))) -> U1_GAA(U5_gaaa(X, split_in_gaaa(.(Y, Xs)))))


----------------------------------------

(45)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_GAA(split_out_gaaa(X1s, X2s)) -> U2_GAA(X2s, mergesort_in_gaa(X1s))
   U2_GAA(X2s, mergesort_out_gaa(Y1s)) -> MERGESORT_IN_GAA(X2s)
   U1_GAA(split_out_gaaa(X1s, X2s)) -> MERGESORT_IN_GAA(X1s)
   MERGESORT_IN_GAA(.(X, .(Y, Xs))) -> U1_GAA(U5_gaaa(X, split_in_gaaa(.(Y, Xs))))

The TRS R consists of the following rules:

   mergesort_in_gaa([]) -> mergesort_out_gaa([])
   mergesort_in_gaa(.(X, [])) -> mergesort_out_gaa(.(X, []))
   mergesort_in_gaa(.(X, .(Y, Xs))) -> U1_gaa(split_in_gaaa(.(X, .(Y, Xs))))
   split_in_gaaa([]) -> split_out_gaaa([], [])
   split_in_gaaa(.(X, Xs)) -> U5_gaaa(X, split_in_gaaa(Xs))
   U5_gaaa(X, split_out_gaaa(Zs, Ys)) -> split_out_gaaa(.(X, Ys), Zs)
   U1_gaa(split_out_gaaa(X1s, X2s)) -> U2_gaa(X2s, mergesort_in_gaa(X1s))
   U2_gaa(X2s, mergesort_out_gaa(Y1s)) -> U3_gaa(Y1s, mergesort_in_gaa(X2s))
   U3_gaa(Y1s, mergesort_out_gaa(Y2s)) -> U4_gaa(merge_in_ggaa(Y1s, Y2s))
   merge_in_ggaa([], Xs) -> merge_out_ggaa(Xs)
   merge_in_ggaa(Xs, []) -> merge_out_ggaa(Xs)
   merge_in_ggaa(.(X, Xs), .(Y, Ys)) -> U6_ggaa(X, Xs, Y, Ys, le_in_gg(X, Y))
   le_in_gg(s(X), s(Y)) -> U11_gg(le_in_gg(X, Y))
   le_in_gg(0, s(0)) -> le_out_gg
   le_in_gg(0, 0) -> le_out_gg
   U11_gg(le_out_gg) -> le_out_gg
   U6_ggaa(X, Xs, Y, Ys, le_out_gg) -> U7_ggaa(X, merge_in_ggaa(Xs, .(Y, Ys)))
   merge_in_ggaa(.(X, Xs), .(Y, Ys)) -> U8_ggaa(X, Xs, Y, Ys, gt_in_gg(X, Y))
   gt_in_gg(s(X), s(Y)) -> U10_gg(gt_in_gg(X, Y))
   gt_in_gg(s(0), 0) -> gt_out_gg
   U10_gg(gt_out_gg) -> gt_out_gg
   U8_ggaa(X, Xs, Y, Ys, gt_out_gg) -> U9_ggaa(Y, merge_in_ggaa(.(X, Xs), Ys))
   U9_ggaa(Y, merge_out_ggaa(Zs)) -> merge_out_ggaa(.(Y, Zs))
   U7_ggaa(X, merge_out_ggaa(Zs)) -> merge_out_ggaa(.(X, Zs))
   U4_gaa(merge_out_ggaa(Ys)) -> mergesort_out_gaa(Ys)

The set Q consists of the following terms:

   mergesort_in_gaa(x0)
   split_in_gaaa(x0)
   U5_gaaa(x0, x1)
   U1_gaa(x0)
   U2_gaa(x0, x1)
   U3_gaa(x0, x1)
   merge_in_ggaa(x0, x1)
   le_in_gg(x0, x1)
   U11_gg(x0)
   U6_ggaa(x0, x1, x2, x3, x4)
   gt_in_gg(x0, x1)
   U10_gg(x0)
   U8_ggaa(x0, x1, x2, x3, x4)
   U9_ggaa(x0, x1)
   U7_ggaa(x0, x1)
   U4_gaa(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(46) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule MERGESORT_IN_GAA(.(X, .(Y, Xs))) -> U1_GAA(U5_gaaa(X, split_in_gaaa(.(Y, Xs)))) at position [0,1] we obtained the following new rules [LPAR04]:

   (MERGESORT_IN_GAA(.(X, .(Y, Xs))) -> U1_GAA(U5_gaaa(X, U5_gaaa(Y, split_in_gaaa(Xs)))),MERGESORT_IN_GAA(.(X, .(Y, Xs))) -> U1_GAA(U5_gaaa(X, U5_gaaa(Y, split_in_gaaa(Xs)))))


----------------------------------------

(47)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_GAA(split_out_gaaa(X1s, X2s)) -> U2_GAA(X2s, mergesort_in_gaa(X1s))
   U2_GAA(X2s, mergesort_out_gaa(Y1s)) -> MERGESORT_IN_GAA(X2s)
   U1_GAA(split_out_gaaa(X1s, X2s)) -> MERGESORT_IN_GAA(X1s)
   MERGESORT_IN_GAA(.(X, .(Y, Xs))) -> U1_GAA(U5_gaaa(X, U5_gaaa(Y, split_in_gaaa(Xs))))

The TRS R consists of the following rules:

   mergesort_in_gaa([]) -> mergesort_out_gaa([])
   mergesort_in_gaa(.(X, [])) -> mergesort_out_gaa(.(X, []))
   mergesort_in_gaa(.(X, .(Y, Xs))) -> U1_gaa(split_in_gaaa(.(X, .(Y, Xs))))
   split_in_gaaa([]) -> split_out_gaaa([], [])
   split_in_gaaa(.(X, Xs)) -> U5_gaaa(X, split_in_gaaa(Xs))
   U5_gaaa(X, split_out_gaaa(Zs, Ys)) -> split_out_gaaa(.(X, Ys), Zs)
   U1_gaa(split_out_gaaa(X1s, X2s)) -> U2_gaa(X2s, mergesort_in_gaa(X1s))
   U2_gaa(X2s, mergesort_out_gaa(Y1s)) -> U3_gaa(Y1s, mergesort_in_gaa(X2s))
   U3_gaa(Y1s, mergesort_out_gaa(Y2s)) -> U4_gaa(merge_in_ggaa(Y1s, Y2s))
   merge_in_ggaa([], Xs) -> merge_out_ggaa(Xs)
   merge_in_ggaa(Xs, []) -> merge_out_ggaa(Xs)
   merge_in_ggaa(.(X, Xs), .(Y, Ys)) -> U6_ggaa(X, Xs, Y, Ys, le_in_gg(X, Y))
   le_in_gg(s(X), s(Y)) -> U11_gg(le_in_gg(X, Y))
   le_in_gg(0, s(0)) -> le_out_gg
   le_in_gg(0, 0) -> le_out_gg
   U11_gg(le_out_gg) -> le_out_gg
   U6_ggaa(X, Xs, Y, Ys, le_out_gg) -> U7_ggaa(X, merge_in_ggaa(Xs, .(Y, Ys)))
   merge_in_ggaa(.(X, Xs), .(Y, Ys)) -> U8_ggaa(X, Xs, Y, Ys, gt_in_gg(X, Y))
   gt_in_gg(s(X), s(Y)) -> U10_gg(gt_in_gg(X, Y))
   gt_in_gg(s(0), 0) -> gt_out_gg
   U10_gg(gt_out_gg) -> gt_out_gg
   U8_ggaa(X, Xs, Y, Ys, gt_out_gg) -> U9_ggaa(Y, merge_in_ggaa(.(X, Xs), Ys))
   U9_ggaa(Y, merge_out_ggaa(Zs)) -> merge_out_ggaa(.(Y, Zs))
   U7_ggaa(X, merge_out_ggaa(Zs)) -> merge_out_ggaa(.(X, Zs))
   U4_gaa(merge_out_ggaa(Ys)) -> mergesort_out_gaa(Ys)

The set Q consists of the following terms:

   mergesort_in_gaa(x0)
   split_in_gaaa(x0)
   U5_gaaa(x0, x1)
   U1_gaa(x0)
   U2_gaa(x0, x1)
   U3_gaa(x0, x1)
   merge_in_ggaa(x0, x1)
   le_in_gg(x0, x1)
   U11_gg(x0)
   U6_ggaa(x0, x1, x2, x3, x4)
   gt_in_gg(x0, x1)
   U10_gg(x0)
   U8_ggaa(x0, x1, x2, x3, x4)
   U9_ggaa(x0, x1)
   U7_ggaa(x0, x1)
   U4_gaa(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(48) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.


Strictly oriented rules of the TRS R:

   mergesort_in_gaa(.(X, [])) -> mergesort_out_gaa(.(X, []))

Used ordering: Polynomial interpretation [POLO]:

   POL(.(x_1, x_2)) = 2 + 2*x_2
   POL(0) = 0
   POL(MERGESORT_IN_GAA(x_1)) = 2*x_1
   POL(U10_gg(x_1)) = 1
   POL(U11_gg(x_1)) = 0
   POL(U1_GAA(x_1)) = 2*x_1
   POL(U1_gaa(x_1)) = x_1
   POL(U2_GAA(x_1, x_2)) = 2*x_1 + x_2
   POL(U2_gaa(x_1, x_2)) = x_1 + x_2
   POL(U3_gaa(x_1, x_2)) = x_2
   POL(U4_gaa(x_1)) = 0
   POL(U5_gaaa(x_1, x_2)) = 2 + 2*x_2
   POL(U6_ggaa(x_1, x_2, x_3, x_4, x_5)) = 2*x_2
   POL(U7_ggaa(x_1, x_2)) = 0
   POL(U8_ggaa(x_1, x_2, x_3, x_4, x_5)) = 2*x_2
   POL(U9_ggaa(x_1, x_2)) = 0
   POL([]) = 0
   POL(gt_in_gg(x_1, x_2)) = 2*x_1
   POL(gt_out_gg) = 0
   POL(le_in_gg(x_1, x_2)) = 0
   POL(le_out_gg) = 0
   POL(merge_in_ggaa(x_1, x_2)) = 2*x_1
   POL(merge_out_ggaa(x_1)) = 0
   POL(mergesort_in_gaa(x_1)) = x_1
   POL(mergesort_out_gaa(x_1)) = 0
   POL(s(x_1)) = 2
   POL(split_in_gaaa(x_1)) = x_1
   POL(split_out_gaaa(x_1, x_2)) = x_1 + x_2


----------------------------------------

(49)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_GAA(split_out_gaaa(X1s, X2s)) -> U2_GAA(X2s, mergesort_in_gaa(X1s))
   U2_GAA(X2s, mergesort_out_gaa(Y1s)) -> MERGESORT_IN_GAA(X2s)
   U1_GAA(split_out_gaaa(X1s, X2s)) -> MERGESORT_IN_GAA(X1s)
   MERGESORT_IN_GAA(.(X, .(Y, Xs))) -> U1_GAA(U5_gaaa(X, U5_gaaa(Y, split_in_gaaa(Xs))))

The TRS R consists of the following rules:

   mergesort_in_gaa([]) -> mergesort_out_gaa([])
   mergesort_in_gaa(.(X, .(Y, Xs))) -> U1_gaa(split_in_gaaa(.(X, .(Y, Xs))))
   split_in_gaaa([]) -> split_out_gaaa([], [])
   split_in_gaaa(.(X, Xs)) -> U5_gaaa(X, split_in_gaaa(Xs))
   U5_gaaa(X, split_out_gaaa(Zs, Ys)) -> split_out_gaaa(.(X, Ys), Zs)
   U1_gaa(split_out_gaaa(X1s, X2s)) -> U2_gaa(X2s, mergesort_in_gaa(X1s))
   U2_gaa(X2s, mergesort_out_gaa(Y1s)) -> U3_gaa(Y1s, mergesort_in_gaa(X2s))
   U3_gaa(Y1s, mergesort_out_gaa(Y2s)) -> U4_gaa(merge_in_ggaa(Y1s, Y2s))
   merge_in_ggaa([], Xs) -> merge_out_ggaa(Xs)
   merge_in_ggaa(Xs, []) -> merge_out_ggaa(Xs)
   merge_in_ggaa(.(X, Xs), .(Y, Ys)) -> U6_ggaa(X, Xs, Y, Ys, le_in_gg(X, Y))
   le_in_gg(s(X), s(Y)) -> U11_gg(le_in_gg(X, Y))
   le_in_gg(0, s(0)) -> le_out_gg
   le_in_gg(0, 0) -> le_out_gg
   U11_gg(le_out_gg) -> le_out_gg
   U6_ggaa(X, Xs, Y, Ys, le_out_gg) -> U7_ggaa(X, merge_in_ggaa(Xs, .(Y, Ys)))
   merge_in_ggaa(.(X, Xs), .(Y, Ys)) -> U8_ggaa(X, Xs, Y, Ys, gt_in_gg(X, Y))
   gt_in_gg(s(X), s(Y)) -> U10_gg(gt_in_gg(X, Y))
   gt_in_gg(s(0), 0) -> gt_out_gg
   U10_gg(gt_out_gg) -> gt_out_gg
   U8_ggaa(X, Xs, Y, Ys, gt_out_gg) -> U9_ggaa(Y, merge_in_ggaa(.(X, Xs), Ys))
   U9_ggaa(Y, merge_out_ggaa(Zs)) -> merge_out_ggaa(.(Y, Zs))
   U7_ggaa(X, merge_out_ggaa(Zs)) -> merge_out_ggaa(.(X, Zs))
   U4_gaa(merge_out_ggaa(Ys)) -> mergesort_out_gaa(Ys)

The set Q consists of the following terms:

   mergesort_in_gaa(x0)
   split_in_gaaa(x0)
   U5_gaaa(x0, x1)
   U1_gaa(x0)
   U2_gaa(x0, x1)
   U3_gaa(x0, x1)
   merge_in_ggaa(x0, x1)
   le_in_gg(x0, x1)
   U11_gg(x0)
   U6_ggaa(x0, x1, x2, x3, x4)
   gt_in_gg(x0, x1)
   U10_gg(x0)
   U8_ggaa(x0, x1, x2, x3, x4)
   U9_ggaa(x0, x1)
   U7_ggaa(x0, x1)
   U4_gaa(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(50) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   U2_GAA(X2s, mergesort_out_gaa(Y1s)) -> MERGESORT_IN_GAA(X2s)
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( U2_GAA_2(x_1, x_2) ) = max{0, x_2 - 1}
POL( mergesort_in_gaa_1(x_1) ) = x_1
POL( [] ) = 2
POL( mergesort_out_gaa_1(x_1) ) = 2
POL( ._2(x_1, x_2) ) = 0
POL( U1_gaa_1(x_1) ) = 2x_1
POL( split_in_gaaa_1(x_1) ) = max{0, -2}
POL( U1_GAA_1(x_1) ) = 2x_1
POL( U5_gaaa_2(x_1, x_2) ) = max{0, -2}
POL( split_out_gaaa_2(x_1, x_2) ) = x_1
POL( U2_gaa_2(x_1, x_2) ) = max{0, 2x_2 - 2}
POL( U3_gaa_2(x_1, x_2) ) = 2
POL( U4_gaa_1(x_1) ) = 2
POL( merge_in_ggaa_2(x_1, x_2) ) = max{0, -2}
POL( merge_out_ggaa_1(x_1) ) = max{0, -2}
POL( U6_ggaa_5(x_1, ..., x_5) ) = 2x_2 + 2x_4 + 2
POL( le_in_gg_2(x_1, x_2) ) = 0
POL( U8_ggaa_5(x_1, ..., x_5) ) = x_1 + x_2 + 2x_3 + 2x_4 + 2
POL( gt_in_gg_2(x_1, x_2) ) = 0
POL( s_1(x_1) ) = 0
POL( U11_gg_1(x_1) ) = max{0, -2}
POL( 0 ) = 0
POL( le_out_gg ) = 2
POL( U7_ggaa_2(x_1, x_2) ) = max{0, 2x_1 - 2}
POL( U10_gg_1(x_1) ) = max{0, -2}
POL( gt_out_gg ) = 0
POL( U9_ggaa_2(x_1, x_2) ) = max{0, 2x_1 - 2}
POL( MERGESORT_IN_GAA_1(x_1) ) = 0

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   mergesort_in_gaa([]) -> mergesort_out_gaa([])
   mergesort_in_gaa(.(X, .(Y, Xs))) -> U1_gaa(split_in_gaaa(.(X, .(Y, Xs))))
   split_in_gaaa(.(X, Xs)) -> U5_gaaa(X, split_in_gaaa(Xs))
   U5_gaaa(X, split_out_gaaa(Zs, Ys)) -> split_out_gaaa(.(X, Ys), Zs)
   U1_gaa(split_out_gaaa(X1s, X2s)) -> U2_gaa(X2s, mergesort_in_gaa(X1s))
   U2_gaa(X2s, mergesort_out_gaa(Y1s)) -> U3_gaa(Y1s, mergesort_in_gaa(X2s))
   U3_gaa(Y1s, mergesort_out_gaa(Y2s)) -> U4_gaa(merge_in_ggaa(Y1s, Y2s))
   U4_gaa(merge_out_ggaa(Ys)) -> mergesort_out_gaa(Ys)


----------------------------------------

(51)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_GAA(split_out_gaaa(X1s, X2s)) -> U2_GAA(X2s, mergesort_in_gaa(X1s))
   U1_GAA(split_out_gaaa(X1s, X2s)) -> MERGESORT_IN_GAA(X1s)
   MERGESORT_IN_GAA(.(X, .(Y, Xs))) -> U1_GAA(U5_gaaa(X, U5_gaaa(Y, split_in_gaaa(Xs))))

The TRS R consists of the following rules:

   mergesort_in_gaa([]) -> mergesort_out_gaa([])
   mergesort_in_gaa(.(X, .(Y, Xs))) -> U1_gaa(split_in_gaaa(.(X, .(Y, Xs))))
   split_in_gaaa([]) -> split_out_gaaa([], [])
   split_in_gaaa(.(X, Xs)) -> U5_gaaa(X, split_in_gaaa(Xs))
   U5_gaaa(X, split_out_gaaa(Zs, Ys)) -> split_out_gaaa(.(X, Ys), Zs)
   U1_gaa(split_out_gaaa(X1s, X2s)) -> U2_gaa(X2s, mergesort_in_gaa(X1s))
   U2_gaa(X2s, mergesort_out_gaa(Y1s)) -> U3_gaa(Y1s, mergesort_in_gaa(X2s))
   U3_gaa(Y1s, mergesort_out_gaa(Y2s)) -> U4_gaa(merge_in_ggaa(Y1s, Y2s))
   merge_in_ggaa([], Xs) -> merge_out_ggaa(Xs)
   merge_in_ggaa(Xs, []) -> merge_out_ggaa(Xs)
   merge_in_ggaa(.(X, Xs), .(Y, Ys)) -> U6_ggaa(X, Xs, Y, Ys, le_in_gg(X, Y))
   le_in_gg(s(X), s(Y)) -> U11_gg(le_in_gg(X, Y))
   le_in_gg(0, s(0)) -> le_out_gg
   le_in_gg(0, 0) -> le_out_gg
   U11_gg(le_out_gg) -> le_out_gg
   U6_ggaa(X, Xs, Y, Ys, le_out_gg) -> U7_ggaa(X, merge_in_ggaa(Xs, .(Y, Ys)))
   merge_in_ggaa(.(X, Xs), .(Y, Ys)) -> U8_ggaa(X, Xs, Y, Ys, gt_in_gg(X, Y))
   gt_in_gg(s(X), s(Y)) -> U10_gg(gt_in_gg(X, Y))
   gt_in_gg(s(0), 0) -> gt_out_gg
   U10_gg(gt_out_gg) -> gt_out_gg
   U8_ggaa(X, Xs, Y, Ys, gt_out_gg) -> U9_ggaa(Y, merge_in_ggaa(.(X, Xs), Ys))
   U9_ggaa(Y, merge_out_ggaa(Zs)) -> merge_out_ggaa(.(Y, Zs))
   U7_ggaa(X, merge_out_ggaa(Zs)) -> merge_out_ggaa(.(X, Zs))
   U4_gaa(merge_out_ggaa(Ys)) -> mergesort_out_gaa(Ys)

The set Q consists of the following terms:

   mergesort_in_gaa(x0)
   split_in_gaaa(x0)
   U5_gaaa(x0, x1)
   U1_gaa(x0)
   U2_gaa(x0, x1)
   U3_gaa(x0, x1)
   merge_in_ggaa(x0, x1)
   le_in_gg(x0, x1)
   U11_gg(x0)
   U6_ggaa(x0, x1, x2, x3, x4)
   gt_in_gg(x0, x1)
   U10_gg(x0)
   U8_ggaa(x0, x1, x2, x3, x4)
   U9_ggaa(x0, x1)
   U7_ggaa(x0, x1)
   U4_gaa(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(52) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(53)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_GAA(split_out_gaaa(X1s, X2s)) -> MERGESORT_IN_GAA(X1s)
   MERGESORT_IN_GAA(.(X, .(Y, Xs))) -> U1_GAA(U5_gaaa(X, U5_gaaa(Y, split_in_gaaa(Xs))))

The TRS R consists of the following rules:

   mergesort_in_gaa([]) -> mergesort_out_gaa([])
   mergesort_in_gaa(.(X, .(Y, Xs))) -> U1_gaa(split_in_gaaa(.(X, .(Y, Xs))))
   split_in_gaaa([]) -> split_out_gaaa([], [])
   split_in_gaaa(.(X, Xs)) -> U5_gaaa(X, split_in_gaaa(Xs))
   U5_gaaa(X, split_out_gaaa(Zs, Ys)) -> split_out_gaaa(.(X, Ys), Zs)
   U1_gaa(split_out_gaaa(X1s, X2s)) -> U2_gaa(X2s, mergesort_in_gaa(X1s))
   U2_gaa(X2s, mergesort_out_gaa(Y1s)) -> U3_gaa(Y1s, mergesort_in_gaa(X2s))
   U3_gaa(Y1s, mergesort_out_gaa(Y2s)) -> U4_gaa(merge_in_ggaa(Y1s, Y2s))
   merge_in_ggaa([], Xs) -> merge_out_ggaa(Xs)
   merge_in_ggaa(Xs, []) -> merge_out_ggaa(Xs)
   merge_in_ggaa(.(X, Xs), .(Y, Ys)) -> U6_ggaa(X, Xs, Y, Ys, le_in_gg(X, Y))
   le_in_gg(s(X), s(Y)) -> U11_gg(le_in_gg(X, Y))
   le_in_gg(0, s(0)) -> le_out_gg
   le_in_gg(0, 0) -> le_out_gg
   U11_gg(le_out_gg) -> le_out_gg
   U6_ggaa(X, Xs, Y, Ys, le_out_gg) -> U7_ggaa(X, merge_in_ggaa(Xs, .(Y, Ys)))
   merge_in_ggaa(.(X, Xs), .(Y, Ys)) -> U8_ggaa(X, Xs, Y, Ys, gt_in_gg(X, Y))
   gt_in_gg(s(X), s(Y)) -> U10_gg(gt_in_gg(X, Y))
   gt_in_gg(s(0), 0) -> gt_out_gg
   U10_gg(gt_out_gg) -> gt_out_gg
   U8_ggaa(X, Xs, Y, Ys, gt_out_gg) -> U9_ggaa(Y, merge_in_ggaa(.(X, Xs), Ys))
   U9_ggaa(Y, merge_out_ggaa(Zs)) -> merge_out_ggaa(.(Y, Zs))
   U7_ggaa(X, merge_out_ggaa(Zs)) -> merge_out_ggaa(.(X, Zs))
   U4_gaa(merge_out_ggaa(Ys)) -> mergesort_out_gaa(Ys)

The set Q consists of the following terms:

   mergesort_in_gaa(x0)
   split_in_gaaa(x0)
   U5_gaaa(x0, x1)
   U1_gaa(x0)
   U2_gaa(x0, x1)
   U3_gaa(x0, x1)
   merge_in_ggaa(x0, x1)
   le_in_gg(x0, x1)
   U11_gg(x0)
   U6_ggaa(x0, x1, x2, x3, x4)
   gt_in_gg(x0, x1)
   U10_gg(x0)
   U8_ggaa(x0, x1, x2, x3, x4)
   U9_ggaa(x0, x1)
   U7_ggaa(x0, x1)
   U4_gaa(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(54) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(55)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_GAA(split_out_gaaa(X1s, X2s)) -> MERGESORT_IN_GAA(X1s)
   MERGESORT_IN_GAA(.(X, .(Y, Xs))) -> U1_GAA(U5_gaaa(X, U5_gaaa(Y, split_in_gaaa(Xs))))

The TRS R consists of the following rules:

   split_in_gaaa([]) -> split_out_gaaa([], [])
   split_in_gaaa(.(X, Xs)) -> U5_gaaa(X, split_in_gaaa(Xs))
   U5_gaaa(X, split_out_gaaa(Zs, Ys)) -> split_out_gaaa(.(X, Ys), Zs)

The set Q consists of the following terms:

   mergesort_in_gaa(x0)
   split_in_gaaa(x0)
   U5_gaaa(x0, x1)
   U1_gaa(x0)
   U2_gaa(x0, x1)
   U3_gaa(x0, x1)
   merge_in_ggaa(x0, x1)
   le_in_gg(x0, x1)
   U11_gg(x0)
   U6_ggaa(x0, x1, x2, x3, x4)
   gt_in_gg(x0, x1)
   U10_gg(x0)
   U8_ggaa(x0, x1, x2, x3, x4)
   U9_ggaa(x0, x1)
   U7_ggaa(x0, x1)
   U4_gaa(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(56) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   mergesort_in_gaa(x0)
   U1_gaa(x0)
   U2_gaa(x0, x1)
   U3_gaa(x0, x1)
   merge_in_ggaa(x0, x1)
   le_in_gg(x0, x1)
   U11_gg(x0)
   U6_ggaa(x0, x1, x2, x3, x4)
   gt_in_gg(x0, x1)
   U10_gg(x0)
   U8_ggaa(x0, x1, x2, x3, x4)
   U9_ggaa(x0, x1)
   U7_ggaa(x0, x1)
   U4_gaa(x0)


----------------------------------------

(57)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_GAA(split_out_gaaa(X1s, X2s)) -> MERGESORT_IN_GAA(X1s)
   MERGESORT_IN_GAA(.(X, .(Y, Xs))) -> U1_GAA(U5_gaaa(X, U5_gaaa(Y, split_in_gaaa(Xs))))

The TRS R consists of the following rules:

   split_in_gaaa([]) -> split_out_gaaa([], [])
   split_in_gaaa(.(X, Xs)) -> U5_gaaa(X, split_in_gaaa(Xs))
   U5_gaaa(X, split_out_gaaa(Zs, Ys)) -> split_out_gaaa(.(X, Ys), Zs)

The set Q consists of the following terms:

   split_in_gaaa(x0)
   U5_gaaa(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(58) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MERGESORT_IN_GAA(.(X, .(Y, Xs))) -> U1_GAA(U5_gaaa(X, U5_gaaa(Y, split_in_gaaa(Xs))))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(U1_GAA(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(split_out_gaaa(x_1, x_2)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[1A]] 	* 	x_2
>>>

   <<<
 POL(MERGESORT_IN_GAA(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(.(x_1, x_2)) =  	[[-I]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[2A]] 	* 	x_2
>>>

   <<<
 POL(U5_gaaa(x_1, x_2)) =  	[[-I]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[1A]] 	* 	x_2
>>>

   <<<
 POL(split_in_gaaa(x_1)) =  	[[-I]] 	 +  	[[1A]] 	* 	x_1
>>>

   <<<
 POL([]) =  	[[0A]]
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   split_in_gaaa([]) -> split_out_gaaa([], [])
   split_in_gaaa(.(X, Xs)) -> U5_gaaa(X, split_in_gaaa(Xs))
   U5_gaaa(X, split_out_gaaa(Zs, Ys)) -> split_out_gaaa(.(X, Ys), Zs)


----------------------------------------

(59)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_GAA(split_out_gaaa(X1s, X2s)) -> MERGESORT_IN_GAA(X1s)

The TRS R consists of the following rules:

   split_in_gaaa([]) -> split_out_gaaa([], [])
   split_in_gaaa(.(X, Xs)) -> U5_gaaa(X, split_in_gaaa(Xs))
   U5_gaaa(X, split_out_gaaa(Zs, Ys)) -> split_out_gaaa(.(X, Ys), Zs)

The set Q consists of the following terms:

   split_in_gaaa(x0)
   U5_gaaa(x0, x1)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(60) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 1 less node.
----------------------------------------

(61)
TRUE
