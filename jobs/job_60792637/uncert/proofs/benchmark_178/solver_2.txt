YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/enWAl.pl
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Left Termination of the query pattern

while(g)

w.r.t. the given Prolog program could successfully be proven:

(0) Prolog
(1) PrologToPiTRSProof [SOUND, 0 ms]
(2) PiTRS
(3) DependencyPairsProof [EQUIVALENT, 0 ms]
(4) PiDP
(5) DependencyGraphProof [EQUIVALENT, 0 ms]
(6) AND
    (7) PiDP
        (8) UsableRulesProof [EQUIVALENT, 0 ms]
        (9) PiDP
        (10) PiDPToQDPProof [SOUND, 3 ms]
        (11) QDP
        (12) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (13) YES
    (14) PiDP
        (15) UsableRulesProof [EQUIVALENT, 0 ms]
        (16) PiDP
        (17) PiDPToQDPProof [EQUIVALENT, 0 ms]
        (18) QDP
        (19) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (20) YES
    (21) PiDP
        (22) UsableRulesProof [EQUIVALENT, 0 ms]
        (23) PiDP
        (24) PiDPToQDPProof [EQUIVALENT, 0 ms]
        (25) QDP
        (26) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (27) YES
    (28) PiDP
        (29) UsableRulesProof [EQUIVALENT, 0 ms]
        (30) PiDP
        (31) PiDPToQDPProof [SOUND, 0 ms]
        (32) QDP
        (33) TransformationProof [EQUIVALENT, 0 ms]
        (34) QDP
        (35) UsableRulesProof [EQUIVALENT, 0 ms]
        (36) QDP
        (37) QReductionProof [EQUIVALENT, 0 ms]
        (38) QDP
        (39) TransformationProof [EQUIVALENT, 0 ms]
        (40) QDP
        (41) UsableRulesProof [EQUIVALENT, 0 ms]
        (42) QDP
        (43) QReductionProof [EQUIVALENT, 0 ms]
        (44) QDP
        (45) TransformationProof [EQUIVALENT, 0 ms]
        (46) QDP
        (47) TransformationProof [EQUIVALENT, 0 ms]
        (48) QDP
        (49) TransformationProof [SOUND, 0 ms]
        (50) QDP
        (51) TransformationProof [EQUIVALENT, 0 ms]
        (52) QDP
        (53) TransformationProof [EQUIVALENT, 0 ms]
        (54) QDP
        (55) SemLabProof [SOUND, 127 ms]
        (56) QDP
        (57) QDPOrderProof [EQUIVALENT, 5 ms]
        (58) QDP
        (59) DependencyGraphProof [EQUIVALENT, 0 ms]
        (60) QDP
        (61) QDPOrderProof [EQUIVALENT, 2 ms]
        (62) QDP
        (63) DependencyGraphProof [EQUIVALENT, 0 ms]
        (64) TRUE


----------------------------------------

(0)
Obligation:
Clauses:

while(s(s(s(s(s(X)))))) :- ','(gt(s(s(s(s(s(X))))), 0), ','(f(s(s(s(s(s(X))))), Y), while(Y))).
f(X, Y) :- ','(mod2(X, 0), if(true, X, Y)).
if(true, X, Z) :- plus(X, s(0), Z).
if(false, X, Z) :- plus(X, s(s(s(0))), Z).
plus(0, X, X).
plus(s(X), Y, Z) :- plus(X, s(Y), Z).
mod2(0, 0).
mod2(s(0), s(0)).
mod2(s(s(X)), Y) :- mod2(X, Y).
gt(s(X1), 0).
gt(s(X), s(Y)) :- gt(X, Y).


Query: while(g)
----------------------------------------

(1) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

while_in_1: (b)

gt_in_2: (b,b)

f_in_2: (b,f)

mod2_in_2: (b,b)

if_in_3: (b,b,f)

plus_in_3: (b,b,f)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   while_in_g(s(s(s(s(s(X)))))) -> U1_g(X, gt_in_gg(s(s(s(s(s(X))))), 0))
   gt_in_gg(s(X1), 0) -> gt_out_gg(s(X1), 0)
   gt_in_gg(s(X), s(Y)) -> U10_gg(X, Y, gt_in_gg(X, Y))
   U10_gg(X, Y, gt_out_gg(X, Y)) -> gt_out_gg(s(X), s(Y))
   U1_g(X, gt_out_gg(s(s(s(s(s(X))))), 0)) -> U2_g(X, f_in_ga(s(s(s(s(s(X))))), Y))
   f_in_ga(X, Y) -> U4_ga(X, Y, mod2_in_gg(X, 0))
   mod2_in_gg(0, 0) -> mod2_out_gg(0, 0)
   mod2_in_gg(s(0), s(0)) -> mod2_out_gg(s(0), s(0))
   mod2_in_gg(s(s(X)), Y) -> U9_gg(X, Y, mod2_in_gg(X, Y))
   U9_gg(X, Y, mod2_out_gg(X, Y)) -> mod2_out_gg(s(s(X)), Y)
   U4_ga(X, Y, mod2_out_gg(X, 0)) -> U5_ga(X, Y, if_in_gga(true, X, Y))
   if_in_gga(true, X, Z) -> U6_gga(X, Z, plus_in_gga(X, s(0), Z))
   plus_in_gga(0, X, X) -> plus_out_gga(0, X, X)
   plus_in_gga(s(X), Y, Z) -> U8_gga(X, Y, Z, plus_in_gga(X, s(Y), Z))
   U8_gga(X, Y, Z, plus_out_gga(X, s(Y), Z)) -> plus_out_gga(s(X), Y, Z)
   U6_gga(X, Z, plus_out_gga(X, s(0), Z)) -> if_out_gga(true, X, Z)
   if_in_gga(false, X, Z) -> U7_gga(X, Z, plus_in_gga(X, s(s(s(0))), Z))
   U7_gga(X, Z, plus_out_gga(X, s(s(s(0))), Z)) -> if_out_gga(false, X, Z)
   U5_ga(X, Y, if_out_gga(true, X, Y)) -> f_out_ga(X, Y)
   U2_g(X, f_out_ga(s(s(s(s(s(X))))), Y)) -> U3_g(X, while_in_g(Y))
   U3_g(X, while_out_g(Y)) -> while_out_g(s(s(s(s(s(X))))))

The argument filtering Pi contains the following mapping:
while_in_g(x1)  =  while_in_g(x1)

s(x1)  =  s(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

gt_in_gg(x1, x2)  =  gt_in_gg(x1, x2)

0  =  0

gt_out_gg(x1, x2)  =  gt_out_gg

U10_gg(x1, x2, x3)  =  U10_gg(x3)

U2_g(x1, x2)  =  U2_g(x2)

f_in_ga(x1, x2)  =  f_in_ga(x1)

U4_ga(x1, x2, x3)  =  U4_ga(x1, x3)

mod2_in_gg(x1, x2)  =  mod2_in_gg(x1, x2)

mod2_out_gg(x1, x2)  =  mod2_out_gg

U9_gg(x1, x2, x3)  =  U9_gg(x3)

U5_ga(x1, x2, x3)  =  U5_ga(x3)

if_in_gga(x1, x2, x3)  =  if_in_gga(x1, x2)

true  =  true

U6_gga(x1, x2, x3)  =  U6_gga(x3)

plus_in_gga(x1, x2, x3)  =  plus_in_gga(x1, x2)

plus_out_gga(x1, x2, x3)  =  plus_out_gga(x3)

U8_gga(x1, x2, x3, x4)  =  U8_gga(x4)

if_out_gga(x1, x2, x3)  =  if_out_gga(x3)

false  =  false

U7_gga(x1, x2, x3)  =  U7_gga(x3)

f_out_ga(x1, x2)  =  f_out_ga(x2)

U3_g(x1, x2)  =  U3_g(x2)

while_out_g(x1)  =  while_out_g





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(2)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   while_in_g(s(s(s(s(s(X)))))) -> U1_g(X, gt_in_gg(s(s(s(s(s(X))))), 0))
   gt_in_gg(s(X1), 0) -> gt_out_gg(s(X1), 0)
   gt_in_gg(s(X), s(Y)) -> U10_gg(X, Y, gt_in_gg(X, Y))
   U10_gg(X, Y, gt_out_gg(X, Y)) -> gt_out_gg(s(X), s(Y))
   U1_g(X, gt_out_gg(s(s(s(s(s(X))))), 0)) -> U2_g(X, f_in_ga(s(s(s(s(s(X))))), Y))
   f_in_ga(X, Y) -> U4_ga(X, Y, mod2_in_gg(X, 0))
   mod2_in_gg(0, 0) -> mod2_out_gg(0, 0)
   mod2_in_gg(s(0), s(0)) -> mod2_out_gg(s(0), s(0))
   mod2_in_gg(s(s(X)), Y) -> U9_gg(X, Y, mod2_in_gg(X, Y))
   U9_gg(X, Y, mod2_out_gg(X, Y)) -> mod2_out_gg(s(s(X)), Y)
   U4_ga(X, Y, mod2_out_gg(X, 0)) -> U5_ga(X, Y, if_in_gga(true, X, Y))
   if_in_gga(true, X, Z) -> U6_gga(X, Z, plus_in_gga(X, s(0), Z))
   plus_in_gga(0, X, X) -> plus_out_gga(0, X, X)
   plus_in_gga(s(X), Y, Z) -> U8_gga(X, Y, Z, plus_in_gga(X, s(Y), Z))
   U8_gga(X, Y, Z, plus_out_gga(X, s(Y), Z)) -> plus_out_gga(s(X), Y, Z)
   U6_gga(X, Z, plus_out_gga(X, s(0), Z)) -> if_out_gga(true, X, Z)
   if_in_gga(false, X, Z) -> U7_gga(X, Z, plus_in_gga(X, s(s(s(0))), Z))
   U7_gga(X, Z, plus_out_gga(X, s(s(s(0))), Z)) -> if_out_gga(false, X, Z)
   U5_ga(X, Y, if_out_gga(true, X, Y)) -> f_out_ga(X, Y)
   U2_g(X, f_out_ga(s(s(s(s(s(X))))), Y)) -> U3_g(X, while_in_g(Y))
   U3_g(X, while_out_g(Y)) -> while_out_g(s(s(s(s(s(X))))))

The argument filtering Pi contains the following mapping:
while_in_g(x1)  =  while_in_g(x1)

s(x1)  =  s(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

gt_in_gg(x1, x2)  =  gt_in_gg(x1, x2)

0  =  0

gt_out_gg(x1, x2)  =  gt_out_gg

U10_gg(x1, x2, x3)  =  U10_gg(x3)

U2_g(x1, x2)  =  U2_g(x2)

f_in_ga(x1, x2)  =  f_in_ga(x1)

U4_ga(x1, x2, x3)  =  U4_ga(x1, x3)

mod2_in_gg(x1, x2)  =  mod2_in_gg(x1, x2)

mod2_out_gg(x1, x2)  =  mod2_out_gg

U9_gg(x1, x2, x3)  =  U9_gg(x3)

U5_ga(x1, x2, x3)  =  U5_ga(x3)

if_in_gga(x1, x2, x3)  =  if_in_gga(x1, x2)

true  =  true

U6_gga(x1, x2, x3)  =  U6_gga(x3)

plus_in_gga(x1, x2, x3)  =  plus_in_gga(x1, x2)

plus_out_gga(x1, x2, x3)  =  plus_out_gga(x3)

U8_gga(x1, x2, x3, x4)  =  U8_gga(x4)

if_out_gga(x1, x2, x3)  =  if_out_gga(x3)

false  =  false

U7_gga(x1, x2, x3)  =  U7_gga(x3)

f_out_ga(x1, x2)  =  f_out_ga(x2)

U3_g(x1, x2)  =  U3_g(x2)

while_out_g(x1)  =  while_out_g



----------------------------------------

(3) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   WHILE_IN_G(s(s(s(s(s(X)))))) -> U1_G(X, gt_in_gg(s(s(s(s(s(X))))), 0))
   WHILE_IN_G(s(s(s(s(s(X)))))) -> GT_IN_GG(s(s(s(s(s(X))))), 0)
   GT_IN_GG(s(X), s(Y)) -> U10_GG(X, Y, gt_in_gg(X, Y))
   GT_IN_GG(s(X), s(Y)) -> GT_IN_GG(X, Y)
   U1_G(X, gt_out_gg(s(s(s(s(s(X))))), 0)) -> U2_G(X, f_in_ga(s(s(s(s(s(X))))), Y))
   U1_G(X, gt_out_gg(s(s(s(s(s(X))))), 0)) -> F_IN_GA(s(s(s(s(s(X))))), Y)
   F_IN_GA(X, Y) -> U4_GA(X, Y, mod2_in_gg(X, 0))
   F_IN_GA(X, Y) -> MOD2_IN_GG(X, 0)
   MOD2_IN_GG(s(s(X)), Y) -> U9_GG(X, Y, mod2_in_gg(X, Y))
   MOD2_IN_GG(s(s(X)), Y) -> MOD2_IN_GG(X, Y)
   U4_GA(X, Y, mod2_out_gg(X, 0)) -> U5_GA(X, Y, if_in_gga(true, X, Y))
   U4_GA(X, Y, mod2_out_gg(X, 0)) -> IF_IN_GGA(true, X, Y)
   IF_IN_GGA(true, X, Z) -> U6_GGA(X, Z, plus_in_gga(X, s(0), Z))
   IF_IN_GGA(true, X, Z) -> PLUS_IN_GGA(X, s(0), Z)
   PLUS_IN_GGA(s(X), Y, Z) -> U8_GGA(X, Y, Z, plus_in_gga(X, s(Y), Z))
   PLUS_IN_GGA(s(X), Y, Z) -> PLUS_IN_GGA(X, s(Y), Z)
   IF_IN_GGA(false, X, Z) -> U7_GGA(X, Z, plus_in_gga(X, s(s(s(0))), Z))
   IF_IN_GGA(false, X, Z) -> PLUS_IN_GGA(X, s(s(s(0))), Z)
   U2_G(X, f_out_ga(s(s(s(s(s(X))))), Y)) -> U3_G(X, while_in_g(Y))
   U2_G(X, f_out_ga(s(s(s(s(s(X))))), Y)) -> WHILE_IN_G(Y)

The TRS R consists of the following rules:

   while_in_g(s(s(s(s(s(X)))))) -> U1_g(X, gt_in_gg(s(s(s(s(s(X))))), 0))
   gt_in_gg(s(X1), 0) -> gt_out_gg(s(X1), 0)
   gt_in_gg(s(X), s(Y)) -> U10_gg(X, Y, gt_in_gg(X, Y))
   U10_gg(X, Y, gt_out_gg(X, Y)) -> gt_out_gg(s(X), s(Y))
   U1_g(X, gt_out_gg(s(s(s(s(s(X))))), 0)) -> U2_g(X, f_in_ga(s(s(s(s(s(X))))), Y))
   f_in_ga(X, Y) -> U4_ga(X, Y, mod2_in_gg(X, 0))
   mod2_in_gg(0, 0) -> mod2_out_gg(0, 0)
   mod2_in_gg(s(0), s(0)) -> mod2_out_gg(s(0), s(0))
   mod2_in_gg(s(s(X)), Y) -> U9_gg(X, Y, mod2_in_gg(X, Y))
   U9_gg(X, Y, mod2_out_gg(X, Y)) -> mod2_out_gg(s(s(X)), Y)
   U4_ga(X, Y, mod2_out_gg(X, 0)) -> U5_ga(X, Y, if_in_gga(true, X, Y))
   if_in_gga(true, X, Z) -> U6_gga(X, Z, plus_in_gga(X, s(0), Z))
   plus_in_gga(0, X, X) -> plus_out_gga(0, X, X)
   plus_in_gga(s(X), Y, Z) -> U8_gga(X, Y, Z, plus_in_gga(X, s(Y), Z))
   U8_gga(X, Y, Z, plus_out_gga(X, s(Y), Z)) -> plus_out_gga(s(X), Y, Z)
   U6_gga(X, Z, plus_out_gga(X, s(0), Z)) -> if_out_gga(true, X, Z)
   if_in_gga(false, X, Z) -> U7_gga(X, Z, plus_in_gga(X, s(s(s(0))), Z))
   U7_gga(X, Z, plus_out_gga(X, s(s(s(0))), Z)) -> if_out_gga(false, X, Z)
   U5_ga(X, Y, if_out_gga(true, X, Y)) -> f_out_ga(X, Y)
   U2_g(X, f_out_ga(s(s(s(s(s(X))))), Y)) -> U3_g(X, while_in_g(Y))
   U3_g(X, while_out_g(Y)) -> while_out_g(s(s(s(s(s(X))))))

The argument filtering Pi contains the following mapping:
while_in_g(x1)  =  while_in_g(x1)

s(x1)  =  s(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

gt_in_gg(x1, x2)  =  gt_in_gg(x1, x2)

0  =  0

gt_out_gg(x1, x2)  =  gt_out_gg

U10_gg(x1, x2, x3)  =  U10_gg(x3)

U2_g(x1, x2)  =  U2_g(x2)

f_in_ga(x1, x2)  =  f_in_ga(x1)

U4_ga(x1, x2, x3)  =  U4_ga(x1, x3)

mod2_in_gg(x1, x2)  =  mod2_in_gg(x1, x2)

mod2_out_gg(x1, x2)  =  mod2_out_gg

U9_gg(x1, x2, x3)  =  U9_gg(x3)

U5_ga(x1, x2, x3)  =  U5_ga(x3)

if_in_gga(x1, x2, x3)  =  if_in_gga(x1, x2)

true  =  true

U6_gga(x1, x2, x3)  =  U6_gga(x3)

plus_in_gga(x1, x2, x3)  =  plus_in_gga(x1, x2)

plus_out_gga(x1, x2, x3)  =  plus_out_gga(x3)

U8_gga(x1, x2, x3, x4)  =  U8_gga(x4)

if_out_gga(x1, x2, x3)  =  if_out_gga(x3)

false  =  false

U7_gga(x1, x2, x3)  =  U7_gga(x3)

f_out_ga(x1, x2)  =  f_out_ga(x2)

U3_g(x1, x2)  =  U3_g(x2)

while_out_g(x1)  =  while_out_g

WHILE_IN_G(x1)  =  WHILE_IN_G(x1)

U1_G(x1, x2)  =  U1_G(x1, x2)

GT_IN_GG(x1, x2)  =  GT_IN_GG(x1, x2)

U10_GG(x1, x2, x3)  =  U10_GG(x3)

U2_G(x1, x2)  =  U2_G(x2)

F_IN_GA(x1, x2)  =  F_IN_GA(x1)

U4_GA(x1, x2, x3)  =  U4_GA(x1, x3)

MOD2_IN_GG(x1, x2)  =  MOD2_IN_GG(x1, x2)

U9_GG(x1, x2, x3)  =  U9_GG(x3)

U5_GA(x1, x2, x3)  =  U5_GA(x3)

IF_IN_GGA(x1, x2, x3)  =  IF_IN_GGA(x1, x2)

U6_GGA(x1, x2, x3)  =  U6_GGA(x3)

PLUS_IN_GGA(x1, x2, x3)  =  PLUS_IN_GGA(x1, x2)

U8_GGA(x1, x2, x3, x4)  =  U8_GGA(x4)

U7_GGA(x1, x2, x3)  =  U7_GGA(x3)

U3_G(x1, x2)  =  U3_G(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(4)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   WHILE_IN_G(s(s(s(s(s(X)))))) -> U1_G(X, gt_in_gg(s(s(s(s(s(X))))), 0))
   WHILE_IN_G(s(s(s(s(s(X)))))) -> GT_IN_GG(s(s(s(s(s(X))))), 0)
   GT_IN_GG(s(X), s(Y)) -> U10_GG(X, Y, gt_in_gg(X, Y))
   GT_IN_GG(s(X), s(Y)) -> GT_IN_GG(X, Y)
   U1_G(X, gt_out_gg(s(s(s(s(s(X))))), 0)) -> U2_G(X, f_in_ga(s(s(s(s(s(X))))), Y))
   U1_G(X, gt_out_gg(s(s(s(s(s(X))))), 0)) -> F_IN_GA(s(s(s(s(s(X))))), Y)
   F_IN_GA(X, Y) -> U4_GA(X, Y, mod2_in_gg(X, 0))
   F_IN_GA(X, Y) -> MOD2_IN_GG(X, 0)
   MOD2_IN_GG(s(s(X)), Y) -> U9_GG(X, Y, mod2_in_gg(X, Y))
   MOD2_IN_GG(s(s(X)), Y) -> MOD2_IN_GG(X, Y)
   U4_GA(X, Y, mod2_out_gg(X, 0)) -> U5_GA(X, Y, if_in_gga(true, X, Y))
   U4_GA(X, Y, mod2_out_gg(X, 0)) -> IF_IN_GGA(true, X, Y)
   IF_IN_GGA(true, X, Z) -> U6_GGA(X, Z, plus_in_gga(X, s(0), Z))
   IF_IN_GGA(true, X, Z) -> PLUS_IN_GGA(X, s(0), Z)
   PLUS_IN_GGA(s(X), Y, Z) -> U8_GGA(X, Y, Z, plus_in_gga(X, s(Y), Z))
   PLUS_IN_GGA(s(X), Y, Z) -> PLUS_IN_GGA(X, s(Y), Z)
   IF_IN_GGA(false, X, Z) -> U7_GGA(X, Z, plus_in_gga(X, s(s(s(0))), Z))
   IF_IN_GGA(false, X, Z) -> PLUS_IN_GGA(X, s(s(s(0))), Z)
   U2_G(X, f_out_ga(s(s(s(s(s(X))))), Y)) -> U3_G(X, while_in_g(Y))
   U2_G(X, f_out_ga(s(s(s(s(s(X))))), Y)) -> WHILE_IN_G(Y)

The TRS R consists of the following rules:

   while_in_g(s(s(s(s(s(X)))))) -> U1_g(X, gt_in_gg(s(s(s(s(s(X))))), 0))
   gt_in_gg(s(X1), 0) -> gt_out_gg(s(X1), 0)
   gt_in_gg(s(X), s(Y)) -> U10_gg(X, Y, gt_in_gg(X, Y))
   U10_gg(X, Y, gt_out_gg(X, Y)) -> gt_out_gg(s(X), s(Y))
   U1_g(X, gt_out_gg(s(s(s(s(s(X))))), 0)) -> U2_g(X, f_in_ga(s(s(s(s(s(X))))), Y))
   f_in_ga(X, Y) -> U4_ga(X, Y, mod2_in_gg(X, 0))
   mod2_in_gg(0, 0) -> mod2_out_gg(0, 0)
   mod2_in_gg(s(0), s(0)) -> mod2_out_gg(s(0), s(0))
   mod2_in_gg(s(s(X)), Y) -> U9_gg(X, Y, mod2_in_gg(X, Y))
   U9_gg(X, Y, mod2_out_gg(X, Y)) -> mod2_out_gg(s(s(X)), Y)
   U4_ga(X, Y, mod2_out_gg(X, 0)) -> U5_ga(X, Y, if_in_gga(true, X, Y))
   if_in_gga(true, X, Z) -> U6_gga(X, Z, plus_in_gga(X, s(0), Z))
   plus_in_gga(0, X, X) -> plus_out_gga(0, X, X)
   plus_in_gga(s(X), Y, Z) -> U8_gga(X, Y, Z, plus_in_gga(X, s(Y), Z))
   U8_gga(X, Y, Z, plus_out_gga(X, s(Y), Z)) -> plus_out_gga(s(X), Y, Z)
   U6_gga(X, Z, plus_out_gga(X, s(0), Z)) -> if_out_gga(true, X, Z)
   if_in_gga(false, X, Z) -> U7_gga(X, Z, plus_in_gga(X, s(s(s(0))), Z))
   U7_gga(X, Z, plus_out_gga(X, s(s(s(0))), Z)) -> if_out_gga(false, X, Z)
   U5_ga(X, Y, if_out_gga(true, X, Y)) -> f_out_ga(X, Y)
   U2_g(X, f_out_ga(s(s(s(s(s(X))))), Y)) -> U3_g(X, while_in_g(Y))
   U3_g(X, while_out_g(Y)) -> while_out_g(s(s(s(s(s(X))))))

The argument filtering Pi contains the following mapping:
while_in_g(x1)  =  while_in_g(x1)

s(x1)  =  s(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

gt_in_gg(x1, x2)  =  gt_in_gg(x1, x2)

0  =  0

gt_out_gg(x1, x2)  =  gt_out_gg

U10_gg(x1, x2, x3)  =  U10_gg(x3)

U2_g(x1, x2)  =  U2_g(x2)

f_in_ga(x1, x2)  =  f_in_ga(x1)

U4_ga(x1, x2, x3)  =  U4_ga(x1, x3)

mod2_in_gg(x1, x2)  =  mod2_in_gg(x1, x2)

mod2_out_gg(x1, x2)  =  mod2_out_gg

U9_gg(x1, x2, x3)  =  U9_gg(x3)

U5_ga(x1, x2, x3)  =  U5_ga(x3)

if_in_gga(x1, x2, x3)  =  if_in_gga(x1, x2)

true  =  true

U6_gga(x1, x2, x3)  =  U6_gga(x3)

plus_in_gga(x1, x2, x3)  =  plus_in_gga(x1, x2)

plus_out_gga(x1, x2, x3)  =  plus_out_gga(x3)

U8_gga(x1, x2, x3, x4)  =  U8_gga(x4)

if_out_gga(x1, x2, x3)  =  if_out_gga(x3)

false  =  false

U7_gga(x1, x2, x3)  =  U7_gga(x3)

f_out_ga(x1, x2)  =  f_out_ga(x2)

U3_g(x1, x2)  =  U3_g(x2)

while_out_g(x1)  =  while_out_g

WHILE_IN_G(x1)  =  WHILE_IN_G(x1)

U1_G(x1, x2)  =  U1_G(x1, x2)

GT_IN_GG(x1, x2)  =  GT_IN_GG(x1, x2)

U10_GG(x1, x2, x3)  =  U10_GG(x3)

U2_G(x1, x2)  =  U2_G(x2)

F_IN_GA(x1, x2)  =  F_IN_GA(x1)

U4_GA(x1, x2, x3)  =  U4_GA(x1, x3)

MOD2_IN_GG(x1, x2)  =  MOD2_IN_GG(x1, x2)

U9_GG(x1, x2, x3)  =  U9_GG(x3)

U5_GA(x1, x2, x3)  =  U5_GA(x3)

IF_IN_GGA(x1, x2, x3)  =  IF_IN_GGA(x1, x2)

U6_GGA(x1, x2, x3)  =  U6_GGA(x3)

PLUS_IN_GGA(x1, x2, x3)  =  PLUS_IN_GGA(x1, x2)

U8_GGA(x1, x2, x3, x4)  =  U8_GGA(x4)

U7_GGA(x1, x2, x3)  =  U7_GGA(x3)

U3_G(x1, x2)  =  U3_G(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(5) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 4 SCCs with 14 less nodes.
----------------------------------------

(6)
Complex Obligation (AND)

----------------------------------------

(7)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   PLUS_IN_GGA(s(X), Y, Z) -> PLUS_IN_GGA(X, s(Y), Z)

The TRS R consists of the following rules:

   while_in_g(s(s(s(s(s(X)))))) -> U1_g(X, gt_in_gg(s(s(s(s(s(X))))), 0))
   gt_in_gg(s(X1), 0) -> gt_out_gg(s(X1), 0)
   gt_in_gg(s(X), s(Y)) -> U10_gg(X, Y, gt_in_gg(X, Y))
   U10_gg(X, Y, gt_out_gg(X, Y)) -> gt_out_gg(s(X), s(Y))
   U1_g(X, gt_out_gg(s(s(s(s(s(X))))), 0)) -> U2_g(X, f_in_ga(s(s(s(s(s(X))))), Y))
   f_in_ga(X, Y) -> U4_ga(X, Y, mod2_in_gg(X, 0))
   mod2_in_gg(0, 0) -> mod2_out_gg(0, 0)
   mod2_in_gg(s(0), s(0)) -> mod2_out_gg(s(0), s(0))
   mod2_in_gg(s(s(X)), Y) -> U9_gg(X, Y, mod2_in_gg(X, Y))
   U9_gg(X, Y, mod2_out_gg(X, Y)) -> mod2_out_gg(s(s(X)), Y)
   U4_ga(X, Y, mod2_out_gg(X, 0)) -> U5_ga(X, Y, if_in_gga(true, X, Y))
   if_in_gga(true, X, Z) -> U6_gga(X, Z, plus_in_gga(X, s(0), Z))
   plus_in_gga(0, X, X) -> plus_out_gga(0, X, X)
   plus_in_gga(s(X), Y, Z) -> U8_gga(X, Y, Z, plus_in_gga(X, s(Y), Z))
   U8_gga(X, Y, Z, plus_out_gga(X, s(Y), Z)) -> plus_out_gga(s(X), Y, Z)
   U6_gga(X, Z, plus_out_gga(X, s(0), Z)) -> if_out_gga(true, X, Z)
   if_in_gga(false, X, Z) -> U7_gga(X, Z, plus_in_gga(X, s(s(s(0))), Z))
   U7_gga(X, Z, plus_out_gga(X, s(s(s(0))), Z)) -> if_out_gga(false, X, Z)
   U5_ga(X, Y, if_out_gga(true, X, Y)) -> f_out_ga(X, Y)
   U2_g(X, f_out_ga(s(s(s(s(s(X))))), Y)) -> U3_g(X, while_in_g(Y))
   U3_g(X, while_out_g(Y)) -> while_out_g(s(s(s(s(s(X))))))

The argument filtering Pi contains the following mapping:
while_in_g(x1)  =  while_in_g(x1)

s(x1)  =  s(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

gt_in_gg(x1, x2)  =  gt_in_gg(x1, x2)

0  =  0

gt_out_gg(x1, x2)  =  gt_out_gg

U10_gg(x1, x2, x3)  =  U10_gg(x3)

U2_g(x1, x2)  =  U2_g(x2)

f_in_ga(x1, x2)  =  f_in_ga(x1)

U4_ga(x1, x2, x3)  =  U4_ga(x1, x3)

mod2_in_gg(x1, x2)  =  mod2_in_gg(x1, x2)

mod2_out_gg(x1, x2)  =  mod2_out_gg

U9_gg(x1, x2, x3)  =  U9_gg(x3)

U5_ga(x1, x2, x3)  =  U5_ga(x3)

if_in_gga(x1, x2, x3)  =  if_in_gga(x1, x2)

true  =  true

U6_gga(x1, x2, x3)  =  U6_gga(x3)

plus_in_gga(x1, x2, x3)  =  plus_in_gga(x1, x2)

plus_out_gga(x1, x2, x3)  =  plus_out_gga(x3)

U8_gga(x1, x2, x3, x4)  =  U8_gga(x4)

if_out_gga(x1, x2, x3)  =  if_out_gga(x3)

false  =  false

U7_gga(x1, x2, x3)  =  U7_gga(x3)

f_out_ga(x1, x2)  =  f_out_ga(x2)

U3_g(x1, x2)  =  U3_g(x2)

while_out_g(x1)  =  while_out_g

PLUS_IN_GGA(x1, x2, x3)  =  PLUS_IN_GGA(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(8) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(9)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   PLUS_IN_GGA(s(X), Y, Z) -> PLUS_IN_GGA(X, s(Y), Z)

R is empty.
The argument filtering Pi contains the following mapping:
s(x1)  =  s(x1)

PLUS_IN_GGA(x1, x2, x3)  =  PLUS_IN_GGA(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(10) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(11)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PLUS_IN_GGA(s(X), Y) -> PLUS_IN_GGA(X, s(Y))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(12) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*PLUS_IN_GGA(s(X), Y) -> PLUS_IN_GGA(X, s(Y))
The graph contains the following edges 1 > 1


----------------------------------------

(13)
YES

----------------------------------------

(14)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MOD2_IN_GG(s(s(X)), Y) -> MOD2_IN_GG(X, Y)

The TRS R consists of the following rules:

   while_in_g(s(s(s(s(s(X)))))) -> U1_g(X, gt_in_gg(s(s(s(s(s(X))))), 0))
   gt_in_gg(s(X1), 0) -> gt_out_gg(s(X1), 0)
   gt_in_gg(s(X), s(Y)) -> U10_gg(X, Y, gt_in_gg(X, Y))
   U10_gg(X, Y, gt_out_gg(X, Y)) -> gt_out_gg(s(X), s(Y))
   U1_g(X, gt_out_gg(s(s(s(s(s(X))))), 0)) -> U2_g(X, f_in_ga(s(s(s(s(s(X))))), Y))
   f_in_ga(X, Y) -> U4_ga(X, Y, mod2_in_gg(X, 0))
   mod2_in_gg(0, 0) -> mod2_out_gg(0, 0)
   mod2_in_gg(s(0), s(0)) -> mod2_out_gg(s(0), s(0))
   mod2_in_gg(s(s(X)), Y) -> U9_gg(X, Y, mod2_in_gg(X, Y))
   U9_gg(X, Y, mod2_out_gg(X, Y)) -> mod2_out_gg(s(s(X)), Y)
   U4_ga(X, Y, mod2_out_gg(X, 0)) -> U5_ga(X, Y, if_in_gga(true, X, Y))
   if_in_gga(true, X, Z) -> U6_gga(X, Z, plus_in_gga(X, s(0), Z))
   plus_in_gga(0, X, X) -> plus_out_gga(0, X, X)
   plus_in_gga(s(X), Y, Z) -> U8_gga(X, Y, Z, plus_in_gga(X, s(Y), Z))
   U8_gga(X, Y, Z, plus_out_gga(X, s(Y), Z)) -> plus_out_gga(s(X), Y, Z)
   U6_gga(X, Z, plus_out_gga(X, s(0), Z)) -> if_out_gga(true, X, Z)
   if_in_gga(false, X, Z) -> U7_gga(X, Z, plus_in_gga(X, s(s(s(0))), Z))
   U7_gga(X, Z, plus_out_gga(X, s(s(s(0))), Z)) -> if_out_gga(false, X, Z)
   U5_ga(X, Y, if_out_gga(true, X, Y)) -> f_out_ga(X, Y)
   U2_g(X, f_out_ga(s(s(s(s(s(X))))), Y)) -> U3_g(X, while_in_g(Y))
   U3_g(X, while_out_g(Y)) -> while_out_g(s(s(s(s(s(X))))))

The argument filtering Pi contains the following mapping:
while_in_g(x1)  =  while_in_g(x1)

s(x1)  =  s(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

gt_in_gg(x1, x2)  =  gt_in_gg(x1, x2)

0  =  0

gt_out_gg(x1, x2)  =  gt_out_gg

U10_gg(x1, x2, x3)  =  U10_gg(x3)

U2_g(x1, x2)  =  U2_g(x2)

f_in_ga(x1, x2)  =  f_in_ga(x1)

U4_ga(x1, x2, x3)  =  U4_ga(x1, x3)

mod2_in_gg(x1, x2)  =  mod2_in_gg(x1, x2)

mod2_out_gg(x1, x2)  =  mod2_out_gg

U9_gg(x1, x2, x3)  =  U9_gg(x3)

U5_ga(x1, x2, x3)  =  U5_ga(x3)

if_in_gga(x1, x2, x3)  =  if_in_gga(x1, x2)

true  =  true

U6_gga(x1, x2, x3)  =  U6_gga(x3)

plus_in_gga(x1, x2, x3)  =  plus_in_gga(x1, x2)

plus_out_gga(x1, x2, x3)  =  plus_out_gga(x3)

U8_gga(x1, x2, x3, x4)  =  U8_gga(x4)

if_out_gga(x1, x2, x3)  =  if_out_gga(x3)

false  =  false

U7_gga(x1, x2, x3)  =  U7_gga(x3)

f_out_ga(x1, x2)  =  f_out_ga(x2)

U3_g(x1, x2)  =  U3_g(x2)

while_out_g(x1)  =  while_out_g

MOD2_IN_GG(x1, x2)  =  MOD2_IN_GG(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(15) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(16)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   MOD2_IN_GG(s(s(X)), Y) -> MOD2_IN_GG(X, Y)

R is empty.
Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(17) PiDPToQDPProof (EQUIVALENT)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(18)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MOD2_IN_GG(s(s(X)), Y) -> MOD2_IN_GG(X, Y)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(19) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*MOD2_IN_GG(s(s(X)), Y) -> MOD2_IN_GG(X, Y)
The graph contains the following edges 1 > 1, 2 >= 2


----------------------------------------

(20)
YES

----------------------------------------

(21)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   GT_IN_GG(s(X), s(Y)) -> GT_IN_GG(X, Y)

The TRS R consists of the following rules:

   while_in_g(s(s(s(s(s(X)))))) -> U1_g(X, gt_in_gg(s(s(s(s(s(X))))), 0))
   gt_in_gg(s(X1), 0) -> gt_out_gg(s(X1), 0)
   gt_in_gg(s(X), s(Y)) -> U10_gg(X, Y, gt_in_gg(X, Y))
   U10_gg(X, Y, gt_out_gg(X, Y)) -> gt_out_gg(s(X), s(Y))
   U1_g(X, gt_out_gg(s(s(s(s(s(X))))), 0)) -> U2_g(X, f_in_ga(s(s(s(s(s(X))))), Y))
   f_in_ga(X, Y) -> U4_ga(X, Y, mod2_in_gg(X, 0))
   mod2_in_gg(0, 0) -> mod2_out_gg(0, 0)
   mod2_in_gg(s(0), s(0)) -> mod2_out_gg(s(0), s(0))
   mod2_in_gg(s(s(X)), Y) -> U9_gg(X, Y, mod2_in_gg(X, Y))
   U9_gg(X, Y, mod2_out_gg(X, Y)) -> mod2_out_gg(s(s(X)), Y)
   U4_ga(X, Y, mod2_out_gg(X, 0)) -> U5_ga(X, Y, if_in_gga(true, X, Y))
   if_in_gga(true, X, Z) -> U6_gga(X, Z, plus_in_gga(X, s(0), Z))
   plus_in_gga(0, X, X) -> plus_out_gga(0, X, X)
   plus_in_gga(s(X), Y, Z) -> U8_gga(X, Y, Z, plus_in_gga(X, s(Y), Z))
   U8_gga(X, Y, Z, plus_out_gga(X, s(Y), Z)) -> plus_out_gga(s(X), Y, Z)
   U6_gga(X, Z, plus_out_gga(X, s(0), Z)) -> if_out_gga(true, X, Z)
   if_in_gga(false, X, Z) -> U7_gga(X, Z, plus_in_gga(X, s(s(s(0))), Z))
   U7_gga(X, Z, plus_out_gga(X, s(s(s(0))), Z)) -> if_out_gga(false, X, Z)
   U5_ga(X, Y, if_out_gga(true, X, Y)) -> f_out_ga(X, Y)
   U2_g(X, f_out_ga(s(s(s(s(s(X))))), Y)) -> U3_g(X, while_in_g(Y))
   U3_g(X, while_out_g(Y)) -> while_out_g(s(s(s(s(s(X))))))

The argument filtering Pi contains the following mapping:
while_in_g(x1)  =  while_in_g(x1)

s(x1)  =  s(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

gt_in_gg(x1, x2)  =  gt_in_gg(x1, x2)

0  =  0

gt_out_gg(x1, x2)  =  gt_out_gg

U10_gg(x1, x2, x3)  =  U10_gg(x3)

U2_g(x1, x2)  =  U2_g(x2)

f_in_ga(x1, x2)  =  f_in_ga(x1)

U4_ga(x1, x2, x3)  =  U4_ga(x1, x3)

mod2_in_gg(x1, x2)  =  mod2_in_gg(x1, x2)

mod2_out_gg(x1, x2)  =  mod2_out_gg

U9_gg(x1, x2, x3)  =  U9_gg(x3)

U5_ga(x1, x2, x3)  =  U5_ga(x3)

if_in_gga(x1, x2, x3)  =  if_in_gga(x1, x2)

true  =  true

U6_gga(x1, x2, x3)  =  U6_gga(x3)

plus_in_gga(x1, x2, x3)  =  plus_in_gga(x1, x2)

plus_out_gga(x1, x2, x3)  =  plus_out_gga(x3)

U8_gga(x1, x2, x3, x4)  =  U8_gga(x4)

if_out_gga(x1, x2, x3)  =  if_out_gga(x3)

false  =  false

U7_gga(x1, x2, x3)  =  U7_gga(x3)

f_out_ga(x1, x2)  =  f_out_ga(x2)

U3_g(x1, x2)  =  U3_g(x2)

while_out_g(x1)  =  while_out_g

GT_IN_GG(x1, x2)  =  GT_IN_GG(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(22) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(23)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   GT_IN_GG(s(X), s(Y)) -> GT_IN_GG(X, Y)

R is empty.
Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(24) PiDPToQDPProof (EQUIVALENT)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(25)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   GT_IN_GG(s(X), s(Y)) -> GT_IN_GG(X, Y)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(26) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*GT_IN_GG(s(X), s(Y)) -> GT_IN_GG(X, Y)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(27)
YES

----------------------------------------

(28)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_G(X, gt_out_gg(s(s(s(s(s(X))))), 0)) -> U2_G(X, f_in_ga(s(s(s(s(s(X))))), Y))
   U2_G(X, f_out_ga(s(s(s(s(s(X))))), Y)) -> WHILE_IN_G(Y)
   WHILE_IN_G(s(s(s(s(s(X)))))) -> U1_G(X, gt_in_gg(s(s(s(s(s(X))))), 0))

The TRS R consists of the following rules:

   while_in_g(s(s(s(s(s(X)))))) -> U1_g(X, gt_in_gg(s(s(s(s(s(X))))), 0))
   gt_in_gg(s(X1), 0) -> gt_out_gg(s(X1), 0)
   gt_in_gg(s(X), s(Y)) -> U10_gg(X, Y, gt_in_gg(X, Y))
   U10_gg(X, Y, gt_out_gg(X, Y)) -> gt_out_gg(s(X), s(Y))
   U1_g(X, gt_out_gg(s(s(s(s(s(X))))), 0)) -> U2_g(X, f_in_ga(s(s(s(s(s(X))))), Y))
   f_in_ga(X, Y) -> U4_ga(X, Y, mod2_in_gg(X, 0))
   mod2_in_gg(0, 0) -> mod2_out_gg(0, 0)
   mod2_in_gg(s(0), s(0)) -> mod2_out_gg(s(0), s(0))
   mod2_in_gg(s(s(X)), Y) -> U9_gg(X, Y, mod2_in_gg(X, Y))
   U9_gg(X, Y, mod2_out_gg(X, Y)) -> mod2_out_gg(s(s(X)), Y)
   U4_ga(X, Y, mod2_out_gg(X, 0)) -> U5_ga(X, Y, if_in_gga(true, X, Y))
   if_in_gga(true, X, Z) -> U6_gga(X, Z, plus_in_gga(X, s(0), Z))
   plus_in_gga(0, X, X) -> plus_out_gga(0, X, X)
   plus_in_gga(s(X), Y, Z) -> U8_gga(X, Y, Z, plus_in_gga(X, s(Y), Z))
   U8_gga(X, Y, Z, plus_out_gga(X, s(Y), Z)) -> plus_out_gga(s(X), Y, Z)
   U6_gga(X, Z, plus_out_gga(X, s(0), Z)) -> if_out_gga(true, X, Z)
   if_in_gga(false, X, Z) -> U7_gga(X, Z, plus_in_gga(X, s(s(s(0))), Z))
   U7_gga(X, Z, plus_out_gga(X, s(s(s(0))), Z)) -> if_out_gga(false, X, Z)
   U5_ga(X, Y, if_out_gga(true, X, Y)) -> f_out_ga(X, Y)
   U2_g(X, f_out_ga(s(s(s(s(s(X))))), Y)) -> U3_g(X, while_in_g(Y))
   U3_g(X, while_out_g(Y)) -> while_out_g(s(s(s(s(s(X))))))

The argument filtering Pi contains the following mapping:
while_in_g(x1)  =  while_in_g(x1)

s(x1)  =  s(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

gt_in_gg(x1, x2)  =  gt_in_gg(x1, x2)

0  =  0

gt_out_gg(x1, x2)  =  gt_out_gg

U10_gg(x1, x2, x3)  =  U10_gg(x3)

U2_g(x1, x2)  =  U2_g(x2)

f_in_ga(x1, x2)  =  f_in_ga(x1)

U4_ga(x1, x2, x3)  =  U4_ga(x1, x3)

mod2_in_gg(x1, x2)  =  mod2_in_gg(x1, x2)

mod2_out_gg(x1, x2)  =  mod2_out_gg

U9_gg(x1, x2, x3)  =  U9_gg(x3)

U5_ga(x1, x2, x3)  =  U5_ga(x3)

if_in_gga(x1, x2, x3)  =  if_in_gga(x1, x2)

true  =  true

U6_gga(x1, x2, x3)  =  U6_gga(x3)

plus_in_gga(x1, x2, x3)  =  plus_in_gga(x1, x2)

plus_out_gga(x1, x2, x3)  =  plus_out_gga(x3)

U8_gga(x1, x2, x3, x4)  =  U8_gga(x4)

if_out_gga(x1, x2, x3)  =  if_out_gga(x3)

false  =  false

U7_gga(x1, x2, x3)  =  U7_gga(x3)

f_out_ga(x1, x2)  =  f_out_ga(x2)

U3_g(x1, x2)  =  U3_g(x2)

while_out_g(x1)  =  while_out_g

WHILE_IN_G(x1)  =  WHILE_IN_G(x1)

U1_G(x1, x2)  =  U1_G(x1, x2)

U2_G(x1, x2)  =  U2_G(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(29) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(30)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_G(X, gt_out_gg(s(s(s(s(s(X))))), 0)) -> U2_G(X, f_in_ga(s(s(s(s(s(X))))), Y))
   U2_G(X, f_out_ga(s(s(s(s(s(X))))), Y)) -> WHILE_IN_G(Y)
   WHILE_IN_G(s(s(s(s(s(X)))))) -> U1_G(X, gt_in_gg(s(s(s(s(s(X))))), 0))

The TRS R consists of the following rules:

   f_in_ga(X, Y) -> U4_ga(X, Y, mod2_in_gg(X, 0))
   gt_in_gg(s(X1), 0) -> gt_out_gg(s(X1), 0)
   U4_ga(X, Y, mod2_out_gg(X, 0)) -> U5_ga(X, Y, if_in_gga(true, X, Y))
   mod2_in_gg(0, 0) -> mod2_out_gg(0, 0)
   mod2_in_gg(s(s(X)), Y) -> U9_gg(X, Y, mod2_in_gg(X, Y))
   U5_ga(X, Y, if_out_gga(true, X, Y)) -> f_out_ga(X, Y)
   U9_gg(X, Y, mod2_out_gg(X, Y)) -> mod2_out_gg(s(s(X)), Y)
   if_in_gga(true, X, Z) -> U6_gga(X, Z, plus_in_gga(X, s(0), Z))
   mod2_in_gg(s(0), s(0)) -> mod2_out_gg(s(0), s(0))
   U6_gga(X, Z, plus_out_gga(X, s(0), Z)) -> if_out_gga(true, X, Z)
   plus_in_gga(0, X, X) -> plus_out_gga(0, X, X)
   plus_in_gga(s(X), Y, Z) -> U8_gga(X, Y, Z, plus_in_gga(X, s(Y), Z))
   U8_gga(X, Y, Z, plus_out_gga(X, s(Y), Z)) -> plus_out_gga(s(X), Y, Z)

The argument filtering Pi contains the following mapping:
s(x1)  =  s(x1)

gt_in_gg(x1, x2)  =  gt_in_gg(x1, x2)

0  =  0

gt_out_gg(x1, x2)  =  gt_out_gg

f_in_ga(x1, x2)  =  f_in_ga(x1)

U4_ga(x1, x2, x3)  =  U4_ga(x1, x3)

mod2_in_gg(x1, x2)  =  mod2_in_gg(x1, x2)

mod2_out_gg(x1, x2)  =  mod2_out_gg

U9_gg(x1, x2, x3)  =  U9_gg(x3)

U5_ga(x1, x2, x3)  =  U5_ga(x3)

if_in_gga(x1, x2, x3)  =  if_in_gga(x1, x2)

true  =  true

U6_gga(x1, x2, x3)  =  U6_gga(x3)

plus_in_gga(x1, x2, x3)  =  plus_in_gga(x1, x2)

plus_out_gga(x1, x2, x3)  =  plus_out_gga(x3)

U8_gga(x1, x2, x3, x4)  =  U8_gga(x4)

if_out_gga(x1, x2, x3)  =  if_out_gga(x3)

f_out_ga(x1, x2)  =  f_out_ga(x2)

WHILE_IN_G(x1)  =  WHILE_IN_G(x1)

U1_G(x1, x2)  =  U1_G(x1, x2)

U2_G(x1, x2)  =  U2_G(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(31) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(32)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, gt_out_gg) -> U2_G(f_in_ga(s(s(s(s(s(X)))))))
   U2_G(f_out_ga(Y)) -> WHILE_IN_G(Y)
   WHILE_IN_G(s(s(s(s(s(X)))))) -> U1_G(X, gt_in_gg(s(s(s(s(s(X))))), 0))

The TRS R consists of the following rules:

   f_in_ga(X) -> U4_ga(X, mod2_in_gg(X, 0))
   gt_in_gg(s(X1), 0) -> gt_out_gg
   U4_ga(X, mod2_out_gg) -> U5_ga(if_in_gga(true, X))
   mod2_in_gg(0, 0) -> mod2_out_gg
   mod2_in_gg(s(s(X)), Y) -> U9_gg(mod2_in_gg(X, Y))
   U5_ga(if_out_gga(Y)) -> f_out_ga(Y)
   U9_gg(mod2_out_gg) -> mod2_out_gg
   if_in_gga(true, X) -> U6_gga(plus_in_gga(X, s(0)))
   mod2_in_gg(s(0), s(0)) -> mod2_out_gg
   U6_gga(plus_out_gga(Z)) -> if_out_gga(Z)
   plus_in_gga(0, X) -> plus_out_gga(X)
   plus_in_gga(s(X), Y) -> U8_gga(plus_in_gga(X, s(Y)))
   U8_gga(plus_out_gga(Z)) -> plus_out_gga(Z)

The set Q consists of the following terms:

   f_in_ga(x0)
   gt_in_gg(x0, x1)
   U4_ga(x0, x1)
   mod2_in_gg(x0, x1)
   U5_ga(x0)
   U9_gg(x0)
   if_in_gga(x0, x1)
   U6_gga(x0)
   plus_in_gga(x0, x1)
   U8_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(33) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U1_G(X, gt_out_gg) -> U2_G(f_in_ga(s(s(s(s(s(X))))))) at position [0] we obtained the following new rules [LPAR04]:

   (U1_G(X, gt_out_gg) -> U2_G(U4_ga(s(s(s(s(s(X))))), mod2_in_gg(s(s(s(s(s(X))))), 0))),U1_G(X, gt_out_gg) -> U2_G(U4_ga(s(s(s(s(s(X))))), mod2_in_gg(s(s(s(s(s(X))))), 0))))


----------------------------------------

(34)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U2_G(f_out_ga(Y)) -> WHILE_IN_G(Y)
   WHILE_IN_G(s(s(s(s(s(X)))))) -> U1_G(X, gt_in_gg(s(s(s(s(s(X))))), 0))
   U1_G(X, gt_out_gg) -> U2_G(U4_ga(s(s(s(s(s(X))))), mod2_in_gg(s(s(s(s(s(X))))), 0)))

The TRS R consists of the following rules:

   f_in_ga(X) -> U4_ga(X, mod2_in_gg(X, 0))
   gt_in_gg(s(X1), 0) -> gt_out_gg
   U4_ga(X, mod2_out_gg) -> U5_ga(if_in_gga(true, X))
   mod2_in_gg(0, 0) -> mod2_out_gg
   mod2_in_gg(s(s(X)), Y) -> U9_gg(mod2_in_gg(X, Y))
   U5_ga(if_out_gga(Y)) -> f_out_ga(Y)
   U9_gg(mod2_out_gg) -> mod2_out_gg
   if_in_gga(true, X) -> U6_gga(plus_in_gga(X, s(0)))
   mod2_in_gg(s(0), s(0)) -> mod2_out_gg
   U6_gga(plus_out_gga(Z)) -> if_out_gga(Z)
   plus_in_gga(0, X) -> plus_out_gga(X)
   plus_in_gga(s(X), Y) -> U8_gga(plus_in_gga(X, s(Y)))
   U8_gga(plus_out_gga(Z)) -> plus_out_gga(Z)

The set Q consists of the following terms:

   f_in_ga(x0)
   gt_in_gg(x0, x1)
   U4_ga(x0, x1)
   mod2_in_gg(x0, x1)
   U5_ga(x0)
   U9_gg(x0)
   if_in_gga(x0, x1)
   U6_gga(x0)
   plus_in_gga(x0, x1)
   U8_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(35) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(36)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U2_G(f_out_ga(Y)) -> WHILE_IN_G(Y)
   WHILE_IN_G(s(s(s(s(s(X)))))) -> U1_G(X, gt_in_gg(s(s(s(s(s(X))))), 0))
   U1_G(X, gt_out_gg) -> U2_G(U4_ga(s(s(s(s(s(X))))), mod2_in_gg(s(s(s(s(s(X))))), 0)))

The TRS R consists of the following rules:

   mod2_in_gg(s(s(X)), Y) -> U9_gg(mod2_in_gg(X, Y))
   U4_ga(X, mod2_out_gg) -> U5_ga(if_in_gga(true, X))
   if_in_gga(true, X) -> U6_gga(plus_in_gga(X, s(0)))
   U5_ga(if_out_gga(Y)) -> f_out_ga(Y)
   plus_in_gga(0, X) -> plus_out_gga(X)
   plus_in_gga(s(X), Y) -> U8_gga(plus_in_gga(X, s(Y)))
   U6_gga(plus_out_gga(Z)) -> if_out_gga(Z)
   U8_gga(plus_out_gga(Z)) -> plus_out_gga(Z)
   mod2_in_gg(0, 0) -> mod2_out_gg
   mod2_in_gg(s(0), s(0)) -> mod2_out_gg
   U9_gg(mod2_out_gg) -> mod2_out_gg
   gt_in_gg(s(X1), 0) -> gt_out_gg

The set Q consists of the following terms:

   f_in_ga(x0)
   gt_in_gg(x0, x1)
   U4_ga(x0, x1)
   mod2_in_gg(x0, x1)
   U5_ga(x0)
   U9_gg(x0)
   if_in_gga(x0, x1)
   U6_gga(x0)
   plus_in_gga(x0, x1)
   U8_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(37) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   f_in_ga(x0)


----------------------------------------

(38)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U2_G(f_out_ga(Y)) -> WHILE_IN_G(Y)
   WHILE_IN_G(s(s(s(s(s(X)))))) -> U1_G(X, gt_in_gg(s(s(s(s(s(X))))), 0))
   U1_G(X, gt_out_gg) -> U2_G(U4_ga(s(s(s(s(s(X))))), mod2_in_gg(s(s(s(s(s(X))))), 0)))

The TRS R consists of the following rules:

   mod2_in_gg(s(s(X)), Y) -> U9_gg(mod2_in_gg(X, Y))
   U4_ga(X, mod2_out_gg) -> U5_ga(if_in_gga(true, X))
   if_in_gga(true, X) -> U6_gga(plus_in_gga(X, s(0)))
   U5_ga(if_out_gga(Y)) -> f_out_ga(Y)
   plus_in_gga(0, X) -> plus_out_gga(X)
   plus_in_gga(s(X), Y) -> U8_gga(plus_in_gga(X, s(Y)))
   U6_gga(plus_out_gga(Z)) -> if_out_gga(Z)
   U8_gga(plus_out_gga(Z)) -> plus_out_gga(Z)
   mod2_in_gg(0, 0) -> mod2_out_gg
   mod2_in_gg(s(0), s(0)) -> mod2_out_gg
   U9_gg(mod2_out_gg) -> mod2_out_gg
   gt_in_gg(s(X1), 0) -> gt_out_gg

The set Q consists of the following terms:

   gt_in_gg(x0, x1)
   U4_ga(x0, x1)
   mod2_in_gg(x0, x1)
   U5_ga(x0)
   U9_gg(x0)
   if_in_gga(x0, x1)
   U6_gga(x0)
   plus_in_gga(x0, x1)
   U8_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(39) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule WHILE_IN_G(s(s(s(s(s(X)))))) -> U1_G(X, gt_in_gg(s(s(s(s(s(X))))), 0)) at position [1] we obtained the following new rules [LPAR04]:

   (WHILE_IN_G(s(s(s(s(s(X)))))) -> U1_G(X, gt_out_gg),WHILE_IN_G(s(s(s(s(s(X)))))) -> U1_G(X, gt_out_gg))


----------------------------------------

(40)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U2_G(f_out_ga(Y)) -> WHILE_IN_G(Y)
   U1_G(X, gt_out_gg) -> U2_G(U4_ga(s(s(s(s(s(X))))), mod2_in_gg(s(s(s(s(s(X))))), 0)))
   WHILE_IN_G(s(s(s(s(s(X)))))) -> U1_G(X, gt_out_gg)

The TRS R consists of the following rules:

   mod2_in_gg(s(s(X)), Y) -> U9_gg(mod2_in_gg(X, Y))
   U4_ga(X, mod2_out_gg) -> U5_ga(if_in_gga(true, X))
   if_in_gga(true, X) -> U6_gga(plus_in_gga(X, s(0)))
   U5_ga(if_out_gga(Y)) -> f_out_ga(Y)
   plus_in_gga(0, X) -> plus_out_gga(X)
   plus_in_gga(s(X), Y) -> U8_gga(plus_in_gga(X, s(Y)))
   U6_gga(plus_out_gga(Z)) -> if_out_gga(Z)
   U8_gga(plus_out_gga(Z)) -> plus_out_gga(Z)
   mod2_in_gg(0, 0) -> mod2_out_gg
   mod2_in_gg(s(0), s(0)) -> mod2_out_gg
   U9_gg(mod2_out_gg) -> mod2_out_gg
   gt_in_gg(s(X1), 0) -> gt_out_gg

The set Q consists of the following terms:

   gt_in_gg(x0, x1)
   U4_ga(x0, x1)
   mod2_in_gg(x0, x1)
   U5_ga(x0)
   U9_gg(x0)
   if_in_gga(x0, x1)
   U6_gga(x0)
   plus_in_gga(x0, x1)
   U8_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(41) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(42)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U2_G(f_out_ga(Y)) -> WHILE_IN_G(Y)
   U1_G(X, gt_out_gg) -> U2_G(U4_ga(s(s(s(s(s(X))))), mod2_in_gg(s(s(s(s(s(X))))), 0)))
   WHILE_IN_G(s(s(s(s(s(X)))))) -> U1_G(X, gt_out_gg)

The TRS R consists of the following rules:

   mod2_in_gg(s(s(X)), Y) -> U9_gg(mod2_in_gg(X, Y))
   U4_ga(X, mod2_out_gg) -> U5_ga(if_in_gga(true, X))
   if_in_gga(true, X) -> U6_gga(plus_in_gga(X, s(0)))
   U5_ga(if_out_gga(Y)) -> f_out_ga(Y)
   plus_in_gga(0, X) -> plus_out_gga(X)
   plus_in_gga(s(X), Y) -> U8_gga(plus_in_gga(X, s(Y)))
   U6_gga(plus_out_gga(Z)) -> if_out_gga(Z)
   U8_gga(plus_out_gga(Z)) -> plus_out_gga(Z)
   mod2_in_gg(0, 0) -> mod2_out_gg
   mod2_in_gg(s(0), s(0)) -> mod2_out_gg
   U9_gg(mod2_out_gg) -> mod2_out_gg

The set Q consists of the following terms:

   gt_in_gg(x0, x1)
   U4_ga(x0, x1)
   mod2_in_gg(x0, x1)
   U5_ga(x0)
   U9_gg(x0)
   if_in_gga(x0, x1)
   U6_gga(x0)
   plus_in_gga(x0, x1)
   U8_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(43) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   gt_in_gg(x0, x1)


----------------------------------------

(44)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U2_G(f_out_ga(Y)) -> WHILE_IN_G(Y)
   U1_G(X, gt_out_gg) -> U2_G(U4_ga(s(s(s(s(s(X))))), mod2_in_gg(s(s(s(s(s(X))))), 0)))
   WHILE_IN_G(s(s(s(s(s(X)))))) -> U1_G(X, gt_out_gg)

The TRS R consists of the following rules:

   mod2_in_gg(s(s(X)), Y) -> U9_gg(mod2_in_gg(X, Y))
   U4_ga(X, mod2_out_gg) -> U5_ga(if_in_gga(true, X))
   if_in_gga(true, X) -> U6_gga(plus_in_gga(X, s(0)))
   U5_ga(if_out_gga(Y)) -> f_out_ga(Y)
   plus_in_gga(0, X) -> plus_out_gga(X)
   plus_in_gga(s(X), Y) -> U8_gga(plus_in_gga(X, s(Y)))
   U6_gga(plus_out_gga(Z)) -> if_out_gga(Z)
   U8_gga(plus_out_gga(Z)) -> plus_out_gga(Z)
   mod2_in_gg(0, 0) -> mod2_out_gg
   mod2_in_gg(s(0), s(0)) -> mod2_out_gg
   U9_gg(mod2_out_gg) -> mod2_out_gg

The set Q consists of the following terms:

   U4_ga(x0, x1)
   mod2_in_gg(x0, x1)
   U5_ga(x0)
   U9_gg(x0)
   if_in_gga(x0, x1)
   U6_gga(x0)
   plus_in_gga(x0, x1)
   U8_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(45) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U1_G(X, gt_out_gg) -> U2_G(U4_ga(s(s(s(s(s(X))))), mod2_in_gg(s(s(s(s(s(X))))), 0))) at position [0,1] we obtained the following new rules [LPAR04]:

   (U1_G(X, gt_out_gg) -> U2_G(U4_ga(s(s(s(s(s(X))))), U9_gg(mod2_in_gg(s(s(s(X))), 0)))),U1_G(X, gt_out_gg) -> U2_G(U4_ga(s(s(s(s(s(X))))), U9_gg(mod2_in_gg(s(s(s(X))), 0)))))


----------------------------------------

(46)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U2_G(f_out_ga(Y)) -> WHILE_IN_G(Y)
   WHILE_IN_G(s(s(s(s(s(X)))))) -> U1_G(X, gt_out_gg)
   U1_G(X, gt_out_gg) -> U2_G(U4_ga(s(s(s(s(s(X))))), U9_gg(mod2_in_gg(s(s(s(X))), 0))))

The TRS R consists of the following rules:

   mod2_in_gg(s(s(X)), Y) -> U9_gg(mod2_in_gg(X, Y))
   U4_ga(X, mod2_out_gg) -> U5_ga(if_in_gga(true, X))
   if_in_gga(true, X) -> U6_gga(plus_in_gga(X, s(0)))
   U5_ga(if_out_gga(Y)) -> f_out_ga(Y)
   plus_in_gga(0, X) -> plus_out_gga(X)
   plus_in_gga(s(X), Y) -> U8_gga(plus_in_gga(X, s(Y)))
   U6_gga(plus_out_gga(Z)) -> if_out_gga(Z)
   U8_gga(plus_out_gga(Z)) -> plus_out_gga(Z)
   mod2_in_gg(0, 0) -> mod2_out_gg
   mod2_in_gg(s(0), s(0)) -> mod2_out_gg
   U9_gg(mod2_out_gg) -> mod2_out_gg

The set Q consists of the following terms:

   U4_ga(x0, x1)
   mod2_in_gg(x0, x1)
   U5_ga(x0)
   U9_gg(x0)
   if_in_gga(x0, x1)
   U6_gga(x0)
   plus_in_gga(x0, x1)
   U8_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(47) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule U1_G(X, gt_out_gg) -> U2_G(U4_ga(s(s(s(s(s(X))))), U9_gg(mod2_in_gg(s(s(s(X))), 0)))) at position [0,1,0] we obtained the following new rules [LPAR04]:

   (U1_G(X, gt_out_gg) -> U2_G(U4_ga(s(s(s(s(s(X))))), U9_gg(U9_gg(mod2_in_gg(s(X), 0))))),U1_G(X, gt_out_gg) -> U2_G(U4_ga(s(s(s(s(s(X))))), U9_gg(U9_gg(mod2_in_gg(s(X), 0))))))


----------------------------------------

(48)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U2_G(f_out_ga(Y)) -> WHILE_IN_G(Y)
   WHILE_IN_G(s(s(s(s(s(X)))))) -> U1_G(X, gt_out_gg)
   U1_G(X, gt_out_gg) -> U2_G(U4_ga(s(s(s(s(s(X))))), U9_gg(U9_gg(mod2_in_gg(s(X), 0)))))

The TRS R consists of the following rules:

   mod2_in_gg(s(s(X)), Y) -> U9_gg(mod2_in_gg(X, Y))
   U4_ga(X, mod2_out_gg) -> U5_ga(if_in_gga(true, X))
   if_in_gga(true, X) -> U6_gga(plus_in_gga(X, s(0)))
   U5_ga(if_out_gga(Y)) -> f_out_ga(Y)
   plus_in_gga(0, X) -> plus_out_gga(X)
   plus_in_gga(s(X), Y) -> U8_gga(plus_in_gga(X, s(Y)))
   U6_gga(plus_out_gga(Z)) -> if_out_gga(Z)
   U8_gga(plus_out_gga(Z)) -> plus_out_gga(Z)
   mod2_in_gg(0, 0) -> mod2_out_gg
   mod2_in_gg(s(0), s(0)) -> mod2_out_gg
   U9_gg(mod2_out_gg) -> mod2_out_gg

The set Q consists of the following terms:

   U4_ga(x0, x1)
   mod2_in_gg(x0, x1)
   U5_ga(x0)
   U9_gg(x0)
   if_in_gga(x0, x1)
   U6_gga(x0)
   plus_in_gga(x0, x1)
   U8_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(49) TransformationProof (SOUND)
By narrowing [LPAR04] the rule U1_G(X, gt_out_gg) -> U2_G(U4_ga(s(s(s(s(s(X))))), U9_gg(U9_gg(mod2_in_gg(s(X), 0))))) at position [0,1,0,0] we obtained the following new rules [LPAR04]:

   (U1_G(s(x0), gt_out_gg) -> U2_G(U4_ga(s(s(s(s(s(s(x0)))))), U9_gg(U9_gg(U9_gg(mod2_in_gg(x0, 0)))))),U1_G(s(x0), gt_out_gg) -> U2_G(U4_ga(s(s(s(s(s(s(x0)))))), U9_gg(U9_gg(U9_gg(mod2_in_gg(x0, 0)))))))


----------------------------------------

(50)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U2_G(f_out_ga(Y)) -> WHILE_IN_G(Y)
   WHILE_IN_G(s(s(s(s(s(X)))))) -> U1_G(X, gt_out_gg)
   U1_G(s(x0), gt_out_gg) -> U2_G(U4_ga(s(s(s(s(s(s(x0)))))), U9_gg(U9_gg(U9_gg(mod2_in_gg(x0, 0))))))

The TRS R consists of the following rules:

   mod2_in_gg(s(s(X)), Y) -> U9_gg(mod2_in_gg(X, Y))
   U4_ga(X, mod2_out_gg) -> U5_ga(if_in_gga(true, X))
   if_in_gga(true, X) -> U6_gga(plus_in_gga(X, s(0)))
   U5_ga(if_out_gga(Y)) -> f_out_ga(Y)
   plus_in_gga(0, X) -> plus_out_gga(X)
   plus_in_gga(s(X), Y) -> U8_gga(plus_in_gga(X, s(Y)))
   U6_gga(plus_out_gga(Z)) -> if_out_gga(Z)
   U8_gga(plus_out_gga(Z)) -> plus_out_gga(Z)
   mod2_in_gg(0, 0) -> mod2_out_gg
   mod2_in_gg(s(0), s(0)) -> mod2_out_gg
   U9_gg(mod2_out_gg) -> mod2_out_gg

The set Q consists of the following terms:

   U4_ga(x0, x1)
   mod2_in_gg(x0, x1)
   U5_ga(x0)
   U9_gg(x0)
   if_in_gga(x0, x1)
   U6_gga(x0)
   plus_in_gga(x0, x1)
   U8_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(51) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule U2_G(f_out_ga(Y)) -> WHILE_IN_G(Y) we obtained the following new rules [LPAR04]:

   (U2_G(f_out_ga(s(s(s(s(s(y_0))))))) -> WHILE_IN_G(s(s(s(s(s(y_0)))))),U2_G(f_out_ga(s(s(s(s(s(y_0))))))) -> WHILE_IN_G(s(s(s(s(s(y_0)))))))


----------------------------------------

(52)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   WHILE_IN_G(s(s(s(s(s(X)))))) -> U1_G(X, gt_out_gg)
   U1_G(s(x0), gt_out_gg) -> U2_G(U4_ga(s(s(s(s(s(s(x0)))))), U9_gg(U9_gg(U9_gg(mod2_in_gg(x0, 0))))))
   U2_G(f_out_ga(s(s(s(s(s(y_0))))))) -> WHILE_IN_G(s(s(s(s(s(y_0))))))

The TRS R consists of the following rules:

   mod2_in_gg(s(s(X)), Y) -> U9_gg(mod2_in_gg(X, Y))
   U4_ga(X, mod2_out_gg) -> U5_ga(if_in_gga(true, X))
   if_in_gga(true, X) -> U6_gga(plus_in_gga(X, s(0)))
   U5_ga(if_out_gga(Y)) -> f_out_ga(Y)
   plus_in_gga(0, X) -> plus_out_gga(X)
   plus_in_gga(s(X), Y) -> U8_gga(plus_in_gga(X, s(Y)))
   U6_gga(plus_out_gga(Z)) -> if_out_gga(Z)
   U8_gga(plus_out_gga(Z)) -> plus_out_gga(Z)
   mod2_in_gg(0, 0) -> mod2_out_gg
   mod2_in_gg(s(0), s(0)) -> mod2_out_gg
   U9_gg(mod2_out_gg) -> mod2_out_gg

The set Q consists of the following terms:

   U4_ga(x0, x1)
   mod2_in_gg(x0, x1)
   U5_ga(x0)
   U9_gg(x0)
   if_in_gga(x0, x1)
   U6_gga(x0)
   plus_in_gga(x0, x1)
   U8_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(53) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule WHILE_IN_G(s(s(s(s(s(X)))))) -> U1_G(X, gt_out_gg) we obtained the following new rules [LPAR04]:

   (WHILE_IN_G(s(s(s(s(s(s(y_0))))))) -> U1_G(s(y_0), gt_out_gg),WHILE_IN_G(s(s(s(s(s(s(y_0))))))) -> U1_G(s(y_0), gt_out_gg))


----------------------------------------

(54)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(s(x0), gt_out_gg) -> U2_G(U4_ga(s(s(s(s(s(s(x0)))))), U9_gg(U9_gg(U9_gg(mod2_in_gg(x0, 0))))))
   U2_G(f_out_ga(s(s(s(s(s(y_0))))))) -> WHILE_IN_G(s(s(s(s(s(y_0))))))
   WHILE_IN_G(s(s(s(s(s(s(y_0))))))) -> U1_G(s(y_0), gt_out_gg)

The TRS R consists of the following rules:

   mod2_in_gg(s(s(X)), Y) -> U9_gg(mod2_in_gg(X, Y))
   U4_ga(X, mod2_out_gg) -> U5_ga(if_in_gga(true, X))
   if_in_gga(true, X) -> U6_gga(plus_in_gga(X, s(0)))
   U5_ga(if_out_gga(Y)) -> f_out_ga(Y)
   plus_in_gga(0, X) -> plus_out_gga(X)
   plus_in_gga(s(X), Y) -> U8_gga(plus_in_gga(X, s(Y)))
   U6_gga(plus_out_gga(Z)) -> if_out_gga(Z)
   U8_gga(plus_out_gga(Z)) -> plus_out_gga(Z)
   mod2_in_gg(0, 0) -> mod2_out_gg
   mod2_in_gg(s(0), s(0)) -> mod2_out_gg
   U9_gg(mod2_out_gg) -> mod2_out_gg

The set Q consists of the following terms:

   U4_ga(x0, x1)
   mod2_in_gg(x0, x1)
   U5_ga(x0)
   U9_gg(x0)
   if_in_gga(x0, x1)
   U6_gga(x0)
   plus_in_gga(x0, x1)
   U8_gga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(55) SemLabProof (SOUND)
We found the following model for the rules of the TRSs R and P.
Interpretation over the domain with elements from 0 to 1.
true: 0
U2_G: 0
U4_ga: 0
plus_out_gga: 0
U6_gga: 0
U8_gga: 0
s: 1 + x<sub>0</sub>
U1_G: 0
mod2_in_gg: 0
f_out_ga: 0
gt_out_gg: 0
U5_ga: 0
mod2_out_gg: 0
0: 0
if_in_gga: 0
if_out_gga: 0
WHILE_IN_G: 0
U9_gg: 0
plus_in_gga: 0
By semantic labelling [SEMLAB] we obtain the following labelled QDP problem.
----------------------------------------

(56)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G.1-0(s.0(x0), gt_out_gg.) -> U2_G.0(U4_ga.0-0(s.1(s.0(s.1(s.0(s.1(s.0(x0)))))), U9_gg.0(U9_gg.0(U9_gg.0(mod2_in_gg.0-0(x0, 0.))))))
   U2_G.0(f_out_ga.1(s.0(s.1(s.0(s.1(s.0(y_0))))))) -> WHILE_IN_G.1(s.0(s.1(s.0(s.1(s.0(y_0))))))
   U2_G.0(f_out_ga.0(s.1(s.0(s.1(s.0(s.1(y_0))))))) -> WHILE_IN_G.0(s.1(s.0(s.1(s.0(s.1(y_0))))))
   U1_G.0-0(s.1(x0), gt_out_gg.) -> U2_G.0(U4_ga.1-0(s.0(s.1(s.0(s.1(s.0(s.1(x0)))))), U9_gg.0(U9_gg.0(U9_gg.0(mod2_in_gg.1-0(x0, 0.))))))
   WHILE_IN_G.0(s.1(s.0(s.1(s.0(s.1(s.0(y_0))))))) -> U1_G.1-0(s.0(y_0), gt_out_gg.)
   WHILE_IN_G.1(s.0(s.1(s.0(s.1(s.0(s.1(y_0))))))) -> U1_G.0-0(s.1(y_0), gt_out_gg.)

The TRS R consists of the following rules:

   mod2_in_gg.0-0(s.1(s.0(X)), Y) -> U9_gg.0(mod2_in_gg.0-0(X, Y))
   mod2_in_gg.0-1(s.1(s.0(X)), Y) -> U9_gg.0(mod2_in_gg.0-1(X, Y))
   mod2_in_gg.1-0(s.0(s.1(X)), Y) -> U9_gg.0(mod2_in_gg.1-0(X, Y))
   mod2_in_gg.1-1(s.0(s.1(X)), Y) -> U9_gg.0(mod2_in_gg.1-1(X, Y))
   U4_ga.0-0(X, mod2_out_gg.) -> U5_ga.0(if_in_gga.0-0(true., X))
   U4_ga.1-0(X, mod2_out_gg.) -> U5_ga.0(if_in_gga.0-1(true., X))
   if_in_gga.0-0(true., X) -> U6_gga.0(plus_in_gga.0-1(X, s.0(0.)))
   if_in_gga.0-1(true., X) -> U6_gga.0(plus_in_gga.1-1(X, s.0(0.)))
   U5_ga.0(if_out_gga.0(Y)) -> f_out_ga.0(Y)
   U5_ga.0(if_out_gga.1(Y)) -> f_out_ga.1(Y)
   plus_in_gga.0-0(0., X) -> plus_out_gga.0(X)
   plus_in_gga.0-1(0., X) -> plus_out_gga.1(X)
   plus_in_gga.1-0(s.0(X), Y) -> U8_gga.0(plus_in_gga.0-1(X, s.0(Y)))
   plus_in_gga.1-1(s.0(X), Y) -> U8_gga.0(plus_in_gga.0-0(X, s.1(Y)))
   plus_in_gga.0-0(s.1(X), Y) -> U8_gga.0(plus_in_gga.1-1(X, s.0(Y)))
   plus_in_gga.0-1(s.1(X), Y) -> U8_gga.0(plus_in_gga.1-0(X, s.1(Y)))
   U6_gga.0(plus_out_gga.0(Z)) -> if_out_gga.0(Z)
   U6_gga.0(plus_out_gga.1(Z)) -> if_out_gga.1(Z)
   U8_gga.0(plus_out_gga.0(Z)) -> plus_out_gga.0(Z)
   U8_gga.0(plus_out_gga.1(Z)) -> plus_out_gga.1(Z)
   mod2_in_gg.0-0(0., 0.) -> mod2_out_gg.
   mod2_in_gg.1-1(s.0(0.), s.0(0.)) -> mod2_out_gg.
   U9_gg.0(mod2_out_gg.) -> mod2_out_gg.

The set Q consists of the following terms:

   U4_ga.0-0(x0, x1)
   U4_ga.0-1(x0, x1)
   U4_ga.1-0(x0, x1)
   U4_ga.1-1(x0, x1)
   mod2_in_gg.0-0(x0, x1)
   mod2_in_gg.0-1(x0, x1)
   mod2_in_gg.1-0(x0, x1)
   mod2_in_gg.1-1(x0, x1)
   U5_ga.0(x0)
   U5_ga.1(x0)
   U9_gg.0(x0)
   U9_gg.1(x0)
   if_in_gga.0-0(x0, x1)
   if_in_gga.0-1(x0, x1)
   if_in_gga.1-0(x0, x1)
   if_in_gga.1-1(x0, x1)
   U6_gga.0(x0)
   U6_gga.1(x0)
   plus_in_gga.0-0(x0, x1)
   plus_in_gga.0-1(x0, x1)
   plus_in_gga.1-0(x0, x1)
   plus_in_gga.1-1(x0, x1)
   U8_gga.0(x0)
   U8_gga.1(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(57) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   WHILE_IN_G.1(s.0(s.1(s.0(s.1(s.0(s.1(y_0))))))) -> U1_G.0-0(s.1(y_0), gt_out_gg.)
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial interpretation [POLO]:

   POL(0.) = 0
   POL(U1_G.0-0(x_1, x_2)) = x_1
   POL(U1_G.1-0(x_1, x_2)) = 1 + x_2
   POL(U2_G.0(x_1)) = 1 + x_1
   POL(U4_ga.0-0(x_1, x_2)) = 1
   POL(U4_ga.1-0(x_1, x_2)) = x_2
   POL(U5_ga.0(x_1)) = 1
   POL(U6_gga.0(x_1)) = 1
   POL(U8_gga.0(x_1)) = 0
   POL(U9_gg.0(x_1)) = x_1
   POL(WHILE_IN_G.0(x_1)) = 1 + x_1
   POL(WHILE_IN_G.1(x_1)) = 1 + x_1
   POL(f_out_ga.0(x_1)) = 1
   POL(f_out_ga.1(x_1)) = 1
   POL(gt_out_gg.) = 1
   POL(if_in_gga.0-0(x_1, x_2)) = x_2
   POL(if_in_gga.0-1(x_1, x_2)) = x_2
   POL(if_out_gga.0(x_1)) = 1 + x_1
   POL(if_out_gga.1(x_1)) = 1 + x_1
   POL(mod2_in_gg.0-0(x_1, x_2)) = x_2
   POL(mod2_in_gg.1-0(x_1, x_2)) = x_2
   POL(mod2_out_gg.) = 1
   POL(plus_in_gga.0-0(x_1, x_2)) = 0
   POL(plus_in_gga.0-1(x_1, x_2)) = 0
   POL(plus_in_gga.1-0(x_1, x_2)) = x_2
   POL(plus_in_gga.1-1(x_1, x_2)) = 0
   POL(plus_out_gga.0(x_1)) = 1 + x_1
   POL(plus_out_gga.1(x_1)) = 1 + x_1
   POL(s.0(x_1)) = x_1
   POL(s.1(x_1)) = 1
   POL(true.) = 0

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   U9_gg.0(mod2_out_gg.) -> mod2_out_gg.
   U4_ga.0-0(X, mod2_out_gg.) -> U5_ga.0(if_in_gga.0-0(true., X))
   mod2_in_gg.1-0(s.0(s.1(X)), Y) -> U9_gg.0(mod2_in_gg.1-0(X, Y))
   U4_ga.1-0(X, mod2_out_gg.) -> U5_ga.0(if_in_gga.0-1(true., X))
   U5_ga.0(if_out_gga.0(Y)) -> f_out_ga.0(Y)
   U5_ga.0(if_out_gga.1(Y)) -> f_out_ga.1(Y)


----------------------------------------

(58)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G.1-0(s.0(x0), gt_out_gg.) -> U2_G.0(U4_ga.0-0(s.1(s.0(s.1(s.0(s.1(s.0(x0)))))), U9_gg.0(U9_gg.0(U9_gg.0(mod2_in_gg.0-0(x0, 0.))))))
   U2_G.0(f_out_ga.1(s.0(s.1(s.0(s.1(s.0(y_0))))))) -> WHILE_IN_G.1(s.0(s.1(s.0(s.1(s.0(y_0))))))
   U2_G.0(f_out_ga.0(s.1(s.0(s.1(s.0(s.1(y_0))))))) -> WHILE_IN_G.0(s.1(s.0(s.1(s.0(s.1(y_0))))))
   U1_G.0-0(s.1(x0), gt_out_gg.) -> U2_G.0(U4_ga.1-0(s.0(s.1(s.0(s.1(s.0(s.1(x0)))))), U9_gg.0(U9_gg.0(U9_gg.0(mod2_in_gg.1-0(x0, 0.))))))
   WHILE_IN_G.0(s.1(s.0(s.1(s.0(s.1(s.0(y_0))))))) -> U1_G.1-0(s.0(y_0), gt_out_gg.)

The TRS R consists of the following rules:

   mod2_in_gg.0-0(s.1(s.0(X)), Y) -> U9_gg.0(mod2_in_gg.0-0(X, Y))
   mod2_in_gg.0-1(s.1(s.0(X)), Y) -> U9_gg.0(mod2_in_gg.0-1(X, Y))
   mod2_in_gg.1-0(s.0(s.1(X)), Y) -> U9_gg.0(mod2_in_gg.1-0(X, Y))
   mod2_in_gg.1-1(s.0(s.1(X)), Y) -> U9_gg.0(mod2_in_gg.1-1(X, Y))
   U4_ga.0-0(X, mod2_out_gg.) -> U5_ga.0(if_in_gga.0-0(true., X))
   U4_ga.1-0(X, mod2_out_gg.) -> U5_ga.0(if_in_gga.0-1(true., X))
   if_in_gga.0-0(true., X) -> U6_gga.0(plus_in_gga.0-1(X, s.0(0.)))
   if_in_gga.0-1(true., X) -> U6_gga.0(plus_in_gga.1-1(X, s.0(0.)))
   U5_ga.0(if_out_gga.0(Y)) -> f_out_ga.0(Y)
   U5_ga.0(if_out_gga.1(Y)) -> f_out_ga.1(Y)
   plus_in_gga.0-0(0., X) -> plus_out_gga.0(X)
   plus_in_gga.0-1(0., X) -> plus_out_gga.1(X)
   plus_in_gga.1-0(s.0(X), Y) -> U8_gga.0(plus_in_gga.0-1(X, s.0(Y)))
   plus_in_gga.1-1(s.0(X), Y) -> U8_gga.0(plus_in_gga.0-0(X, s.1(Y)))
   plus_in_gga.0-0(s.1(X), Y) -> U8_gga.0(plus_in_gga.1-1(X, s.0(Y)))
   plus_in_gga.0-1(s.1(X), Y) -> U8_gga.0(plus_in_gga.1-0(X, s.1(Y)))
   U6_gga.0(plus_out_gga.0(Z)) -> if_out_gga.0(Z)
   U6_gga.0(plus_out_gga.1(Z)) -> if_out_gga.1(Z)
   U8_gga.0(plus_out_gga.0(Z)) -> plus_out_gga.0(Z)
   U8_gga.0(plus_out_gga.1(Z)) -> plus_out_gga.1(Z)
   mod2_in_gg.0-0(0., 0.) -> mod2_out_gg.
   mod2_in_gg.1-1(s.0(0.), s.0(0.)) -> mod2_out_gg.
   U9_gg.0(mod2_out_gg.) -> mod2_out_gg.

The set Q consists of the following terms:

   U4_ga.0-0(x0, x1)
   U4_ga.0-1(x0, x1)
   U4_ga.1-0(x0, x1)
   U4_ga.1-1(x0, x1)
   mod2_in_gg.0-0(x0, x1)
   mod2_in_gg.0-1(x0, x1)
   mod2_in_gg.1-0(x0, x1)
   mod2_in_gg.1-1(x0, x1)
   U5_ga.0(x0)
   U5_ga.1(x0)
   U9_gg.0(x0)
   U9_gg.1(x0)
   if_in_gga.0-0(x0, x1)
   if_in_gga.0-1(x0, x1)
   if_in_gga.1-0(x0, x1)
   if_in_gga.1-1(x0, x1)
   U6_gga.0(x0)
   U6_gga.1(x0)
   plus_in_gga.0-0(x0, x1)
   plus_in_gga.0-1(x0, x1)
   plus_in_gga.1-0(x0, x1)
   plus_in_gga.1-1(x0, x1)
   U8_gga.0(x0)
   U8_gga.1(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(59) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(60)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U2_G.0(f_out_ga.0(s.1(s.0(s.1(s.0(s.1(y_0))))))) -> WHILE_IN_G.0(s.1(s.0(s.1(s.0(s.1(y_0))))))
   WHILE_IN_G.0(s.1(s.0(s.1(s.0(s.1(s.0(y_0))))))) -> U1_G.1-0(s.0(y_0), gt_out_gg.)
   U1_G.1-0(s.0(x0), gt_out_gg.) -> U2_G.0(U4_ga.0-0(s.1(s.0(s.1(s.0(s.1(s.0(x0)))))), U9_gg.0(U9_gg.0(U9_gg.0(mod2_in_gg.0-0(x0, 0.))))))

The TRS R consists of the following rules:

   mod2_in_gg.0-0(s.1(s.0(X)), Y) -> U9_gg.0(mod2_in_gg.0-0(X, Y))
   mod2_in_gg.0-1(s.1(s.0(X)), Y) -> U9_gg.0(mod2_in_gg.0-1(X, Y))
   mod2_in_gg.1-0(s.0(s.1(X)), Y) -> U9_gg.0(mod2_in_gg.1-0(X, Y))
   mod2_in_gg.1-1(s.0(s.1(X)), Y) -> U9_gg.0(mod2_in_gg.1-1(X, Y))
   U4_ga.0-0(X, mod2_out_gg.) -> U5_ga.0(if_in_gga.0-0(true., X))
   U4_ga.1-0(X, mod2_out_gg.) -> U5_ga.0(if_in_gga.0-1(true., X))
   if_in_gga.0-0(true., X) -> U6_gga.0(plus_in_gga.0-1(X, s.0(0.)))
   if_in_gga.0-1(true., X) -> U6_gga.0(plus_in_gga.1-1(X, s.0(0.)))
   U5_ga.0(if_out_gga.0(Y)) -> f_out_ga.0(Y)
   U5_ga.0(if_out_gga.1(Y)) -> f_out_ga.1(Y)
   plus_in_gga.0-0(0., X) -> plus_out_gga.0(X)
   plus_in_gga.0-1(0., X) -> plus_out_gga.1(X)
   plus_in_gga.1-0(s.0(X), Y) -> U8_gga.0(plus_in_gga.0-1(X, s.0(Y)))
   plus_in_gga.1-1(s.0(X), Y) -> U8_gga.0(plus_in_gga.0-0(X, s.1(Y)))
   plus_in_gga.0-0(s.1(X), Y) -> U8_gga.0(plus_in_gga.1-1(X, s.0(Y)))
   plus_in_gga.0-1(s.1(X), Y) -> U8_gga.0(plus_in_gga.1-0(X, s.1(Y)))
   U6_gga.0(plus_out_gga.0(Z)) -> if_out_gga.0(Z)
   U6_gga.0(plus_out_gga.1(Z)) -> if_out_gga.1(Z)
   U8_gga.0(plus_out_gga.0(Z)) -> plus_out_gga.0(Z)
   U8_gga.0(plus_out_gga.1(Z)) -> plus_out_gga.1(Z)
   mod2_in_gg.0-0(0., 0.) -> mod2_out_gg.
   mod2_in_gg.1-1(s.0(0.), s.0(0.)) -> mod2_out_gg.
   U9_gg.0(mod2_out_gg.) -> mod2_out_gg.

The set Q consists of the following terms:

   U4_ga.0-0(x0, x1)
   U4_ga.0-1(x0, x1)
   U4_ga.1-0(x0, x1)
   U4_ga.1-1(x0, x1)
   mod2_in_gg.0-0(x0, x1)
   mod2_in_gg.0-1(x0, x1)
   mod2_in_gg.1-0(x0, x1)
   mod2_in_gg.1-1(x0, x1)
   U5_ga.0(x0)
   U5_ga.1(x0)
   U9_gg.0(x0)
   U9_gg.1(x0)
   if_in_gga.0-0(x0, x1)
   if_in_gga.0-1(x0, x1)
   if_in_gga.1-0(x0, x1)
   if_in_gga.1-1(x0, x1)
   U6_gga.0(x0)
   U6_gga.1(x0)
   plus_in_gga.0-0(x0, x1)
   plus_in_gga.0-1(x0, x1)
   plus_in_gga.1-0(x0, x1)
   plus_in_gga.1-1(x0, x1)
   U8_gga.0(x0)
   U8_gga.1(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(61) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   WHILE_IN_G.0(s.1(s.0(s.1(s.0(s.1(s.0(y_0))))))) -> U1_G.1-0(s.0(y_0), gt_out_gg.)
   U1_G.1-0(s.0(x0), gt_out_gg.) -> U2_G.0(U4_ga.0-0(s.1(s.0(s.1(s.0(s.1(s.0(x0)))))), U9_gg.0(U9_gg.0(U9_gg.0(mod2_in_gg.0-0(x0, 0.))))))
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial interpretation [POLO]:

   POL(0.) = 0
   POL(U1_G.1-0(x_1, x_2)) = x_1 + x_2
   POL(U2_G.0(x_1)) = x_1
   POL(U4_ga.0-0(x_1, x_2)) = 0
   POL(U5_ga.0(x_1)) = x_1
   POL(U6_gga.0(x_1)) = x_1
   POL(U8_gga.0(x_1)) = x_1
   POL(U9_gg.0(x_1)) = 0
   POL(WHILE_IN_G.0(x_1)) = 1 + x_1
   POL(f_out_ga.0(x_1)) = 1 + x_1
   POL(f_out_ga.1(x_1)) = 0
   POL(gt_out_gg.) = 0
   POL(if_in_gga.0-0(x_1, x_2)) = 0
   POL(if_out_gga.0(x_1)) = 1 + x_1
   POL(if_out_gga.1(x_1)) = 0
   POL(mod2_in_gg.0-0(x_1, x_2)) = x_2
   POL(mod2_out_gg.) = 0
   POL(plus_in_gga.0-1(x_1, x_2)) = 0
   POL(plus_in_gga.1-0(x_1, x_2)) = 0
   POL(plus_out_gga.0(x_1)) = 1 + x_1
   POL(plus_out_gga.1(x_1)) = 0
   POL(s.0(x_1)) = 1
   POL(s.1(x_1)) = x_1
   POL(true.) = 0

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   U4_ga.0-0(X, mod2_out_gg.) -> U5_ga.0(if_in_gga.0-0(true., X))
   if_in_gga.0-0(true., X) -> U6_gga.0(plus_in_gga.0-1(X, s.0(0.)))
   U5_ga.0(if_out_gga.0(Y)) -> f_out_ga.0(Y)
   U5_ga.0(if_out_gga.1(Y)) -> f_out_ga.1(Y)
   plus_in_gga.0-1(0., X) -> plus_out_gga.1(X)
   plus_in_gga.0-1(s.1(X), Y) -> U8_gga.0(plus_in_gga.1-0(X, s.1(Y)))
   U6_gga.0(plus_out_gga.0(Z)) -> if_out_gga.0(Z)
   U6_gga.0(plus_out_gga.1(Z)) -> if_out_gga.1(Z)
   U8_gga.0(plus_out_gga.0(Z)) -> plus_out_gga.0(Z)
   U8_gga.0(plus_out_gga.1(Z)) -> plus_out_gga.1(Z)
   plus_in_gga.1-0(s.0(X), Y) -> U8_gga.0(plus_in_gga.0-1(X, s.0(Y)))


----------------------------------------

(62)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U2_G.0(f_out_ga.0(s.1(s.0(s.1(s.0(s.1(y_0))))))) -> WHILE_IN_G.0(s.1(s.0(s.1(s.0(s.1(y_0))))))

The TRS R consists of the following rules:

   mod2_in_gg.0-0(s.1(s.0(X)), Y) -> U9_gg.0(mod2_in_gg.0-0(X, Y))
   mod2_in_gg.0-1(s.1(s.0(X)), Y) -> U9_gg.0(mod2_in_gg.0-1(X, Y))
   mod2_in_gg.1-0(s.0(s.1(X)), Y) -> U9_gg.0(mod2_in_gg.1-0(X, Y))
   mod2_in_gg.1-1(s.0(s.1(X)), Y) -> U9_gg.0(mod2_in_gg.1-1(X, Y))
   U4_ga.0-0(X, mod2_out_gg.) -> U5_ga.0(if_in_gga.0-0(true., X))
   U4_ga.1-0(X, mod2_out_gg.) -> U5_ga.0(if_in_gga.0-1(true., X))
   if_in_gga.0-0(true., X) -> U6_gga.0(plus_in_gga.0-1(X, s.0(0.)))
   if_in_gga.0-1(true., X) -> U6_gga.0(plus_in_gga.1-1(X, s.0(0.)))
   U5_ga.0(if_out_gga.0(Y)) -> f_out_ga.0(Y)
   U5_ga.0(if_out_gga.1(Y)) -> f_out_ga.1(Y)
   plus_in_gga.0-0(0., X) -> plus_out_gga.0(X)
   plus_in_gga.0-1(0., X) -> plus_out_gga.1(X)
   plus_in_gga.1-0(s.0(X), Y) -> U8_gga.0(plus_in_gga.0-1(X, s.0(Y)))
   plus_in_gga.1-1(s.0(X), Y) -> U8_gga.0(plus_in_gga.0-0(X, s.1(Y)))
   plus_in_gga.0-0(s.1(X), Y) -> U8_gga.0(plus_in_gga.1-1(X, s.0(Y)))
   plus_in_gga.0-1(s.1(X), Y) -> U8_gga.0(plus_in_gga.1-0(X, s.1(Y)))
   U6_gga.0(plus_out_gga.0(Z)) -> if_out_gga.0(Z)
   U6_gga.0(plus_out_gga.1(Z)) -> if_out_gga.1(Z)
   U8_gga.0(plus_out_gga.0(Z)) -> plus_out_gga.0(Z)
   U8_gga.0(plus_out_gga.1(Z)) -> plus_out_gga.1(Z)
   mod2_in_gg.0-0(0., 0.) -> mod2_out_gg.
   mod2_in_gg.1-1(s.0(0.), s.0(0.)) -> mod2_out_gg.
   U9_gg.0(mod2_out_gg.) -> mod2_out_gg.

The set Q consists of the following terms:

   U4_ga.0-0(x0, x1)
   U4_ga.0-1(x0, x1)
   U4_ga.1-0(x0, x1)
   U4_ga.1-1(x0, x1)
   mod2_in_gg.0-0(x0, x1)
   mod2_in_gg.0-1(x0, x1)
   mod2_in_gg.1-0(x0, x1)
   mod2_in_gg.1-1(x0, x1)
   U5_ga.0(x0)
   U5_ga.1(x0)
   U9_gg.0(x0)
   U9_gg.1(x0)
   if_in_gga.0-0(x0, x1)
   if_in_gga.0-1(x0, x1)
   if_in_gga.1-0(x0, x1)
   if_in_gga.1-1(x0, x1)
   U6_gga.0(x0)
   U6_gga.1(x0)
   plus_in_gga.0-0(x0, x1)
   plus_in_gga.0-1(x0, x1)
   plus_in_gga.1-0(x0, x1)
   plus_in_gga.1-1(x0, x1)
   U8_gga.0(x0)
   U8_gga.1(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(63) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 1 less node.
----------------------------------------

(64)
TRUE
