MAYBE
proof of /hpcwork/ff862203/termcomp25/benchmarks/Aii5W.pl
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Left Termination of the query pattern

f(g)

w.r.t. the given Prolog program could not be shown:

(0) Prolog
(1) PrologToPiTRSProof [SOUND, 0 ms]
(2) PiTRS
    (3) DependencyPairsProof [EQUIVALENT, 0 ms]
    (4) PiDP
    (5) DependencyGraphProof [EQUIVALENT, 0 ms]
    (6) PiDP
    (7) UsableRulesProof [EQUIVALENT, 0 ms]
    (8) PiDP
    (9) PiDPToQDPProof [SOUND, 0 ms]
    (10) QDP
    (11) TransformationProof [SOUND, 0 ms]
    (12) QDP
    (13) DependencyGraphProof [EQUIVALENT, 0 ms]
    (14) QDP
    (15) UsableRulesProof [EQUIVALENT, 0 ms]
    (16) QDP
    (17) QReductionProof [EQUIVALENT, 0 ms]
    (18) QDP
    (19) TransformationProof [EQUIVALENT, 0 ms]
    (20) QDP
    (21) NonTerminationLoopProof [COMPLETE, 0 ms]
    (22) NO
(23) PrologToPiTRSProof [SOUND, 0 ms]
(24) PiTRS
    (25) DependencyPairsProof [EQUIVALENT, 0 ms]
    (26) PiDP
    (27) DependencyGraphProof [EQUIVALENT, 0 ms]
    (28) PiDP
    (29) UsableRulesProof [EQUIVALENT, 0 ms]
    (30) PiDP
    (31) PiDPToQDPProof [EQUIVALENT, 0 ms]
    (32) QDP
    (33) UsableRulesReductionPairsProof [EQUIVALENT, 15 ms]
    (34) QDP
    (35) TransformationProof [SOUND, 0 ms]
    (36) QDP
    (37) UsableRulesProof [EQUIVALENT, 0 ms]
    (38) QDP
    (39) QReductionProof [EQUIVALENT, 0 ms]
    (40) QDP
    (41) TransformationProof [EQUIVALENT, 0 ms]
    (42) QDP
    (43) NonTerminationLoopProof [COMPLETE, 0 ms]
    (44) NO
(45) PrologToDTProblemTransformerProof [SOUND, 0 ms]
(46) TRIPLES
    (47) UndefinedPredicateInTriplesTransformerProof [SOUND, 0 ms]
    (48) TRIPLES
    (49) TriplesToPiDPProof [SOUND, 0 ms]
    (50) PiDP
    (51) DependencyGraphProof [EQUIVALENT, 0 ms]
    (52) PiDP
    (53) PiDPToQDPProof [EQUIVALENT, 0 ms]
    (54) QDP
    (55) NonTerminationLoopProof [COMPLETE, 0 ms]
    (56) NO
(57) PrologToTRSTransformerProof [SOUND, 0 ms]
(58) QTRS
    (59) Overlay + Local Confluence [EQUIVALENT, 0 ms]
    (60) QTRS
    (61) DependencyPairsProof [EQUIVALENT, 0 ms]
    (62) QDP
    (63) DependencyGraphProof [EQUIVALENT, 0 ms]
    (64) QDP
    (65) UsableRulesProof [EQUIVALENT, 0 ms]
    (66) QDP
    (67) QReductionProof [EQUIVALENT, 0 ms]
    (68) QDP
    (69) TransformationProof [EQUIVALENT, 0 ms]
    (70) QDP
    (71) DependencyGraphProof [EQUIVALENT, 0 ms]
    (72) QDP
    (73) UsableRulesProof [EQUIVALENT, 0 ms]
    (74) QDP
    (75) QReductionProof [EQUIVALENT, 0 ms]
    (76) QDP
    (77) TransformationProof [EQUIVALENT, 0 ms]
    (78) QDP
    (79) TransformationProof [EQUIVALENT, 0 ms]
    (80) QDP
    (81) NonTerminationLoopProof [COMPLETE, 0 ms]
    (82) NO
(83) PrologToIRSwTTransformerProof [SOUND, 0 ms]
(84) AND
    (85) IRSwT
        (86) IRSwTSimpleDependencyGraphProof [EQUIVALENT, 0 ms]
        (87) IRSwT
        (88) IntTRSCompressionProof [EQUIVALENT, 22 ms]
        (89) IRSwT
        (90) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
        (91) IRSwT
        (92) IRSwTTerminationDigraphProof [EQUIVALENT, 0 ms]
        (93) TRUE
    (94) IRSwT
        (95) IRSwTSimpleDependencyGraphProof [EQUIVALENT, 0 ms]
        (96) IRSwT
        (97) IntTRSCompressionProof [EQUIVALENT, 5 ms]
        (98) IRSwT
        (99) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
        (100) IRSwT
        (101) IRSwTTerminationDigraphProof [EQUIVALENT, 3 ms]
        (102) IRSwT
        (103) IntTRSCompressionProof [EQUIVALENT, 0 ms]
        (104) IRSwT


----------------------------------------

(0)
Obligation:
Clauses:

f(X) :- ','(isList(X), f(X)).
isList(nil).
isList(cons(X1, xs)) :- isList(xs).


Query: f(g)
----------------------------------------

(1) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

f_in_1: (b)

isList_in_1: (b)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   f_in_g(X) -> U1_g(X, isList_in_g(X))
   isList_in_g(nil) -> isList_out_g(nil)
   isList_in_g(cons(X1, xs)) -> U3_g(X1, isList_in_g(xs))
   U3_g(X1, isList_out_g(xs)) -> isList_out_g(cons(X1, xs))
   U1_g(X, isList_out_g(X)) -> U2_g(X, f_in_g(X))
   U2_g(X, f_out_g(X)) -> f_out_g(X)

The argument filtering Pi contains the following mapping:
f_in_g(x1)  =  f_in_g(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

isList_in_g(x1)  =  isList_in_g(x1)

nil  =  nil

isList_out_g(x1)  =  isList_out_g

cons(x1, x2)  =  cons(x1, x2)

xs  =  xs

U3_g(x1, x2)  =  U3_g(x2)

U2_g(x1, x2)  =  U2_g(x2)

f_out_g(x1)  =  f_out_g





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(2)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   f_in_g(X) -> U1_g(X, isList_in_g(X))
   isList_in_g(nil) -> isList_out_g(nil)
   isList_in_g(cons(X1, xs)) -> U3_g(X1, isList_in_g(xs))
   U3_g(X1, isList_out_g(xs)) -> isList_out_g(cons(X1, xs))
   U1_g(X, isList_out_g(X)) -> U2_g(X, f_in_g(X))
   U2_g(X, f_out_g(X)) -> f_out_g(X)

The argument filtering Pi contains the following mapping:
f_in_g(x1)  =  f_in_g(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

isList_in_g(x1)  =  isList_in_g(x1)

nil  =  nil

isList_out_g(x1)  =  isList_out_g

cons(x1, x2)  =  cons(x1, x2)

xs  =  xs

U3_g(x1, x2)  =  U3_g(x2)

U2_g(x1, x2)  =  U2_g(x2)

f_out_g(x1)  =  f_out_g



----------------------------------------

(3) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   F_IN_G(X) -> U1_G(X, isList_in_g(X))
   F_IN_G(X) -> ISLIST_IN_G(X)
   ISLIST_IN_G(cons(X1, xs)) -> U3_G(X1, isList_in_g(xs))
   ISLIST_IN_G(cons(X1, xs)) -> ISLIST_IN_G(xs)
   U1_G(X, isList_out_g(X)) -> U2_G(X, f_in_g(X))
   U1_G(X, isList_out_g(X)) -> F_IN_G(X)

The TRS R consists of the following rules:

   f_in_g(X) -> U1_g(X, isList_in_g(X))
   isList_in_g(nil) -> isList_out_g(nil)
   isList_in_g(cons(X1, xs)) -> U3_g(X1, isList_in_g(xs))
   U3_g(X1, isList_out_g(xs)) -> isList_out_g(cons(X1, xs))
   U1_g(X, isList_out_g(X)) -> U2_g(X, f_in_g(X))
   U2_g(X, f_out_g(X)) -> f_out_g(X)

The argument filtering Pi contains the following mapping:
f_in_g(x1)  =  f_in_g(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

isList_in_g(x1)  =  isList_in_g(x1)

nil  =  nil

isList_out_g(x1)  =  isList_out_g

cons(x1, x2)  =  cons(x1, x2)

xs  =  xs

U3_g(x1, x2)  =  U3_g(x2)

U2_g(x1, x2)  =  U2_g(x2)

f_out_g(x1)  =  f_out_g

F_IN_G(x1)  =  F_IN_G(x1)

U1_G(x1, x2)  =  U1_G(x1, x2)

ISLIST_IN_G(x1)  =  ISLIST_IN_G(x1)

U3_G(x1, x2)  =  U3_G(x2)

U2_G(x1, x2)  =  U2_G(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(4)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   F_IN_G(X) -> U1_G(X, isList_in_g(X))
   F_IN_G(X) -> ISLIST_IN_G(X)
   ISLIST_IN_G(cons(X1, xs)) -> U3_G(X1, isList_in_g(xs))
   ISLIST_IN_G(cons(X1, xs)) -> ISLIST_IN_G(xs)
   U1_G(X, isList_out_g(X)) -> U2_G(X, f_in_g(X))
   U1_G(X, isList_out_g(X)) -> F_IN_G(X)

The TRS R consists of the following rules:

   f_in_g(X) -> U1_g(X, isList_in_g(X))
   isList_in_g(nil) -> isList_out_g(nil)
   isList_in_g(cons(X1, xs)) -> U3_g(X1, isList_in_g(xs))
   U3_g(X1, isList_out_g(xs)) -> isList_out_g(cons(X1, xs))
   U1_g(X, isList_out_g(X)) -> U2_g(X, f_in_g(X))
   U2_g(X, f_out_g(X)) -> f_out_g(X)

The argument filtering Pi contains the following mapping:
f_in_g(x1)  =  f_in_g(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

isList_in_g(x1)  =  isList_in_g(x1)

nil  =  nil

isList_out_g(x1)  =  isList_out_g

cons(x1, x2)  =  cons(x1, x2)

xs  =  xs

U3_g(x1, x2)  =  U3_g(x2)

U2_g(x1, x2)  =  U2_g(x2)

f_out_g(x1)  =  f_out_g

F_IN_G(x1)  =  F_IN_G(x1)

U1_G(x1, x2)  =  U1_G(x1, x2)

ISLIST_IN_G(x1)  =  ISLIST_IN_G(x1)

U3_G(x1, x2)  =  U3_G(x2)

U2_G(x1, x2)  =  U2_G(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(5) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 4 less nodes.
----------------------------------------

(6)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_G(X, isList_out_g(X)) -> F_IN_G(X)
   F_IN_G(X) -> U1_G(X, isList_in_g(X))

The TRS R consists of the following rules:

   f_in_g(X) -> U1_g(X, isList_in_g(X))
   isList_in_g(nil) -> isList_out_g(nil)
   isList_in_g(cons(X1, xs)) -> U3_g(X1, isList_in_g(xs))
   U3_g(X1, isList_out_g(xs)) -> isList_out_g(cons(X1, xs))
   U1_g(X, isList_out_g(X)) -> U2_g(X, f_in_g(X))
   U2_g(X, f_out_g(X)) -> f_out_g(X)

The argument filtering Pi contains the following mapping:
f_in_g(x1)  =  f_in_g(x1)

U1_g(x1, x2)  =  U1_g(x1, x2)

isList_in_g(x1)  =  isList_in_g(x1)

nil  =  nil

isList_out_g(x1)  =  isList_out_g

cons(x1, x2)  =  cons(x1, x2)

xs  =  xs

U3_g(x1, x2)  =  U3_g(x2)

U2_g(x1, x2)  =  U2_g(x2)

f_out_g(x1)  =  f_out_g

F_IN_G(x1)  =  F_IN_G(x1)

U1_G(x1, x2)  =  U1_G(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(7) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(8)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_G(X, isList_out_g(X)) -> F_IN_G(X)
   F_IN_G(X) -> U1_G(X, isList_in_g(X))

The TRS R consists of the following rules:

   isList_in_g(nil) -> isList_out_g(nil)
   isList_in_g(cons(X1, xs)) -> U3_g(X1, isList_in_g(xs))

The argument filtering Pi contains the following mapping:
isList_in_g(x1)  =  isList_in_g(x1)

nil  =  nil

isList_out_g(x1)  =  isList_out_g

cons(x1, x2)  =  cons(x1, x2)

xs  =  xs

U3_g(x1, x2)  =  U3_g(x2)

F_IN_G(x1)  =  F_IN_G(x1)

U1_G(x1, x2)  =  U1_G(x1, x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(9) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(10)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, isList_out_g) -> F_IN_G(X)
   F_IN_G(X) -> U1_G(X, isList_in_g(X))

The TRS R consists of the following rules:

   isList_in_g(nil) -> isList_out_g
   isList_in_g(cons(X1, xs)) -> U3_g(isList_in_g(xs))

The set Q consists of the following terms:

   isList_in_g(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(11) TransformationProof (SOUND)
By narrowing [LPAR04] the rule F_IN_G(X) -> U1_G(X, isList_in_g(X)) at position [1] we obtained the following new rules [LPAR04]:

   (F_IN_G(nil) -> U1_G(nil, isList_out_g),F_IN_G(nil) -> U1_G(nil, isList_out_g))
   (F_IN_G(cons(x0, xs)) -> U1_G(cons(x0, xs), U3_g(isList_in_g(xs))),F_IN_G(cons(x0, xs)) -> U1_G(cons(x0, xs), U3_g(isList_in_g(xs))))


----------------------------------------

(12)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, isList_out_g) -> F_IN_G(X)
   F_IN_G(nil) -> U1_G(nil, isList_out_g)
   F_IN_G(cons(x0, xs)) -> U1_G(cons(x0, xs), U3_g(isList_in_g(xs)))

The TRS R consists of the following rules:

   isList_in_g(nil) -> isList_out_g
   isList_in_g(cons(X1, xs)) -> U3_g(isList_in_g(xs))

The set Q consists of the following terms:

   isList_in_g(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(13) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(14)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F_IN_G(nil) -> U1_G(nil, isList_out_g)
   U1_G(X, isList_out_g) -> F_IN_G(X)

The TRS R consists of the following rules:

   isList_in_g(nil) -> isList_out_g
   isList_in_g(cons(X1, xs)) -> U3_g(isList_in_g(xs))

The set Q consists of the following terms:

   isList_in_g(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(15) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(16)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F_IN_G(nil) -> U1_G(nil, isList_out_g)
   U1_G(X, isList_out_g) -> F_IN_G(X)

R is empty.
The set Q consists of the following terms:

   isList_in_g(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(17) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   isList_in_g(x0)


----------------------------------------

(18)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F_IN_G(nil) -> U1_G(nil, isList_out_g)
   U1_G(X, isList_out_g) -> F_IN_G(X)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(19) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U1_G(X, isList_out_g) -> F_IN_G(X) we obtained the following new rules [LPAR04]:

   (U1_G(nil, isList_out_g) -> F_IN_G(nil),U1_G(nil, isList_out_g) -> F_IN_G(nil))


----------------------------------------

(20)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F_IN_G(nil) -> U1_G(nil, isList_out_g)
   U1_G(nil, isList_out_g) -> F_IN_G(nil)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(21) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = U1_G(nil, isList_out_g) evaluates to  t =U1_G(nil, isList_out_g)

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

U1_G(nil, isList_out_g) -> F_IN_G(nil)
with rule U1_G(nil, isList_out_g) -> F_IN_G(nil) at position [] and matcher [ ]

F_IN_G(nil) -> U1_G(nil, isList_out_g)
with rule F_IN_G(nil) -> U1_G(nil, isList_out_g)

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(22)
NO

----------------------------------------

(23) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

f_in_1: (b)

isList_in_1: (b)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   f_in_g(X) -> U1_g(X, isList_in_g(X))
   isList_in_g(nil) -> isList_out_g(nil)
   isList_in_g(cons(X1, xs)) -> U3_g(X1, isList_in_g(xs))
   U3_g(X1, isList_out_g(xs)) -> isList_out_g(cons(X1, xs))
   U1_g(X, isList_out_g(X)) -> U2_g(X, f_in_g(X))
   U2_g(X, f_out_g(X)) -> f_out_g(X)

Pi is empty.



Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(24)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   f_in_g(X) -> U1_g(X, isList_in_g(X))
   isList_in_g(nil) -> isList_out_g(nil)
   isList_in_g(cons(X1, xs)) -> U3_g(X1, isList_in_g(xs))
   U3_g(X1, isList_out_g(xs)) -> isList_out_g(cons(X1, xs))
   U1_g(X, isList_out_g(X)) -> U2_g(X, f_in_g(X))
   U2_g(X, f_out_g(X)) -> f_out_g(X)

Pi is empty.

----------------------------------------

(25) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   F_IN_G(X) -> U1_G(X, isList_in_g(X))
   F_IN_G(X) -> ISLIST_IN_G(X)
   ISLIST_IN_G(cons(X1, xs)) -> U3_G(X1, isList_in_g(xs))
   ISLIST_IN_G(cons(X1, xs)) -> ISLIST_IN_G(xs)
   U1_G(X, isList_out_g(X)) -> U2_G(X, f_in_g(X))
   U1_G(X, isList_out_g(X)) -> F_IN_G(X)

The TRS R consists of the following rules:

   f_in_g(X) -> U1_g(X, isList_in_g(X))
   isList_in_g(nil) -> isList_out_g(nil)
   isList_in_g(cons(X1, xs)) -> U3_g(X1, isList_in_g(xs))
   U3_g(X1, isList_out_g(xs)) -> isList_out_g(cons(X1, xs))
   U1_g(X, isList_out_g(X)) -> U2_g(X, f_in_g(X))
   U2_g(X, f_out_g(X)) -> f_out_g(X)

Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(26)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   F_IN_G(X) -> U1_G(X, isList_in_g(X))
   F_IN_G(X) -> ISLIST_IN_G(X)
   ISLIST_IN_G(cons(X1, xs)) -> U3_G(X1, isList_in_g(xs))
   ISLIST_IN_G(cons(X1, xs)) -> ISLIST_IN_G(xs)
   U1_G(X, isList_out_g(X)) -> U2_G(X, f_in_g(X))
   U1_G(X, isList_out_g(X)) -> F_IN_G(X)

The TRS R consists of the following rules:

   f_in_g(X) -> U1_g(X, isList_in_g(X))
   isList_in_g(nil) -> isList_out_g(nil)
   isList_in_g(cons(X1, xs)) -> U3_g(X1, isList_in_g(xs))
   U3_g(X1, isList_out_g(xs)) -> isList_out_g(cons(X1, xs))
   U1_g(X, isList_out_g(X)) -> U2_g(X, f_in_g(X))
   U2_g(X, f_out_g(X)) -> f_out_g(X)

Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(27) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 4 less nodes.
----------------------------------------

(28)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_G(X, isList_out_g(X)) -> F_IN_G(X)
   F_IN_G(X) -> U1_G(X, isList_in_g(X))

The TRS R consists of the following rules:

   f_in_g(X) -> U1_g(X, isList_in_g(X))
   isList_in_g(nil) -> isList_out_g(nil)
   isList_in_g(cons(X1, xs)) -> U3_g(X1, isList_in_g(xs))
   U3_g(X1, isList_out_g(xs)) -> isList_out_g(cons(X1, xs))
   U1_g(X, isList_out_g(X)) -> U2_g(X, f_in_g(X))
   U2_g(X, f_out_g(X)) -> f_out_g(X)

Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(29) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(30)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_G(X, isList_out_g(X)) -> F_IN_G(X)
   F_IN_G(X) -> U1_G(X, isList_in_g(X))

The TRS R consists of the following rules:

   isList_in_g(nil) -> isList_out_g(nil)
   isList_in_g(cons(X1, xs)) -> U3_g(X1, isList_in_g(xs))

Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(31) PiDPToQDPProof (EQUIVALENT)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(32)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, isList_out_g(X)) -> F_IN_G(X)
   F_IN_G(X) -> U1_G(X, isList_in_g(X))

The TRS R consists of the following rules:

   isList_in_g(nil) -> isList_out_g(nil)
   isList_in_g(cons(X1, xs)) -> U3_g(X1, isList_in_g(xs))

The set Q consists of the following terms:

   isList_in_g(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(33) UsableRulesReductionPairsProof (EQUIVALENT)
By using the usable rules with reduction pair processor [LPAR04] with a polynomial ordering [POLO], all dependency pairs and the corresponding usable rules [FROCOS05] can be oriented non-strictly. All non-usable rules are removed, and those dependency pairs and usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

No dependency pairs are removed.

The following rules are removed from R:

   isList_in_g(cons(X1, xs)) -> U3_g(X1, isList_in_g(xs))
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(F_IN_G(x_1)) = 2*x_1
   POL(U1_G(x_1, x_2)) = x_1 + x_2
   POL(U3_g(x_1, x_2)) = 2*x_1 + x_2
   POL(cons(x_1, x_2)) = 2 + 2*x_1 + x_2
   POL(isList_in_g(x_1)) = x_1
   POL(isList_out_g(x_1)) = 2*x_1
   POL(nil) = 0
   POL(xs) = 2


----------------------------------------

(34)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, isList_out_g(X)) -> F_IN_G(X)
   F_IN_G(X) -> U1_G(X, isList_in_g(X))

The TRS R consists of the following rules:

   isList_in_g(nil) -> isList_out_g(nil)

The set Q consists of the following terms:

   isList_in_g(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(35) TransformationProof (SOUND)
By narrowing [LPAR04] the rule F_IN_G(X) -> U1_G(X, isList_in_g(X)) at position [1] we obtained the following new rules [LPAR04]:

   (F_IN_G(nil) -> U1_G(nil, isList_out_g(nil)),F_IN_G(nil) -> U1_G(nil, isList_out_g(nil)))


----------------------------------------

(36)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, isList_out_g(X)) -> F_IN_G(X)
   F_IN_G(nil) -> U1_G(nil, isList_out_g(nil))

The TRS R consists of the following rules:

   isList_in_g(nil) -> isList_out_g(nil)

The set Q consists of the following terms:

   isList_in_g(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(37) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(38)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, isList_out_g(X)) -> F_IN_G(X)
   F_IN_G(nil) -> U1_G(nil, isList_out_g(nil))

R is empty.
The set Q consists of the following terms:

   isList_in_g(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(39) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   isList_in_g(x0)


----------------------------------------

(40)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_G(X, isList_out_g(X)) -> F_IN_G(X)
   F_IN_G(nil) -> U1_G(nil, isList_out_g(nil))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(41) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U1_G(X, isList_out_g(X)) -> F_IN_G(X) we obtained the following new rules [LPAR04]:

   (U1_G(nil, isList_out_g(nil)) -> F_IN_G(nil),U1_G(nil, isList_out_g(nil)) -> F_IN_G(nil))


----------------------------------------

(42)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F_IN_G(nil) -> U1_G(nil, isList_out_g(nil))
   U1_G(nil, isList_out_g(nil)) -> F_IN_G(nil)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(43) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = U1_G(nil, isList_out_g(nil)) evaluates to  t =U1_G(nil, isList_out_g(nil))

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

U1_G(nil, isList_out_g(nil)) -> F_IN_G(nil)
with rule U1_G(nil, isList_out_g(nil)) -> F_IN_G(nil) at position [] and matcher [ ]

F_IN_G(nil) -> U1_G(nil, isList_out_g(nil))
with rule F_IN_G(nil) -> U1_G(nil, isList_out_g(nil))

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(44)
NO

----------------------------------------

(45) PrologToDTProblemTransformerProof (SOUND)
Built DT problem from termination graph DT10.

{
    "root": 107,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(f X)",
                "(',' (isList X) (f X))"
            ],
            [
                "(isList (nil))",
                null
            ],
            [
                "(isList (cons X1 (xs)))",
                "(isList (xs))"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "type": "Nodes",
            "120": {
                "goal": [{
                    "clause": 2,
                    "scope": 3,
                    "term": "(isList (xs))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "110": {
                "goal": [
                    {
                        "clause": 1,
                        "scope": 2,
                        "term": "(',' (isList T3) (f T3))"
                    },
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(',' (isList T3) (f T3))"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T3"],
                    "free": [],
                    "exprvars": []
                }
            },
            "121": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "111": {
                "goal": [{
                    "clause": 1,
                    "scope": 2,
                    "term": "(',' (isList T3) (f T3))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T3"],
                    "free": [],
                    "exprvars": []
                }
            },
            "112": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(',' (isList T3) (f T3))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T3"],
                    "free": [],
                    "exprvars": []
                }
            },
            "113": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(f (nil))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "114": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "115": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (isList (xs)) (f (cons T6 (xs))))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T6"],
                    "free": [],
                    "exprvars": []
                }
            },
            "116": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "117": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(isList (xs))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "107": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(f T1)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "118": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(f (cons T6 (xs)))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T6"],
                    "free": [],
                    "exprvars": []
                }
            },
            "108": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(f T1)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "119": {
                "goal": [
                    {
                        "clause": 1,
                        "scope": 3,
                        "term": "(isList (xs))"
                    },
                    {
                        "clause": 2,
                        "scope": 3,
                        "term": "(isList (xs))"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "109": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (isList T3) (f T3))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T3"],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 107,
                "to": 108,
                "label": "CASE"
            },
            {
                "from": 108,
                "to": 109,
                "label": "ONLY EVAL with clause\nf(X3) :- ','(isList(X3), f(X3)).\nand substitutionT1 -> T3,\nX3 -> T3"
            },
            {
                "from": 109,
                "to": 110,
                "label": "CASE"
            },
            {
                "from": 110,
                "to": 111,
                "label": "PARALLEL"
            },
            {
                "from": 110,
                "to": 112,
                "label": "PARALLEL"
            },
            {
                "from": 111,
                "to": 113,
                "label": "EVAL with clause\nisList(nil).\nand substitutionT3 -> nil"
            },
            {
                "from": 111,
                "to": 114,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 112,
                "to": 115,
                "label": "EVAL with clause\nisList(cons(X7, xs)) :- isList(xs).\nand substitutionX7 -> T6,\nT3 -> cons(T6, xs)"
            },
            {
                "from": 112,
                "to": 116,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 113,
                "to": 107,
                "label": "INSTANCE with matching:\nT1 -> nil"
            },
            {
                "from": 115,
                "to": 117,
                "label": "SPLIT 1"
            },
            {
                "from": 115,
                "to": 118,
                "label": "SPLIT 2"
            },
            {
                "from": 117,
                "to": 119,
                "label": "CASE"
            },
            {
                "from": 118,
                "to": 107,
                "label": "INSTANCE with matching:\nT1 -> cons(T6, xs)"
            },
            {
                "from": 119,
                "to": 120,
                "label": "BACKTRACK\nfor clause: isList(nil)because of non-unification"
            },
            {
                "from": 120,
                "to": 121,
                "label": "BACKTRACK\nfor clause: isList(cons(X1, xs)) :- isList(xs)because of non-unification"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(46)
Obligation:
Triples:

fA(nil) :- fA(nil).
fA(cons(X1, xs)) :- ','(isListcB, fA(cons(X1, xs))).

Clauses:

fcA(nil) :- fcA(nil).
fcA(cons(X1, xs)) :- ','(isListcB, fcA(cons(X1, xs))).

Afs:

fA(x1)  =  fA(x1)


----------------------------------------

(47) UndefinedPredicateInTriplesTransformerProof (SOUND)
Deleted triples and predicates having undefined goals [DT09].
----------------------------------------

(48)
Obligation:
Triples:

fA(nil) :- fA(nil).

Clauses:

fcA(nil) :- fcA(nil).

Afs:

fA(x1)  =  fA(x1)


----------------------------------------

(49) TriplesToPiDPProof (SOUND)
We use the technique of [DT09]. With regard to the inferred argument filtering the predicates were used in the following modes:

fA_in_1: (b)

Transforming TRIPLES into the following Term Rewriting System:

Pi DP problem:
The TRS P consists of the following rules:

   FA_IN_G(nil) -> U1_G(fA_in_g(nil))
   FA_IN_G(nil) -> FA_IN_G(nil)

R is empty.
Pi is empty.
We have to consider all (P,R,Pi)-chains


Infinitary Constructor Rewriting Termination of PiDP implies Termination of TRIPLES



----------------------------------------

(50)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   FA_IN_G(nil) -> U1_G(fA_in_g(nil))
   FA_IN_G(nil) -> FA_IN_G(nil)

R is empty.
Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(51) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 1 less node.
----------------------------------------

(52)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   FA_IN_G(nil) -> FA_IN_G(nil)

R is empty.
Pi is empty.
We have to consider all (P,R,Pi)-chains
----------------------------------------

(53) PiDPToQDPProof (EQUIVALENT)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(54)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   FA_IN_G(nil) -> FA_IN_G(nil)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(55) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by semiunifying a rule from P directly.

s = FA_IN_G(nil) evaluates to  t =FA_IN_G(nil)

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

The DP semiunifies directly so there is only one rewrite step from FA_IN_G(nil) to FA_IN_G(nil).




----------------------------------------

(56)
NO

----------------------------------------

(57) PrologToTRSTransformerProof (SOUND)
Transformed Prolog program to TRS.

{
    "root": 1,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(f X)",
                "(',' (isList X) (f X))"
            ],
            [
                "(isList (nil))",
                null
            ],
            [
                "(isList (cons X1 (xs)))",
                "(isList (xs))"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "22": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "12": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (isList T4) (f T4))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [],
                    "exprvars": []
                }
            },
            "45": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(isList (xs))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "13": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(isList T4)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [],
                    "exprvars": []
                }
            },
            "46": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "14": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(f T4)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [],
                    "exprvars": []
                }
            },
            "15": {
                "goal": [
                    {
                        "clause": 1,
                        "scope": 2,
                        "term": "(isList T4)"
                    },
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(isList T4)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [],
                    "exprvars": []
                }
            },
            "16": {
                "goal": [{
                    "clause": 1,
                    "scope": 2,
                    "term": "(isList T4)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [],
                    "exprvars": []
                }
            },
            "17": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(isList T4)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [],
                    "exprvars": []
                }
            },
            "18": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "1": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(f T1)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "3": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(f T1)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "42": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 1,
                "to": 3,
                "label": "CASE"
            },
            {
                "from": 3,
                "to": 12,
                "label": "ONLY EVAL with clause\nf(X4) :- ','(isList(X4), f(X4)).\nand substitutionT1 -> T4,\nX4 -> T4"
            },
            {
                "from": 12,
                "to": 13,
                "label": "SPLIT 1"
            },
            {
                "from": 12,
                "to": 14,
                "label": "SPLIT 2\nnew knowledge:\nT4 is ground"
            },
            {
                "from": 13,
                "to": 15,
                "label": "CASE"
            },
            {
                "from": 14,
                "to": 1,
                "label": "INSTANCE with matching:\nT1 -> T4"
            },
            {
                "from": 15,
                "to": 16,
                "label": "PARALLEL"
            },
            {
                "from": 15,
                "to": 17,
                "label": "PARALLEL"
            },
            {
                "from": 16,
                "to": 18,
                "label": "EVAL with clause\nisList(nil).\nand substitutionT4 -> nil"
            },
            {
                "from": 16,
                "to": 22,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 17,
                "to": 45,
                "label": "EVAL with clause\nisList(cons(X7, xs)) :- isList(xs).\nand substitutionX7 -> T7,\nT4 -> cons(T7, xs)"
            },
            {
                "from": 17,
                "to": 46,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 18,
                "to": 42,
                "label": "SUCCESS"
            },
            {
                "from": 45,
                "to": 13,
                "label": "INSTANCE with matching:\nT4 -> xs"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(58)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f1_in(T4) -> U1(f12_in(T4), T4)
   U1(f12_out1, T4) -> f1_out1
   f13_in(nil) -> f13_out1
   f13_in(cons(T7, xs)) -> U2(f13_in(xs), cons(T7, xs))
   U2(f13_out1, cons(T7, xs)) -> f13_out1
   f12_in(T4) -> U3(f13_in(T4), T4)
   U3(f13_out1, T4) -> U4(f1_in(T4), T4)
   U4(f1_out1, T4) -> f12_out1

Q is empty.

----------------------------------------

(59) Overlay + Local Confluence (EQUIVALENT)
The TRS is overlay and locally confluent. By [NOC] we can switch to innermost.
----------------------------------------

(60)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f1_in(T4) -> U1(f12_in(T4), T4)
   U1(f12_out1, T4) -> f1_out1
   f13_in(nil) -> f13_out1
   f13_in(cons(T7, xs)) -> U2(f13_in(xs), cons(T7, xs))
   U2(f13_out1, cons(T7, xs)) -> f13_out1
   f12_in(T4) -> U3(f13_in(T4), T4)
   U3(f13_out1, T4) -> U4(f1_in(T4), T4)
   U4(f1_out1, T4) -> f12_out1

The set Q consists of the following terms:

   f1_in(x0)
   U1(f12_out1, x0)
   f13_in(nil)
   f13_in(cons(x0, xs))
   U2(f13_out1, cons(x0, xs))
   f12_in(x0)
   U3(f13_out1, x0)
   U4(f1_out1, x0)


----------------------------------------

(61) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(62)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(T4) -> U1^1(f12_in(T4), T4)
   F1_IN(T4) -> F12_IN(T4)
   F13_IN(cons(T7, xs)) -> U2^1(f13_in(xs), cons(T7, xs))
   F13_IN(cons(T7, xs)) -> F13_IN(xs)
   F12_IN(T4) -> U3^1(f13_in(T4), T4)
   F12_IN(T4) -> F13_IN(T4)
   U3^1(f13_out1, T4) -> U4^1(f1_in(T4), T4)
   U3^1(f13_out1, T4) -> F1_IN(T4)

The TRS R consists of the following rules:

   f1_in(T4) -> U1(f12_in(T4), T4)
   U1(f12_out1, T4) -> f1_out1
   f13_in(nil) -> f13_out1
   f13_in(cons(T7, xs)) -> U2(f13_in(xs), cons(T7, xs))
   U2(f13_out1, cons(T7, xs)) -> f13_out1
   f12_in(T4) -> U3(f13_in(T4), T4)
   U3(f13_out1, T4) -> U4(f1_in(T4), T4)
   U4(f1_out1, T4) -> f12_out1

The set Q consists of the following terms:

   f1_in(x0)
   U1(f12_out1, x0)
   f13_in(nil)
   f13_in(cons(x0, xs))
   U2(f13_out1, cons(x0, xs))
   f12_in(x0)
   U3(f13_out1, x0)
   U4(f1_out1, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(63) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 5 less nodes.
----------------------------------------

(64)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(T4) -> F12_IN(T4)
   F12_IN(T4) -> U3^1(f13_in(T4), T4)
   U3^1(f13_out1, T4) -> F1_IN(T4)

The TRS R consists of the following rules:

   f1_in(T4) -> U1(f12_in(T4), T4)
   U1(f12_out1, T4) -> f1_out1
   f13_in(nil) -> f13_out1
   f13_in(cons(T7, xs)) -> U2(f13_in(xs), cons(T7, xs))
   U2(f13_out1, cons(T7, xs)) -> f13_out1
   f12_in(T4) -> U3(f13_in(T4), T4)
   U3(f13_out1, T4) -> U4(f1_in(T4), T4)
   U4(f1_out1, T4) -> f12_out1

The set Q consists of the following terms:

   f1_in(x0)
   U1(f12_out1, x0)
   f13_in(nil)
   f13_in(cons(x0, xs))
   U2(f13_out1, cons(x0, xs))
   f12_in(x0)
   U3(f13_out1, x0)
   U4(f1_out1, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(65) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(66)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(T4) -> F12_IN(T4)
   F12_IN(T4) -> U3^1(f13_in(T4), T4)
   U3^1(f13_out1, T4) -> F1_IN(T4)

The TRS R consists of the following rules:

   f13_in(nil) -> f13_out1
   f13_in(cons(T7, xs)) -> U2(f13_in(xs), cons(T7, xs))

The set Q consists of the following terms:

   f1_in(x0)
   U1(f12_out1, x0)
   f13_in(nil)
   f13_in(cons(x0, xs))
   U2(f13_out1, cons(x0, xs))
   f12_in(x0)
   U3(f13_out1, x0)
   U4(f1_out1, x0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(67) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   f1_in(x0)
   U1(f12_out1, x0)
   f12_in(x0)
   U3(f13_out1, x0)
   U4(f1_out1, x0)


----------------------------------------

(68)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(T4) -> F12_IN(T4)
   F12_IN(T4) -> U3^1(f13_in(T4), T4)
   U3^1(f13_out1, T4) -> F1_IN(T4)

The TRS R consists of the following rules:

   f13_in(nil) -> f13_out1
   f13_in(cons(T7, xs)) -> U2(f13_in(xs), cons(T7, xs))

The set Q consists of the following terms:

   f13_in(nil)
   f13_in(cons(x0, xs))
   U2(f13_out1, cons(x0, xs))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(69) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule F12_IN(T4) -> U3^1(f13_in(T4), T4) at position [0] we obtained the following new rules [LPAR04]:

   (F12_IN(nil) -> U3^1(f13_out1, nil),F12_IN(nil) -> U3^1(f13_out1, nil))
   (F12_IN(cons(x0, xs)) -> U3^1(U2(f13_in(xs), cons(x0, xs)), cons(x0, xs)),F12_IN(cons(x0, xs)) -> U3^1(U2(f13_in(xs), cons(x0, xs)), cons(x0, xs)))


----------------------------------------

(70)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F1_IN(T4) -> F12_IN(T4)
   U3^1(f13_out1, T4) -> F1_IN(T4)
   F12_IN(nil) -> U3^1(f13_out1, nil)
   F12_IN(cons(x0, xs)) -> U3^1(U2(f13_in(xs), cons(x0, xs)), cons(x0, xs))

The TRS R consists of the following rules:

   f13_in(nil) -> f13_out1
   f13_in(cons(T7, xs)) -> U2(f13_in(xs), cons(T7, xs))

The set Q consists of the following terms:

   f13_in(nil)
   f13_in(cons(x0, xs))
   U2(f13_out1, cons(x0, xs))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(71) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(72)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F12_IN(nil) -> U3^1(f13_out1, nil)
   U3^1(f13_out1, T4) -> F1_IN(T4)
   F1_IN(T4) -> F12_IN(T4)

The TRS R consists of the following rules:

   f13_in(nil) -> f13_out1
   f13_in(cons(T7, xs)) -> U2(f13_in(xs), cons(T7, xs))

The set Q consists of the following terms:

   f13_in(nil)
   f13_in(cons(x0, xs))
   U2(f13_out1, cons(x0, xs))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(73) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(74)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F12_IN(nil) -> U3^1(f13_out1, nil)
   U3^1(f13_out1, T4) -> F1_IN(T4)
   F1_IN(T4) -> F12_IN(T4)

R is empty.
The set Q consists of the following terms:

   f13_in(nil)
   f13_in(cons(x0, xs))
   U2(f13_out1, cons(x0, xs))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(75) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   f13_in(nil)
   f13_in(cons(x0, xs))
   U2(f13_out1, cons(x0, xs))


----------------------------------------

(76)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F12_IN(nil) -> U3^1(f13_out1, nil)
   U3^1(f13_out1, T4) -> F1_IN(T4)
   F1_IN(T4) -> F12_IN(T4)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(77) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U3^1(f13_out1, T4) -> F1_IN(T4) we obtained the following new rules [LPAR04]:

   (U3^1(f13_out1, nil) -> F1_IN(nil),U3^1(f13_out1, nil) -> F1_IN(nil))


----------------------------------------

(78)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F12_IN(nil) -> U3^1(f13_out1, nil)
   F1_IN(T4) -> F12_IN(T4)
   U3^1(f13_out1, nil) -> F1_IN(nil)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(79) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule F1_IN(T4) -> F12_IN(T4) we obtained the following new rules [LPAR04]:

   (F1_IN(nil) -> F12_IN(nil),F1_IN(nil) -> F12_IN(nil))


----------------------------------------

(80)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F12_IN(nil) -> U3^1(f13_out1, nil)
   U3^1(f13_out1, nil) -> F1_IN(nil)
   F1_IN(nil) -> F12_IN(nil)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(81) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = U3^1(f13_out1, nil) evaluates to  t =U3^1(f13_out1, nil)

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

U3^1(f13_out1, nil) -> F1_IN(nil)
with rule U3^1(f13_out1, nil) -> F1_IN(nil) at position [] and matcher [ ]

F1_IN(nil) -> F12_IN(nil)
with rule F1_IN(nil) -> F12_IN(nil) at position [] and matcher [ ]

F12_IN(nil) -> U3^1(f13_out1, nil)
with rule F12_IN(nil) -> U3^1(f13_out1, nil)

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(82)
NO

----------------------------------------

(83) PrologToIRSwTTransformerProof (SOUND)
Transformed Prolog program to IRSwT according to method in Master Thesis of A. Weinert

{
    "root": 2,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(f X)",
                "(',' (isList X) (f X))"
            ],
            [
                "(isList (nil))",
                null
            ],
            [
                "(isList (cons X1 (xs)))",
                "(isList (xs))"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "56": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(isList T4)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [],
                    "exprvars": []
                }
            },
            "68": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(isList (xs))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "47": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (isList T4) (f T4))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [],
                    "exprvars": []
                }
            },
            "69": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "59": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "2": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(f T1)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "4": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(f T1)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "60": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "50": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(isList T4)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [],
                    "exprvars": []
                }
            },
            "51": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(f T4)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [],
                    "exprvars": []
                }
            },
            "62": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "52": {
                "goal": [
                    {
                        "clause": 1,
                        "scope": 2,
                        "term": "(isList T4)"
                    },
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(isList T4)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [],
                    "exprvars": []
                }
            },
            "54": {
                "goal": [{
                    "clause": 1,
                    "scope": 2,
                    "term": "(isList T4)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T4"],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 2,
                "to": 4,
                "label": "CASE"
            },
            {
                "from": 4,
                "to": 47,
                "label": "ONLY EVAL with clause\nf(X4) :- ','(isList(X4), f(X4)).\nand substitutionT1 -> T4,\nX4 -> T4"
            },
            {
                "from": 47,
                "to": 50,
                "label": "SPLIT 1"
            },
            {
                "from": 47,
                "to": 51,
                "label": "SPLIT 2\nnew knowledge:\nT4 is ground"
            },
            {
                "from": 50,
                "to": 52,
                "label": "CASE"
            },
            {
                "from": 51,
                "to": 2,
                "label": "INSTANCE with matching:\nT1 -> T4"
            },
            {
                "from": 52,
                "to": 54,
                "label": "PARALLEL"
            },
            {
                "from": 52,
                "to": 56,
                "label": "PARALLEL"
            },
            {
                "from": 54,
                "to": 59,
                "label": "EVAL with clause\nisList(nil).\nand substitutionT4 -> nil"
            },
            {
                "from": 54,
                "to": 60,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 56,
                "to": 68,
                "label": "EVAL with clause\nisList(cons(X7, xs)) :- isList(xs).\nand substitutionX7 -> T7,\nT4 -> cons(T7, xs)"
            },
            {
                "from": 56,
                "to": 69,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 59,
                "to": 62,
                "label": "SUCCESS"
            },
            {
                "from": 68,
                "to": 50,
                "label": "INSTANCE with matching:\nT4 -> xs"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(84)
Complex Obligation (AND)

----------------------------------------

(85)
Obligation:
Rules:
f68_out -> f56_out(cons(T7, xs)) :|: TRUE
f56_in(T4) -> f69_in :|: TRUE
f56_in(cons(x, xs)) -> f68_in :|: TRUE
f69_out -> f56_out(x1) :|: TRUE
f50_in(x2) -> f52_in(x2) :|: TRUE
f52_out(x3) -> f50_out(x3) :|: TRUE
f52_in(x4) -> f54_in(x4) :|: TRUE
f52_in(x5) -> f56_in(x5) :|: TRUE
f54_out(x6) -> f52_out(x6) :|: TRUE
f56_out(x7) -> f52_out(x7) :|: TRUE
f68_in -> f50_in(xs) :|: TRUE
f50_out(xs) -> f68_out :|: TRUE
f2_in(T1) -> f4_in(T1) :|: TRUE
f4_out(x8) -> f2_out(x8) :|: TRUE
f47_out(x9) -> f4_out(x9) :|: TRUE
f4_in(x10) -> f47_in(x10) :|: TRUE
f51_out(x11) -> f47_out(x11) :|: TRUE
f47_in(x12) -> f50_in(x12) :|: TRUE
f50_out(x13) -> f51_in(x13) :|: TRUE
Start term: f2_in(T1)

----------------------------------------

(86) IRSwTSimpleDependencyGraphProof (EQUIVALENT)
Constructed simple dependency graph.

Simplified to the following IRSwTs:

intTRSProblem:
f56_in(cons(x, xs)) -> f68_in :|: TRUE
f50_in(x2) -> f52_in(x2) :|: TRUE
f52_in(x5) -> f56_in(x5) :|: TRUE
f68_in -> f50_in(xs) :|: TRUE


----------------------------------------

(87)
Obligation:
Rules:
f56_in(cons(x, xs)) -> f68_in :|: TRUE
f50_in(x2) -> f52_in(x2) :|: TRUE
f52_in(x5) -> f56_in(x5) :|: TRUE
f68_in -> f50_in(xs) :|: TRUE

----------------------------------------

(88) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(89)
Obligation:
Rules:
f50_in(cons(x:0, xs)) -> f50_in(xs) :|: TRUE

----------------------------------------

(90) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(91)
Obligation:
Rules:
f50_in(cons(x:0, xs)) -> f50_in(xs) :|: TRUE

----------------------------------------

(92) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f50_in(cons(x:0, xs)) -> f50_in(xs) :|: TRUE

No arcs!

This digraph is fully evaluated!
----------------------------------------

(93)
TRUE

----------------------------------------

(94)
Obligation:
Rules:
f50_in(T4) -> f52_in(T4) :|: TRUE
f52_out(x) -> f50_out(x) :|: TRUE
f68_out -> f56_out(cons(T7, xs)) :|: TRUE
f56_in(x1) -> f69_in :|: TRUE
f56_in(cons(x2, xs)) -> f68_in :|: TRUE
f69_out -> f56_out(x3) :|: TRUE
f47_out(x4) -> f4_out(x4) :|: TRUE
f4_in(x5) -> f47_in(x5) :|: TRUE
f68_in -> f50_in(xs) :|: TRUE
f50_out(xs) -> f68_out :|: TRUE
f59_out -> f54_out(nil) :|: TRUE
f54_in(nil) -> f59_in :|: TRUE
f54_in(x6) -> f60_in :|: TRUE
f60_out -> f54_out(x7) :|: TRUE
f51_out(x8) -> f47_out(x8) :|: TRUE
f47_in(x9) -> f50_in(x9) :|: TRUE
f50_out(x10) -> f51_in(x10) :|: TRUE
f2_out(x11) -> f51_out(x11) :|: TRUE
f51_in(x12) -> f2_in(x12) :|: TRUE
f52_in(x13) -> f54_in(x13) :|: TRUE
f52_in(x14) -> f56_in(x14) :|: TRUE
f54_out(x15) -> f52_out(x15) :|: TRUE
f56_out(x16) -> f52_out(x16) :|: TRUE
f59_in -> f59_out :|: TRUE
f2_in(T1) -> f4_in(T1) :|: TRUE
f4_out(x17) -> f2_out(x17) :|: TRUE
Start term: f2_in(T1)

----------------------------------------

(95) IRSwTSimpleDependencyGraphProof (EQUIVALENT)
Constructed simple dependency graph.

Simplified to the following IRSwTs:

intTRSProblem:
f50_in(T4) -> f52_in(T4) :|: TRUE
f52_out(x) -> f50_out(x) :|: TRUE
f68_out -> f56_out(cons(T7, xs)) :|: TRUE
f56_in(cons(x2, xs)) -> f68_in :|: TRUE
f4_in(x5) -> f47_in(x5) :|: TRUE
f68_in -> f50_in(xs) :|: TRUE
f50_out(xs) -> f68_out :|: TRUE
f59_out -> f54_out(nil) :|: TRUE
f54_in(nil) -> f59_in :|: TRUE
f47_in(x9) -> f50_in(x9) :|: TRUE
f50_out(x10) -> f51_in(x10) :|: TRUE
f51_in(x12) -> f2_in(x12) :|: TRUE
f52_in(x13) -> f54_in(x13) :|: TRUE
f52_in(x14) -> f56_in(x14) :|: TRUE
f54_out(x15) -> f52_out(x15) :|: TRUE
f56_out(x16) -> f52_out(x16) :|: TRUE
f59_in -> f59_out :|: TRUE
f2_in(T1) -> f4_in(T1) :|: TRUE


----------------------------------------

(96)
Obligation:
Rules:
f50_in(T4) -> f52_in(T4) :|: TRUE
f52_out(x) -> f50_out(x) :|: TRUE
f68_out -> f56_out(cons(T7, xs)) :|: TRUE
f56_in(cons(x2, xs)) -> f68_in :|: TRUE
f4_in(x5) -> f47_in(x5) :|: TRUE
f68_in -> f50_in(xs) :|: TRUE
f50_out(xs) -> f68_out :|: TRUE
f59_out -> f54_out(nil) :|: TRUE
f54_in(nil) -> f59_in :|: TRUE
f47_in(x9) -> f50_in(x9) :|: TRUE
f50_out(x10) -> f51_in(x10) :|: TRUE
f51_in(x12) -> f2_in(x12) :|: TRUE
f52_in(x13) -> f54_in(x13) :|: TRUE
f52_in(x14) -> f56_in(x14) :|: TRUE
f54_out(x15) -> f52_out(x15) :|: TRUE
f56_out(x16) -> f52_out(x16) :|: TRUE
f59_in -> f59_out :|: TRUE
f2_in(T1) -> f4_in(T1) :|: TRUE

----------------------------------------

(97) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(98)
Obligation:
Rules:
f52_out(x:0) -> f50_in(x:0) :|: TRUE
f50_in(nil) -> f52_out(nil) :|: TRUE
f50_in(cons(x2:0, xs)) -> f50_in(xs) :|: TRUE
f52_out(xs) -> f52_out(cons(T7:0, xs)) :|: TRUE

----------------------------------------

(99) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(100)
Obligation:
Rules:
f52_out(x:0) -> f50_in(x:0) :|: TRUE
f50_in(nil) -> f52_out(nil) :|: TRUE
f50_in(cons(x2:0, xs)) -> f50_in(xs) :|: TRUE
f52_out(xs) -> f52_out(cons(T7:0, xs)) :|: TRUE

----------------------------------------

(101) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f52_out(x:0) -> f50_in(x:0) :|: TRUE
(2) f50_in(nil) -> f52_out(nil) :|: TRUE
(3) f50_in(cons(x2:0, xs)) -> f50_in(xs) :|: TRUE
(4) f52_out(xs) -> f52_out(cons(T7:0, xs)) :|: TRUE

Arcs:
(1) -> (2), (3)
(2) -> (1)
(4) -> (1)

This digraph is fully evaluated!
----------------------------------------

(102)
Obligation:

Termination digraph:
Nodes:
(1) f52_out(x:0) -> f50_in(x:0) :|: TRUE
(2) f50_in(nil) -> f52_out(nil) :|: TRUE

Arcs:
(1) -> (2)
(2) -> (1)

This digraph is fully evaluated!

----------------------------------------

(103) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(104)
Obligation:
Rules:
f52_out(nil) -> f52_out(nil) :|: TRUE
