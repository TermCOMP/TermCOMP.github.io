MAYBE
proof of /hpcwork/ff862203/termcomp25/benchmarks/QPVnv.pl
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Left Termination of the query pattern

add(a,g,a)

w.r.t. the given Prolog program could not be shown:

(0) Prolog
(1) CutEliminatorProof [SOUND, 0 ms]
(2) Prolog
    (3) PrologToPiTRSProof [SOUND, 0 ms]
    (4) PiTRS
        (5) DependencyPairsProof [EQUIVALENT, 0 ms]
        (6) PiDP
        (7) DependencyGraphProof [EQUIVALENT, 0 ms]
        (8) PiDP
        (9) UsableRulesProof [EQUIVALENT, 0 ms]
        (10) PiDP
        (11) PiDPToQDPProof [SOUND, 0 ms]
        (12) QDP
        (13) TransformationProof [SOUND, 0 ms]
        (14) QDP
        (15) UsableRulesProof [EQUIVALENT, 0 ms]
        (16) QDP
        (17) QReductionProof [EQUIVALENT, 0 ms]
        (18) QDP
        (19) TransformationProof [EQUIVALENT, 0 ms]
        (20) QDP
        (21) DependencyGraphProof [EQUIVALENT, 0 ms]
        (22) AND
            (23) QDP
                (24) NonTerminationLoopProof [COMPLETE, 0 ms]
                (25) NO
            (26) QDP
                (27) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                (28) YES
    (29) PrologToPiTRSProof [SOUND, 0 ms]
    (30) PiTRS
        (31) DependencyPairsProof [EQUIVALENT, 0 ms]
        (32) PiDP
        (33) DependencyGraphProof [EQUIVALENT, 0 ms]
        (34) PiDP
        (35) UsableRulesProof [EQUIVALENT, 0 ms]
        (36) PiDP
        (37) PiDPToQDPProof [SOUND, 0 ms]
        (38) QDP
        (39) UsableRulesReductionPairsProof [EQUIVALENT, 12 ms]
        (40) QDP
(41) PrologToDTProblemTransformerProof [SOUND, 0 ms]
(42) TRIPLES
    (43) TriplesToPiDPProof [SOUND, 0 ms]
    (44) PiDP
    (45) DependencyGraphProof [EQUIVALENT, 0 ms]
    (46) AND
        (47) PiDP
            (48) PiDPToQDPProof [SOUND, 0 ms]
            (49) QDP
            (50) NonTerminationLoopProof [COMPLETE, 0 ms]
            (51) NO
        (52) PiDP
            (53) PiDPToQDPProof [SOUND, 0 ms]
            (54) QDP
            (55) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (56) YES
(57) PrologToTRSTransformerProof [SOUND, 0 ms]
(58) QTRS
    (59) QTRSRRRProof [EQUIVALENT, 23 ms]
    (60) QTRS
    (61) QTRSRRRProof [EQUIVALENT, 3 ms]
    (62) QTRS
    (63) QTRSRRRProof [EQUIVALENT, 0 ms]
    (64) QTRS
    (65) Overlay + Local Confluence [EQUIVALENT, 0 ms]
    (66) QTRS
    (67) DependencyPairsProof [EQUIVALENT, 0 ms]
    (68) QDP
    (69) UsableRulesProof [EQUIVALENT, 0 ms]
    (70) QDP
    (71) QReductionProof [EQUIVALENT, 0 ms]
    (72) QDP
    (73) NonTerminationLoopProof [COMPLETE, 0 ms]
    (74) NO
(75) PrologToIRSwTTransformerProof [SOUND, 0 ms]
(76) IRSwT
    (77) IRSwTSimpleDependencyGraphProof [EQUIVALENT, 0 ms]
    (78) IRSwT
    (79) IntTRSCompressionProof [EQUIVALENT, 24 ms]
    (80) IRSwT
    (81) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
    (82) IRSwT
    (83) IRSwTTerminationDigraphProof [EQUIVALENT, 7 ms]
    (84) AND
        (85) IRSwT
            (86) TempFilterProof [SOUND, 0 ms]
            (87) IRSwT
            (88) IRSwTToQDPProof [SOUND, 0 ms]
            (89) QDP
            (90) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (91) YES
        (92) IRSwT
            (93) IntTRSCompressionProof [EQUIVALENT, 0 ms]
            (94) IRSwT


----------------------------------------

(0)
Obligation:
Clauses:

add(X, 0, X) :- !.
add(X, Y, s(Z)) :- ','(p(Y, P), add(X, P, Z)).
p(0, 0).
p(s(X), X).


Query: add(a,g,a)
----------------------------------------

(1) CutEliminatorProof (SOUND)
Eliminated all cuts by simply ignoring them[PROLOG].
----------------------------------------

(2)
Obligation:
Clauses:

add(X, 0, X).
add(X, Y, s(Z)) :- ','(p(Y, P), add(X, P, Z)).
p(0, 0).
p(s(X), X).


Query: add(a,g,a)
----------------------------------------

(3) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

add_in_3: (f,b,f)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   add_in_aga(X, 0, X) -> add_out_aga(X, 0, X)
   add_in_aga(X, Y, s(Z)) -> U1_aga(X, Y, Z, p_in_ga(Y, P))
   p_in_ga(0, 0) -> p_out_ga(0, 0)
   p_in_ga(s(X), X) -> p_out_ga(s(X), X)
   U1_aga(X, Y, Z, p_out_ga(Y, P)) -> U2_aga(X, Y, Z, P, add_in_aga(X, P, Z))
   U2_aga(X, Y, Z, P, add_out_aga(X, P, Z)) -> add_out_aga(X, Y, s(Z))

The argument filtering Pi contains the following mapping:
add_in_aga(x1, x2, x3)  =  add_in_aga(x2)

0  =  0

add_out_aga(x1, x2, x3)  =  add_out_aga(x2)

U1_aga(x1, x2, x3, x4)  =  U1_aga(x2, x4)

p_in_ga(x1, x2)  =  p_in_ga(x1)

p_out_ga(x1, x2)  =  p_out_ga(x1, x2)

s(x1)  =  s(x1)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x2, x5)





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(4)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   add_in_aga(X, 0, X) -> add_out_aga(X, 0, X)
   add_in_aga(X, Y, s(Z)) -> U1_aga(X, Y, Z, p_in_ga(Y, P))
   p_in_ga(0, 0) -> p_out_ga(0, 0)
   p_in_ga(s(X), X) -> p_out_ga(s(X), X)
   U1_aga(X, Y, Z, p_out_ga(Y, P)) -> U2_aga(X, Y, Z, P, add_in_aga(X, P, Z))
   U2_aga(X, Y, Z, P, add_out_aga(X, P, Z)) -> add_out_aga(X, Y, s(Z))

The argument filtering Pi contains the following mapping:
add_in_aga(x1, x2, x3)  =  add_in_aga(x2)

0  =  0

add_out_aga(x1, x2, x3)  =  add_out_aga(x2)

U1_aga(x1, x2, x3, x4)  =  U1_aga(x2, x4)

p_in_ga(x1, x2)  =  p_in_ga(x1)

p_out_ga(x1, x2)  =  p_out_ga(x1, x2)

s(x1)  =  s(x1)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x2, x5)



----------------------------------------

(5) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   ADD_IN_AGA(X, Y, s(Z)) -> U1_AGA(X, Y, Z, p_in_ga(Y, P))
   ADD_IN_AGA(X, Y, s(Z)) -> P_IN_GA(Y, P)
   U1_AGA(X, Y, Z, p_out_ga(Y, P)) -> U2_AGA(X, Y, Z, P, add_in_aga(X, P, Z))
   U1_AGA(X, Y, Z, p_out_ga(Y, P)) -> ADD_IN_AGA(X, P, Z)

The TRS R consists of the following rules:

   add_in_aga(X, 0, X) -> add_out_aga(X, 0, X)
   add_in_aga(X, Y, s(Z)) -> U1_aga(X, Y, Z, p_in_ga(Y, P))
   p_in_ga(0, 0) -> p_out_ga(0, 0)
   p_in_ga(s(X), X) -> p_out_ga(s(X), X)
   U1_aga(X, Y, Z, p_out_ga(Y, P)) -> U2_aga(X, Y, Z, P, add_in_aga(X, P, Z))
   U2_aga(X, Y, Z, P, add_out_aga(X, P, Z)) -> add_out_aga(X, Y, s(Z))

The argument filtering Pi contains the following mapping:
add_in_aga(x1, x2, x3)  =  add_in_aga(x2)

0  =  0

add_out_aga(x1, x2, x3)  =  add_out_aga(x2)

U1_aga(x1, x2, x3, x4)  =  U1_aga(x2, x4)

p_in_ga(x1, x2)  =  p_in_ga(x1)

p_out_ga(x1, x2)  =  p_out_ga(x1, x2)

s(x1)  =  s(x1)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x2, x5)

ADD_IN_AGA(x1, x2, x3)  =  ADD_IN_AGA(x2)

U1_AGA(x1, x2, x3, x4)  =  U1_AGA(x2, x4)

P_IN_GA(x1, x2)  =  P_IN_GA(x1)

U2_AGA(x1, x2, x3, x4, x5)  =  U2_AGA(x2, x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(6)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   ADD_IN_AGA(X, Y, s(Z)) -> U1_AGA(X, Y, Z, p_in_ga(Y, P))
   ADD_IN_AGA(X, Y, s(Z)) -> P_IN_GA(Y, P)
   U1_AGA(X, Y, Z, p_out_ga(Y, P)) -> U2_AGA(X, Y, Z, P, add_in_aga(X, P, Z))
   U1_AGA(X, Y, Z, p_out_ga(Y, P)) -> ADD_IN_AGA(X, P, Z)

The TRS R consists of the following rules:

   add_in_aga(X, 0, X) -> add_out_aga(X, 0, X)
   add_in_aga(X, Y, s(Z)) -> U1_aga(X, Y, Z, p_in_ga(Y, P))
   p_in_ga(0, 0) -> p_out_ga(0, 0)
   p_in_ga(s(X), X) -> p_out_ga(s(X), X)
   U1_aga(X, Y, Z, p_out_ga(Y, P)) -> U2_aga(X, Y, Z, P, add_in_aga(X, P, Z))
   U2_aga(X, Y, Z, P, add_out_aga(X, P, Z)) -> add_out_aga(X, Y, s(Z))

The argument filtering Pi contains the following mapping:
add_in_aga(x1, x2, x3)  =  add_in_aga(x2)

0  =  0

add_out_aga(x1, x2, x3)  =  add_out_aga(x2)

U1_aga(x1, x2, x3, x4)  =  U1_aga(x2, x4)

p_in_ga(x1, x2)  =  p_in_ga(x1)

p_out_ga(x1, x2)  =  p_out_ga(x1, x2)

s(x1)  =  s(x1)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x2, x5)

ADD_IN_AGA(x1, x2, x3)  =  ADD_IN_AGA(x2)

U1_AGA(x1, x2, x3, x4)  =  U1_AGA(x2, x4)

P_IN_GA(x1, x2)  =  P_IN_GA(x1)

U2_AGA(x1, x2, x3, x4, x5)  =  U2_AGA(x2, x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(7) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 2 less nodes.
----------------------------------------

(8)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_AGA(X, Y, Z, p_out_ga(Y, P)) -> ADD_IN_AGA(X, P, Z)
   ADD_IN_AGA(X, Y, s(Z)) -> U1_AGA(X, Y, Z, p_in_ga(Y, P))

The TRS R consists of the following rules:

   add_in_aga(X, 0, X) -> add_out_aga(X, 0, X)
   add_in_aga(X, Y, s(Z)) -> U1_aga(X, Y, Z, p_in_ga(Y, P))
   p_in_ga(0, 0) -> p_out_ga(0, 0)
   p_in_ga(s(X), X) -> p_out_ga(s(X), X)
   U1_aga(X, Y, Z, p_out_ga(Y, P)) -> U2_aga(X, Y, Z, P, add_in_aga(X, P, Z))
   U2_aga(X, Y, Z, P, add_out_aga(X, P, Z)) -> add_out_aga(X, Y, s(Z))

The argument filtering Pi contains the following mapping:
add_in_aga(x1, x2, x3)  =  add_in_aga(x2)

0  =  0

add_out_aga(x1, x2, x3)  =  add_out_aga(x2)

U1_aga(x1, x2, x3, x4)  =  U1_aga(x2, x4)

p_in_ga(x1, x2)  =  p_in_ga(x1)

p_out_ga(x1, x2)  =  p_out_ga(x1, x2)

s(x1)  =  s(x1)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x2, x5)

ADD_IN_AGA(x1, x2, x3)  =  ADD_IN_AGA(x2)

U1_AGA(x1, x2, x3, x4)  =  U1_AGA(x2, x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(9) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(10)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_AGA(X, Y, Z, p_out_ga(Y, P)) -> ADD_IN_AGA(X, P, Z)
   ADD_IN_AGA(X, Y, s(Z)) -> U1_AGA(X, Y, Z, p_in_ga(Y, P))

The TRS R consists of the following rules:

   p_in_ga(0, 0) -> p_out_ga(0, 0)
   p_in_ga(s(X), X) -> p_out_ga(s(X), X)

The argument filtering Pi contains the following mapping:
0  =  0

p_in_ga(x1, x2)  =  p_in_ga(x1)

p_out_ga(x1, x2)  =  p_out_ga(x1, x2)

s(x1)  =  s(x1)

ADD_IN_AGA(x1, x2, x3)  =  ADD_IN_AGA(x2)

U1_AGA(x1, x2, x3, x4)  =  U1_AGA(x2, x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(11) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(12)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AGA(Y, p_out_ga(Y, P)) -> ADD_IN_AGA(P)
   ADD_IN_AGA(Y) -> U1_AGA(Y, p_in_ga(Y))

The TRS R consists of the following rules:

   p_in_ga(0) -> p_out_ga(0, 0)
   p_in_ga(s(X)) -> p_out_ga(s(X), X)

The set Q consists of the following terms:

   p_in_ga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(13) TransformationProof (SOUND)
By narrowing [LPAR04] the rule ADD_IN_AGA(Y) -> U1_AGA(Y, p_in_ga(Y)) at position [1] we obtained the following new rules [LPAR04]:

   (ADD_IN_AGA(0) -> U1_AGA(0, p_out_ga(0, 0)),ADD_IN_AGA(0) -> U1_AGA(0, p_out_ga(0, 0)))
   (ADD_IN_AGA(s(x0)) -> U1_AGA(s(x0), p_out_ga(s(x0), x0)),ADD_IN_AGA(s(x0)) -> U1_AGA(s(x0), p_out_ga(s(x0), x0)))


----------------------------------------

(14)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AGA(Y, p_out_ga(Y, P)) -> ADD_IN_AGA(P)
   ADD_IN_AGA(0) -> U1_AGA(0, p_out_ga(0, 0))
   ADD_IN_AGA(s(x0)) -> U1_AGA(s(x0), p_out_ga(s(x0), x0))

The TRS R consists of the following rules:

   p_in_ga(0) -> p_out_ga(0, 0)
   p_in_ga(s(X)) -> p_out_ga(s(X), X)

The set Q consists of the following terms:

   p_in_ga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(15) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(16)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AGA(Y, p_out_ga(Y, P)) -> ADD_IN_AGA(P)
   ADD_IN_AGA(0) -> U1_AGA(0, p_out_ga(0, 0))
   ADD_IN_AGA(s(x0)) -> U1_AGA(s(x0), p_out_ga(s(x0), x0))

R is empty.
The set Q consists of the following terms:

   p_in_ga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(17) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   p_in_ga(x0)


----------------------------------------

(18)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AGA(Y, p_out_ga(Y, P)) -> ADD_IN_AGA(P)
   ADD_IN_AGA(0) -> U1_AGA(0, p_out_ga(0, 0))
   ADD_IN_AGA(s(x0)) -> U1_AGA(s(x0), p_out_ga(s(x0), x0))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(19) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U1_AGA(Y, p_out_ga(Y, P)) -> ADD_IN_AGA(P) we obtained the following new rules [LPAR04]:

   (U1_AGA(0, p_out_ga(0, 0)) -> ADD_IN_AGA(0),U1_AGA(0, p_out_ga(0, 0)) -> ADD_IN_AGA(0))
   (U1_AGA(s(z0), p_out_ga(s(z0), z0)) -> ADD_IN_AGA(z0),U1_AGA(s(z0), p_out_ga(s(z0), z0)) -> ADD_IN_AGA(z0))


----------------------------------------

(20)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ADD_IN_AGA(0) -> U1_AGA(0, p_out_ga(0, 0))
   ADD_IN_AGA(s(x0)) -> U1_AGA(s(x0), p_out_ga(s(x0), x0))
   U1_AGA(0, p_out_ga(0, 0)) -> ADD_IN_AGA(0)
   U1_AGA(s(z0), p_out_ga(s(z0), z0)) -> ADD_IN_AGA(z0)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(21) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs.
----------------------------------------

(22)
Complex Obligation (AND)

----------------------------------------

(23)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AGA(0, p_out_ga(0, 0)) -> ADD_IN_AGA(0)
   ADD_IN_AGA(0) -> U1_AGA(0, p_out_ga(0, 0))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(24) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = ADD_IN_AGA(0) evaluates to  t =ADD_IN_AGA(0)

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

ADD_IN_AGA(0) -> U1_AGA(0, p_out_ga(0, 0))
with rule ADD_IN_AGA(0) -> U1_AGA(0, p_out_ga(0, 0)) at position [] and matcher [ ]

U1_AGA(0, p_out_ga(0, 0)) -> ADD_IN_AGA(0)
with rule U1_AGA(0, p_out_ga(0, 0)) -> ADD_IN_AGA(0)

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(25)
NO

----------------------------------------

(26)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ADD_IN_AGA(s(x0)) -> U1_AGA(s(x0), p_out_ga(s(x0), x0))
   U1_AGA(s(z0), p_out_ga(s(z0), z0)) -> ADD_IN_AGA(z0)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(27) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*U1_AGA(s(z0), p_out_ga(s(z0), z0)) -> ADD_IN_AGA(z0)
The graph contains the following edges 1 > 1, 2 > 1


*ADD_IN_AGA(s(x0)) -> U1_AGA(s(x0), p_out_ga(s(x0), x0))
The graph contains the following edges 1 >= 1


----------------------------------------

(28)
YES

----------------------------------------

(29) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

add_in_3: (f,b,f)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   add_in_aga(X, 0, X) -> add_out_aga(X, 0, X)
   add_in_aga(X, Y, s(Z)) -> U1_aga(X, Y, Z, p_in_ga(Y, P))
   p_in_ga(0, 0) -> p_out_ga(0, 0)
   p_in_ga(s(X), X) -> p_out_ga(s(X), X)
   U1_aga(X, Y, Z, p_out_ga(Y, P)) -> U2_aga(X, Y, Z, P, add_in_aga(X, P, Z))
   U2_aga(X, Y, Z, P, add_out_aga(X, P, Z)) -> add_out_aga(X, Y, s(Z))

The argument filtering Pi contains the following mapping:
add_in_aga(x1, x2, x3)  =  add_in_aga(x2)

0  =  0

add_out_aga(x1, x2, x3)  =  add_out_aga

U1_aga(x1, x2, x3, x4)  =  U1_aga(x4)

p_in_ga(x1, x2)  =  p_in_ga(x1)

p_out_ga(x1, x2)  =  p_out_ga(x2)

s(x1)  =  s(x1)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x5)





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(30)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   add_in_aga(X, 0, X) -> add_out_aga(X, 0, X)
   add_in_aga(X, Y, s(Z)) -> U1_aga(X, Y, Z, p_in_ga(Y, P))
   p_in_ga(0, 0) -> p_out_ga(0, 0)
   p_in_ga(s(X), X) -> p_out_ga(s(X), X)
   U1_aga(X, Y, Z, p_out_ga(Y, P)) -> U2_aga(X, Y, Z, P, add_in_aga(X, P, Z))
   U2_aga(X, Y, Z, P, add_out_aga(X, P, Z)) -> add_out_aga(X, Y, s(Z))

The argument filtering Pi contains the following mapping:
add_in_aga(x1, x2, x3)  =  add_in_aga(x2)

0  =  0

add_out_aga(x1, x2, x3)  =  add_out_aga

U1_aga(x1, x2, x3, x4)  =  U1_aga(x4)

p_in_ga(x1, x2)  =  p_in_ga(x1)

p_out_ga(x1, x2)  =  p_out_ga(x2)

s(x1)  =  s(x1)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x5)



----------------------------------------

(31) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   ADD_IN_AGA(X, Y, s(Z)) -> U1_AGA(X, Y, Z, p_in_ga(Y, P))
   ADD_IN_AGA(X, Y, s(Z)) -> P_IN_GA(Y, P)
   U1_AGA(X, Y, Z, p_out_ga(Y, P)) -> U2_AGA(X, Y, Z, P, add_in_aga(X, P, Z))
   U1_AGA(X, Y, Z, p_out_ga(Y, P)) -> ADD_IN_AGA(X, P, Z)

The TRS R consists of the following rules:

   add_in_aga(X, 0, X) -> add_out_aga(X, 0, X)
   add_in_aga(X, Y, s(Z)) -> U1_aga(X, Y, Z, p_in_ga(Y, P))
   p_in_ga(0, 0) -> p_out_ga(0, 0)
   p_in_ga(s(X), X) -> p_out_ga(s(X), X)
   U1_aga(X, Y, Z, p_out_ga(Y, P)) -> U2_aga(X, Y, Z, P, add_in_aga(X, P, Z))
   U2_aga(X, Y, Z, P, add_out_aga(X, P, Z)) -> add_out_aga(X, Y, s(Z))

The argument filtering Pi contains the following mapping:
add_in_aga(x1, x2, x3)  =  add_in_aga(x2)

0  =  0

add_out_aga(x1, x2, x3)  =  add_out_aga

U1_aga(x1, x2, x3, x4)  =  U1_aga(x4)

p_in_ga(x1, x2)  =  p_in_ga(x1)

p_out_ga(x1, x2)  =  p_out_ga(x2)

s(x1)  =  s(x1)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x5)

ADD_IN_AGA(x1, x2, x3)  =  ADD_IN_AGA(x2)

U1_AGA(x1, x2, x3, x4)  =  U1_AGA(x4)

P_IN_GA(x1, x2)  =  P_IN_GA(x1)

U2_AGA(x1, x2, x3, x4, x5)  =  U2_AGA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(32)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   ADD_IN_AGA(X, Y, s(Z)) -> U1_AGA(X, Y, Z, p_in_ga(Y, P))
   ADD_IN_AGA(X, Y, s(Z)) -> P_IN_GA(Y, P)
   U1_AGA(X, Y, Z, p_out_ga(Y, P)) -> U2_AGA(X, Y, Z, P, add_in_aga(X, P, Z))
   U1_AGA(X, Y, Z, p_out_ga(Y, P)) -> ADD_IN_AGA(X, P, Z)

The TRS R consists of the following rules:

   add_in_aga(X, 0, X) -> add_out_aga(X, 0, X)
   add_in_aga(X, Y, s(Z)) -> U1_aga(X, Y, Z, p_in_ga(Y, P))
   p_in_ga(0, 0) -> p_out_ga(0, 0)
   p_in_ga(s(X), X) -> p_out_ga(s(X), X)
   U1_aga(X, Y, Z, p_out_ga(Y, P)) -> U2_aga(X, Y, Z, P, add_in_aga(X, P, Z))
   U2_aga(X, Y, Z, P, add_out_aga(X, P, Z)) -> add_out_aga(X, Y, s(Z))

The argument filtering Pi contains the following mapping:
add_in_aga(x1, x2, x3)  =  add_in_aga(x2)

0  =  0

add_out_aga(x1, x2, x3)  =  add_out_aga

U1_aga(x1, x2, x3, x4)  =  U1_aga(x4)

p_in_ga(x1, x2)  =  p_in_ga(x1)

p_out_ga(x1, x2)  =  p_out_ga(x2)

s(x1)  =  s(x1)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x5)

ADD_IN_AGA(x1, x2, x3)  =  ADD_IN_AGA(x2)

U1_AGA(x1, x2, x3, x4)  =  U1_AGA(x4)

P_IN_GA(x1, x2)  =  P_IN_GA(x1)

U2_AGA(x1, x2, x3, x4, x5)  =  U2_AGA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(33) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 2 less nodes.
----------------------------------------

(34)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_AGA(X, Y, Z, p_out_ga(Y, P)) -> ADD_IN_AGA(X, P, Z)
   ADD_IN_AGA(X, Y, s(Z)) -> U1_AGA(X, Y, Z, p_in_ga(Y, P))

The TRS R consists of the following rules:

   add_in_aga(X, 0, X) -> add_out_aga(X, 0, X)
   add_in_aga(X, Y, s(Z)) -> U1_aga(X, Y, Z, p_in_ga(Y, P))
   p_in_ga(0, 0) -> p_out_ga(0, 0)
   p_in_ga(s(X), X) -> p_out_ga(s(X), X)
   U1_aga(X, Y, Z, p_out_ga(Y, P)) -> U2_aga(X, Y, Z, P, add_in_aga(X, P, Z))
   U2_aga(X, Y, Z, P, add_out_aga(X, P, Z)) -> add_out_aga(X, Y, s(Z))

The argument filtering Pi contains the following mapping:
add_in_aga(x1, x2, x3)  =  add_in_aga(x2)

0  =  0

add_out_aga(x1, x2, x3)  =  add_out_aga

U1_aga(x1, x2, x3, x4)  =  U1_aga(x4)

p_in_ga(x1, x2)  =  p_in_ga(x1)

p_out_ga(x1, x2)  =  p_out_ga(x2)

s(x1)  =  s(x1)

U2_aga(x1, x2, x3, x4, x5)  =  U2_aga(x5)

ADD_IN_AGA(x1, x2, x3)  =  ADD_IN_AGA(x2)

U1_AGA(x1, x2, x3, x4)  =  U1_AGA(x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(35) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(36)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_AGA(X, Y, Z, p_out_ga(Y, P)) -> ADD_IN_AGA(X, P, Z)
   ADD_IN_AGA(X, Y, s(Z)) -> U1_AGA(X, Y, Z, p_in_ga(Y, P))

The TRS R consists of the following rules:

   p_in_ga(0, 0) -> p_out_ga(0, 0)
   p_in_ga(s(X), X) -> p_out_ga(s(X), X)

The argument filtering Pi contains the following mapping:
0  =  0

p_in_ga(x1, x2)  =  p_in_ga(x1)

p_out_ga(x1, x2)  =  p_out_ga(x2)

s(x1)  =  s(x1)

ADD_IN_AGA(x1, x2, x3)  =  ADD_IN_AGA(x2)

U1_AGA(x1, x2, x3, x4)  =  U1_AGA(x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(37) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(38)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AGA(p_out_ga(P)) -> ADD_IN_AGA(P)
   ADD_IN_AGA(Y) -> U1_AGA(p_in_ga(Y))

The TRS R consists of the following rules:

   p_in_ga(0) -> p_out_ga(0)
   p_in_ga(s(X)) -> p_out_ga(X)

The set Q consists of the following terms:

   p_in_ga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(39) UsableRulesReductionPairsProof (EQUIVALENT)
By using the usable rules with reduction pair processor [LPAR04] with a polynomial ordering [POLO], all dependency pairs and the corresponding usable rules [FROCOS05] can be oriented non-strictly. All non-usable rules are removed, and those dependency pairs and usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

No dependency pairs are removed.

The following rules are removed from R:

   p_in_ga(s(X)) -> p_out_ga(X)
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(ADD_IN_AGA(x_1)) = x_1
   POL(U1_AGA(x_1)) = x_1
   POL(p_in_ga(x_1)) = x_1
   POL(p_out_ga(x_1)) = x_1
   POL(s(x_1)) = 2*x_1


----------------------------------------

(40)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_AGA(p_out_ga(P)) -> ADD_IN_AGA(P)
   ADD_IN_AGA(Y) -> U1_AGA(p_in_ga(Y))

The TRS R consists of the following rules:

   p_in_ga(0) -> p_out_ga(0)

The set Q consists of the following terms:

   p_in_ga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(41) PrologToDTProblemTransformerProof (SOUND)
Built DT problem from termination graph DT10.

{
    "root": 3,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(add X (0) X)",
                "(!)"
            ],
            [
                "(add X Y (s Z))",
                "(',' (p Y P) (add X P Z))"
            ],
            [
                "(p (0) (0))",
                null
            ],
            [
                "(p (s X) X)",
                null
            ]
        ]
    },
    "graph": {
        "nodes": {
            "33": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(add T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [[
                        "(add T1 T2 T3)",
                        "(add X2 (0) X2)"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T2"],
                    "free": ["X2"],
                    "exprvars": []
                }
            },
            "44": {
                "goal": [{
                    "clause": 3,
                    "scope": 2,
                    "term": "(',' (p T10 X9) (add T12 X9 T13))"
                }],
                "kb": {
                    "nonunifying": [[
                        "(add T1 T10 T3)",
                        "(add X2 (0) X2)"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T10"],
                    "free": [
                        "X2",
                        "X9"
                    ],
                    "exprvars": []
                }
            },
            "45": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(add T12 (0) T13)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "89": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(add T12 T17 T13)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T17"],
                    "free": [],
                    "exprvars": []
                }
            },
            "46": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "38": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "39": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "29": {
                "goal": [
                    {
                        "clause": -1,
                        "scope": -1,
                        "term": "(!_1)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(add T1 (0) T3)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "3": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(add T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T2"],
                    "free": [],
                    "exprvars": []
                }
            },
            "4": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 1,
                        "term": "(add T1 T2 T3)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(add T1 T2 T3)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T2"],
                    "free": [],
                    "exprvars": []
                }
            },
            "90": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "40": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (p T10 X9) (add T12 X9 T13))"
                }],
                "kb": {
                    "nonunifying": [[
                        "(add T1 T10 T3)",
                        "(add X2 (0) X2)"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T10"],
                    "free": [
                        "X2",
                        "X9"
                    ],
                    "exprvars": []
                }
            },
            "41": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "42": {
                "goal": [
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(',' (p T10 X9) (add T12 X9 T13))"
                    },
                    {
                        "clause": 3,
                        "scope": 2,
                        "term": "(',' (p T10 X9) (add T12 X9 T13))"
                    }
                ],
                "kb": {
                    "nonunifying": [[
                        "(add T1 T10 T3)",
                        "(add X2 (0) X2)"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T10"],
                    "free": [
                        "X2",
                        "X9"
                    ],
                    "exprvars": []
                }
            },
            "43": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(',' (p T10 X9) (add T12 X9 T13))"
                }],
                "kb": {
                    "nonunifying": [[
                        "(add T1 T10 T3)",
                        "(add X2 (0) X2)"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T10"],
                    "free": [
                        "X2",
                        "X9"
                    ],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 3,
                "to": 4,
                "label": "CASE"
            },
            {
                "from": 4,
                "to": 29,
                "label": "EVAL with clause\nadd(X2, 0, X2) :- !_1.\nand substitutionT1 -> T5,\nX2 -> T5,\nT2 -> 0,\nT3 -> T5"
            },
            {
                "from": 4,
                "to": 33,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 29,
                "to": 38,
                "label": "CUT"
            },
            {
                "from": 33,
                "to": 40,
                "label": "EVAL with clause\nadd(X6, X7, s(X8)) :- ','(p(X7, X9), add(X6, X9, X8)).\nand substitutionT1 -> T12,\nX6 -> T12,\nT2 -> T10,\nX7 -> T10,\nX8 -> T13,\nT3 -> s(T13),\nT9 -> T12,\nT11 -> T13"
            },
            {
                "from": 33,
                "to": 41,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 38,
                "to": 39,
                "label": "SUCCESS"
            },
            {
                "from": 40,
                "to": 42,
                "label": "CASE"
            },
            {
                "from": 42,
                "to": 43,
                "label": "PARALLEL"
            },
            {
                "from": 42,
                "to": 44,
                "label": "PARALLEL"
            },
            {
                "from": 43,
                "to": 45,
                "label": "EVAL with clause\np(0, 0).\nand substitutionT10 -> 0,\nX9 -> 0"
            },
            {
                "from": 43,
                "to": 46,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 44,
                "to": 89,
                "label": "EVAL with clause\np(s(X13), X13).\nand substitutionX13 -> T17,\nT10 -> s(T17),\nX9 -> T17"
            },
            {
                "from": 44,
                "to": 90,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 45,
                "to": 3,
                "label": "INSTANCE with matching:\nT1 -> T12\nT2 -> 0\nT3 -> T13"
            },
            {
                "from": 89,
                "to": 3,
                "label": "INSTANCE with matching:\nT1 -> T12\nT2 -> T17\nT3 -> T13"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(42)
Obligation:
Triples:

addA(X1, 0, s(X2)) :- addA(X1, 0, X2).
addA(X1, s(X2), s(X3)) :- addA(X1, X2, X3).

Clauses:

addcA(X1, 0, X1).
addcA(X1, 0, s(X2)) :- addcA(X1, 0, X2).
addcA(X1, s(X2), s(X3)) :- addcA(X1, X2, X3).

Afs:

addA(x1, x2, x3)  =  addA(x2)


----------------------------------------

(43) TriplesToPiDPProof (SOUND)
We use the technique of [DT09]. With regard to the inferred argument filtering the predicates were used in the following modes:

addA_in_3: (f,b,f)

Transforming TRIPLES into the following Term Rewriting System:

Pi DP problem:
The TRS P consists of the following rules:

   ADDA_IN_AGA(X1, 0, s(X2)) -> U1_AGA(X1, X2, addA_in_aga(X1, 0, X2))
   ADDA_IN_AGA(X1, 0, s(X2)) -> ADDA_IN_AGA(X1, 0, X2)
   ADDA_IN_AGA(X1, s(X2), s(X3)) -> U2_AGA(X1, X2, X3, addA_in_aga(X1, X2, X3))
   ADDA_IN_AGA(X1, s(X2), s(X3)) -> ADDA_IN_AGA(X1, X2, X3)

R is empty.
The argument filtering Pi contains the following mapping:
addA_in_aga(x1, x2, x3)  =  addA_in_aga(x2)

0  =  0

s(x1)  =  s(x1)

ADDA_IN_AGA(x1, x2, x3)  =  ADDA_IN_AGA(x2)

U1_AGA(x1, x2, x3)  =  U1_AGA(x3)

U2_AGA(x1, x2, x3, x4)  =  U2_AGA(x2, x4)


We have to consider all (P,R,Pi)-chains


Infinitary Constructor Rewriting Termination of PiDP implies Termination of TRIPLES



----------------------------------------

(44)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   ADDA_IN_AGA(X1, 0, s(X2)) -> U1_AGA(X1, X2, addA_in_aga(X1, 0, X2))
   ADDA_IN_AGA(X1, 0, s(X2)) -> ADDA_IN_AGA(X1, 0, X2)
   ADDA_IN_AGA(X1, s(X2), s(X3)) -> U2_AGA(X1, X2, X3, addA_in_aga(X1, X2, X3))
   ADDA_IN_AGA(X1, s(X2), s(X3)) -> ADDA_IN_AGA(X1, X2, X3)

R is empty.
The argument filtering Pi contains the following mapping:
addA_in_aga(x1, x2, x3)  =  addA_in_aga(x2)

0  =  0

s(x1)  =  s(x1)

ADDA_IN_AGA(x1, x2, x3)  =  ADDA_IN_AGA(x2)

U1_AGA(x1, x2, x3)  =  U1_AGA(x3)

U2_AGA(x1, x2, x3, x4)  =  U2_AGA(x2, x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(45) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 2 SCCs with 2 less nodes.
----------------------------------------

(46)
Complex Obligation (AND)

----------------------------------------

(47)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   ADDA_IN_AGA(X1, 0, s(X2)) -> ADDA_IN_AGA(X1, 0, X2)

R is empty.
The argument filtering Pi contains the following mapping:
0  =  0

s(x1)  =  s(x1)

ADDA_IN_AGA(x1, x2, x3)  =  ADDA_IN_AGA(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(48) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(49)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ADDA_IN_AGA(0) -> ADDA_IN_AGA(0)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(50) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by semiunifying a rule from P directly.

s = ADDA_IN_AGA(0) evaluates to  t =ADDA_IN_AGA(0)

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

The DP semiunifies directly so there is only one rewrite step from ADDA_IN_AGA(0) to ADDA_IN_AGA(0).




----------------------------------------

(51)
NO

----------------------------------------

(52)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   ADDA_IN_AGA(X1, s(X2), s(X3)) -> ADDA_IN_AGA(X1, X2, X3)

R is empty.
The argument filtering Pi contains the following mapping:
s(x1)  =  s(x1)

ADDA_IN_AGA(x1, x2, x3)  =  ADDA_IN_AGA(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(53) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(54)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ADDA_IN_AGA(s(X2)) -> ADDA_IN_AGA(X2)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(55) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*ADDA_IN_AGA(s(X2)) -> ADDA_IN_AGA(X2)
The graph contains the following edges 1 > 1


----------------------------------------

(56)
YES

----------------------------------------

(57) PrologToTRSTransformerProof (SOUND)
Transformed Prolog program to TRS.

{
    "root": 2,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(add X (0) X)",
                "(!)"
            ],
            [
                "(add X Y (s Z))",
                "(',' (p Y P) (add X P Z))"
            ],
            [
                "(p (0) (0))",
                null
            ],
            [
                "(p (s X) X)",
                null
            ]
        ]
    },
    "graph": {
        "nodes": {
            "11": {
                "goal": [
                    {
                        "clause": -1,
                        "scope": -1,
                        "term": "(!_1)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(add T1 (0) T3)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "22": {
                "goal": [
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(',' (p T14 X14) (add T16 X14 T17))"
                    },
                    {
                        "clause": 3,
                        "scope": 2,
                        "term": "(',' (p T14 X14) (add T16 X14 T17))"
                    }
                ],
                "kb": {
                    "nonunifying": [[
                        "(add T1 T14 T3)",
                        "(add X3 (0) X3)"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": [
                        "X3",
                        "X14"
                    ],
                    "exprvars": []
                }
            },
            "12": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(add T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [[
                        "(add T1 T2 T3)",
                        "(add X3 (0) X3)"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T2"],
                    "free": ["X3"],
                    "exprvars": []
                }
            },
            "13": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "24": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(',' (p T14 X14) (add T16 X14 T17))"
                }],
                "kb": {
                    "nonunifying": [[
                        "(add T1 T14 T3)",
                        "(add X3 (0) X3)"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": [
                        "X3",
                        "X14"
                    ],
                    "exprvars": []
                }
            },
            "14": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "26": {
                "goal": [{
                    "clause": 3,
                    "scope": 2,
                    "term": "(',' (p T14 X14) (add T16 X14 T17))"
                }],
                "kb": {
                    "nonunifying": [[
                        "(add T1 T14 T3)",
                        "(add X3 (0) X3)"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": [
                        "X3",
                        "X14"
                    ],
                    "exprvars": []
                }
            },
            "27": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(add T16 (0) T17)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "17": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (p T14 X14) (add T16 X14 T17))"
                }],
                "kb": {
                    "nonunifying": [[
                        "(add T1 T14 T3)",
                        "(add X3 (0) X3)"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": [
                        "X3",
                        "X14"
                    ],
                    "exprvars": []
                }
            },
            "28": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "19": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "164": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(add T16 T22 T17)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T22"],
                    "free": [],
                    "exprvars": []
                }
            },
            "165": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "2": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(add T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T2"],
                    "free": [],
                    "exprvars": []
                }
            },
            "6": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 1,
                        "term": "(add T1 T2 T3)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(add T1 T2 T3)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T2"],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 2,
                "to": 6,
                "label": "CASE"
            },
            {
                "from": 6,
                "to": 11,
                "label": "EVAL with clause\nadd(X3, 0, X3) :- !_1.\nand substitutionT1 -> T6,\nX3 -> T6,\nT2 -> 0,\nT3 -> T6"
            },
            {
                "from": 6,
                "to": 12,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 11,
                "to": 13,
                "label": "CUT"
            },
            {
                "from": 12,
                "to": 17,
                "label": "EVAL with clause\nadd(X11, X12, s(X13)) :- ','(p(X12, X14), add(X11, X14, X13)).\nand substitutionT1 -> T16,\nX11 -> T16,\nT2 -> T14,\nX12 -> T14,\nX13 -> T17,\nT3 -> s(T17),\nT13 -> T16,\nT15 -> T17"
            },
            {
                "from": 12,
                "to": 19,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 13,
                "to": 14,
                "label": "SUCCESS"
            },
            {
                "from": 17,
                "to": 22,
                "label": "CASE"
            },
            {
                "from": 22,
                "to": 24,
                "label": "PARALLEL"
            },
            {
                "from": 22,
                "to": 26,
                "label": "PARALLEL"
            },
            {
                "from": 24,
                "to": 27,
                "label": "EVAL with clause\np(0, 0).\nand substitutionT14 -> 0,\nX14 -> 0"
            },
            {
                "from": 24,
                "to": 28,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 26,
                "to": 164,
                "label": "EVAL with clause\np(s(X19), X19).\nand substitutionX19 -> T22,\nT14 -> s(T22),\nX14 -> T22"
            },
            {
                "from": 26,
                "to": 165,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 27,
                "to": 2,
                "label": "INSTANCE with matching:\nT1 -> T16\nT2 -> 0\nT3 -> T17"
            },
            {
                "from": 164,
                "to": 2,
                "label": "INSTANCE with matching:\nT1 -> T16\nT2 -> T22\nT3 -> T17"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(58)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f2_in(0) -> f2_out1
   f2_in(0) -> U1(f2_in(0), 0)
   U1(f2_out1, 0) -> f2_out1
   f2_in(s(T22)) -> U2(f2_in(T22), s(T22))
   U2(f2_out1, s(T22)) -> f2_out1

Q is empty.

----------------------------------------

(59) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(U1(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(U2(x_1, x_2)) = x_1 + x_2
   POL(f2_in(x_1)) = 2*x_1
   POL(f2_out1) = 0
   POL(s(x_1)) = 2 + 2*x_1
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   f2_in(s(T22)) -> U2(f2_in(T22), s(T22))
   U2(f2_out1, s(T22)) -> f2_out1




----------------------------------------

(60)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f2_in(0) -> f2_out1
   f2_in(0) -> U1(f2_in(0), 0)
   U1(f2_out1, 0) -> f2_out1

Q is empty.

----------------------------------------

(61) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(U1(x_1, x_2)) = x_1 + x_2
   POL(f2_in(x_1)) = 1 + 2*x_1
   POL(f2_out1) = 0
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   f2_in(0) -> f2_out1




----------------------------------------

(62)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f2_in(0) -> U1(f2_in(0), 0)
   U1(f2_out1, 0) -> f2_out1

Q is empty.

----------------------------------------

(63) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(U1(x_1, x_2)) = 2*x_1 + x_2
   POL(f2_in(x_1)) = 2*x_1
   POL(f2_out1) = 2
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   U1(f2_out1, 0) -> f2_out1




----------------------------------------

(64)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f2_in(0) -> U1(f2_in(0), 0)

Q is empty.

----------------------------------------

(65) Overlay + Local Confluence (EQUIVALENT)
The TRS is overlay and locally confluent. By [NOC] we can switch to innermost.
----------------------------------------

(66)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f2_in(0) -> U1(f2_in(0), 0)

The set Q consists of the following terms:

   f2_in(0)


----------------------------------------

(67) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(68)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F2_IN(0) -> F2_IN(0)

The TRS R consists of the following rules:

   f2_in(0) -> U1(f2_in(0), 0)

The set Q consists of the following terms:

   f2_in(0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(69) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(70)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F2_IN(0) -> F2_IN(0)

R is empty.
The set Q consists of the following terms:

   f2_in(0)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(71) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   f2_in(0)


----------------------------------------

(72)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F2_IN(0) -> F2_IN(0)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(73) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by semiunifying a rule from P directly.

s = F2_IN(0) evaluates to  t =F2_IN(0)

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

The DP semiunifies directly so there is only one rewrite step from F2_IN(0) to F2_IN(0).




----------------------------------------

(74)
NO

----------------------------------------

(75) PrologToIRSwTTransformerProof (SOUND)
Transformed Prolog program to IRSwT according to method in Master Thesis of A. Weinert

{
    "root": 1,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(add X (0) X)",
                "(!)"
            ],
            [
                "(add X Y (s Z))",
                "(',' (p Y P) (add X P Z))"
            ],
            [
                "(p (0) (0))",
                null
            ],
            [
                "(p (s X) X)",
                null
            ]
        ]
    },
    "graph": {
        "nodes": {
            "55": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(add T16 T22 T17)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T22"],
                    "free": [],
                    "exprvars": []
                }
            },
            "23": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(add T16 (0) T17)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "67": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "25": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "15": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (p T14 X14) (add T16 X14 T17))"
                }],
                "kb": {
                    "nonunifying": [[
                        "(add T1 T14 T3)",
                        "(add X3 (0) X3)"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": [
                        "X3",
                        "X14"
                    ],
                    "exprvars": []
                }
            },
            "16": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "18": {
                "goal": [
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(',' (p T14 X14) (add T16 X14 T17))"
                    },
                    {
                        "clause": 3,
                        "scope": 2,
                        "term": "(',' (p T14 X14) (add T16 X14 T17))"
                    }
                ],
                "kb": {
                    "nonunifying": [[
                        "(add T1 T14 T3)",
                        "(add X3 (0) X3)"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": [
                        "X3",
                        "X14"
                    ],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "1": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(add T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T2"],
                    "free": [],
                    "exprvars": []
                }
            },
            "5": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 1,
                        "term": "(add T1 T2 T3)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(add T1 T2 T3)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T2"],
                    "free": [],
                    "exprvars": []
                }
            },
            "7": {
                "goal": [
                    {
                        "clause": -1,
                        "scope": -1,
                        "term": "(!_1)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(add T1 (0) T3)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "8": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(add T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [[
                        "(add T1 T2 T3)",
                        "(add X3 (0) X3)"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T2"],
                    "free": ["X3"],
                    "exprvars": []
                }
            },
            "9": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "20": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(',' (p T14 X14) (add T16 X14 T17))"
                }],
                "kb": {
                    "nonunifying": [[
                        "(add T1 T14 T3)",
                        "(add X3 (0) X3)"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": [
                        "X3",
                        "X14"
                    ],
                    "exprvars": []
                }
            },
            "10": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "21": {
                "goal": [{
                    "clause": 3,
                    "scope": 2,
                    "term": "(',' (p T14 X14) (add T16 X14 T17))"
                }],
                "kb": {
                    "nonunifying": [[
                        "(add T1 T14 T3)",
                        "(add X3 (0) X3)"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T14"],
                    "free": [
                        "X3",
                        "X14"
                    ],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 1,
                "to": 5,
                "label": "CASE"
            },
            {
                "from": 5,
                "to": 7,
                "label": "EVAL with clause\nadd(X3, 0, X3) :- !_1.\nand substitutionT1 -> T6,\nX3 -> T6,\nT2 -> 0,\nT3 -> T6"
            },
            {
                "from": 5,
                "to": 8,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 7,
                "to": 9,
                "label": "CUT"
            },
            {
                "from": 8,
                "to": 15,
                "label": "EVAL with clause\nadd(X11, X12, s(X13)) :- ','(p(X12, X14), add(X11, X14, X13)).\nand substitutionT1 -> T16,\nX11 -> T16,\nT2 -> T14,\nX12 -> T14,\nX13 -> T17,\nT3 -> s(T17),\nT13 -> T16,\nT15 -> T17"
            },
            {
                "from": 8,
                "to": 16,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 9,
                "to": 10,
                "label": "SUCCESS"
            },
            {
                "from": 15,
                "to": 18,
                "label": "CASE"
            },
            {
                "from": 18,
                "to": 20,
                "label": "PARALLEL"
            },
            {
                "from": 18,
                "to": 21,
                "label": "PARALLEL"
            },
            {
                "from": 20,
                "to": 23,
                "label": "EVAL with clause\np(0, 0).\nand substitutionT14 -> 0,\nX14 -> 0"
            },
            {
                "from": 20,
                "to": 25,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 21,
                "to": 55,
                "label": "EVAL with clause\np(s(X19), X19).\nand substitutionX19 -> T22,\nT14 -> s(T22),\nX14 -> T22"
            },
            {
                "from": 21,
                "to": 67,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 23,
                "to": 1,
                "label": "INSTANCE with matching:\nT1 -> T16\nT2 -> 0\nT3 -> T17"
            },
            {
                "from": 55,
                "to": 1,
                "label": "INSTANCE with matching:\nT1 -> T16\nT2 -> T22\nT3 -> T17"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(76)
Obligation:
Rules:
f21_in(T14) -> f67_in :|: TRUE
f55_out(T22) -> f21_out(s(T22)) :|: TRUE
f67_out -> f21_out(x) :|: TRUE
f21_in(s(x1)) -> f55_in(x1) :|: TRUE
f7_out -> f5_out(0) :|: TRUE
f5_in(T2) -> f8_in(T2) :|: TRUE
f8_out(x2) -> f5_out(x2) :|: TRUE
f5_in(0) -> f7_in :|: TRUE
f8_in(x3) -> f15_in(x3) :|: TRUE
f16_out -> f8_out(x4) :|: TRUE
f8_in(x5) -> f16_in :|: TRUE
f15_out(x6) -> f8_out(x6) :|: TRUE
f15_in(x7) -> f18_in(x7) :|: TRUE
f18_out(x8) -> f15_out(x8) :|: TRUE
f1_in(x9) -> f5_in(x9) :|: TRUE
f5_out(x10) -> f1_out(x10) :|: TRUE
f21_out(x11) -> f18_out(x11) :|: TRUE
f20_out(x12) -> f18_out(x12) :|: TRUE
f18_in(x13) -> f21_in(x13) :|: TRUE
f18_in(x14) -> f20_in(x14) :|: TRUE
f23_in -> f1_in(0) :|: TRUE
f1_out(0) -> f23_out :|: TRUE
f55_in(x15) -> f1_in(x15) :|: TRUE
f1_out(x16) -> f55_out(x16) :|: TRUE
f20_in(x17) -> f25_in :|: TRUE
f23_out -> f20_out(0) :|: TRUE
f20_in(0) -> f23_in :|: TRUE
f25_out -> f20_out(x18) :|: TRUE
Start term: f1_in(T2)

----------------------------------------

(77) IRSwTSimpleDependencyGraphProof (EQUIVALENT)
Constructed simple dependency graph.

Simplified to the following IRSwTs:

intTRSProblem:
f21_in(s(x1)) -> f55_in(x1) :|: TRUE
f5_in(T2) -> f8_in(T2) :|: TRUE
f8_in(x3) -> f15_in(x3) :|: TRUE
f15_in(x7) -> f18_in(x7) :|: TRUE
f1_in(x9) -> f5_in(x9) :|: TRUE
f18_in(x13) -> f21_in(x13) :|: TRUE
f18_in(x14) -> f20_in(x14) :|: TRUE
f23_in -> f1_in(0) :|: TRUE
f55_in(x15) -> f1_in(x15) :|: TRUE
f20_in(0) -> f23_in :|: TRUE


----------------------------------------

(78)
Obligation:
Rules:
f21_in(s(x1)) -> f55_in(x1) :|: TRUE
f5_in(T2) -> f8_in(T2) :|: TRUE
f8_in(x3) -> f15_in(x3) :|: TRUE
f15_in(x7) -> f18_in(x7) :|: TRUE
f1_in(x9) -> f5_in(x9) :|: TRUE
f18_in(x13) -> f21_in(x13) :|: TRUE
f18_in(x14) -> f20_in(x14) :|: TRUE
f23_in -> f1_in(0) :|: TRUE
f55_in(x15) -> f1_in(x15) :|: TRUE
f20_in(0) -> f23_in :|: TRUE

----------------------------------------

(79) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(80)
Obligation:
Rules:
f1_in(cons_0) -> f1_in(0) :|: TRUE && cons_0 = 0
f1_in(s(x1:0)) -> f1_in(x1:0) :|: TRUE

----------------------------------------

(81) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(82)
Obligation:
Rules:
f1_in(cons_0) -> f1_in(0) :|: TRUE && cons_0 = 0
f1_in(s(x1:0)) -> f1_in(x1:0) :|: TRUE

----------------------------------------

(83) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f1_in(cons_0) -> f1_in(0) :|: TRUE && cons_0 = 0
(2) f1_in(s(x1:0)) -> f1_in(x1:0) :|: TRUE

Arcs:
(1) -> (1)
(2) -> (1), (2)

This digraph is fully evaluated!
----------------------------------------

(84)
Complex Obligation (AND)

----------------------------------------

(85)
Obligation:

Termination digraph:
Nodes:
(1) f1_in(s(x1:0)) -> f1_in(x1:0) :|: TRUE

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(86) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f1_in(VARIABLE)
s(VARIABLE)
Removed predefined arithmetic.
----------------------------------------

(87)
Obligation:
Rules:
f1_in(s(x1:0)) -> f1_in(x1:0)

----------------------------------------

(88) IRSwTToQDPProof (SOUND)
Removed the integers and created a QDP-Problem.
----------------------------------------

(89)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   f1_in(s(x1:0)) -> f1_in(x1:0)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(90) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*f1_in(s(x1:0)) -> f1_in(x1:0)
The graph contains the following edges 1 > 1


----------------------------------------

(91)
YES

----------------------------------------

(92)
Obligation:

Termination digraph:
Nodes:
(1) f1_in(cons_0) -> f1_in(0) :|: TRUE && cons_0 = 0

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(93) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(94)
Obligation:
Rules:
f1_in(cons_0) -> f1_in(0) :|: TRUE && cons_0 = 0
