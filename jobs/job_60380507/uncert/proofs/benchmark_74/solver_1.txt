YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/UYbDc.pl
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Left Termination of the query pattern

in_order(a,g)

w.r.t. the given Prolog program could successfully be proven:

(0) Prolog
(1) CutEliminatorProof [SOUND, 0 ms]
(2) Prolog
(3) PrologToPiTRSProof [SOUND, 0 ms]
(4) PiTRS
(5) DependencyPairsProof [EQUIVALENT, 6 ms]
(6) PiDP
(7) DependencyGraphProof [EQUIVALENT, 0 ms]
(8) AND
    (9) PiDP
        (10) UsableRulesProof [EQUIVALENT, 0 ms]
        (11) PiDP
        (12) PiDPToQDPProof [SOUND, 0 ms]
        (13) QDP
        (14) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (15) YES
    (16) PiDP
        (17) PiDPToQDPProof [SOUND, 0 ms]
        (18) QDP
        (19) MRRProof [EQUIVALENT, 84 ms]
        (20) QDP
        (21) PisEmptyProof [EQUIVALENT, 0 ms]
        (22) YES


----------------------------------------

(0)
Obligation:
Clauses:

in_order(void, L) :- ','(!, eq(L, [])).
in_order(T, Xs) :- ','(value(T, X), ','(app(Ls, .(X, Rs), Xs), ','(left(T, L), ','(in_order(L, Ls), ','(right(T, R), in_order(R, Rs)))))).
app([], X, X).
app(.(X, Xs), Ys, .(X, Zs)) :- app(Xs, Ys, Zs).
left(void, void).
left(node(L, X1, X2), L).
right(void, void).
right(node(X3, X4, R), R).
value(void, X5).
value(node(X6, X, X7), X).
eq(X, X).


Query: in_order(a,g)
----------------------------------------

(1) CutEliminatorProof (SOUND)
Eliminated all cuts by simply ignoring them[PROLOG].
----------------------------------------

(2)
Obligation:
Clauses:

in_order(void, L) :- eq(L, []).
in_order(T, Xs) :- ','(value(T, X), ','(app(Ls, .(X, Rs), Xs), ','(left(T, L), ','(in_order(L, Ls), ','(right(T, R), in_order(R, Rs)))))).
app([], X, X).
app(.(X, Xs), Ys, .(X, Zs)) :- app(Xs, Ys, Zs).
left(void, void).
left(node(L, X1, X2), L).
right(void, void).
right(node(X3, X4, R), R).
value(void, X5).
value(node(X6, X, X7), X).
eq(X, X).


Query: in_order(a,g)
----------------------------------------

(3) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

in_order_in_2: (f,b)

app_in_3: (f,f,b)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   in_order_in_ag(void, L) -> U1_ag(L, eq_in_gg(L, []))
   eq_in_gg(X, X) -> eq_out_gg(X, X)
   U1_ag(L, eq_out_gg(L, [])) -> in_order_out_ag(void, L)
   in_order_in_ag(T, Xs) -> U2_ag(T, Xs, value_in_aa(T, X))
   value_in_aa(void, X5) -> value_out_aa(void, X5)
   value_in_aa(node(X6, X, X7), X) -> value_out_aa(node(X6, X, X7), X)
   U2_ag(T, Xs, value_out_aa(T, X)) -> U3_ag(T, Xs, X, app_in_aag(Ls, .(X, Rs), Xs))
   app_in_aag([], X, X) -> app_out_aag([], X, X)
   app_in_aag(.(X, Xs), Ys, .(X, Zs)) -> U8_aag(X, Xs, Ys, Zs, app_in_aag(Xs, Ys, Zs))
   U8_aag(X, Xs, Ys, Zs, app_out_aag(Xs, Ys, Zs)) -> app_out_aag(.(X, Xs), Ys, .(X, Zs))
   U3_ag(T, Xs, X, app_out_aag(Ls, .(X, Rs), Xs)) -> U4_ag(T, Xs, X, Ls, Rs, left_in_aa(T, L))
   left_in_aa(void, void) -> left_out_aa(void, void)
   left_in_aa(node(L, X1, X2), L) -> left_out_aa(node(L, X1, X2), L)
   U4_ag(T, Xs, X, Ls, Rs, left_out_aa(T, L)) -> U5_ag(T, Xs, X, Ls, Rs, L, in_order_in_ag(L, Ls))
   U5_ag(T, Xs, X, Ls, Rs, L, in_order_out_ag(L, Ls)) -> U6_ag(T, Xs, X, Ls, Rs, L, right_in_aa(T, R))
   right_in_aa(void, void) -> right_out_aa(void, void)
   right_in_aa(node(X3, X4, R), R) -> right_out_aa(node(X3, X4, R), R)
   U6_ag(T, Xs, X, Ls, Rs, L, right_out_aa(T, R)) -> U7_ag(T, Xs, in_order_in_ag(R, Rs))
   U7_ag(T, Xs, in_order_out_ag(R, Rs)) -> in_order_out_ag(T, Xs)

The argument filtering Pi contains the following mapping:
in_order_in_ag(x1, x2)  =  in_order_in_ag(x2)

U1_ag(x1, x2)  =  U1_ag(x2)

eq_in_gg(x1, x2)  =  eq_in_gg(x1, x2)

eq_out_gg(x1, x2)  =  eq_out_gg

[]  =  []

in_order_out_ag(x1, x2)  =  in_order_out_ag

U2_ag(x1, x2, x3)  =  U2_ag(x2, x3)

value_in_aa(x1, x2)  =  value_in_aa

value_out_aa(x1, x2)  =  value_out_aa

U3_ag(x1, x2, x3, x4)  =  U3_ag(x4)

app_in_aag(x1, x2, x3)  =  app_in_aag(x3)

.(x1, x2)  =  .(x2)

app_out_aag(x1, x2, x3)  =  app_out_aag(x1, x2)

U8_aag(x1, x2, x3, x4, x5)  =  U8_aag(x5)

U4_ag(x1, x2, x3, x4, x5, x6)  =  U4_ag(x4, x5, x6)

left_in_aa(x1, x2)  =  left_in_aa

left_out_aa(x1, x2)  =  left_out_aa

U5_ag(x1, x2, x3, x4, x5, x6, x7)  =  U5_ag(x5, x7)

U6_ag(x1, x2, x3, x4, x5, x6, x7)  =  U6_ag(x5, x7)

right_in_aa(x1, x2)  =  right_in_aa

right_out_aa(x1, x2)  =  right_out_aa

U7_ag(x1, x2, x3)  =  U7_ag(x3)





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(4)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   in_order_in_ag(void, L) -> U1_ag(L, eq_in_gg(L, []))
   eq_in_gg(X, X) -> eq_out_gg(X, X)
   U1_ag(L, eq_out_gg(L, [])) -> in_order_out_ag(void, L)
   in_order_in_ag(T, Xs) -> U2_ag(T, Xs, value_in_aa(T, X))
   value_in_aa(void, X5) -> value_out_aa(void, X5)
   value_in_aa(node(X6, X, X7), X) -> value_out_aa(node(X6, X, X7), X)
   U2_ag(T, Xs, value_out_aa(T, X)) -> U3_ag(T, Xs, X, app_in_aag(Ls, .(X, Rs), Xs))
   app_in_aag([], X, X) -> app_out_aag([], X, X)
   app_in_aag(.(X, Xs), Ys, .(X, Zs)) -> U8_aag(X, Xs, Ys, Zs, app_in_aag(Xs, Ys, Zs))
   U8_aag(X, Xs, Ys, Zs, app_out_aag(Xs, Ys, Zs)) -> app_out_aag(.(X, Xs), Ys, .(X, Zs))
   U3_ag(T, Xs, X, app_out_aag(Ls, .(X, Rs), Xs)) -> U4_ag(T, Xs, X, Ls, Rs, left_in_aa(T, L))
   left_in_aa(void, void) -> left_out_aa(void, void)
   left_in_aa(node(L, X1, X2), L) -> left_out_aa(node(L, X1, X2), L)
   U4_ag(T, Xs, X, Ls, Rs, left_out_aa(T, L)) -> U5_ag(T, Xs, X, Ls, Rs, L, in_order_in_ag(L, Ls))
   U5_ag(T, Xs, X, Ls, Rs, L, in_order_out_ag(L, Ls)) -> U6_ag(T, Xs, X, Ls, Rs, L, right_in_aa(T, R))
   right_in_aa(void, void) -> right_out_aa(void, void)
   right_in_aa(node(X3, X4, R), R) -> right_out_aa(node(X3, X4, R), R)
   U6_ag(T, Xs, X, Ls, Rs, L, right_out_aa(T, R)) -> U7_ag(T, Xs, in_order_in_ag(R, Rs))
   U7_ag(T, Xs, in_order_out_ag(R, Rs)) -> in_order_out_ag(T, Xs)

The argument filtering Pi contains the following mapping:
in_order_in_ag(x1, x2)  =  in_order_in_ag(x2)

U1_ag(x1, x2)  =  U1_ag(x2)

eq_in_gg(x1, x2)  =  eq_in_gg(x1, x2)

eq_out_gg(x1, x2)  =  eq_out_gg

[]  =  []

in_order_out_ag(x1, x2)  =  in_order_out_ag

U2_ag(x1, x2, x3)  =  U2_ag(x2, x3)

value_in_aa(x1, x2)  =  value_in_aa

value_out_aa(x1, x2)  =  value_out_aa

U3_ag(x1, x2, x3, x4)  =  U3_ag(x4)

app_in_aag(x1, x2, x3)  =  app_in_aag(x3)

.(x1, x2)  =  .(x2)

app_out_aag(x1, x2, x3)  =  app_out_aag(x1, x2)

U8_aag(x1, x2, x3, x4, x5)  =  U8_aag(x5)

U4_ag(x1, x2, x3, x4, x5, x6)  =  U4_ag(x4, x5, x6)

left_in_aa(x1, x2)  =  left_in_aa

left_out_aa(x1, x2)  =  left_out_aa

U5_ag(x1, x2, x3, x4, x5, x6, x7)  =  U5_ag(x5, x7)

U6_ag(x1, x2, x3, x4, x5, x6, x7)  =  U6_ag(x5, x7)

right_in_aa(x1, x2)  =  right_in_aa

right_out_aa(x1, x2)  =  right_out_aa

U7_ag(x1, x2, x3)  =  U7_ag(x3)



----------------------------------------

(5) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   IN_ORDER_IN_AG(void, L) -> U1_AG(L, eq_in_gg(L, []))
   IN_ORDER_IN_AG(void, L) -> EQ_IN_GG(L, [])
   IN_ORDER_IN_AG(T, Xs) -> U2_AG(T, Xs, value_in_aa(T, X))
   IN_ORDER_IN_AG(T, Xs) -> VALUE_IN_AA(T, X)
   U2_AG(T, Xs, value_out_aa(T, X)) -> U3_AG(T, Xs, X, app_in_aag(Ls, .(X, Rs), Xs))
   U2_AG(T, Xs, value_out_aa(T, X)) -> APP_IN_AAG(Ls, .(X, Rs), Xs)
   APP_IN_AAG(.(X, Xs), Ys, .(X, Zs)) -> U8_AAG(X, Xs, Ys, Zs, app_in_aag(Xs, Ys, Zs))
   APP_IN_AAG(.(X, Xs), Ys, .(X, Zs)) -> APP_IN_AAG(Xs, Ys, Zs)
   U3_AG(T, Xs, X, app_out_aag(Ls, .(X, Rs), Xs)) -> U4_AG(T, Xs, X, Ls, Rs, left_in_aa(T, L))
   U3_AG(T, Xs, X, app_out_aag(Ls, .(X, Rs), Xs)) -> LEFT_IN_AA(T, L)
   U4_AG(T, Xs, X, Ls, Rs, left_out_aa(T, L)) -> U5_AG(T, Xs, X, Ls, Rs, L, in_order_in_ag(L, Ls))
   U4_AG(T, Xs, X, Ls, Rs, left_out_aa(T, L)) -> IN_ORDER_IN_AG(L, Ls)
   U5_AG(T, Xs, X, Ls, Rs, L, in_order_out_ag(L, Ls)) -> U6_AG(T, Xs, X, Ls, Rs, L, right_in_aa(T, R))
   U5_AG(T, Xs, X, Ls, Rs, L, in_order_out_ag(L, Ls)) -> RIGHT_IN_AA(T, R)
   U6_AG(T, Xs, X, Ls, Rs, L, right_out_aa(T, R)) -> U7_AG(T, Xs, in_order_in_ag(R, Rs))
   U6_AG(T, Xs, X, Ls, Rs, L, right_out_aa(T, R)) -> IN_ORDER_IN_AG(R, Rs)

The TRS R consists of the following rules:

   in_order_in_ag(void, L) -> U1_ag(L, eq_in_gg(L, []))
   eq_in_gg(X, X) -> eq_out_gg(X, X)
   U1_ag(L, eq_out_gg(L, [])) -> in_order_out_ag(void, L)
   in_order_in_ag(T, Xs) -> U2_ag(T, Xs, value_in_aa(T, X))
   value_in_aa(void, X5) -> value_out_aa(void, X5)
   value_in_aa(node(X6, X, X7), X) -> value_out_aa(node(X6, X, X7), X)
   U2_ag(T, Xs, value_out_aa(T, X)) -> U3_ag(T, Xs, X, app_in_aag(Ls, .(X, Rs), Xs))
   app_in_aag([], X, X) -> app_out_aag([], X, X)
   app_in_aag(.(X, Xs), Ys, .(X, Zs)) -> U8_aag(X, Xs, Ys, Zs, app_in_aag(Xs, Ys, Zs))
   U8_aag(X, Xs, Ys, Zs, app_out_aag(Xs, Ys, Zs)) -> app_out_aag(.(X, Xs), Ys, .(X, Zs))
   U3_ag(T, Xs, X, app_out_aag(Ls, .(X, Rs), Xs)) -> U4_ag(T, Xs, X, Ls, Rs, left_in_aa(T, L))
   left_in_aa(void, void) -> left_out_aa(void, void)
   left_in_aa(node(L, X1, X2), L) -> left_out_aa(node(L, X1, X2), L)
   U4_ag(T, Xs, X, Ls, Rs, left_out_aa(T, L)) -> U5_ag(T, Xs, X, Ls, Rs, L, in_order_in_ag(L, Ls))
   U5_ag(T, Xs, X, Ls, Rs, L, in_order_out_ag(L, Ls)) -> U6_ag(T, Xs, X, Ls, Rs, L, right_in_aa(T, R))
   right_in_aa(void, void) -> right_out_aa(void, void)
   right_in_aa(node(X3, X4, R), R) -> right_out_aa(node(X3, X4, R), R)
   U6_ag(T, Xs, X, Ls, Rs, L, right_out_aa(T, R)) -> U7_ag(T, Xs, in_order_in_ag(R, Rs))
   U7_ag(T, Xs, in_order_out_ag(R, Rs)) -> in_order_out_ag(T, Xs)

The argument filtering Pi contains the following mapping:
in_order_in_ag(x1, x2)  =  in_order_in_ag(x2)

U1_ag(x1, x2)  =  U1_ag(x2)

eq_in_gg(x1, x2)  =  eq_in_gg(x1, x2)

eq_out_gg(x1, x2)  =  eq_out_gg

[]  =  []

in_order_out_ag(x1, x2)  =  in_order_out_ag

U2_ag(x1, x2, x3)  =  U2_ag(x2, x3)

value_in_aa(x1, x2)  =  value_in_aa

value_out_aa(x1, x2)  =  value_out_aa

U3_ag(x1, x2, x3, x4)  =  U3_ag(x4)

app_in_aag(x1, x2, x3)  =  app_in_aag(x3)

.(x1, x2)  =  .(x2)

app_out_aag(x1, x2, x3)  =  app_out_aag(x1, x2)

U8_aag(x1, x2, x3, x4, x5)  =  U8_aag(x5)

U4_ag(x1, x2, x3, x4, x5, x6)  =  U4_ag(x4, x5, x6)

left_in_aa(x1, x2)  =  left_in_aa

left_out_aa(x1, x2)  =  left_out_aa

U5_ag(x1, x2, x3, x4, x5, x6, x7)  =  U5_ag(x5, x7)

U6_ag(x1, x2, x3, x4, x5, x6, x7)  =  U6_ag(x5, x7)

right_in_aa(x1, x2)  =  right_in_aa

right_out_aa(x1, x2)  =  right_out_aa

U7_ag(x1, x2, x3)  =  U7_ag(x3)

IN_ORDER_IN_AG(x1, x2)  =  IN_ORDER_IN_AG(x2)

U1_AG(x1, x2)  =  U1_AG(x2)

EQ_IN_GG(x1, x2)  =  EQ_IN_GG(x1, x2)

U2_AG(x1, x2, x3)  =  U2_AG(x2, x3)

VALUE_IN_AA(x1, x2)  =  VALUE_IN_AA

U3_AG(x1, x2, x3, x4)  =  U3_AG(x4)

APP_IN_AAG(x1, x2, x3)  =  APP_IN_AAG(x3)

U8_AAG(x1, x2, x3, x4, x5)  =  U8_AAG(x5)

U4_AG(x1, x2, x3, x4, x5, x6)  =  U4_AG(x4, x5, x6)

LEFT_IN_AA(x1, x2)  =  LEFT_IN_AA

U5_AG(x1, x2, x3, x4, x5, x6, x7)  =  U5_AG(x5, x7)

U6_AG(x1, x2, x3, x4, x5, x6, x7)  =  U6_AG(x5, x7)

RIGHT_IN_AA(x1, x2)  =  RIGHT_IN_AA

U7_AG(x1, x2, x3)  =  U7_AG(x3)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(6)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   IN_ORDER_IN_AG(void, L) -> U1_AG(L, eq_in_gg(L, []))
   IN_ORDER_IN_AG(void, L) -> EQ_IN_GG(L, [])
   IN_ORDER_IN_AG(T, Xs) -> U2_AG(T, Xs, value_in_aa(T, X))
   IN_ORDER_IN_AG(T, Xs) -> VALUE_IN_AA(T, X)
   U2_AG(T, Xs, value_out_aa(T, X)) -> U3_AG(T, Xs, X, app_in_aag(Ls, .(X, Rs), Xs))
   U2_AG(T, Xs, value_out_aa(T, X)) -> APP_IN_AAG(Ls, .(X, Rs), Xs)
   APP_IN_AAG(.(X, Xs), Ys, .(X, Zs)) -> U8_AAG(X, Xs, Ys, Zs, app_in_aag(Xs, Ys, Zs))
   APP_IN_AAG(.(X, Xs), Ys, .(X, Zs)) -> APP_IN_AAG(Xs, Ys, Zs)
   U3_AG(T, Xs, X, app_out_aag(Ls, .(X, Rs), Xs)) -> U4_AG(T, Xs, X, Ls, Rs, left_in_aa(T, L))
   U3_AG(T, Xs, X, app_out_aag(Ls, .(X, Rs), Xs)) -> LEFT_IN_AA(T, L)
   U4_AG(T, Xs, X, Ls, Rs, left_out_aa(T, L)) -> U5_AG(T, Xs, X, Ls, Rs, L, in_order_in_ag(L, Ls))
   U4_AG(T, Xs, X, Ls, Rs, left_out_aa(T, L)) -> IN_ORDER_IN_AG(L, Ls)
   U5_AG(T, Xs, X, Ls, Rs, L, in_order_out_ag(L, Ls)) -> U6_AG(T, Xs, X, Ls, Rs, L, right_in_aa(T, R))
   U5_AG(T, Xs, X, Ls, Rs, L, in_order_out_ag(L, Ls)) -> RIGHT_IN_AA(T, R)
   U6_AG(T, Xs, X, Ls, Rs, L, right_out_aa(T, R)) -> U7_AG(T, Xs, in_order_in_ag(R, Rs))
   U6_AG(T, Xs, X, Ls, Rs, L, right_out_aa(T, R)) -> IN_ORDER_IN_AG(R, Rs)

The TRS R consists of the following rules:

   in_order_in_ag(void, L) -> U1_ag(L, eq_in_gg(L, []))
   eq_in_gg(X, X) -> eq_out_gg(X, X)
   U1_ag(L, eq_out_gg(L, [])) -> in_order_out_ag(void, L)
   in_order_in_ag(T, Xs) -> U2_ag(T, Xs, value_in_aa(T, X))
   value_in_aa(void, X5) -> value_out_aa(void, X5)
   value_in_aa(node(X6, X, X7), X) -> value_out_aa(node(X6, X, X7), X)
   U2_ag(T, Xs, value_out_aa(T, X)) -> U3_ag(T, Xs, X, app_in_aag(Ls, .(X, Rs), Xs))
   app_in_aag([], X, X) -> app_out_aag([], X, X)
   app_in_aag(.(X, Xs), Ys, .(X, Zs)) -> U8_aag(X, Xs, Ys, Zs, app_in_aag(Xs, Ys, Zs))
   U8_aag(X, Xs, Ys, Zs, app_out_aag(Xs, Ys, Zs)) -> app_out_aag(.(X, Xs), Ys, .(X, Zs))
   U3_ag(T, Xs, X, app_out_aag(Ls, .(X, Rs), Xs)) -> U4_ag(T, Xs, X, Ls, Rs, left_in_aa(T, L))
   left_in_aa(void, void) -> left_out_aa(void, void)
   left_in_aa(node(L, X1, X2), L) -> left_out_aa(node(L, X1, X2), L)
   U4_ag(T, Xs, X, Ls, Rs, left_out_aa(T, L)) -> U5_ag(T, Xs, X, Ls, Rs, L, in_order_in_ag(L, Ls))
   U5_ag(T, Xs, X, Ls, Rs, L, in_order_out_ag(L, Ls)) -> U6_ag(T, Xs, X, Ls, Rs, L, right_in_aa(T, R))
   right_in_aa(void, void) -> right_out_aa(void, void)
   right_in_aa(node(X3, X4, R), R) -> right_out_aa(node(X3, X4, R), R)
   U6_ag(T, Xs, X, Ls, Rs, L, right_out_aa(T, R)) -> U7_ag(T, Xs, in_order_in_ag(R, Rs))
   U7_ag(T, Xs, in_order_out_ag(R, Rs)) -> in_order_out_ag(T, Xs)

The argument filtering Pi contains the following mapping:
in_order_in_ag(x1, x2)  =  in_order_in_ag(x2)

U1_ag(x1, x2)  =  U1_ag(x2)

eq_in_gg(x1, x2)  =  eq_in_gg(x1, x2)

eq_out_gg(x1, x2)  =  eq_out_gg

[]  =  []

in_order_out_ag(x1, x2)  =  in_order_out_ag

U2_ag(x1, x2, x3)  =  U2_ag(x2, x3)

value_in_aa(x1, x2)  =  value_in_aa

value_out_aa(x1, x2)  =  value_out_aa

U3_ag(x1, x2, x3, x4)  =  U3_ag(x4)

app_in_aag(x1, x2, x3)  =  app_in_aag(x3)

.(x1, x2)  =  .(x2)

app_out_aag(x1, x2, x3)  =  app_out_aag(x1, x2)

U8_aag(x1, x2, x3, x4, x5)  =  U8_aag(x5)

U4_ag(x1, x2, x3, x4, x5, x6)  =  U4_ag(x4, x5, x6)

left_in_aa(x1, x2)  =  left_in_aa

left_out_aa(x1, x2)  =  left_out_aa

U5_ag(x1, x2, x3, x4, x5, x6, x7)  =  U5_ag(x5, x7)

U6_ag(x1, x2, x3, x4, x5, x6, x7)  =  U6_ag(x5, x7)

right_in_aa(x1, x2)  =  right_in_aa

right_out_aa(x1, x2)  =  right_out_aa

U7_ag(x1, x2, x3)  =  U7_ag(x3)

IN_ORDER_IN_AG(x1, x2)  =  IN_ORDER_IN_AG(x2)

U1_AG(x1, x2)  =  U1_AG(x2)

EQ_IN_GG(x1, x2)  =  EQ_IN_GG(x1, x2)

U2_AG(x1, x2, x3)  =  U2_AG(x2, x3)

VALUE_IN_AA(x1, x2)  =  VALUE_IN_AA

U3_AG(x1, x2, x3, x4)  =  U3_AG(x4)

APP_IN_AAG(x1, x2, x3)  =  APP_IN_AAG(x3)

U8_AAG(x1, x2, x3, x4, x5)  =  U8_AAG(x5)

U4_AG(x1, x2, x3, x4, x5, x6)  =  U4_AG(x4, x5, x6)

LEFT_IN_AA(x1, x2)  =  LEFT_IN_AA

U5_AG(x1, x2, x3, x4, x5, x6, x7)  =  U5_AG(x5, x7)

U6_AG(x1, x2, x3, x4, x5, x6, x7)  =  U6_AG(x5, x7)

RIGHT_IN_AA(x1, x2)  =  RIGHT_IN_AA

U7_AG(x1, x2, x3)  =  U7_AG(x3)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(7) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 2 SCCs with 8 less nodes.
----------------------------------------

(8)
Complex Obligation (AND)

----------------------------------------

(9)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   APP_IN_AAG(.(X, Xs), Ys, .(X, Zs)) -> APP_IN_AAG(Xs, Ys, Zs)

The TRS R consists of the following rules:

   in_order_in_ag(void, L) -> U1_ag(L, eq_in_gg(L, []))
   eq_in_gg(X, X) -> eq_out_gg(X, X)
   U1_ag(L, eq_out_gg(L, [])) -> in_order_out_ag(void, L)
   in_order_in_ag(T, Xs) -> U2_ag(T, Xs, value_in_aa(T, X))
   value_in_aa(void, X5) -> value_out_aa(void, X5)
   value_in_aa(node(X6, X, X7), X) -> value_out_aa(node(X6, X, X7), X)
   U2_ag(T, Xs, value_out_aa(T, X)) -> U3_ag(T, Xs, X, app_in_aag(Ls, .(X, Rs), Xs))
   app_in_aag([], X, X) -> app_out_aag([], X, X)
   app_in_aag(.(X, Xs), Ys, .(X, Zs)) -> U8_aag(X, Xs, Ys, Zs, app_in_aag(Xs, Ys, Zs))
   U8_aag(X, Xs, Ys, Zs, app_out_aag(Xs, Ys, Zs)) -> app_out_aag(.(X, Xs), Ys, .(X, Zs))
   U3_ag(T, Xs, X, app_out_aag(Ls, .(X, Rs), Xs)) -> U4_ag(T, Xs, X, Ls, Rs, left_in_aa(T, L))
   left_in_aa(void, void) -> left_out_aa(void, void)
   left_in_aa(node(L, X1, X2), L) -> left_out_aa(node(L, X1, X2), L)
   U4_ag(T, Xs, X, Ls, Rs, left_out_aa(T, L)) -> U5_ag(T, Xs, X, Ls, Rs, L, in_order_in_ag(L, Ls))
   U5_ag(T, Xs, X, Ls, Rs, L, in_order_out_ag(L, Ls)) -> U6_ag(T, Xs, X, Ls, Rs, L, right_in_aa(T, R))
   right_in_aa(void, void) -> right_out_aa(void, void)
   right_in_aa(node(X3, X4, R), R) -> right_out_aa(node(X3, X4, R), R)
   U6_ag(T, Xs, X, Ls, Rs, L, right_out_aa(T, R)) -> U7_ag(T, Xs, in_order_in_ag(R, Rs))
   U7_ag(T, Xs, in_order_out_ag(R, Rs)) -> in_order_out_ag(T, Xs)

The argument filtering Pi contains the following mapping:
in_order_in_ag(x1, x2)  =  in_order_in_ag(x2)

U1_ag(x1, x2)  =  U1_ag(x2)

eq_in_gg(x1, x2)  =  eq_in_gg(x1, x2)

eq_out_gg(x1, x2)  =  eq_out_gg

[]  =  []

in_order_out_ag(x1, x2)  =  in_order_out_ag

U2_ag(x1, x2, x3)  =  U2_ag(x2, x3)

value_in_aa(x1, x2)  =  value_in_aa

value_out_aa(x1, x2)  =  value_out_aa

U3_ag(x1, x2, x3, x4)  =  U3_ag(x4)

app_in_aag(x1, x2, x3)  =  app_in_aag(x3)

.(x1, x2)  =  .(x2)

app_out_aag(x1, x2, x3)  =  app_out_aag(x1, x2)

U8_aag(x1, x2, x3, x4, x5)  =  U8_aag(x5)

U4_ag(x1, x2, x3, x4, x5, x6)  =  U4_ag(x4, x5, x6)

left_in_aa(x1, x2)  =  left_in_aa

left_out_aa(x1, x2)  =  left_out_aa

U5_ag(x1, x2, x3, x4, x5, x6, x7)  =  U5_ag(x5, x7)

U6_ag(x1, x2, x3, x4, x5, x6, x7)  =  U6_ag(x5, x7)

right_in_aa(x1, x2)  =  right_in_aa

right_out_aa(x1, x2)  =  right_out_aa

U7_ag(x1, x2, x3)  =  U7_ag(x3)

APP_IN_AAG(x1, x2, x3)  =  APP_IN_AAG(x3)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(10) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(11)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   APP_IN_AAG(.(X, Xs), Ys, .(X, Zs)) -> APP_IN_AAG(Xs, Ys, Zs)

R is empty.
The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x2)

APP_IN_AAG(x1, x2, x3)  =  APP_IN_AAG(x3)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(12) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(13)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   APP_IN_AAG(.(Zs)) -> APP_IN_AAG(Zs)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(14) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*APP_IN_AAG(.(Zs)) -> APP_IN_AAG(Zs)
The graph contains the following edges 1 > 1


----------------------------------------

(15)
YES

----------------------------------------

(16)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   IN_ORDER_IN_AG(T, Xs) -> U2_AG(T, Xs, value_in_aa(T, X))
   U2_AG(T, Xs, value_out_aa(T, X)) -> U3_AG(T, Xs, X, app_in_aag(Ls, .(X, Rs), Xs))
   U3_AG(T, Xs, X, app_out_aag(Ls, .(X, Rs), Xs)) -> U4_AG(T, Xs, X, Ls, Rs, left_in_aa(T, L))
   U4_AG(T, Xs, X, Ls, Rs, left_out_aa(T, L)) -> U5_AG(T, Xs, X, Ls, Rs, L, in_order_in_ag(L, Ls))
   U5_AG(T, Xs, X, Ls, Rs, L, in_order_out_ag(L, Ls)) -> U6_AG(T, Xs, X, Ls, Rs, L, right_in_aa(T, R))
   U6_AG(T, Xs, X, Ls, Rs, L, right_out_aa(T, R)) -> IN_ORDER_IN_AG(R, Rs)
   U4_AG(T, Xs, X, Ls, Rs, left_out_aa(T, L)) -> IN_ORDER_IN_AG(L, Ls)

The TRS R consists of the following rules:

   in_order_in_ag(void, L) -> U1_ag(L, eq_in_gg(L, []))
   eq_in_gg(X, X) -> eq_out_gg(X, X)
   U1_ag(L, eq_out_gg(L, [])) -> in_order_out_ag(void, L)
   in_order_in_ag(T, Xs) -> U2_ag(T, Xs, value_in_aa(T, X))
   value_in_aa(void, X5) -> value_out_aa(void, X5)
   value_in_aa(node(X6, X, X7), X) -> value_out_aa(node(X6, X, X7), X)
   U2_ag(T, Xs, value_out_aa(T, X)) -> U3_ag(T, Xs, X, app_in_aag(Ls, .(X, Rs), Xs))
   app_in_aag([], X, X) -> app_out_aag([], X, X)
   app_in_aag(.(X, Xs), Ys, .(X, Zs)) -> U8_aag(X, Xs, Ys, Zs, app_in_aag(Xs, Ys, Zs))
   U8_aag(X, Xs, Ys, Zs, app_out_aag(Xs, Ys, Zs)) -> app_out_aag(.(X, Xs), Ys, .(X, Zs))
   U3_ag(T, Xs, X, app_out_aag(Ls, .(X, Rs), Xs)) -> U4_ag(T, Xs, X, Ls, Rs, left_in_aa(T, L))
   left_in_aa(void, void) -> left_out_aa(void, void)
   left_in_aa(node(L, X1, X2), L) -> left_out_aa(node(L, X1, X2), L)
   U4_ag(T, Xs, X, Ls, Rs, left_out_aa(T, L)) -> U5_ag(T, Xs, X, Ls, Rs, L, in_order_in_ag(L, Ls))
   U5_ag(T, Xs, X, Ls, Rs, L, in_order_out_ag(L, Ls)) -> U6_ag(T, Xs, X, Ls, Rs, L, right_in_aa(T, R))
   right_in_aa(void, void) -> right_out_aa(void, void)
   right_in_aa(node(X3, X4, R), R) -> right_out_aa(node(X3, X4, R), R)
   U6_ag(T, Xs, X, Ls, Rs, L, right_out_aa(T, R)) -> U7_ag(T, Xs, in_order_in_ag(R, Rs))
   U7_ag(T, Xs, in_order_out_ag(R, Rs)) -> in_order_out_ag(T, Xs)

The argument filtering Pi contains the following mapping:
in_order_in_ag(x1, x2)  =  in_order_in_ag(x2)

U1_ag(x1, x2)  =  U1_ag(x2)

eq_in_gg(x1, x2)  =  eq_in_gg(x1, x2)

eq_out_gg(x1, x2)  =  eq_out_gg

[]  =  []

in_order_out_ag(x1, x2)  =  in_order_out_ag

U2_ag(x1, x2, x3)  =  U2_ag(x2, x3)

value_in_aa(x1, x2)  =  value_in_aa

value_out_aa(x1, x2)  =  value_out_aa

U3_ag(x1, x2, x3, x4)  =  U3_ag(x4)

app_in_aag(x1, x2, x3)  =  app_in_aag(x3)

.(x1, x2)  =  .(x2)

app_out_aag(x1, x2, x3)  =  app_out_aag(x1, x2)

U8_aag(x1, x2, x3, x4, x5)  =  U8_aag(x5)

U4_ag(x1, x2, x3, x4, x5, x6)  =  U4_ag(x4, x5, x6)

left_in_aa(x1, x2)  =  left_in_aa

left_out_aa(x1, x2)  =  left_out_aa

U5_ag(x1, x2, x3, x4, x5, x6, x7)  =  U5_ag(x5, x7)

U6_ag(x1, x2, x3, x4, x5, x6, x7)  =  U6_ag(x5, x7)

right_in_aa(x1, x2)  =  right_in_aa

right_out_aa(x1, x2)  =  right_out_aa

U7_ag(x1, x2, x3)  =  U7_ag(x3)

IN_ORDER_IN_AG(x1, x2)  =  IN_ORDER_IN_AG(x2)

U2_AG(x1, x2, x3)  =  U2_AG(x2, x3)

U3_AG(x1, x2, x3, x4)  =  U3_AG(x4)

U4_AG(x1, x2, x3, x4, x5, x6)  =  U4_AG(x4, x5, x6)

U5_AG(x1, x2, x3, x4, x5, x6, x7)  =  U5_AG(x5, x7)

U6_AG(x1, x2, x3, x4, x5, x6, x7)  =  U6_AG(x5, x7)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(17) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(18)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IN_ORDER_IN_AG(Xs) -> U2_AG(Xs, value_in_aa)
   U2_AG(Xs, value_out_aa) -> U3_AG(app_in_aag(Xs))
   U3_AG(app_out_aag(Ls, .(Rs))) -> U4_AG(Ls, Rs, left_in_aa)
   U4_AG(Ls, Rs, left_out_aa) -> U5_AG(Rs, in_order_in_ag(Ls))
   U5_AG(Rs, in_order_out_ag) -> U6_AG(Rs, right_in_aa)
   U6_AG(Rs, right_out_aa) -> IN_ORDER_IN_AG(Rs)
   U4_AG(Ls, Rs, left_out_aa) -> IN_ORDER_IN_AG(Ls)

The TRS R consists of the following rules:

   in_order_in_ag(L) -> U1_ag(eq_in_gg(L, []))
   eq_in_gg(X, X) -> eq_out_gg
   U1_ag(eq_out_gg) -> in_order_out_ag
   in_order_in_ag(Xs) -> U2_ag(Xs, value_in_aa)
   value_in_aa -> value_out_aa
   U2_ag(Xs, value_out_aa) -> U3_ag(app_in_aag(Xs))
   app_in_aag(X) -> app_out_aag([], X)
   app_in_aag(.(Zs)) -> U8_aag(app_in_aag(Zs))
   U8_aag(app_out_aag(Xs, Ys)) -> app_out_aag(.(Xs), Ys)
   U3_ag(app_out_aag(Ls, .(Rs))) -> U4_ag(Ls, Rs, left_in_aa)
   left_in_aa -> left_out_aa
   U4_ag(Ls, Rs, left_out_aa) -> U5_ag(Rs, in_order_in_ag(Ls))
   U5_ag(Rs, in_order_out_ag) -> U6_ag(Rs, right_in_aa)
   right_in_aa -> right_out_aa
   U6_ag(Rs, right_out_aa) -> U7_ag(in_order_in_ag(Rs))
   U7_ag(in_order_out_ag) -> in_order_out_ag

The set Q consists of the following terms:

   in_order_in_ag(x0)
   eq_in_gg(x0, x1)
   U1_ag(x0)
   value_in_aa
   U2_ag(x0, x1)
   app_in_aag(x0)
   U8_aag(x0)
   U3_ag(x0)
   left_in_aa
   U4_ag(x0, x1, x2)
   U5_ag(x0, x1)
   right_in_aa
   U6_ag(x0, x1)
   U7_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(19) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   IN_ORDER_IN_AG(Xs) -> U2_AG(Xs, value_in_aa)
   U2_AG(Xs, value_out_aa) -> U3_AG(app_in_aag(Xs))
   U3_AG(app_out_aag(Ls, .(Rs))) -> U4_AG(Ls, Rs, left_in_aa)
   U4_AG(Ls, Rs, left_out_aa) -> U5_AG(Rs, in_order_in_ag(Ls))
   U5_AG(Rs, in_order_out_ag) -> U6_AG(Rs, right_in_aa)
   U6_AG(Rs, right_out_aa) -> IN_ORDER_IN_AG(Rs)
   U4_AG(Ls, Rs, left_out_aa) -> IN_ORDER_IN_AG(Ls)

Strictly oriented rules of the TRS R:

   in_order_in_ag(L) -> U1_ag(eq_in_gg(L, []))
   eq_in_gg(X, X) -> eq_out_gg
   U1_ag(eq_out_gg) -> in_order_out_ag
   in_order_in_ag(Xs) -> U2_ag(Xs, value_in_aa)
   value_in_aa -> value_out_aa
   U2_ag(Xs, value_out_aa) -> U3_ag(app_in_aag(Xs))
   app_in_aag(X) -> app_out_aag([], X)
   app_in_aag(.(Zs)) -> U8_aag(app_in_aag(Zs))
   U8_aag(app_out_aag(Xs, Ys)) -> app_out_aag(.(Xs), Ys)
   U3_ag(app_out_aag(Ls, .(Rs))) -> U4_ag(Ls, Rs, left_in_aa)
   left_in_aa -> left_out_aa
   U4_ag(Ls, Rs, left_out_aa) -> U5_ag(Rs, in_order_in_ag(Ls))
   U5_ag(Rs, in_order_out_ag) -> U6_ag(Rs, right_in_aa)
   right_in_aa -> right_out_aa
   U6_ag(Rs, right_out_aa) -> U7_ag(in_order_in_ag(Rs))
   U7_ag(in_order_out_ag) -> in_order_out_ag

Used ordering: Knuth-Bendix order [KBO] with precedence:U4_AG_3 > left_in_aa > U1_ag_1 > right_out_aa > right_in_aa > IN_ORDER_IN_AG_1 > left_out_aa > in_order_in_ag_1 > U2_ag_2 > in_order_out_ag > eq_out_gg > app_in_aag_1 > U8_aag_1 > [] > app_out_aag_2 > U2_AG_2 > value_in_aa > U3_ag_1 > U7_ag_1 > U4_ag_3 > U5_ag_2 > U6_ag_2 > U5_AG_2 > U6_AG_2 > U3_AG_1 > ._1 > value_out_aa > eq_in_gg_2

and weight map:

   []=2
   eq_out_gg=10
   in_order_out_ag=11
   value_in_aa=2
   value_out_aa=1
   left_in_aa=19
   left_out_aa=18
   right_in_aa=10
   right_out_aa=9
   in_order_in_ag_1=13
   U1_ag_1=1
   U3_ag_1=1
   app_in_aag_1=11
   ._1=10
   U8_aag_1=10
   U7_ag_1=1
   IN_ORDER_IN_AG_1=14
   U3_AG_1=2
   eq_in_gg_2=9
   U2_ag_2=11
   app_out_aag_2=8
   U4_ag_3=0
   U5_ag_2=5
   U6_ag_2=6
   U2_AG_2=12
   U4_AG_3=0
   U5_AG_2=5
   U6_AG_2=6

The variable weight is 1

----------------------------------------

(20)
Obligation:
Q DP problem:
P is empty.
R is empty.
The set Q consists of the following terms:

   in_order_in_ag(x0)
   eq_in_gg(x0, x1)
   U1_ag(x0)
   value_in_aa
   U2_ag(x0, x1)
   app_in_aag(x0)
   U8_aag(x0)
   U3_ag(x0)
   left_in_aa
   U4_ag(x0, x1, x2)
   U5_ag(x0, x1)
   right_in_aa
   U6_ag(x0, x1)
   U7_ag(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(21) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(22)
YES
