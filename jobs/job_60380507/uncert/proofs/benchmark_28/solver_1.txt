YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/NLuin.pl
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Left Termination of the query pattern

p(a)

w.r.t. the given Prolog program could successfully be proven:

(0) Prolog
(1) BuiltinConflictTransformerProof [EQUIVALENT, 0 ms]
(2) Prolog
(3) CutEliminatorProof [SOUND, 0 ms]
(4) Prolog
(5) PrologToPiTRSProof [SOUND, 0 ms]
(6) PiTRS
(7) DependencyPairsProof [EQUIVALENT, 0 ms]
(8) PiDP
(9) DependencyGraphProof [EQUIVALENT, 0 ms]
(10) TRUE


----------------------------------------

(0)
Obligation:
Clauses:

p(X) :- ','(q(X), r(X)).
p(X) :- =(X, 2).
q(X) :- ','(=(X, 1), !).
q(X) :- =(X, 3).
r(X) :- ','(=(X, 1), !).
r(X) :- =(X, 4).
=(X, X).


Query: p(a)
----------------------------------------

(1) BuiltinConflictTransformerProof (EQUIVALENT)
Renamed defined predicates conflicting with built-in predicates [PROLOG].
----------------------------------------

(2)
Obligation:
Clauses:

p(X) :- ','(q(X), r(X)).
p(X) :- user_defined_=(X, 2).
q(X) :- ','(user_defined_=(X, 1), !).
q(X) :- user_defined_=(X, 3).
r(X) :- ','(user_defined_=(X, 1), !).
r(X) :- user_defined_=(X, 4).
user_defined_=(X, X).


Query: p(a)
----------------------------------------

(3) CutEliminatorProof (SOUND)
Eliminated all cuts by simply ignoring them[PROLOG].
----------------------------------------

(4)
Obligation:
Clauses:

p(X) :- ','(q(X), r(X)).
p(X) :- user_defined_=(X, 2).
q(X) :- user_defined_=(X, 1).
q(X) :- user_defined_=(X, 3).
r(X) :- user_defined_=(X, 1).
r(X) :- user_defined_=(X, 4).
user_defined_=(X, X).


Query: p(a)
----------------------------------------

(5) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

p_in_1: (f)

q_in_1: (f)

r_in_1: (b)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   p_in_a(X) -> U1_a(X, q_in_a(X))
   q_in_a(X) -> U4_a(X, user_defined_=_in_ag(X, 1))
   user_defined_=_in_ag(X, X) -> user_defined_=_out_ag(X, X)
   U4_a(X, user_defined_=_out_ag(X, 1)) -> q_out_a(X)
   q_in_a(X) -> U5_a(X, user_defined_=_in_ag(X, 3))
   U5_a(X, user_defined_=_out_ag(X, 3)) -> q_out_a(X)
   U1_a(X, q_out_a(X)) -> U2_a(X, r_in_g(X))
   r_in_g(X) -> U6_g(X, user_defined_=_in_gg(X, 1))
   user_defined_=_in_gg(X, X) -> user_defined_=_out_gg(X, X)
   U6_g(X, user_defined_=_out_gg(X, 1)) -> r_out_g(X)
   r_in_g(X) -> U7_g(X, user_defined_=_in_gg(X, 4))
   U7_g(X, user_defined_=_out_gg(X, 4)) -> r_out_g(X)
   U2_a(X, r_out_g(X)) -> p_out_a(X)
   p_in_a(X) -> U3_a(X, user_defined_=_in_ag(X, 2))
   U3_a(X, user_defined_=_out_ag(X, 2)) -> p_out_a(X)

The argument filtering Pi contains the following mapping:
p_in_a(x1)  =  p_in_a

U1_a(x1, x2)  =  U1_a(x2)

q_in_a(x1)  =  q_in_a

U4_a(x1, x2)  =  U4_a(x2)

user_defined_=_in_ag(x1, x2)  =  user_defined_=_in_ag(x2)

user_defined_=_out_ag(x1, x2)  =  user_defined_=_out_ag(x1)

1  =  1

q_out_a(x1)  =  q_out_a(x1)

U5_a(x1, x2)  =  U5_a(x2)

3  =  3

U2_a(x1, x2)  =  U2_a(x1, x2)

r_in_g(x1)  =  r_in_g(x1)

U6_g(x1, x2)  =  U6_g(x2)

user_defined_=_in_gg(x1, x2)  =  user_defined_=_in_gg(x1, x2)

user_defined_=_out_gg(x1, x2)  =  user_defined_=_out_gg

r_out_g(x1)  =  r_out_g

U7_g(x1, x2)  =  U7_g(x2)

4  =  4

p_out_a(x1)  =  p_out_a(x1)

U3_a(x1, x2)  =  U3_a(x2)

2  =  2





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(6)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   p_in_a(X) -> U1_a(X, q_in_a(X))
   q_in_a(X) -> U4_a(X, user_defined_=_in_ag(X, 1))
   user_defined_=_in_ag(X, X) -> user_defined_=_out_ag(X, X)
   U4_a(X, user_defined_=_out_ag(X, 1)) -> q_out_a(X)
   q_in_a(X) -> U5_a(X, user_defined_=_in_ag(X, 3))
   U5_a(X, user_defined_=_out_ag(X, 3)) -> q_out_a(X)
   U1_a(X, q_out_a(X)) -> U2_a(X, r_in_g(X))
   r_in_g(X) -> U6_g(X, user_defined_=_in_gg(X, 1))
   user_defined_=_in_gg(X, X) -> user_defined_=_out_gg(X, X)
   U6_g(X, user_defined_=_out_gg(X, 1)) -> r_out_g(X)
   r_in_g(X) -> U7_g(X, user_defined_=_in_gg(X, 4))
   U7_g(X, user_defined_=_out_gg(X, 4)) -> r_out_g(X)
   U2_a(X, r_out_g(X)) -> p_out_a(X)
   p_in_a(X) -> U3_a(X, user_defined_=_in_ag(X, 2))
   U3_a(X, user_defined_=_out_ag(X, 2)) -> p_out_a(X)

The argument filtering Pi contains the following mapping:
p_in_a(x1)  =  p_in_a

U1_a(x1, x2)  =  U1_a(x2)

q_in_a(x1)  =  q_in_a

U4_a(x1, x2)  =  U4_a(x2)

user_defined_=_in_ag(x1, x2)  =  user_defined_=_in_ag(x2)

user_defined_=_out_ag(x1, x2)  =  user_defined_=_out_ag(x1)

1  =  1

q_out_a(x1)  =  q_out_a(x1)

U5_a(x1, x2)  =  U5_a(x2)

3  =  3

U2_a(x1, x2)  =  U2_a(x1, x2)

r_in_g(x1)  =  r_in_g(x1)

U6_g(x1, x2)  =  U6_g(x2)

user_defined_=_in_gg(x1, x2)  =  user_defined_=_in_gg(x1, x2)

user_defined_=_out_gg(x1, x2)  =  user_defined_=_out_gg

r_out_g(x1)  =  r_out_g

U7_g(x1, x2)  =  U7_g(x2)

4  =  4

p_out_a(x1)  =  p_out_a(x1)

U3_a(x1, x2)  =  U3_a(x2)

2  =  2



----------------------------------------

(7) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   P_IN_A(X) -> U1_A(X, q_in_a(X))
   P_IN_A(X) -> Q_IN_A(X)
   Q_IN_A(X) -> U4_A(X, user_defined_=_in_ag(X, 1))
   Q_IN_A(X) -> USER_DEFINED_=_IN_AG(X, 1)
   Q_IN_A(X) -> U5_A(X, user_defined_=_in_ag(X, 3))
   Q_IN_A(X) -> USER_DEFINED_=_IN_AG(X, 3)
   U1_A(X, q_out_a(X)) -> U2_A(X, r_in_g(X))
   U1_A(X, q_out_a(X)) -> R_IN_G(X)
   R_IN_G(X) -> U6_G(X, user_defined_=_in_gg(X, 1))
   R_IN_G(X) -> USER_DEFINED_=_IN_GG(X, 1)
   R_IN_G(X) -> U7_G(X, user_defined_=_in_gg(X, 4))
   R_IN_G(X) -> USER_DEFINED_=_IN_GG(X, 4)
   P_IN_A(X) -> U3_A(X, user_defined_=_in_ag(X, 2))
   P_IN_A(X) -> USER_DEFINED_=_IN_AG(X, 2)

The TRS R consists of the following rules:

   p_in_a(X) -> U1_a(X, q_in_a(X))
   q_in_a(X) -> U4_a(X, user_defined_=_in_ag(X, 1))
   user_defined_=_in_ag(X, X) -> user_defined_=_out_ag(X, X)
   U4_a(X, user_defined_=_out_ag(X, 1)) -> q_out_a(X)
   q_in_a(X) -> U5_a(X, user_defined_=_in_ag(X, 3))
   U5_a(X, user_defined_=_out_ag(X, 3)) -> q_out_a(X)
   U1_a(X, q_out_a(X)) -> U2_a(X, r_in_g(X))
   r_in_g(X) -> U6_g(X, user_defined_=_in_gg(X, 1))
   user_defined_=_in_gg(X, X) -> user_defined_=_out_gg(X, X)
   U6_g(X, user_defined_=_out_gg(X, 1)) -> r_out_g(X)
   r_in_g(X) -> U7_g(X, user_defined_=_in_gg(X, 4))
   U7_g(X, user_defined_=_out_gg(X, 4)) -> r_out_g(X)
   U2_a(X, r_out_g(X)) -> p_out_a(X)
   p_in_a(X) -> U3_a(X, user_defined_=_in_ag(X, 2))
   U3_a(X, user_defined_=_out_ag(X, 2)) -> p_out_a(X)

The argument filtering Pi contains the following mapping:
p_in_a(x1)  =  p_in_a

U1_a(x1, x2)  =  U1_a(x2)

q_in_a(x1)  =  q_in_a

U4_a(x1, x2)  =  U4_a(x2)

user_defined_=_in_ag(x1, x2)  =  user_defined_=_in_ag(x2)

user_defined_=_out_ag(x1, x2)  =  user_defined_=_out_ag(x1)

1  =  1

q_out_a(x1)  =  q_out_a(x1)

U5_a(x1, x2)  =  U5_a(x2)

3  =  3

U2_a(x1, x2)  =  U2_a(x1, x2)

r_in_g(x1)  =  r_in_g(x1)

U6_g(x1, x2)  =  U6_g(x2)

user_defined_=_in_gg(x1, x2)  =  user_defined_=_in_gg(x1, x2)

user_defined_=_out_gg(x1, x2)  =  user_defined_=_out_gg

r_out_g(x1)  =  r_out_g

U7_g(x1, x2)  =  U7_g(x2)

4  =  4

p_out_a(x1)  =  p_out_a(x1)

U3_a(x1, x2)  =  U3_a(x2)

2  =  2

P_IN_A(x1)  =  P_IN_A

U1_A(x1, x2)  =  U1_A(x2)

Q_IN_A(x1)  =  Q_IN_A

U4_A(x1, x2)  =  U4_A(x2)

USER_DEFINED_=_IN_AG(x1, x2)  =  USER_DEFINED_=_IN_AG(x2)

U5_A(x1, x2)  =  U5_A(x2)

U2_A(x1, x2)  =  U2_A(x1, x2)

R_IN_G(x1)  =  R_IN_G(x1)

U6_G(x1, x2)  =  U6_G(x2)

USER_DEFINED_=_IN_GG(x1, x2)  =  USER_DEFINED_=_IN_GG(x1, x2)

U7_G(x1, x2)  =  U7_G(x2)

U3_A(x1, x2)  =  U3_A(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(8)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   P_IN_A(X) -> U1_A(X, q_in_a(X))
   P_IN_A(X) -> Q_IN_A(X)
   Q_IN_A(X) -> U4_A(X, user_defined_=_in_ag(X, 1))
   Q_IN_A(X) -> USER_DEFINED_=_IN_AG(X, 1)
   Q_IN_A(X) -> U5_A(X, user_defined_=_in_ag(X, 3))
   Q_IN_A(X) -> USER_DEFINED_=_IN_AG(X, 3)
   U1_A(X, q_out_a(X)) -> U2_A(X, r_in_g(X))
   U1_A(X, q_out_a(X)) -> R_IN_G(X)
   R_IN_G(X) -> U6_G(X, user_defined_=_in_gg(X, 1))
   R_IN_G(X) -> USER_DEFINED_=_IN_GG(X, 1)
   R_IN_G(X) -> U7_G(X, user_defined_=_in_gg(X, 4))
   R_IN_G(X) -> USER_DEFINED_=_IN_GG(X, 4)
   P_IN_A(X) -> U3_A(X, user_defined_=_in_ag(X, 2))
   P_IN_A(X) -> USER_DEFINED_=_IN_AG(X, 2)

The TRS R consists of the following rules:

   p_in_a(X) -> U1_a(X, q_in_a(X))
   q_in_a(X) -> U4_a(X, user_defined_=_in_ag(X, 1))
   user_defined_=_in_ag(X, X) -> user_defined_=_out_ag(X, X)
   U4_a(X, user_defined_=_out_ag(X, 1)) -> q_out_a(X)
   q_in_a(X) -> U5_a(X, user_defined_=_in_ag(X, 3))
   U5_a(X, user_defined_=_out_ag(X, 3)) -> q_out_a(X)
   U1_a(X, q_out_a(X)) -> U2_a(X, r_in_g(X))
   r_in_g(X) -> U6_g(X, user_defined_=_in_gg(X, 1))
   user_defined_=_in_gg(X, X) -> user_defined_=_out_gg(X, X)
   U6_g(X, user_defined_=_out_gg(X, 1)) -> r_out_g(X)
   r_in_g(X) -> U7_g(X, user_defined_=_in_gg(X, 4))
   U7_g(X, user_defined_=_out_gg(X, 4)) -> r_out_g(X)
   U2_a(X, r_out_g(X)) -> p_out_a(X)
   p_in_a(X) -> U3_a(X, user_defined_=_in_ag(X, 2))
   U3_a(X, user_defined_=_out_ag(X, 2)) -> p_out_a(X)

The argument filtering Pi contains the following mapping:
p_in_a(x1)  =  p_in_a

U1_a(x1, x2)  =  U1_a(x2)

q_in_a(x1)  =  q_in_a

U4_a(x1, x2)  =  U4_a(x2)

user_defined_=_in_ag(x1, x2)  =  user_defined_=_in_ag(x2)

user_defined_=_out_ag(x1, x2)  =  user_defined_=_out_ag(x1)

1  =  1

q_out_a(x1)  =  q_out_a(x1)

U5_a(x1, x2)  =  U5_a(x2)

3  =  3

U2_a(x1, x2)  =  U2_a(x1, x2)

r_in_g(x1)  =  r_in_g(x1)

U6_g(x1, x2)  =  U6_g(x2)

user_defined_=_in_gg(x1, x2)  =  user_defined_=_in_gg(x1, x2)

user_defined_=_out_gg(x1, x2)  =  user_defined_=_out_gg

r_out_g(x1)  =  r_out_g

U7_g(x1, x2)  =  U7_g(x2)

4  =  4

p_out_a(x1)  =  p_out_a(x1)

U3_a(x1, x2)  =  U3_a(x2)

2  =  2

P_IN_A(x1)  =  P_IN_A

U1_A(x1, x2)  =  U1_A(x2)

Q_IN_A(x1)  =  Q_IN_A

U4_A(x1, x2)  =  U4_A(x2)

USER_DEFINED_=_IN_AG(x1, x2)  =  USER_DEFINED_=_IN_AG(x2)

U5_A(x1, x2)  =  U5_A(x2)

U2_A(x1, x2)  =  U2_A(x1, x2)

R_IN_G(x1)  =  R_IN_G(x1)

U6_G(x1, x2)  =  U6_G(x2)

USER_DEFINED_=_IN_GG(x1, x2)  =  USER_DEFINED_=_IN_GG(x1, x2)

U7_G(x1, x2)  =  U7_G(x2)

U3_A(x1, x2)  =  U3_A(x2)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(9) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 0 SCCs with 14 less nodes.
----------------------------------------

(10)
TRUE
