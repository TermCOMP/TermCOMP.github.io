MAYBE
proof of /hpcwork/ff862203/termcomp25/benchmarks/cJMR1.pl
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Left Termination of the query pattern

len(g,a)

w.r.t. the given Prolog program could not be shown:

(0) Prolog
(1) CutEliminatorProof [SOUND, 0 ms]
(2) Prolog
    (3) PrologToPiTRSProof [SOUND, 0 ms]
    (4) PiTRS
        (5) DependencyPairsProof [EQUIVALENT, 0 ms]
        (6) PiDP
        (7) DependencyGraphProof [EQUIVALENT, 0 ms]
        (8) PiDP
        (9) UsableRulesProof [EQUIVALENT, 0 ms]
        (10) PiDP
        (11) PiDPToQDPProof [SOUND, 0 ms]
        (12) QDP
        (13) TransformationProof [SOUND, 0 ms]
        (14) QDP
        (15) UsableRulesProof [EQUIVALENT, 0 ms]
        (16) QDP
        (17) QReductionProof [EQUIVALENT, 0 ms]
        (18) QDP
        (19) QDPOrderProof [EQUIVALENT, 0 ms]
        (20) QDP
        (21) TransformationProof [EQUIVALENT, 0 ms]
        (22) QDP
        (23) NonTerminationLoopProof [COMPLETE, 0 ms]
        (24) NO
    (25) PrologToPiTRSProof [SOUND, 0 ms]
    (26) PiTRS
        (27) DependencyPairsProof [EQUIVALENT, 0 ms]
        (28) PiDP
        (29) DependencyGraphProof [EQUIVALENT, 0 ms]
        (30) PiDP
        (31) UsableRulesProof [EQUIVALENT, 0 ms]
        (32) PiDP
        (33) PiDPToQDPProof [SOUND, 0 ms]
        (34) QDP
        (35) UsableRulesReductionPairsProof [EQUIVALENT, 19 ms]
        (36) QDP
(37) PrologToDTProblemTransformerProof [SOUND, 0 ms]
(38) TRIPLES
    (39) TriplesToPiDPProof [SOUND, 0 ms]
    (40) PiDP
    (41) DependencyGraphProof [EQUIVALENT, 0 ms]
    (42) AND
        (43) PiDP
            (44) PiDPToQDPProof [SOUND, 0 ms]
            (45) QDP
            (46) NonTerminationLoopProof [COMPLETE, 0 ms]
            (47) NO
        (48) PiDP
            (49) PiDPToQDPProof [SOUND, 0 ms]
            (50) QDP
            (51) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (52) YES
(53) PrologToTRSTransformerProof [SOUND, 0 ms]
(54) QTRS
    (55) QTRSRRRProof [EQUIVALENT, 10 ms]
    (56) QTRS
    (57) QTRSRRRProof [EQUIVALENT, 0 ms]
    (58) QTRS
    (59) QTRSRRRProof [EQUIVALENT, 2 ms]
    (60) QTRS
    (61) QTRSRRRProof [EQUIVALENT, 4 ms]
    (62) QTRS
    (63) Overlay + Local Confluence [EQUIVALENT, 0 ms]
    (64) QTRS
    (65) DependencyPairsProof [EQUIVALENT, 0 ms]
    (66) QDP
    (67) UsableRulesProof [EQUIVALENT, 0 ms]
    (68) QDP
    (69) QReductionProof [EQUIVALENT, 0 ms]
    (70) QDP
    (71) NonTerminationLoopProof [COMPLETE, 0 ms]
    (72) NO
(73) PrologToIRSwTTransformerProof [SOUND, 0 ms]
(74) IRSwT
    (75) IRSwTSimpleDependencyGraphProof [EQUIVALENT, 0 ms]
    (76) IRSwT
    (77) IntTRSCompressionProof [EQUIVALENT, 15 ms]
    (78) IRSwT
    (79) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
    (80) IRSwT
    (81) IRSwTTerminationDigraphProof [EQUIVALENT, 6 ms]
    (82) AND
        (83) IRSwT
            (84) IntTRSUnneededArgumentFilterProof [EQUIVALENT, 0 ms]
            (85) IRSwT
            (86) TempFilterProof [SOUND, 1 ms]
            (87) IRSwT
            (88) IRSwTToQDPProof [SOUND, 0 ms]
            (89) QDP
            (90) QDPSizeChangeProof [EQUIVALENT, 0 ms]
            (91) YES
        (92) IRSwT


----------------------------------------

(0)
Obligation:
Clauses:

len([], 0) :- !.
len(Xs, s(N)) :- ','(tail(Xs, Ys), len(Ys, N)).
tail([], []).
tail(.(X, Xs), Xs).


Query: len(g,a)
----------------------------------------

(1) CutEliminatorProof (SOUND)
Eliminated all cuts by simply ignoring them[PROLOG].
----------------------------------------

(2)
Obligation:
Clauses:

len([], 0).
len(Xs, s(N)) :- ','(tail(Xs, Ys), len(Ys, N)).
tail([], []).
tail(.(X, Xs), Xs).


Query: len(g,a)
----------------------------------------

(3) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

len_in_2: (b,f)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   len_in_ga([], 0) -> len_out_ga([], 0)
   len_in_ga(Xs, s(N)) -> U1_ga(Xs, N, tail_in_ga(Xs, Ys))
   tail_in_ga([], []) -> tail_out_ga([], [])
   tail_in_ga(.(X, Xs), Xs) -> tail_out_ga(.(X, Xs), Xs)
   U1_ga(Xs, N, tail_out_ga(Xs, Ys)) -> U2_ga(Xs, N, Ys, len_in_ga(Ys, N))
   U2_ga(Xs, N, Ys, len_out_ga(Ys, N)) -> len_out_ga(Xs, s(N))

The argument filtering Pi contains the following mapping:
len_in_ga(x1, x2)  =  len_in_ga(x1)

[]  =  []

len_out_ga(x1, x2)  =  len_out_ga(x1, x2)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

tail_in_ga(x1, x2)  =  tail_in_ga(x1)

tail_out_ga(x1, x2)  =  tail_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

U2_ga(x1, x2, x3, x4)  =  U2_ga(x1, x4)

s(x1)  =  s(x1)





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(4)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   len_in_ga([], 0) -> len_out_ga([], 0)
   len_in_ga(Xs, s(N)) -> U1_ga(Xs, N, tail_in_ga(Xs, Ys))
   tail_in_ga([], []) -> tail_out_ga([], [])
   tail_in_ga(.(X, Xs), Xs) -> tail_out_ga(.(X, Xs), Xs)
   U1_ga(Xs, N, tail_out_ga(Xs, Ys)) -> U2_ga(Xs, N, Ys, len_in_ga(Ys, N))
   U2_ga(Xs, N, Ys, len_out_ga(Ys, N)) -> len_out_ga(Xs, s(N))

The argument filtering Pi contains the following mapping:
len_in_ga(x1, x2)  =  len_in_ga(x1)

[]  =  []

len_out_ga(x1, x2)  =  len_out_ga(x1, x2)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

tail_in_ga(x1, x2)  =  tail_in_ga(x1)

tail_out_ga(x1, x2)  =  tail_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

U2_ga(x1, x2, x3, x4)  =  U2_ga(x1, x4)

s(x1)  =  s(x1)



----------------------------------------

(5) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   LEN_IN_GA(Xs, s(N)) -> U1_GA(Xs, N, tail_in_ga(Xs, Ys))
   LEN_IN_GA(Xs, s(N)) -> TAIL_IN_GA(Xs, Ys)
   U1_GA(Xs, N, tail_out_ga(Xs, Ys)) -> U2_GA(Xs, N, Ys, len_in_ga(Ys, N))
   U1_GA(Xs, N, tail_out_ga(Xs, Ys)) -> LEN_IN_GA(Ys, N)

The TRS R consists of the following rules:

   len_in_ga([], 0) -> len_out_ga([], 0)
   len_in_ga(Xs, s(N)) -> U1_ga(Xs, N, tail_in_ga(Xs, Ys))
   tail_in_ga([], []) -> tail_out_ga([], [])
   tail_in_ga(.(X, Xs), Xs) -> tail_out_ga(.(X, Xs), Xs)
   U1_ga(Xs, N, tail_out_ga(Xs, Ys)) -> U2_ga(Xs, N, Ys, len_in_ga(Ys, N))
   U2_ga(Xs, N, Ys, len_out_ga(Ys, N)) -> len_out_ga(Xs, s(N))

The argument filtering Pi contains the following mapping:
len_in_ga(x1, x2)  =  len_in_ga(x1)

[]  =  []

len_out_ga(x1, x2)  =  len_out_ga(x1, x2)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

tail_in_ga(x1, x2)  =  tail_in_ga(x1)

tail_out_ga(x1, x2)  =  tail_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

U2_ga(x1, x2, x3, x4)  =  U2_ga(x1, x4)

s(x1)  =  s(x1)

LEN_IN_GA(x1, x2)  =  LEN_IN_GA(x1)

U1_GA(x1, x2, x3)  =  U1_GA(x1, x3)

TAIL_IN_GA(x1, x2)  =  TAIL_IN_GA(x1)

U2_GA(x1, x2, x3, x4)  =  U2_GA(x1, x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(6)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   LEN_IN_GA(Xs, s(N)) -> U1_GA(Xs, N, tail_in_ga(Xs, Ys))
   LEN_IN_GA(Xs, s(N)) -> TAIL_IN_GA(Xs, Ys)
   U1_GA(Xs, N, tail_out_ga(Xs, Ys)) -> U2_GA(Xs, N, Ys, len_in_ga(Ys, N))
   U1_GA(Xs, N, tail_out_ga(Xs, Ys)) -> LEN_IN_GA(Ys, N)

The TRS R consists of the following rules:

   len_in_ga([], 0) -> len_out_ga([], 0)
   len_in_ga(Xs, s(N)) -> U1_ga(Xs, N, tail_in_ga(Xs, Ys))
   tail_in_ga([], []) -> tail_out_ga([], [])
   tail_in_ga(.(X, Xs), Xs) -> tail_out_ga(.(X, Xs), Xs)
   U1_ga(Xs, N, tail_out_ga(Xs, Ys)) -> U2_ga(Xs, N, Ys, len_in_ga(Ys, N))
   U2_ga(Xs, N, Ys, len_out_ga(Ys, N)) -> len_out_ga(Xs, s(N))

The argument filtering Pi contains the following mapping:
len_in_ga(x1, x2)  =  len_in_ga(x1)

[]  =  []

len_out_ga(x1, x2)  =  len_out_ga(x1, x2)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

tail_in_ga(x1, x2)  =  tail_in_ga(x1)

tail_out_ga(x1, x2)  =  tail_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

U2_ga(x1, x2, x3, x4)  =  U2_ga(x1, x4)

s(x1)  =  s(x1)

LEN_IN_GA(x1, x2)  =  LEN_IN_GA(x1)

U1_GA(x1, x2, x3)  =  U1_GA(x1, x3)

TAIL_IN_GA(x1, x2)  =  TAIL_IN_GA(x1)

U2_GA(x1, x2, x3, x4)  =  U2_GA(x1, x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(7) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 2 less nodes.
----------------------------------------

(8)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_GA(Xs, N, tail_out_ga(Xs, Ys)) -> LEN_IN_GA(Ys, N)
   LEN_IN_GA(Xs, s(N)) -> U1_GA(Xs, N, tail_in_ga(Xs, Ys))

The TRS R consists of the following rules:

   len_in_ga([], 0) -> len_out_ga([], 0)
   len_in_ga(Xs, s(N)) -> U1_ga(Xs, N, tail_in_ga(Xs, Ys))
   tail_in_ga([], []) -> tail_out_ga([], [])
   tail_in_ga(.(X, Xs), Xs) -> tail_out_ga(.(X, Xs), Xs)
   U1_ga(Xs, N, tail_out_ga(Xs, Ys)) -> U2_ga(Xs, N, Ys, len_in_ga(Ys, N))
   U2_ga(Xs, N, Ys, len_out_ga(Ys, N)) -> len_out_ga(Xs, s(N))

The argument filtering Pi contains the following mapping:
len_in_ga(x1, x2)  =  len_in_ga(x1)

[]  =  []

len_out_ga(x1, x2)  =  len_out_ga(x1, x2)

U1_ga(x1, x2, x3)  =  U1_ga(x1, x3)

tail_in_ga(x1, x2)  =  tail_in_ga(x1)

tail_out_ga(x1, x2)  =  tail_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

U2_ga(x1, x2, x3, x4)  =  U2_ga(x1, x4)

s(x1)  =  s(x1)

LEN_IN_GA(x1, x2)  =  LEN_IN_GA(x1)

U1_GA(x1, x2, x3)  =  U1_GA(x1, x3)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(9) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(10)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_GA(Xs, N, tail_out_ga(Xs, Ys)) -> LEN_IN_GA(Ys, N)
   LEN_IN_GA(Xs, s(N)) -> U1_GA(Xs, N, tail_in_ga(Xs, Ys))

The TRS R consists of the following rules:

   tail_in_ga([], []) -> tail_out_ga([], [])
   tail_in_ga(.(X, Xs), Xs) -> tail_out_ga(.(X, Xs), Xs)

The argument filtering Pi contains the following mapping:
[]  =  []

tail_in_ga(x1, x2)  =  tail_in_ga(x1)

tail_out_ga(x1, x2)  =  tail_out_ga(x1, x2)

.(x1, x2)  =  .(x1, x2)

s(x1)  =  s(x1)

LEN_IN_GA(x1, x2)  =  LEN_IN_GA(x1)

U1_GA(x1, x2, x3)  =  U1_GA(x1, x3)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(11) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(12)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_GA(Xs, tail_out_ga(Xs, Ys)) -> LEN_IN_GA(Ys)
   LEN_IN_GA(Xs) -> U1_GA(Xs, tail_in_ga(Xs))

The TRS R consists of the following rules:

   tail_in_ga([]) -> tail_out_ga([], [])
   tail_in_ga(.(X, Xs)) -> tail_out_ga(.(X, Xs), Xs)

The set Q consists of the following terms:

   tail_in_ga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(13) TransformationProof (SOUND)
By narrowing [LPAR04] the rule LEN_IN_GA(Xs) -> U1_GA(Xs, tail_in_ga(Xs)) at position [1] we obtained the following new rules [LPAR04]:

   (LEN_IN_GA([]) -> U1_GA([], tail_out_ga([], [])),LEN_IN_GA([]) -> U1_GA([], tail_out_ga([], [])))
   (LEN_IN_GA(.(x0, x1)) -> U1_GA(.(x0, x1), tail_out_ga(.(x0, x1), x1)),LEN_IN_GA(.(x0, x1)) -> U1_GA(.(x0, x1), tail_out_ga(.(x0, x1), x1)))


----------------------------------------

(14)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_GA(Xs, tail_out_ga(Xs, Ys)) -> LEN_IN_GA(Ys)
   LEN_IN_GA([]) -> U1_GA([], tail_out_ga([], []))
   LEN_IN_GA(.(x0, x1)) -> U1_GA(.(x0, x1), tail_out_ga(.(x0, x1), x1))

The TRS R consists of the following rules:

   tail_in_ga([]) -> tail_out_ga([], [])
   tail_in_ga(.(X, Xs)) -> tail_out_ga(.(X, Xs), Xs)

The set Q consists of the following terms:

   tail_in_ga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(15) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(16)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_GA(Xs, tail_out_ga(Xs, Ys)) -> LEN_IN_GA(Ys)
   LEN_IN_GA([]) -> U1_GA([], tail_out_ga([], []))
   LEN_IN_GA(.(x0, x1)) -> U1_GA(.(x0, x1), tail_out_ga(.(x0, x1), x1))

R is empty.
The set Q consists of the following terms:

   tail_in_ga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(17) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   tail_in_ga(x0)


----------------------------------------

(18)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_GA(Xs, tail_out_ga(Xs, Ys)) -> LEN_IN_GA(Ys)
   LEN_IN_GA([]) -> U1_GA([], tail_out_ga([], []))
   LEN_IN_GA(.(x0, x1)) -> U1_GA(.(x0, x1), tail_out_ga(.(x0, x1), x1))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(19) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   LEN_IN_GA(.(x0, x1)) -> U1_GA(.(x0, x1), tail_out_ga(.(x0, x1), x1))
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
U1_GA(x1, x2)  =  x2

tail_out_ga(x1, x2)  =  x2

LEN_IN_GA(x1)  =  x1

[]  =  []

.(x1, x2)  =  .(x2)


Knuth-Bendix order [KBO] with precedence:trivial

and weight map:

   []=1
   ._1=1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:
none


----------------------------------------

(20)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_GA(Xs, tail_out_ga(Xs, Ys)) -> LEN_IN_GA(Ys)
   LEN_IN_GA([]) -> U1_GA([], tail_out_ga([], []))

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(21) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule U1_GA(Xs, tail_out_ga(Xs, Ys)) -> LEN_IN_GA(Ys) we obtained the following new rules [LPAR04]:

   (U1_GA([], tail_out_ga([], [])) -> LEN_IN_GA([]),U1_GA([], tail_out_ga([], [])) -> LEN_IN_GA([]))


----------------------------------------

(22)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LEN_IN_GA([]) -> U1_GA([], tail_out_ga([], []))
   U1_GA([], tail_out_ga([], [])) -> LEN_IN_GA([])

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(23) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = U1_GA([], tail_out_ga([], [])) evaluates to  t =U1_GA([], tail_out_ga([], []))

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

U1_GA([], tail_out_ga([], [])) -> LEN_IN_GA([])
with rule U1_GA([], tail_out_ga([], [])) -> LEN_IN_GA([]) at position [] and matcher [ ]

LEN_IN_GA([]) -> U1_GA([], tail_out_ga([], []))
with rule LEN_IN_GA([]) -> U1_GA([], tail_out_ga([], []))

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(24)
NO

----------------------------------------

(25) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

len_in_2: (b,f)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   len_in_ga([], 0) -> len_out_ga([], 0)
   len_in_ga(Xs, s(N)) -> U1_ga(Xs, N, tail_in_ga(Xs, Ys))
   tail_in_ga([], []) -> tail_out_ga([], [])
   tail_in_ga(.(X, Xs), Xs) -> tail_out_ga(.(X, Xs), Xs)
   U1_ga(Xs, N, tail_out_ga(Xs, Ys)) -> U2_ga(Xs, N, Ys, len_in_ga(Ys, N))
   U2_ga(Xs, N, Ys, len_out_ga(Ys, N)) -> len_out_ga(Xs, s(N))

The argument filtering Pi contains the following mapping:
len_in_ga(x1, x2)  =  len_in_ga(x1)

[]  =  []

len_out_ga(x1, x2)  =  len_out_ga(x2)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

tail_in_ga(x1, x2)  =  tail_in_ga(x1)

tail_out_ga(x1, x2)  =  tail_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

U2_ga(x1, x2, x3, x4)  =  U2_ga(x4)

s(x1)  =  s(x1)





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(26)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   len_in_ga([], 0) -> len_out_ga([], 0)
   len_in_ga(Xs, s(N)) -> U1_ga(Xs, N, tail_in_ga(Xs, Ys))
   tail_in_ga([], []) -> tail_out_ga([], [])
   tail_in_ga(.(X, Xs), Xs) -> tail_out_ga(.(X, Xs), Xs)
   U1_ga(Xs, N, tail_out_ga(Xs, Ys)) -> U2_ga(Xs, N, Ys, len_in_ga(Ys, N))
   U2_ga(Xs, N, Ys, len_out_ga(Ys, N)) -> len_out_ga(Xs, s(N))

The argument filtering Pi contains the following mapping:
len_in_ga(x1, x2)  =  len_in_ga(x1)

[]  =  []

len_out_ga(x1, x2)  =  len_out_ga(x2)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

tail_in_ga(x1, x2)  =  tail_in_ga(x1)

tail_out_ga(x1, x2)  =  tail_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

U2_ga(x1, x2, x3, x4)  =  U2_ga(x4)

s(x1)  =  s(x1)



----------------------------------------

(27) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   LEN_IN_GA(Xs, s(N)) -> U1_GA(Xs, N, tail_in_ga(Xs, Ys))
   LEN_IN_GA(Xs, s(N)) -> TAIL_IN_GA(Xs, Ys)
   U1_GA(Xs, N, tail_out_ga(Xs, Ys)) -> U2_GA(Xs, N, Ys, len_in_ga(Ys, N))
   U1_GA(Xs, N, tail_out_ga(Xs, Ys)) -> LEN_IN_GA(Ys, N)

The TRS R consists of the following rules:

   len_in_ga([], 0) -> len_out_ga([], 0)
   len_in_ga(Xs, s(N)) -> U1_ga(Xs, N, tail_in_ga(Xs, Ys))
   tail_in_ga([], []) -> tail_out_ga([], [])
   tail_in_ga(.(X, Xs), Xs) -> tail_out_ga(.(X, Xs), Xs)
   U1_ga(Xs, N, tail_out_ga(Xs, Ys)) -> U2_ga(Xs, N, Ys, len_in_ga(Ys, N))
   U2_ga(Xs, N, Ys, len_out_ga(Ys, N)) -> len_out_ga(Xs, s(N))

The argument filtering Pi contains the following mapping:
len_in_ga(x1, x2)  =  len_in_ga(x1)

[]  =  []

len_out_ga(x1, x2)  =  len_out_ga(x2)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

tail_in_ga(x1, x2)  =  tail_in_ga(x1)

tail_out_ga(x1, x2)  =  tail_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

U2_ga(x1, x2, x3, x4)  =  U2_ga(x4)

s(x1)  =  s(x1)

LEN_IN_GA(x1, x2)  =  LEN_IN_GA(x1)

U1_GA(x1, x2, x3)  =  U1_GA(x3)

TAIL_IN_GA(x1, x2)  =  TAIL_IN_GA(x1)

U2_GA(x1, x2, x3, x4)  =  U2_GA(x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(28)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   LEN_IN_GA(Xs, s(N)) -> U1_GA(Xs, N, tail_in_ga(Xs, Ys))
   LEN_IN_GA(Xs, s(N)) -> TAIL_IN_GA(Xs, Ys)
   U1_GA(Xs, N, tail_out_ga(Xs, Ys)) -> U2_GA(Xs, N, Ys, len_in_ga(Ys, N))
   U1_GA(Xs, N, tail_out_ga(Xs, Ys)) -> LEN_IN_GA(Ys, N)

The TRS R consists of the following rules:

   len_in_ga([], 0) -> len_out_ga([], 0)
   len_in_ga(Xs, s(N)) -> U1_ga(Xs, N, tail_in_ga(Xs, Ys))
   tail_in_ga([], []) -> tail_out_ga([], [])
   tail_in_ga(.(X, Xs), Xs) -> tail_out_ga(.(X, Xs), Xs)
   U1_ga(Xs, N, tail_out_ga(Xs, Ys)) -> U2_ga(Xs, N, Ys, len_in_ga(Ys, N))
   U2_ga(Xs, N, Ys, len_out_ga(Ys, N)) -> len_out_ga(Xs, s(N))

The argument filtering Pi contains the following mapping:
len_in_ga(x1, x2)  =  len_in_ga(x1)

[]  =  []

len_out_ga(x1, x2)  =  len_out_ga(x2)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

tail_in_ga(x1, x2)  =  tail_in_ga(x1)

tail_out_ga(x1, x2)  =  tail_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

U2_ga(x1, x2, x3, x4)  =  U2_ga(x4)

s(x1)  =  s(x1)

LEN_IN_GA(x1, x2)  =  LEN_IN_GA(x1)

U1_GA(x1, x2, x3)  =  U1_GA(x3)

TAIL_IN_GA(x1, x2)  =  TAIL_IN_GA(x1)

U2_GA(x1, x2, x3, x4)  =  U2_GA(x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(29) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 2 less nodes.
----------------------------------------

(30)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_GA(Xs, N, tail_out_ga(Xs, Ys)) -> LEN_IN_GA(Ys, N)
   LEN_IN_GA(Xs, s(N)) -> U1_GA(Xs, N, tail_in_ga(Xs, Ys))

The TRS R consists of the following rules:

   len_in_ga([], 0) -> len_out_ga([], 0)
   len_in_ga(Xs, s(N)) -> U1_ga(Xs, N, tail_in_ga(Xs, Ys))
   tail_in_ga([], []) -> tail_out_ga([], [])
   tail_in_ga(.(X, Xs), Xs) -> tail_out_ga(.(X, Xs), Xs)
   U1_ga(Xs, N, tail_out_ga(Xs, Ys)) -> U2_ga(Xs, N, Ys, len_in_ga(Ys, N))
   U2_ga(Xs, N, Ys, len_out_ga(Ys, N)) -> len_out_ga(Xs, s(N))

The argument filtering Pi contains the following mapping:
len_in_ga(x1, x2)  =  len_in_ga(x1)

[]  =  []

len_out_ga(x1, x2)  =  len_out_ga(x2)

U1_ga(x1, x2, x3)  =  U1_ga(x3)

tail_in_ga(x1, x2)  =  tail_in_ga(x1)

tail_out_ga(x1, x2)  =  tail_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

U2_ga(x1, x2, x3, x4)  =  U2_ga(x4)

s(x1)  =  s(x1)

LEN_IN_GA(x1, x2)  =  LEN_IN_GA(x1)

U1_GA(x1, x2, x3)  =  U1_GA(x3)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(31) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(32)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   U1_GA(Xs, N, tail_out_ga(Xs, Ys)) -> LEN_IN_GA(Ys, N)
   LEN_IN_GA(Xs, s(N)) -> U1_GA(Xs, N, tail_in_ga(Xs, Ys))

The TRS R consists of the following rules:

   tail_in_ga([], []) -> tail_out_ga([], [])
   tail_in_ga(.(X, Xs), Xs) -> tail_out_ga(.(X, Xs), Xs)

The argument filtering Pi contains the following mapping:
[]  =  []

tail_in_ga(x1, x2)  =  tail_in_ga(x1)

tail_out_ga(x1, x2)  =  tail_out_ga(x2)

.(x1, x2)  =  .(x1, x2)

s(x1)  =  s(x1)

LEN_IN_GA(x1, x2)  =  LEN_IN_GA(x1)

U1_GA(x1, x2, x3)  =  U1_GA(x3)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(33) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(34)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_GA(tail_out_ga(Ys)) -> LEN_IN_GA(Ys)
   LEN_IN_GA(Xs) -> U1_GA(tail_in_ga(Xs))

The TRS R consists of the following rules:

   tail_in_ga([]) -> tail_out_ga([])
   tail_in_ga(.(X, Xs)) -> tail_out_ga(Xs)

The set Q consists of the following terms:

   tail_in_ga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(35) UsableRulesReductionPairsProof (EQUIVALENT)
By using the usable rules with reduction pair processor [LPAR04] with a polynomial ordering [POLO], all dependency pairs and the corresponding usable rules [FROCOS05] can be oriented non-strictly. All non-usable rules are removed, and those dependency pairs and usable rules that have been oriented strictly or contain non-usable symbols in their left-hand side are removed as well.

No dependency pairs are removed.

The following rules are removed from R:

   tail_in_ga(.(X, Xs)) -> tail_out_ga(Xs)
Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(.(x_1, x_2)) = x_1 + 2*x_2
   POL(LEN_IN_GA(x_1)) = x_1
   POL(U1_GA(x_1)) = x_1
   POL([]) = 0
   POL(tail_in_ga(x_1)) = x_1
   POL(tail_out_ga(x_1)) = x_1


----------------------------------------

(36)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U1_GA(tail_out_ga(Ys)) -> LEN_IN_GA(Ys)
   LEN_IN_GA(Xs) -> U1_GA(tail_in_ga(Xs))

The TRS R consists of the following rules:

   tail_in_ga([]) -> tail_out_ga([])

The set Q consists of the following terms:

   tail_in_ga(x0)

We have to consider all (P,Q,R)-chains.
----------------------------------------

(37) PrologToDTProblemTransformerProof (SOUND)
Built DT problem from termination graph DT10.

{
    "root": 5,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(len ([]) (0))",
                "(!)"
            ],
            [
                "(len Xs (s N))",
                "(',' (tail Xs Ys) (len Ys N))"
            ],
            [
                "(tail ([]) ([]))",
                null
            ],
            [
                "(tail (. X Xs) Xs)",
                null
            ]
        ]
    },
    "graph": {
        "nodes": {
            "11": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 1,
                        "term": "(len T1 T2)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(len T1 T2)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "88": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (tail T5 X5) (len X5 T7))"
                }],
                "kb": {
                    "nonunifying": [[
                        "(len T5 T2)",
                        "(len ([]) (0))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T5"],
                    "free": ["X5"],
                    "exprvars": []
                }
            },
            "89": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "156": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(len T13 T7)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T13"],
                    "free": [],
                    "exprvars": []
                }
            },
            "113": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(len ([]) T7)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "157": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "114": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "5": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(len T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "91": {
                "goal": [
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(',' (tail T5 X5) (len X5 T7))"
                    },
                    {
                        "clause": 3,
                        "scope": 2,
                        "term": "(',' (tail T5 X5) (len X5 T7))"
                    }
                ],
                "kb": {
                    "nonunifying": [[
                        "(len T5 T2)",
                        "(len ([]) (0))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T5"],
                    "free": ["X5"],
                    "exprvars": []
                }
            },
            "81": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(len T1 T2)"
                }],
                "kb": {
                    "nonunifying": [[
                        "(len T1 T2)",
                        "(len ([]) (0))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "93": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(',' (tail T5 X5) (len X5 T7))"
                }],
                "kb": {
                    "nonunifying": [[
                        "(len T5 T2)",
                        "(len ([]) (0))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T5"],
                    "free": ["X5"],
                    "exprvars": []
                }
            },
            "73": {
                "goal": [
                    {
                        "clause": -1,
                        "scope": -1,
                        "term": "(!_1)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(len ([]) T2)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "84": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "95": {
                "goal": [{
                    "clause": 3,
                    "scope": 2,
                    "term": "(',' (tail T5 X5) (len X5 T7))"
                }],
                "kb": {
                    "nonunifying": [[
                        "(len T5 T2)",
                        "(len ([]) (0))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T5"],
                    "free": ["X5"],
                    "exprvars": []
                }
            },
            "85": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 5,
                "to": 11,
                "label": "CASE"
            },
            {
                "from": 11,
                "to": 73,
                "label": "EVAL with clause\nlen([], 0) :- !_1.\nand substitutionT1 -> [],\nT2 -> 0"
            },
            {
                "from": 11,
                "to": 81,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 73,
                "to": 84,
                "label": "CUT"
            },
            {
                "from": 81,
                "to": 88,
                "label": "EVAL with clause\nlen(X3, s(X4)) :- ','(tail(X3, X5), len(X5, X4)).\nand substitutionT1 -> T5,\nX3 -> T5,\nX4 -> T7,\nT2 -> s(T7),\nT6 -> T7"
            },
            {
                "from": 81,
                "to": 89,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 84,
                "to": 85,
                "label": "SUCCESS"
            },
            {
                "from": 88,
                "to": 91,
                "label": "CASE"
            },
            {
                "from": 91,
                "to": 93,
                "label": "PARALLEL"
            },
            {
                "from": 91,
                "to": 95,
                "label": "PARALLEL"
            },
            {
                "from": 93,
                "to": 113,
                "label": "EVAL with clause\ntail([], []).\nand substitutionT5 -> [],\nX5 -> []"
            },
            {
                "from": 93,
                "to": 114,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 95,
                "to": 156,
                "label": "EVAL with clause\ntail(.(X10, X11), X11).\nand substitutionX10 -> T12,\nX11 -> T13,\nT5 -> .(T12, T13),\nX5 -> T13"
            },
            {
                "from": 95,
                "to": 157,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 113,
                "to": 5,
                "label": "INSTANCE with matching:\nT1 -> []\nT2 -> T7"
            },
            {
                "from": 156,
                "to": 5,
                "label": "INSTANCE with matching:\nT1 -> T13\nT2 -> T7"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(38)
Obligation:
Triples:

lenA([], s(X1)) :- lenA([], X1).
lenA(.(X1, X2), s(X3)) :- lenA(X2, X3).

Clauses:

lencA([], 0).
lencA([], s(X1)) :- lencA([], X1).
lencA(.(X1, X2), s(X3)) :- lencA(X2, X3).

Afs:

lenA(x1, x2)  =  lenA(x1)


----------------------------------------

(39) TriplesToPiDPProof (SOUND)
We use the technique of [DT09]. With regard to the inferred argument filtering the predicates were used in the following modes:

lenA_in_2: (b,f)

Transforming TRIPLES into the following Term Rewriting System:

Pi DP problem:
The TRS P consists of the following rules:

   LENA_IN_GA([], s(X1)) -> U1_GA(X1, lenA_in_ga([], X1))
   LENA_IN_GA([], s(X1)) -> LENA_IN_GA([], X1)
   LENA_IN_GA(.(X1, X2), s(X3)) -> U2_GA(X1, X2, X3, lenA_in_ga(X2, X3))
   LENA_IN_GA(.(X1, X2), s(X3)) -> LENA_IN_GA(X2, X3)

R is empty.
The argument filtering Pi contains the following mapping:
lenA_in_ga(x1, x2)  =  lenA_in_ga(x1)

[]  =  []

.(x1, x2)  =  .(x1, x2)

s(x1)  =  s(x1)

LENA_IN_GA(x1, x2)  =  LENA_IN_GA(x1)

U1_GA(x1, x2)  =  U1_GA(x2)

U2_GA(x1, x2, x3, x4)  =  U2_GA(x1, x2, x4)


We have to consider all (P,R,Pi)-chains


Infinitary Constructor Rewriting Termination of PiDP implies Termination of TRIPLES



----------------------------------------

(40)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   LENA_IN_GA([], s(X1)) -> U1_GA(X1, lenA_in_ga([], X1))
   LENA_IN_GA([], s(X1)) -> LENA_IN_GA([], X1)
   LENA_IN_GA(.(X1, X2), s(X3)) -> U2_GA(X1, X2, X3, lenA_in_ga(X2, X3))
   LENA_IN_GA(.(X1, X2), s(X3)) -> LENA_IN_GA(X2, X3)

R is empty.
The argument filtering Pi contains the following mapping:
lenA_in_ga(x1, x2)  =  lenA_in_ga(x1)

[]  =  []

.(x1, x2)  =  .(x1, x2)

s(x1)  =  s(x1)

LENA_IN_GA(x1, x2)  =  LENA_IN_GA(x1)

U1_GA(x1, x2)  =  U1_GA(x2)

U2_GA(x1, x2, x3, x4)  =  U2_GA(x1, x2, x4)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(41) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 2 SCCs with 2 less nodes.
----------------------------------------

(42)
Complex Obligation (AND)

----------------------------------------

(43)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   LENA_IN_GA([], s(X1)) -> LENA_IN_GA([], X1)

R is empty.
The argument filtering Pi contains the following mapping:
[]  =  []

s(x1)  =  s(x1)

LENA_IN_GA(x1, x2)  =  LENA_IN_GA(x1)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(44) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(45)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LENA_IN_GA([]) -> LENA_IN_GA([])

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(46) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by semiunifying a rule from P directly.

s = LENA_IN_GA([]) evaluates to  t =LENA_IN_GA([])

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

The DP semiunifies directly so there is only one rewrite step from LENA_IN_GA([]) to LENA_IN_GA([]).




----------------------------------------

(47)
NO

----------------------------------------

(48)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   LENA_IN_GA(.(X1, X2), s(X3)) -> LENA_IN_GA(X2, X3)

R is empty.
The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x1, x2)

s(x1)  =  s(x1)

LENA_IN_GA(x1, x2)  =  LENA_IN_GA(x1)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(49) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(50)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LENA_IN_GA(.(X1, X2)) -> LENA_IN_GA(X2)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(51) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*LENA_IN_GA(.(X1, X2)) -> LENA_IN_GA(X2)
The graph contains the following edges 1 > 1


----------------------------------------

(52)
YES

----------------------------------------

(53) PrologToTRSTransformerProof (SOUND)
Transformed Prolog program to TRS.

{
    "root": 12,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(len ([]) (0))",
                "(!)"
            ],
            [
                "(len Xs (s N))",
                "(',' (tail Xs Ys) (len Ys N))"
            ],
            [
                "(tail ([]) ([]))",
                null
            ],
            [
                "(tail (. X Xs) Xs)",
                null
            ]
        ]
    },
    "graph": {
        "nodes": {
            "12": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(len T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "13": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 1,
                        "term": "(len T1 T2)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(len T1 T2)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "58": {
                "goal": [
                    {
                        "clause": -1,
                        "scope": -1,
                        "term": "(!_1)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(len ([]) T2)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "59": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(len T1 T2)"
                }],
                "kb": {
                    "nonunifying": [[
                        "(len T1 T2)",
                        "(len ([]) (0))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "154": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(len T15 T9)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T15"],
                    "free": [],
                    "exprvars": []
                }
            },
            "155": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "90": {
                "goal": [
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(',' (tail T7 X8) (len X8 T9))"
                    },
                    {
                        "clause": 3,
                        "scope": 2,
                        "term": "(',' (tail T7 X8) (len X8 T9))"
                    }
                ],
                "kb": {
                    "nonunifying": [[
                        "(len T7 T2)",
                        "(len ([]) (0))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T7"],
                    "free": ["X8"],
                    "exprvars": []
                }
            },
            "92": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(',' (tail T7 X8) (len X8 T9))"
                }],
                "kb": {
                    "nonunifying": [[
                        "(len T7 T2)",
                        "(len ([]) (0))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T7"],
                    "free": ["X8"],
                    "exprvars": []
                }
            },
            "60": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "61": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "94": {
                "goal": [{
                    "clause": 3,
                    "scope": 2,
                    "term": "(',' (tail T7 X8) (len X8 T9))"
                }],
                "kb": {
                    "nonunifying": [[
                        "(len T7 T2)",
                        "(len ([]) (0))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T7"],
                    "free": ["X8"],
                    "exprvars": []
                }
            },
            "86": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (tail T7 X8) (len X8 T9))"
                }],
                "kb": {
                    "nonunifying": [[
                        "(len T7 T2)",
                        "(len ([]) (0))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T7"],
                    "free": ["X8"],
                    "exprvars": []
                }
            },
            "97": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(len ([]) T9)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "87": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "98": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 12,
                "to": 13,
                "label": "CASE"
            },
            {
                "from": 13,
                "to": 58,
                "label": "EVAL with clause\nlen([], 0) :- !_1.\nand substitutionT1 -> [],\nT2 -> 0"
            },
            {
                "from": 13,
                "to": 59,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 58,
                "to": 60,
                "label": "CUT"
            },
            {
                "from": 59,
                "to": 86,
                "label": "EVAL with clause\nlen(X6, s(X7)) :- ','(tail(X6, X8), len(X8, X7)).\nand substitutionT1 -> T7,\nX6 -> T7,\nX7 -> T9,\nT2 -> s(T9),\nT8 -> T9"
            },
            {
                "from": 59,
                "to": 87,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 60,
                "to": 61,
                "label": "SUCCESS"
            },
            {
                "from": 86,
                "to": 90,
                "label": "CASE"
            },
            {
                "from": 90,
                "to": 92,
                "label": "PARALLEL"
            },
            {
                "from": 90,
                "to": 94,
                "label": "PARALLEL"
            },
            {
                "from": 92,
                "to": 97,
                "label": "EVAL with clause\ntail([], []).\nand substitutionT7 -> [],\nX8 -> []"
            },
            {
                "from": 92,
                "to": 98,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 94,
                "to": 154,
                "label": "EVAL with clause\ntail(.(X13, X14), X14).\nand substitutionX13 -> T14,\nX14 -> T15,\nT7 -> .(T14, T15),\nX8 -> T15"
            },
            {
                "from": 94,
                "to": 155,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 97,
                "to": 12,
                "label": "INSTANCE with matching:\nT1 -> []\nT2 -> T9"
            },
            {
                "from": 154,
                "to": 12,
                "label": "INSTANCE with matching:\nT1 -> T15\nT2 -> T9"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(54)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f12_in([]) -> f12_out1(0)
   f12_in([]) -> U1(f12_in([]), [])
   U1(f12_out1(T9), []) -> f12_out1(s(T9))
   f12_in(.(T14, T15)) -> U2(f12_in(T15), .(T14, T15))
   U2(f12_out1(T9), .(T14, T15)) -> f12_out1(s(T9))

Q is empty.

----------------------------------------

(55) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(.(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(0) = 0
   POL(U1(x_1, x_2)) = x_1 + 2*x_2
   POL(U2(x_1, x_2)) = x_1 + x_2
   POL([]) = 0
   POL(f12_in(x_1)) = 1 + 2*x_1
   POL(f12_out1(x_1)) = 2*x_1
   POL(s(x_1)) = x_1
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   f12_in([]) -> f12_out1(0)




----------------------------------------

(56)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f12_in([]) -> U1(f12_in([]), [])
   U1(f12_out1(T9), []) -> f12_out1(s(T9))
   f12_in(.(T14, T15)) -> U2(f12_in(T15), .(T14, T15))
   U2(f12_out1(T9), .(T14, T15)) -> f12_out1(s(T9))

Q is empty.

----------------------------------------

(57) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(.(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(U1(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(U2(x_1, x_2)) = x_1 + x_2
   POL([]) = 0
   POL(f12_in(x_1)) = 2*x_1
   POL(f12_out1(x_1)) = 2 + x_1
   POL(s(x_1)) = x_1
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   U1(f12_out1(T9), []) -> f12_out1(s(T9))




----------------------------------------

(58)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f12_in([]) -> U1(f12_in([]), [])
   f12_in(.(T14, T15)) -> U2(f12_in(T15), .(T14, T15))
   U2(f12_out1(T9), .(T14, T15)) -> f12_out1(s(T9))

Q is empty.

----------------------------------------

(59) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(.(x_1, x_2)) = 1 + 2*x_1 + 2*x_2
   POL(U1(x_1, x_2)) = x_1 + x_2
   POL(U2(x_1, x_2)) = 1 + x_1 + x_2
   POL([]) = 0
   POL(f12_in(x_1)) = 2*x_1
   POL(f12_out1(x_1)) = 2*x_1
   POL(s(x_1)) = x_1
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   U2(f12_out1(T9), .(T14, T15)) -> f12_out1(s(T9))




----------------------------------------

(60)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f12_in([]) -> U1(f12_in([]), [])
   f12_in(.(T14, T15)) -> U2(f12_in(T15), .(T14, T15))

Q is empty.

----------------------------------------

(61) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(.(x_1, x_2)) = 2 + 2*x_1 + 2*x_2
   POL(U1(x_1, x_2)) = x_1 + x_2
   POL(U2(x_1, x_2)) = 1 + x_1 + x_2
   POL([]) = 0
   POL(f12_in(x_1)) = 2*x_1
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   f12_in(.(T14, T15)) -> U2(f12_in(T15), .(T14, T15))




----------------------------------------

(62)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f12_in([]) -> U1(f12_in([]), [])

Q is empty.

----------------------------------------

(63) Overlay + Local Confluence (EQUIVALENT)
The TRS is overlay and locally confluent. By [NOC] we can switch to innermost.
----------------------------------------

(64)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f12_in([]) -> U1(f12_in([]), [])

The set Q consists of the following terms:

   f12_in([])


----------------------------------------

(65) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(66)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F12_IN([]) -> F12_IN([])

The TRS R consists of the following rules:

   f12_in([]) -> U1(f12_in([]), [])

The set Q consists of the following terms:

   f12_in([])

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(67) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(68)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F12_IN([]) -> F12_IN([])

R is empty.
The set Q consists of the following terms:

   f12_in([])

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(69) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   f12_in([])


----------------------------------------

(70)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F12_IN([]) -> F12_IN([])

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(71) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by semiunifying a rule from P directly.

s = F12_IN([]) evaluates to  t =F12_IN([])

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

The DP semiunifies directly so there is only one rewrite step from F12_IN([]) to F12_IN([]).




----------------------------------------

(72)
NO

----------------------------------------

(73) PrologToIRSwTTransformerProof (SOUND)
Transformed Prolog program to IRSwT according to method in Master Thesis of A. Weinert

{
    "root": 1,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(len ([]) (0))",
                "(!)"
            ],
            [
                "(len Xs (s N))",
                "(',' (tail Xs Ys) (len Ys N))"
            ],
            [
                "(tail ([]) ([]))",
                null
            ],
            [
                "(tail (. X Xs) Xs)",
                null
            ]
        ]
    },
    "graph": {
        "nodes": {
            "56": {
                "goal": [
                    {
                        "clause": -1,
                        "scope": -1,
                        "term": "(!_1)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(len ([]) T2)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "57": {
                "goal": [{
                    "clause": 1,
                    "scope": 1,
                    "term": "(len T1 T2)"
                }],
                "kb": {
                    "nonunifying": [[
                        "(len T1 T2)",
                        "(len ([]) (0))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "110": {
                "goal": [{
                    "clause": 3,
                    "scope": 2,
                    "term": "(',' (tail T7 X8) (len X8 T9))"
                }],
                "kb": {
                    "nonunifying": [[
                        "(len T7 T2)",
                        "(len ([]) (0))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T7"],
                    "free": ["X8"],
                    "exprvars": []
                }
            },
            "1": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(len T1 T2)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "111": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(len ([]) T9)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "2": {
                "goal": [
                    {
                        "clause": 0,
                        "scope": 1,
                        "term": "(len T1 T2)"
                    },
                    {
                        "clause": 1,
                        "scope": 1,
                        "term": "(len T1 T2)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T1"],
                    "free": [],
                    "exprvars": []
                }
            },
            "112": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "102": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "158": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(len T15 T9)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T15"],
                    "free": [],
                    "exprvars": []
                }
            },
            "104": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "159": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "106": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (tail T7 X8) (len X8 T9))"
                }],
                "kb": {
                    "nonunifying": [[
                        "(len T7 T2)",
                        "(len ([]) (0))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T7"],
                    "free": ["X8"],
                    "exprvars": []
                }
            },
            "107": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "108": {
                "goal": [
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(',' (tail T7 X8) (len X8 T9))"
                    },
                    {
                        "clause": 3,
                        "scope": 2,
                        "term": "(',' (tail T7 X8) (len X8 T9))"
                    }
                ],
                "kb": {
                    "nonunifying": [[
                        "(len T7 T2)",
                        "(len ([]) (0))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T7"],
                    "free": ["X8"],
                    "exprvars": []
                }
            },
            "109": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(',' (tail T7 X8) (len X8 T9))"
                }],
                "kb": {
                    "nonunifying": [[
                        "(len T7 T2)",
                        "(len ([]) (0))"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": ["T7"],
                    "free": ["X8"],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 1,
                "to": 2,
                "label": "CASE"
            },
            {
                "from": 2,
                "to": 56,
                "label": "EVAL with clause\nlen([], 0) :- !_1.\nand substitutionT1 -> [],\nT2 -> 0"
            },
            {
                "from": 2,
                "to": 57,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 56,
                "to": 102,
                "label": "CUT"
            },
            {
                "from": 57,
                "to": 106,
                "label": "EVAL with clause\nlen(X6, s(X7)) :- ','(tail(X6, X8), len(X8, X7)).\nand substitutionT1 -> T7,\nX6 -> T7,\nX7 -> T9,\nT2 -> s(T9),\nT8 -> T9"
            },
            {
                "from": 57,
                "to": 107,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 102,
                "to": 104,
                "label": "SUCCESS"
            },
            {
                "from": 106,
                "to": 108,
                "label": "CASE"
            },
            {
                "from": 108,
                "to": 109,
                "label": "PARALLEL"
            },
            {
                "from": 108,
                "to": 110,
                "label": "PARALLEL"
            },
            {
                "from": 109,
                "to": 111,
                "label": "EVAL with clause\ntail([], []).\nand substitutionT7 -> [],\nX8 -> []"
            },
            {
                "from": 109,
                "to": 112,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 110,
                "to": 158,
                "label": "EVAL with clause\ntail(.(X13, X14), X14).\nand substitutionX13 -> T14,\nX14 -> T15,\nT7 -> .(T14, T15),\nX8 -> T15"
            },
            {
                "from": 110,
                "to": 159,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 111,
                "to": 1,
                "label": "INSTANCE with matching:\nT1 -> []\nT2 -> T9"
            },
            {
                "from": 158,
                "to": 1,
                "label": "INSTANCE with matching:\nT1 -> T15\nT2 -> T9"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(74)
Obligation:
Rules:
f159_out -> f110_out(T7) :|: TRUE
f110_in(x) -> f159_in :|: TRUE
f158_out(T15) -> f110_out(.(T14, T15)) :|: TRUE
f110_in(.(x1, x2)) -> f158_in(x2) :|: TRUE
f2_in([]) -> f56_in :|: TRUE
f56_out -> f2_out([]) :|: TRUE
f57_out(T1) -> f2_out(T1) :|: TRUE
f2_in(x3) -> f57_in(x3) :|: TRUE
f57_in(x4) -> f106_in(x4) :|: TRUE
f57_in(x5) -> f107_in :|: TRUE
f106_out(x6) -> f57_out(x6) :|: TRUE
f107_out -> f57_out(x7) :|: TRUE
f108_out(x8) -> f106_out(x8) :|: TRUE
f106_in(x9) -> f108_in(x9) :|: TRUE
f108_in(x10) -> f109_in(x10) :|: TRUE
f110_out(x11) -> f108_out(x11) :|: TRUE
f109_out(x12) -> f108_out(x12) :|: TRUE
f108_in(x13) -> f110_in(x13) :|: TRUE
f158_in(x14) -> f1_in(x14) :|: TRUE
f1_out(x15) -> f158_out(x15) :|: TRUE
f109_in([]) -> f111_in :|: TRUE
f111_out -> f109_out([]) :|: TRUE
f112_out -> f109_out(x16) :|: TRUE
f109_in(x17) -> f112_in :|: TRUE
f2_out(x18) -> f1_out(x18) :|: TRUE
f1_in(x19) -> f2_in(x19) :|: TRUE
f111_in -> f1_in([]) :|: TRUE
f1_out([]) -> f111_out :|: TRUE
Start term: f1_in(T1)

----------------------------------------

(75) IRSwTSimpleDependencyGraphProof (EQUIVALENT)
Constructed simple dependency graph.

Simplified to the following IRSwTs:

intTRSProblem:
f110_in(.(x1, x2)) -> f158_in(x2) :|: TRUE
f2_in(x3) -> f57_in(x3) :|: TRUE
f57_in(x4) -> f106_in(x4) :|: TRUE
f106_in(x9) -> f108_in(x9) :|: TRUE
f108_in(x10) -> f109_in(x10) :|: TRUE
f108_in(x13) -> f110_in(x13) :|: TRUE
f158_in(x14) -> f1_in(x14) :|: TRUE
f109_in([]) -> f111_in :|: TRUE
f1_in(x19) -> f2_in(x19) :|: TRUE
f111_in -> f1_in([]) :|: TRUE


----------------------------------------

(76)
Obligation:
Rules:
f110_in(.(x1, x2)) -> f158_in(x2) :|: TRUE
f2_in(x3) -> f57_in(x3) :|: TRUE
f57_in(x4) -> f106_in(x4) :|: TRUE
f106_in(x9) -> f108_in(x9) :|: TRUE
f108_in(x10) -> f109_in(x10) :|: TRUE
f108_in(x13) -> f110_in(x13) :|: TRUE
f158_in(x14) -> f1_in(x14) :|: TRUE
f109_in([]) -> f111_in :|: TRUE
f1_in(x19) -> f2_in(x19) :|: TRUE
f111_in -> f1_in([]) :|: TRUE

----------------------------------------

(77) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(78)
Obligation:
Rules:
f2_in(.(x1:0, x2:0)) -> f2_in(x2:0) :|: TRUE
f2_in([]) -> f2_in([]) :|: TRUE

----------------------------------------

(79) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(80)
Obligation:
Rules:
f2_in(.(x1:0, x2:0)) -> f2_in(x2:0) :|: TRUE
f2_in([]) -> f2_in([]) :|: TRUE

----------------------------------------

(81) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f2_in(.(x1:0, x2:0)) -> f2_in(x2:0) :|: TRUE
(2) f2_in([]) -> f2_in([]) :|: TRUE

Arcs:
(1) -> (1), (2)
(2) -> (2)

This digraph is fully evaluated!
----------------------------------------

(82)
Complex Obligation (AND)

----------------------------------------

(83)
Obligation:

Termination digraph:
Nodes:
(1) f2_in(.(x1:0, x2:0)) -> f2_in(x2:0) :|: TRUE

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(84) IntTRSUnneededArgumentFilterProof (EQUIVALENT)
Some arguments are removed because they cannot influence termination. We removed arguments according to the following replacements:

   .(x1, x2) -> .(x2)

----------------------------------------

(85)
Obligation:
Rules:
f2_in(.(x2:0)) -> f2_in(x2:0) :|: TRUE

----------------------------------------

(86) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f2_in(VARIABLE)
.(VARIABLE)
Removed predefined arithmetic.
----------------------------------------

(87)
Obligation:
Rules:
f2_in(.(x2:0)) -> f2_in(x2:0)

----------------------------------------

(88) IRSwTToQDPProof (SOUND)
Removed the integers and created a QDP-Problem.
----------------------------------------

(89)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   f2_in(.(x2:0)) -> f2_in(x2:0)

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(90) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*f2_in(.(x2:0)) -> f2_in(x2:0)
The graph contains the following edges 1 > 1


----------------------------------------

(91)
YES

----------------------------------------

(92)
Obligation:

Termination digraph:
Nodes:
(1) f2_in([]) -> f2_in([]) :|: TRUE

Arcs:
(1) -> (1)

This digraph is fully evaluated!
