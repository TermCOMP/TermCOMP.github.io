MAYBE
proof of /hpcwork/ff862203/termcomp25/benchmarks/mvNB8.pl
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Left Termination of the query pattern

p(a,a,a)

w.r.t. the given Prolog program could not be shown:

(0) Prolog
(1) CutEliminatorProof [SOUND, 0 ms]
(2) Prolog
    (3) PrologToPiTRSProof [SOUND, 0 ms]
    (4) PiTRS
        (5) DependencyPairsProof [EQUIVALENT, 0 ms]
        (6) PiDP
        (7) DependencyGraphProof [EQUIVALENT, 0 ms]
        (8) PiDP
        (9) UsableRulesProof [EQUIVALENT, 0 ms]
        (10) PiDP
        (11) PiDPToQDPProof [SOUND, 0 ms]
        (12) QDP
    (13) PrologToPiTRSProof [SOUND, 0 ms]
    (14) PiTRS
        (15) DependencyPairsProof [EQUIVALENT, 0 ms]
        (16) PiDP
        (17) DependencyGraphProof [EQUIVALENT, 0 ms]
        (18) PiDP
        (19) UsableRulesProof [EQUIVALENT, 0 ms]
        (20) PiDP
        (21) PiDPToQDPProof [SOUND, 0 ms]
        (22) QDP
(23) PrologToTRSTransformerProof [SOUND, 0 ms]
(24) QTRS
    (25) QTRSRRRProof [EQUIVALENT, 27 ms]
    (26) QTRS
    (27) QTRSRRRProof [EQUIVALENT, 3 ms]
    (28) QTRS
    (29) QTRSRRRProof [EQUIVALENT, 1 ms]
    (30) QTRS
    (31) QTRSRRRProof [EQUIVALENT, 2 ms]
    (32) QTRS
    (33) QTRSRRRProof [EQUIVALENT, 0 ms]
    (34) QTRS
(35) PrologToIRSwTTransformerProof [SOUND, 0 ms]
(36) IRSwT
    (37) IRSwTSimpleDependencyGraphProof [EQUIVALENT, 0 ms]
    (38) IRSwT
    (39) IntTRSCompressionProof [EQUIVALENT, 11 ms]
    (40) IRSwT
    (41) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
    (42) IRSwT
    (43) IRSwTTerminationDigraphProof [EQUIVALENT, 0 ms]
    (44) IRSwT
    (45) FilterProof [EQUIVALENT, 0 ms]
    (46) IntTRS
    (47) IntTRSPeriodicNontermProof [COMPLETE, 2 ms]
    (48) NO
(49) PrologToDTProblemTransformerProof [SOUND, 0 ms]
(50) TRIPLES
    (51) TriplesToPiDPProof [SOUND, 4 ms]
    (52) PiDP
    (53) DependencyGraphProof [EQUIVALENT, 0 ms]
    (54) PiDP
    (55) PiDPToQDPProof [SOUND, 0 ms]
    (56) QDP


----------------------------------------

(0)
Obligation:
Clauses:

p(X, Y, Z) :- ','(append(X, Y, Z), !).
append([], Y, Y).
append(.(H, Xs), Ys, .(H, Zs)) :- append(Xs, Ys, Zs).


Query: p(a,a,a)
----------------------------------------

(1) CutEliminatorProof (SOUND)
Eliminated all cuts by simply ignoring them[PROLOG].
----------------------------------------

(2)
Obligation:
Clauses:

p(X, Y, Z) :- append(X, Y, Z).
append([], Y, Y).
append(.(H, Xs), Ys, .(H, Zs)) :- append(Xs, Ys, Zs).


Query: p(a,a,a)
----------------------------------------

(3) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

p_in_3: (f,f,f)

append_in_3: (f,f,f)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   p_in_aaa(X, Y, Z) -> U1_aaa(X, Y, Z, append_in_aaa(X, Y, Z))
   append_in_aaa([], Y, Y) -> append_out_aaa([], Y, Y)
   append_in_aaa(.(H, Xs), Ys, .(H, Zs)) -> U2_aaa(H, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U2_aaa(H, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(H, Xs), Ys, .(H, Zs))
   U1_aaa(X, Y, Z, append_out_aaa(X, Y, Z)) -> p_out_aaa(X, Y, Z)

The argument filtering Pi contains the following mapping:
p_in_aaa(x1, x2, x3)  =  p_in_aaa

U1_aaa(x1, x2, x3, x4)  =  U1_aaa(x4)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa(x1)

U2_aaa(x1, x2, x3, x4, x5)  =  U2_aaa(x5)

.(x1, x2)  =  .(x2)

p_out_aaa(x1, x2, x3)  =  p_out_aaa(x1)





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(4)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   p_in_aaa(X, Y, Z) -> U1_aaa(X, Y, Z, append_in_aaa(X, Y, Z))
   append_in_aaa([], Y, Y) -> append_out_aaa([], Y, Y)
   append_in_aaa(.(H, Xs), Ys, .(H, Zs)) -> U2_aaa(H, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U2_aaa(H, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(H, Xs), Ys, .(H, Zs))
   U1_aaa(X, Y, Z, append_out_aaa(X, Y, Z)) -> p_out_aaa(X, Y, Z)

The argument filtering Pi contains the following mapping:
p_in_aaa(x1, x2, x3)  =  p_in_aaa

U1_aaa(x1, x2, x3, x4)  =  U1_aaa(x4)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa(x1)

U2_aaa(x1, x2, x3, x4, x5)  =  U2_aaa(x5)

.(x1, x2)  =  .(x2)

p_out_aaa(x1, x2, x3)  =  p_out_aaa(x1)



----------------------------------------

(5) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   P_IN_AAA(X, Y, Z) -> U1_AAA(X, Y, Z, append_in_aaa(X, Y, Z))
   P_IN_AAA(X, Y, Z) -> APPEND_IN_AAA(X, Y, Z)
   APPEND_IN_AAA(.(H, Xs), Ys, .(H, Zs)) -> U2_AAA(H, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   APPEND_IN_AAA(.(H, Xs), Ys, .(H, Zs)) -> APPEND_IN_AAA(Xs, Ys, Zs)

The TRS R consists of the following rules:

   p_in_aaa(X, Y, Z) -> U1_aaa(X, Y, Z, append_in_aaa(X, Y, Z))
   append_in_aaa([], Y, Y) -> append_out_aaa([], Y, Y)
   append_in_aaa(.(H, Xs), Ys, .(H, Zs)) -> U2_aaa(H, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U2_aaa(H, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(H, Xs), Ys, .(H, Zs))
   U1_aaa(X, Y, Z, append_out_aaa(X, Y, Z)) -> p_out_aaa(X, Y, Z)

The argument filtering Pi contains the following mapping:
p_in_aaa(x1, x2, x3)  =  p_in_aaa

U1_aaa(x1, x2, x3, x4)  =  U1_aaa(x4)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa(x1)

U2_aaa(x1, x2, x3, x4, x5)  =  U2_aaa(x5)

.(x1, x2)  =  .(x2)

p_out_aaa(x1, x2, x3)  =  p_out_aaa(x1)

P_IN_AAA(x1, x2, x3)  =  P_IN_AAA

U1_AAA(x1, x2, x3, x4)  =  U1_AAA(x4)

APPEND_IN_AAA(x1, x2, x3)  =  APPEND_IN_AAA

U2_AAA(x1, x2, x3, x4, x5)  =  U2_AAA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(6)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   P_IN_AAA(X, Y, Z) -> U1_AAA(X, Y, Z, append_in_aaa(X, Y, Z))
   P_IN_AAA(X, Y, Z) -> APPEND_IN_AAA(X, Y, Z)
   APPEND_IN_AAA(.(H, Xs), Ys, .(H, Zs)) -> U2_AAA(H, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   APPEND_IN_AAA(.(H, Xs), Ys, .(H, Zs)) -> APPEND_IN_AAA(Xs, Ys, Zs)

The TRS R consists of the following rules:

   p_in_aaa(X, Y, Z) -> U1_aaa(X, Y, Z, append_in_aaa(X, Y, Z))
   append_in_aaa([], Y, Y) -> append_out_aaa([], Y, Y)
   append_in_aaa(.(H, Xs), Ys, .(H, Zs)) -> U2_aaa(H, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U2_aaa(H, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(H, Xs), Ys, .(H, Zs))
   U1_aaa(X, Y, Z, append_out_aaa(X, Y, Z)) -> p_out_aaa(X, Y, Z)

The argument filtering Pi contains the following mapping:
p_in_aaa(x1, x2, x3)  =  p_in_aaa

U1_aaa(x1, x2, x3, x4)  =  U1_aaa(x4)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa(x1)

U2_aaa(x1, x2, x3, x4, x5)  =  U2_aaa(x5)

.(x1, x2)  =  .(x2)

p_out_aaa(x1, x2, x3)  =  p_out_aaa(x1)

P_IN_AAA(x1, x2, x3)  =  P_IN_AAA

U1_AAA(x1, x2, x3, x4)  =  U1_AAA(x4)

APPEND_IN_AAA(x1, x2, x3)  =  APPEND_IN_AAA

U2_AAA(x1, x2, x3, x4, x5)  =  U2_AAA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(7) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 3 less nodes.
----------------------------------------

(8)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   APPEND_IN_AAA(.(H, Xs), Ys, .(H, Zs)) -> APPEND_IN_AAA(Xs, Ys, Zs)

The TRS R consists of the following rules:

   p_in_aaa(X, Y, Z) -> U1_aaa(X, Y, Z, append_in_aaa(X, Y, Z))
   append_in_aaa([], Y, Y) -> append_out_aaa([], Y, Y)
   append_in_aaa(.(H, Xs), Ys, .(H, Zs)) -> U2_aaa(H, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U2_aaa(H, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(H, Xs), Ys, .(H, Zs))
   U1_aaa(X, Y, Z, append_out_aaa(X, Y, Z)) -> p_out_aaa(X, Y, Z)

The argument filtering Pi contains the following mapping:
p_in_aaa(x1, x2, x3)  =  p_in_aaa

U1_aaa(x1, x2, x3, x4)  =  U1_aaa(x4)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa(x1)

U2_aaa(x1, x2, x3, x4, x5)  =  U2_aaa(x5)

.(x1, x2)  =  .(x2)

p_out_aaa(x1, x2, x3)  =  p_out_aaa(x1)

APPEND_IN_AAA(x1, x2, x3)  =  APPEND_IN_AAA


We have to consider all (P,R,Pi)-chains
----------------------------------------

(9) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(10)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   APPEND_IN_AAA(.(H, Xs), Ys, .(H, Zs)) -> APPEND_IN_AAA(Xs, Ys, Zs)

R is empty.
The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x2)

APPEND_IN_AAA(x1, x2, x3)  =  APPEND_IN_AAA


We have to consider all (P,R,Pi)-chains
----------------------------------------

(11) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(12)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   APPEND_IN_AAA -> APPEND_IN_AAA

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(13) PrologToPiTRSProof (SOUND)
We use the technique of [TOCL09]. With regard to the inferred argument filtering the predicates were used in the following modes:

p_in_3: (f,f,f)

append_in_3: (f,f,f)

Transforming Prolog into the following Term Rewriting System:

Pi-finite rewrite system:
The TRS R consists of the following rules:

   p_in_aaa(X, Y, Z) -> U1_aaa(X, Y, Z, append_in_aaa(X, Y, Z))
   append_in_aaa([], Y, Y) -> append_out_aaa([], Y, Y)
   append_in_aaa(.(H, Xs), Ys, .(H, Zs)) -> U2_aaa(H, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U2_aaa(H, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(H, Xs), Ys, .(H, Zs))
   U1_aaa(X, Y, Z, append_out_aaa(X, Y, Z)) -> p_out_aaa(X, Y, Z)

The argument filtering Pi contains the following mapping:
p_in_aaa(x1, x2, x3)  =  p_in_aaa

U1_aaa(x1, x2, x3, x4)  =  U1_aaa(x4)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa(x1)

U2_aaa(x1, x2, x3, x4, x5)  =  U2_aaa(x5)

.(x1, x2)  =  .(x2)

p_out_aaa(x1, x2, x3)  =  p_out_aaa(x1)





Infinitary Constructor Rewriting Termination of PiTRS implies Termination of Prolog



----------------------------------------

(14)
Obligation:
Pi-finite rewrite system:
The TRS R consists of the following rules:

   p_in_aaa(X, Y, Z) -> U1_aaa(X, Y, Z, append_in_aaa(X, Y, Z))
   append_in_aaa([], Y, Y) -> append_out_aaa([], Y, Y)
   append_in_aaa(.(H, Xs), Ys, .(H, Zs)) -> U2_aaa(H, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U2_aaa(H, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(H, Xs), Ys, .(H, Zs))
   U1_aaa(X, Y, Z, append_out_aaa(X, Y, Z)) -> p_out_aaa(X, Y, Z)

The argument filtering Pi contains the following mapping:
p_in_aaa(x1, x2, x3)  =  p_in_aaa

U1_aaa(x1, x2, x3, x4)  =  U1_aaa(x4)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa(x1)

U2_aaa(x1, x2, x3, x4, x5)  =  U2_aaa(x5)

.(x1, x2)  =  .(x2)

p_out_aaa(x1, x2, x3)  =  p_out_aaa(x1)



----------------------------------------

(15) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LOPSTR] we result in the following initial DP problem:
Pi DP problem:
The TRS P consists of the following rules:

   P_IN_AAA(X, Y, Z) -> U1_AAA(X, Y, Z, append_in_aaa(X, Y, Z))
   P_IN_AAA(X, Y, Z) -> APPEND_IN_AAA(X, Y, Z)
   APPEND_IN_AAA(.(H, Xs), Ys, .(H, Zs)) -> U2_AAA(H, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   APPEND_IN_AAA(.(H, Xs), Ys, .(H, Zs)) -> APPEND_IN_AAA(Xs, Ys, Zs)

The TRS R consists of the following rules:

   p_in_aaa(X, Y, Z) -> U1_aaa(X, Y, Z, append_in_aaa(X, Y, Z))
   append_in_aaa([], Y, Y) -> append_out_aaa([], Y, Y)
   append_in_aaa(.(H, Xs), Ys, .(H, Zs)) -> U2_aaa(H, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U2_aaa(H, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(H, Xs), Ys, .(H, Zs))
   U1_aaa(X, Y, Z, append_out_aaa(X, Y, Z)) -> p_out_aaa(X, Y, Z)

The argument filtering Pi contains the following mapping:
p_in_aaa(x1, x2, x3)  =  p_in_aaa

U1_aaa(x1, x2, x3, x4)  =  U1_aaa(x4)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa(x1)

U2_aaa(x1, x2, x3, x4, x5)  =  U2_aaa(x5)

.(x1, x2)  =  .(x2)

p_out_aaa(x1, x2, x3)  =  p_out_aaa(x1)

P_IN_AAA(x1, x2, x3)  =  P_IN_AAA

U1_AAA(x1, x2, x3, x4)  =  U1_AAA(x4)

APPEND_IN_AAA(x1, x2, x3)  =  APPEND_IN_AAA

U2_AAA(x1, x2, x3, x4, x5)  =  U2_AAA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(16)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   P_IN_AAA(X, Y, Z) -> U1_AAA(X, Y, Z, append_in_aaa(X, Y, Z))
   P_IN_AAA(X, Y, Z) -> APPEND_IN_AAA(X, Y, Z)
   APPEND_IN_AAA(.(H, Xs), Ys, .(H, Zs)) -> U2_AAA(H, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   APPEND_IN_AAA(.(H, Xs), Ys, .(H, Zs)) -> APPEND_IN_AAA(Xs, Ys, Zs)

The TRS R consists of the following rules:

   p_in_aaa(X, Y, Z) -> U1_aaa(X, Y, Z, append_in_aaa(X, Y, Z))
   append_in_aaa([], Y, Y) -> append_out_aaa([], Y, Y)
   append_in_aaa(.(H, Xs), Ys, .(H, Zs)) -> U2_aaa(H, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U2_aaa(H, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(H, Xs), Ys, .(H, Zs))
   U1_aaa(X, Y, Z, append_out_aaa(X, Y, Z)) -> p_out_aaa(X, Y, Z)

The argument filtering Pi contains the following mapping:
p_in_aaa(x1, x2, x3)  =  p_in_aaa

U1_aaa(x1, x2, x3, x4)  =  U1_aaa(x4)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa(x1)

U2_aaa(x1, x2, x3, x4, x5)  =  U2_aaa(x5)

.(x1, x2)  =  .(x2)

p_out_aaa(x1, x2, x3)  =  p_out_aaa(x1)

P_IN_AAA(x1, x2, x3)  =  P_IN_AAA

U1_AAA(x1, x2, x3, x4)  =  U1_AAA(x4)

APPEND_IN_AAA(x1, x2, x3)  =  APPEND_IN_AAA

U2_AAA(x1, x2, x3, x4, x5)  =  U2_AAA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(17) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 3 less nodes.
----------------------------------------

(18)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   APPEND_IN_AAA(.(H, Xs), Ys, .(H, Zs)) -> APPEND_IN_AAA(Xs, Ys, Zs)

The TRS R consists of the following rules:

   p_in_aaa(X, Y, Z) -> U1_aaa(X, Y, Z, append_in_aaa(X, Y, Z))
   append_in_aaa([], Y, Y) -> append_out_aaa([], Y, Y)
   append_in_aaa(.(H, Xs), Ys, .(H, Zs)) -> U2_aaa(H, Xs, Ys, Zs, append_in_aaa(Xs, Ys, Zs))
   U2_aaa(H, Xs, Ys, Zs, append_out_aaa(Xs, Ys, Zs)) -> append_out_aaa(.(H, Xs), Ys, .(H, Zs))
   U1_aaa(X, Y, Z, append_out_aaa(X, Y, Z)) -> p_out_aaa(X, Y, Z)

The argument filtering Pi contains the following mapping:
p_in_aaa(x1, x2, x3)  =  p_in_aaa

U1_aaa(x1, x2, x3, x4)  =  U1_aaa(x4)

append_in_aaa(x1, x2, x3)  =  append_in_aaa

append_out_aaa(x1, x2, x3)  =  append_out_aaa(x1)

U2_aaa(x1, x2, x3, x4, x5)  =  U2_aaa(x5)

.(x1, x2)  =  .(x2)

p_out_aaa(x1, x2, x3)  =  p_out_aaa(x1)

APPEND_IN_AAA(x1, x2, x3)  =  APPEND_IN_AAA


We have to consider all (P,R,Pi)-chains
----------------------------------------

(19) UsableRulesProof (EQUIVALENT)
For (infinitary) constructor rewriting [LOPSTR] we can delete all non-usable rules from R.
----------------------------------------

(20)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   APPEND_IN_AAA(.(H, Xs), Ys, .(H, Zs)) -> APPEND_IN_AAA(Xs, Ys, Zs)

R is empty.
The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x2)

APPEND_IN_AAA(x1, x2, x3)  =  APPEND_IN_AAA


We have to consider all (P,R,Pi)-chains
----------------------------------------

(21) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(22)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   APPEND_IN_AAA -> APPEND_IN_AAA

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(23) PrologToTRSTransformerProof (SOUND)
Transformed Prolog program to TRS.

{
    "root": 1,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(p X Y Z)",
                "(',' (append X Y Z) (!))"
            ],
            [
                "(append ([]) Y Y)",
                null
            ],
            [
                "(append (. H Xs) Ys (. H Zs))",
                "(append Xs Ys Zs)"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "22": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(!_1)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "23": {
                "goal": [
                    {
                        "clause": 1,
                        "scope": 2,
                        "term": "(append T18 T19 T20)"
                    },
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(append T18 T19 T20)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "24": {
                "goal": [{
                    "clause": 1,
                    "scope": 2,
                    "term": "(append T18 T19 T20)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "25": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(append T18 T19 T20)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "26": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "27": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "17": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (append T18 T19 T20) (!_1))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "1": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "144": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "145": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(append T42 T43 T44)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "3": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(p T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "146": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "148": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "149": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "21": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(append T18 T19 T20)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 1,
                "to": 3,
                "label": "CASE"
            },
            {
                "from": 3,
                "to": 17,
                "label": "ONLY EVAL with clause\np(X9, X10, X11) :- ','(append(X9, X10, X11), !_1).\nand substitutionT1 -> T18,\nX9 -> T18,\nT2 -> T19,\nX10 -> T19,\nT3 -> T20,\nX11 -> T20,\nT15 -> T18,\nT16 -> T19,\nT17 -> T20"
            },
            {
                "from": 17,
                "to": 21,
                "label": "SPLIT 1"
            },
            {
                "from": 17,
                "to": 22,
                "label": "SPLIT 2"
            },
            {
                "from": 21,
                "to": 23,
                "label": "CASE"
            },
            {
                "from": 22,
                "to": 148,
                "label": "CUT"
            },
            {
                "from": 23,
                "to": 24,
                "label": "PARALLEL"
            },
            {
                "from": 23,
                "to": 25,
                "label": "PARALLEL"
            },
            {
                "from": 24,
                "to": 26,
                "label": "EVAL with clause\nappend([], X20, X20).\nand substitutionT18 -> [],\nT19 -> T29,\nX20 -> T29,\nT20 -> T29"
            },
            {
                "from": 24,
                "to": 27,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 25,
                "to": 145,
                "label": "EVAL with clause\nappend(.(X29, X30), X31, .(X29, X32)) :- append(X30, X31, X32).\nand substitutionX29 -> T38,\nX30 -> T42,\nT18 -> .(T38, T42),\nT19 -> T43,\nX31 -> T43,\nX32 -> T44,\nT20 -> .(T38, T44),\nT39 -> T42,\nT40 -> T43,\nT41 -> T44"
            },
            {
                "from": 25,
                "to": 146,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 26,
                "to": 144,
                "label": "SUCCESS"
            },
            {
                "from": 145,
                "to": 21,
                "label": "INSTANCE with matching:\nT18 -> T42\nT19 -> T43\nT20 -> T44"
            },
            {
                "from": 148,
                "to": 149,
                "label": "SUCCESS"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(24)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f1_in -> U1(f17_in)
   U1(f17_out1) -> f1_out1
   f21_in -> f21_out1
   f21_in -> U2(f21_in)
   U2(f21_out1) -> f21_out1
   f22_in -> f22_out1
   f17_in -> U3(f21_in)
   U3(f21_out1) -> U4(f22_in)
   U4(f22_out1) -> f17_out1

Q is empty.

----------------------------------------

(25) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(U1(x_1)) = 2*x_1
   POL(U2(x_1)) = 2*x_1
   POL(U3(x_1)) = 2*x_1
   POL(U4(x_1)) = x_1
   POL(f17_in) = 0
   POL(f17_out1) = 0
   POL(f1_in) = 2
   POL(f1_out1) = 0
   POL(f21_in) = 0
   POL(f21_out1) = 0
   POL(f22_in) = 0
   POL(f22_out1) = 0
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   f1_in -> U1(f17_in)




----------------------------------------

(26)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   U1(f17_out1) -> f1_out1
   f21_in -> f21_out1
   f21_in -> U2(f21_in)
   U2(f21_out1) -> f21_out1
   f22_in -> f22_out1
   f17_in -> U3(f21_in)
   U3(f21_out1) -> U4(f22_in)
   U4(f22_out1) -> f17_out1

Q is empty.

----------------------------------------

(27) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(U1(x_1)) = 1 + 2*x_1
   POL(U2(x_1)) = 2*x_1
   POL(U3(x_1)) = 2*x_1
   POL(U4(x_1)) = 2*x_1
   POL(f17_in) = 1
   POL(f17_out1) = 0
   POL(f1_out1) = 0
   POL(f21_in) = 0
   POL(f21_out1) = 0
   POL(f22_in) = 0
   POL(f22_out1) = 0
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   U1(f17_out1) -> f1_out1
   f17_in -> U3(f21_in)




----------------------------------------

(28)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f21_in -> f21_out1
   f21_in -> U2(f21_in)
   U2(f21_out1) -> f21_out1
   f22_in -> f22_out1
   U3(f21_out1) -> U4(f22_in)
   U4(f22_out1) -> f17_out1

Q is empty.

----------------------------------------

(29) QTRSRRRProof (EQUIVALENT)
Used ordering:
f21_in/0)
f21_out1/0)
U2/1)YES(
f22_in/0)
f22_out1/0)
U3/1)YES(
U4/1)YES(
f17_out1/0)

Quasi precedence:
f21_in > f21_out1 > f22_in > [f22_out1, f17_out1]


Status:
f21_in: multiset status
f21_out1: multiset status
f22_in: multiset status
f22_out1: multiset status
f17_out1: multiset status

With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   f21_in -> f21_out1
   f22_in -> f22_out1
   U3(f21_out1) -> U4(f22_in)




----------------------------------------

(30)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f21_in -> U2(f21_in)
   U2(f21_out1) -> f21_out1
   U4(f22_out1) -> f17_out1

Q is empty.

----------------------------------------

(31) QTRSRRRProof (EQUIVALENT)
Used ordering:
f21_in/0)
U2/1)YES(
f21_out1/0)
U4/1)YES(
f22_out1/0)
f17_out1/0)

Quasi precedence:
f22_out1 > f17_out1


Status:
f21_in: multiset status
f21_out1: multiset status
f22_out1: multiset status
f17_out1: multiset status

With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   U4(f22_out1) -> f17_out1




----------------------------------------

(32)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f21_in -> U2(f21_in)
   U2(f21_out1) -> f21_out1

Q is empty.

----------------------------------------

(33) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(U2(x_1)) = 2*x_1
   POL(f21_in) = 0
   POL(f21_out1) = 1
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   U2(f21_out1) -> f21_out1




----------------------------------------

(34)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f21_in -> U2(f21_in)

Q is empty.

----------------------------------------

(35) PrologToIRSwTTransformerProof (SOUND)
Transformed Prolog program to IRSwT according to method in Master Thesis of A. Weinert

{
    "root": 2,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(p X Y Z)",
                "(',' (append X Y Z) (!))"
            ],
            [
                "(append ([]) Y Y)",
                null
            ],
            [
                "(append (. H Xs) Ys (. H Zs))",
                "(append Xs Ys Zs)"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "33": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "12": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (append T18 T19 T20) (!_1))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "34": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "28": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(append T18 T19 T20)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "29": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(!_1)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "142": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(append T42 T43 T44)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "153": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "143": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "154": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "2": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "4": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(p T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "137": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "30": {
                "goal": [
                    {
                        "clause": 1,
                        "scope": 2,
                        "term": "(append T18 T19 T20)"
                    },
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(append T18 T19 T20)"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "31": {
                "goal": [{
                    "clause": 1,
                    "scope": 2,
                    "term": "(append T18 T19 T20)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "32": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(append T18 T19 T20)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 2,
                "to": 4,
                "label": "CASE"
            },
            {
                "from": 4,
                "to": 12,
                "label": "ONLY EVAL with clause\np(X9, X10, X11) :- ','(append(X9, X10, X11), !_1).\nand substitutionT1 -> T18,\nX9 -> T18,\nT2 -> T19,\nX10 -> T19,\nT3 -> T20,\nX11 -> T20,\nT15 -> T18,\nT16 -> T19,\nT17 -> T20"
            },
            {
                "from": 12,
                "to": 28,
                "label": "SPLIT 1"
            },
            {
                "from": 12,
                "to": 29,
                "label": "SPLIT 2"
            },
            {
                "from": 28,
                "to": 30,
                "label": "CASE"
            },
            {
                "from": 29,
                "to": 153,
                "label": "CUT"
            },
            {
                "from": 30,
                "to": 31,
                "label": "PARALLEL"
            },
            {
                "from": 30,
                "to": 32,
                "label": "PARALLEL"
            },
            {
                "from": 31,
                "to": 33,
                "label": "EVAL with clause\nappend([], X20, X20).\nand substitutionT18 -> [],\nT19 -> T29,\nX20 -> T29,\nT20 -> T29"
            },
            {
                "from": 31,
                "to": 34,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 32,
                "to": 142,
                "label": "EVAL with clause\nappend(.(X29, X30), X31, .(X29, X32)) :- append(X30, X31, X32).\nand substitutionX29 -> T38,\nX30 -> T42,\nT18 -> .(T38, T42),\nT19 -> T43,\nX31 -> T43,\nX32 -> T44,\nT20 -> .(T38, T44),\nT39 -> T42,\nT40 -> T43,\nT41 -> T44"
            },
            {
                "from": 32,
                "to": 143,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 33,
                "to": 137,
                "label": "SUCCESS"
            },
            {
                "from": 142,
                "to": 28,
                "label": "INSTANCE with matching:\nT18 -> T42\nT19 -> T43\nT20 -> T44"
            },
            {
                "from": 153,
                "to": 154,
                "label": "SUCCESS"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(36)
Obligation:
Rules:
f143_out -> f32_out :|: TRUE
f142_out -> f32_out :|: TRUE
f32_in -> f143_in :|: TRUE
f32_in -> f142_in :|: TRUE
f30_in -> f32_in :|: TRUE
f31_out -> f30_out :|: TRUE
f32_out -> f30_out :|: TRUE
f30_in -> f31_in :|: TRUE
f28_out -> f142_out :|: TRUE
f142_in -> f28_in :|: TRUE
f28_in -> f30_in :|: TRUE
f30_out -> f28_out :|: TRUE
f2_in -> f4_in :|: TRUE
f4_out -> f2_out :|: TRUE
f4_in -> f12_in :|: TRUE
f12_out -> f4_out :|: TRUE
f29_out -> f12_out :|: TRUE
f12_in -> f28_in :|: TRUE
f28_out -> f29_in :|: TRUE
Start term: f2_in

----------------------------------------

(37) IRSwTSimpleDependencyGraphProof (EQUIVALENT)
Constructed simple dependency graph.

Simplified to the following IRSwTs:

intTRSProblem:
f32_in -> f142_in :|: TRUE
f30_in -> f32_in :|: TRUE
f142_in -> f28_in :|: TRUE
f28_in -> f30_in :|: TRUE


----------------------------------------

(38)
Obligation:
Rules:
f32_in -> f142_in :|: TRUE
f30_in -> f32_in :|: TRUE
f142_in -> f28_in :|: TRUE
f28_in -> f30_in :|: TRUE

----------------------------------------

(39) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(40)
Obligation:
Rules:
f30_in -> f30_in :|: TRUE

----------------------------------------

(41) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(42)
Obligation:
Rules:
f30_in -> f30_in :|: TRUE

----------------------------------------

(43) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f30_in -> f30_in :|: TRUE

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(44)
Obligation:

Termination digraph:
Nodes:
(1) f30_in -> f30_in :|: TRUE

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(45) FilterProof (EQUIVALENT)
Used the following sort dictionary for filtering: 
f30_in()
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(46)
Obligation:
Rules:
f30_in -> f30_in :|: TRUE

----------------------------------------

(47) IntTRSPeriodicNontermProof (COMPLETE)
Normalized system to the following form:
f(pc) -> f(1) :|: pc = 1 && TRUE
Witness term starting non-terminating reduction: f(1)
----------------------------------------

(48)
NO

----------------------------------------

(49) PrologToDTProblemTransformerProof (SOUND)
Built DT problem from termination graph DT10.

{
    "root": 5,
    "program": {
        "directives": [],
        "clauses": [
            [
                "(p X Y Z)",
                "(',' (append X Y Z) (!))"
            ],
            [
                "(append ([]) Y Y)",
                null
            ],
            [
                "(append (. H Xs) Ys (. H Zs))",
                "(append Xs Ys Zs)"
            ]
        ]
    },
    "graph": {
        "nodes": {
            "147": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(true)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "5": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(p T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "16": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (append T10 T11 T12) (!_1))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "6": {
                "goal": [{
                    "clause": 0,
                    "scope": 1,
                    "term": "(p T1 T2 T3)"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "18": {
                "goal": [
                    {
                        "clause": 1,
                        "scope": 2,
                        "term": "(',' (append T10 T11 T12) (!_1))"
                    },
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(',' (append T10 T11 T12) (!_1))"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "19": {
                "goal": [
                    {
                        "clause": -1,
                        "scope": -1,
                        "term": "(!_1)"
                    },
                    {
                        "clause": 2,
                        "scope": 2,
                        "term": "(',' (append T10 T11 T12) (!_1))"
                    }
                ],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "type": "Nodes",
            "150": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "151": {
                "goal": [{
                    "clause": -1,
                    "scope": -1,
                    "term": "(',' (append T28 T29 T30) (!_1))"
                }],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            },
            "20": {
                "goal": [{
                    "clause": 2,
                    "scope": 2,
                    "term": "(',' (append T10 T11 T12) (!_1))"
                }],
                "kb": {
                    "nonunifying": [[
                        "(append T10 T11 T12)",
                        "(append ([]) X9 X9)"
                    ]],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": ["X9"],
                    "exprvars": []
                }
            },
            "152": {
                "goal": [],
                "kb": {
                    "nonunifying": [],
                    "intvars": {},
                    "arithmetic": {
                        "type": "PlainIntegerRelationState",
                        "relations": []
                    },
                    "ground": [],
                    "free": [],
                    "exprvars": []
                }
            }
        },
        "edges": [
            {
                "from": 5,
                "to": 6,
                "label": "CASE"
            },
            {
                "from": 6,
                "to": 16,
                "label": "ONLY EVAL with clause\np(X4, X5, X6) :- ','(append(X4, X5, X6), !_1).\nand substitutionT1 -> T10,\nX4 -> T10,\nT2 -> T11,\nX5 -> T11,\nT3 -> T12,\nX6 -> T12,\nT7 -> T10,\nT8 -> T11,\nT9 -> T12"
            },
            {
                "from": 16,
                "to": 18,
                "label": "CASE"
            },
            {
                "from": 18,
                "to": 19,
                "label": "EVAL with clause\nappend([], X9, X9).\nand substitutionT10 -> [],\nT11 -> T15,\nX9 -> T15,\nT12 -> T15"
            },
            {
                "from": 18,
                "to": 20,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 19,
                "to": 147,
                "label": "CUT"
            },
            {
                "from": 20,
                "to": 151,
                "label": "EVAL with clause\nappend(.(X18, X19), X20, .(X18, X21)) :- append(X19, X20, X21).\nand substitutionX18 -> T24,\nX19 -> T28,\nT10 -> .(T24, T28),\nT11 -> T29,\nX20 -> T29,\nX21 -> T30,\nT12 -> .(T24, T30),\nT25 -> T28,\nT26 -> T29,\nT27 -> T30"
            },
            {
                "from": 20,
                "to": 152,
                "label": "EVAL-BACKTRACK"
            },
            {
                "from": 147,
                "to": 150,
                "label": "SUCCESS"
            },
            {
                "from": 151,
                "to": 16,
                "label": "INSTANCE with matching:\nT10 -> T28\nT11 -> T29\nT12 -> T30"
            }
        ],
        "type": "Graph"
    }
}

----------------------------------------

(50)
Obligation:
Triples:

pA(.(X1, X2), X3, .(X1, X4)) :- pA(X2, X3, X4).
pB(X1, X2, X3) :- pA(X1, X2, X3).

Clauses:

qcA([], X1, X1).
qcA(.(X1, X2), X3, .(X1, X4)) :- qcA(X2, X3, X4).

Afs:

pB(x1, x2, x3)  =  pB


----------------------------------------

(51) TriplesToPiDPProof (SOUND)
We use the technique of [DT09]. With regard to the inferred argument filtering the predicates were used in the following modes:

pB_in_3: (f,f,f)

pA_in_3: (f,f,f)

Transforming TRIPLES into the following Term Rewriting System:

Pi DP problem:
The TRS P consists of the following rules:

   PB_IN_AAA(X1, X2, X3) -> U2_AAA(X1, X2, X3, pA_in_aaa(X1, X2, X3))
   PB_IN_AAA(X1, X2, X3) -> PA_IN_AAA(X1, X2, X3)
   PA_IN_AAA(.(X1, X2), X3, .(X1, X4)) -> U1_AAA(X1, X2, X3, X4, pA_in_aaa(X2, X3, X4))
   PA_IN_AAA(.(X1, X2), X3, .(X1, X4)) -> PA_IN_AAA(X2, X3, X4)

R is empty.
The argument filtering Pi contains the following mapping:
pA_in_aaa(x1, x2, x3)  =  pA_in_aaa

.(x1, x2)  =  .(x2)

PB_IN_AAA(x1, x2, x3)  =  PB_IN_AAA

U2_AAA(x1, x2, x3, x4)  =  U2_AAA(x4)

PA_IN_AAA(x1, x2, x3)  =  PA_IN_AAA

U1_AAA(x1, x2, x3, x4, x5)  =  U1_AAA(x5)


We have to consider all (P,R,Pi)-chains


Infinitary Constructor Rewriting Termination of PiDP implies Termination of TRIPLES



----------------------------------------

(52)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   PB_IN_AAA(X1, X2, X3) -> U2_AAA(X1, X2, X3, pA_in_aaa(X1, X2, X3))
   PB_IN_AAA(X1, X2, X3) -> PA_IN_AAA(X1, X2, X3)
   PA_IN_AAA(.(X1, X2), X3, .(X1, X4)) -> U1_AAA(X1, X2, X3, X4, pA_in_aaa(X2, X3, X4))
   PA_IN_AAA(.(X1, X2), X3, .(X1, X4)) -> PA_IN_AAA(X2, X3, X4)

R is empty.
The argument filtering Pi contains the following mapping:
pA_in_aaa(x1, x2, x3)  =  pA_in_aaa

.(x1, x2)  =  .(x2)

PB_IN_AAA(x1, x2, x3)  =  PB_IN_AAA

U2_AAA(x1, x2, x3, x4)  =  U2_AAA(x4)

PA_IN_AAA(x1, x2, x3)  =  PA_IN_AAA

U1_AAA(x1, x2, x3, x4, x5)  =  U1_AAA(x5)


We have to consider all (P,R,Pi)-chains
----------------------------------------

(53) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LOPSTR] contains 1 SCC with 3 less nodes.
----------------------------------------

(54)
Obligation:
Pi DP problem:
The TRS P consists of the following rules:

   PA_IN_AAA(.(X1, X2), X3, .(X1, X4)) -> PA_IN_AAA(X2, X3, X4)

R is empty.
The argument filtering Pi contains the following mapping:
.(x1, x2)  =  .(x2)

PA_IN_AAA(x1, x2, x3)  =  PA_IN_AAA


We have to consider all (P,R,Pi)-chains
----------------------------------------

(55) PiDPToQDPProof (SOUND)
Transforming (infinitary) constructor rewriting Pi-DP problem [LOPSTR] into ordinary QDP problem [LPAR04] by application of Pi.
----------------------------------------

(56)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   PA_IN_AAA -> PA_IN_AAA

R is empty.
Q is empty.
We have to consider all (P,Q,R)-chains.