Input TRS:
    1: and(false(),false()) -> false()
    2: and(true(),false()) -> false()
    3: and(false(),true()) -> false()
    4: and(true(),true()) -> true()
    5: eq(nil(),nil()) -> true()
    6: eq(cons(T,L),nil()) -> false()
    7: eq(nil(),cons(T,L)) -> false()
    8: eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
    9: eq(var(L),var(Lp)) -> eq(L,Lp)
    10: eq(var(L),apply(T,S)) -> false()
    11: eq(var(L),lambda(X,T)) -> false()
    12: eq(apply(T,S),var(L)) -> false()
    13: eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
    14: eq(apply(T,S),lambda(X,Tp)) -> false()
    15: eq(lambda(X,T),var(L)) -> false()
    16: eq(lambda(X,T),apply(Tp,Sp)) -> false()
    17: eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
    18: if(true(),var(K),var(L)) -> var(K)
    19: if(false(),var(K),var(L)) -> var(L)
    20: ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
    21: ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
    22: ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil())))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil())))),T)))
Number of strict rules: 22
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #eq(apply(T,S),apply(Tp,Sp)) -> #and(eq(T,Tp),eq(S,Sp))
   #2: #eq(apply(T,S),apply(Tp,Sp)) -> #eq(T,Tp)
   #3: #eq(apply(T,S),apply(Tp,Sp)) -> #eq(S,Sp)
   #4: #eq(var(L),var(Lp)) -> #eq(L,Lp)
   #5: #ren(var(L),var(K),var(Lp)) -> #if(eq(L,Lp),var(K),var(Lp))
   #6: #ren(var(L),var(K),var(Lp)) -> #eq(L,Lp)
   #7: #ren(X,Y,lambda(Z,T)) -> #ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil())))),T))
   #8: #ren(X,Y,lambda(Z,T)) -> #ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil())))),T)
   #9: #eq(lambda(X,T),lambda(Xp,Tp)) -> #and(eq(T,Tp),eq(X,Xp))
   #10: #eq(lambda(X,T),lambda(Xp,Tp)) -> #eq(T,Tp)
   #11: #eq(lambda(X,T),lambda(Xp,Tp)) -> #eq(X,Xp)
   #12: #ren(X,Y,apply(T,S)) -> #ren(X,Y,T)
   #13: #ren(X,Y,apply(T,S)) -> #ren(X,Y,S)
   #14: #eq(cons(T,L),cons(Tp,Lp)) -> #and(eq(T,Tp),eq(L,Lp))
   #15: #eq(cons(T,L),cons(Tp,Lp)) -> #eq(T,Tp)
   #16: #eq(cons(T,L),cons(Tp,Lp)) -> #eq(L,Lp)
Number of SCCs: 2, DPs: 11, edges: 65
	SCC { #7 #8 #12 #13 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
 apply(x1,x2)	weight: (/ 1 4) + x1 + x2
   ren(x1,x2,x3)	weight: x3
   and(x1,x2)	weight: (/ 1 4) + x2
    eq(x1,x2)	weight: (/ 1 4)
lambda(x1,x2)	weight: (/ 1 4) + x2
 false()	weight: 0
  true()	weight: 0
  #eq(x1,x2)	weight: 0
    if(x1,x2,x3)	weight: (/ 1 4)
   nil()	weight: 0
 #ren(x1,x2,x3)	weight: x3
  cons(x1,x2)	weight: (/ 1 4)
  #if(x1,x2,x3)	weight: 0
   var(x1)	weight: (/ 1 4)
 #and(x1,x2)	weight: 0
    Usable rules: { 18..22 }
    Removed DPs: #7 #8 #12 #13
Number of SCCs: 1, DPs: 7, edges: 49
	SCC { #2..4 #10 #11 #15 #16 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
 apply(x1,x2)	weight: (/ 1 8) + x1 + x2
   ren(x1,x2,x3)	weight: x3
   and(x1,x2)	weight: (/ 1 8) + x2
    eq(x1,x2)	weight: (/ 1 4)
lambda(x1,x2)	weight: (/ 1 8) + x1 + x2
 false()	weight: 0
  true()	weight: 0
  #eq(x1,x2)	weight: x1
    if(x1,x2,x3)	weight: x1
   nil()	weight: 0
 #ren(x1,x2,x3)	weight: 0
  cons(x1,x2)	weight: (/ 1 8) + x1 + x2
  #if(x1,x2,x3)	weight: 0
   var(x1)	weight: (/ 1 8) + x1
 #and(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #2..4 #10 #11 #15 #16
Number of SCCs: 0, DPs: 0, edges: 0
