Input TRS:
    1: U101(tt(),N,XS) -> fst(splitAt(activate(N),activate(XS)))
    2: U11(tt(),N,XS) -> snd(splitAt(activate(N),activate(XS)))
    3: U21(tt(),X) -> activate(X)
    4: U31(tt(),N) -> activate(N)
    5: U41(tt(),N) -> cons(activate(N),n__natsFrom(n__s(activate(N))))
    6: U51(tt(),N,XS) -> head(afterNth(activate(N),activate(XS)))
    7: U61(tt(),Y) -> activate(Y)
    8: U71(tt(),XS) -> pair(nil(),activate(XS))
    9: U81(tt(),N,X,XS) -> U82(splitAt(activate(N),activate(XS)),activate(X))
    10: U82(pair(YS,ZS),X) -> pair(cons(activate(X),YS),ZS)
    11: U91(tt(),XS) -> activate(XS)
    12: afterNth(N,XS) -> U11(and(isNatural(N),n__isLNat(XS)),N,XS)
    13: and(tt(),X) -> activate(X)
    14: fst(pair(X,Y)) -> U21(and(isLNat(X),n__isLNat(Y)),X)
    15: head(cons(N,XS)) -> U31(and(isNatural(N),n__isLNat(activate(XS))),N)
    16: isLNat(n__nil()) -> tt()
    17: isLNat(n__afterNth(V1,V2)) -> and(isNatural(activate(V1)),n__isLNat(activate(V2)))
    18: isLNat(n__cons(V1,V2)) -> and(isNatural(activate(V1)),n__isLNat(activate(V2)))
    19: isLNat(n__fst(V1)) -> isPLNat(activate(V1))
    20: isLNat(n__natsFrom(V1)) -> isNatural(activate(V1))
    21: isLNat(n__snd(V1)) -> isPLNat(activate(V1))
    22: isLNat(n__tail(V1)) -> isLNat(activate(V1))
    23: isLNat(n__take(V1,V2)) -> and(isNatural(activate(V1)),n__isLNat(activate(V2)))
    24: isNatural(n__0()) -> tt()
    25: isNatural(n__head(V1)) -> isLNat(activate(V1))
    26: isNatural(n__s(V1)) -> isNatural(activate(V1))
    27: isNatural(n__sel(V1,V2)) -> and(isNatural(activate(V1)),n__isLNat(activate(V2)))
    28: isPLNat(n__pair(V1,V2)) -> and(isLNat(activate(V1)),n__isLNat(activate(V2)))
    29: isPLNat(n__splitAt(V1,V2)) -> and(isNatural(activate(V1)),n__isLNat(activate(V2)))
    30: natsFrom(N) -> U41(isNatural(N),N)
    31: sel(N,XS) -> U51(and(isNatural(N),n__isLNat(XS)),N,XS)
    32: snd(pair(X,Y)) -> U61(and(isLNat(X),n__isLNat(Y)),Y)
    33: splitAt(0(),XS) -> U71(isLNat(XS),XS)
    34: splitAt(s(N),cons(X,XS)) -> U81(and(isNatural(N),n__and(n__isNatural(X),n__isLNat(activate(XS)))),N,X,activate(XS))
    35: tail(cons(N,XS)) -> U91(and(isNatural(N),n__isLNat(activate(XS))),activate(XS))
    36: take(N,XS) -> U101(and(isNatural(N),n__isLNat(XS)),N,XS)
    37: natsFrom(X) -> n__natsFrom(X)
    38: s(X) -> n__s(X)
    39: isLNat(X) -> n__isLNat(X)
    40: nil() -> n__nil()
    41: afterNth(X1,X2) -> n__afterNth(X1,X2)
    42: cons(X1,X2) -> n__cons(X1,X2)
    43: fst(X) -> n__fst(X)
    44: snd(X) -> n__snd(X)
    45: tail(X) -> n__tail(X)
    46: take(X1,X2) -> n__take(X1,X2)
    47: 0() -> n__0()
    48: head(X) -> n__head(X)
    49: sel(X1,X2) -> n__sel(X1,X2)
    50: pair(X1,X2) -> n__pair(X1,X2)
    51: splitAt(X1,X2) -> n__splitAt(X1,X2)
    52: and(X1,X2) -> n__and(X1,X2)
    53: isNatural(X) -> n__isNatural(X)
    54: activate(n__natsFrom(X)) -> natsFrom(activate(X))
    55: activate(n__s(X)) -> s(activate(X))
    56: activate(n__isLNat(X)) -> isLNat(X)
    57: activate(n__nil()) -> nil()
    58: activate(n__afterNth(X1,X2)) -> afterNth(activate(X1),activate(X2))
    59: activate(n__cons(X1,X2)) -> cons(activate(X1),X2)
    60: activate(n__fst(X)) -> fst(activate(X))
    61: activate(n__snd(X)) -> snd(activate(X))
    62: activate(n__tail(X)) -> tail(activate(X))
    63: activate(n__take(X1,X2)) -> take(activate(X1),activate(X2))
    64: activate(n__0()) -> 0()
    65: activate(n__head(X)) -> head(activate(X))
    66: activate(n__sel(X1,X2)) -> sel(activate(X1),activate(X2))
    67: activate(n__pair(X1,X2)) -> pair(activate(X1),activate(X2))
    68: activate(n__splitAt(X1,X2)) -> splitAt(activate(X1),activate(X2))
    69: activate(n__and(X1,X2)) -> and(activate(X1),X2)
    70: activate(n__isNatural(X)) -> isNatural(X)
    71: activate(X) -> X
Number of strict rules: 71
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #U11(tt(),N,XS) -> #snd(splitAt(activate(N),activate(XS)))
   #2: #U11(tt(),N,XS) -> #splitAt(activate(N),activate(XS))
   #3: #U11(tt(),N,XS) -> #activate(N)
   #4: #U11(tt(),N,XS) -> #activate(XS)
   #5: #isPLNat(n__splitAt(V1,V2)) -> #and(isNatural(activate(V1)),n__isLNat(activate(V2)))
   #6: #isPLNat(n__splitAt(V1,V2)) -> #isNatural(activate(V1))
   #7: #isPLNat(n__splitAt(V1,V2)) -> #activate(V1)
   #8: #isPLNat(n__splitAt(V1,V2)) -> #activate(V2)
   #9: #tail(cons(N,XS)) -> #U91(and(isNatural(N),n__isLNat(activate(XS))),activate(XS))
   #10: #tail(cons(N,XS)) -> #and(isNatural(N),n__isLNat(activate(XS)))
   #11: #tail(cons(N,XS)) -> #isNatural(N)
   #12: #tail(cons(N,XS)) -> #activate(XS)
   #13: #tail(cons(N,XS)) -> #activate(XS)
   #14: #activate(n__sel(X1,X2)) -> #sel(activate(X1),activate(X2))
   #15: #activate(n__sel(X1,X2)) -> #activate(X1)
   #16: #activate(n__sel(X1,X2)) -> #activate(X2)
   #17: #activate(n__afterNth(X1,X2)) -> #afterNth(activate(X1),activate(X2))
   #18: #activate(n__afterNth(X1,X2)) -> #activate(X1)
   #19: #activate(n__afterNth(X1,X2)) -> #activate(X2)
   #20: #activate(n__snd(X)) -> #snd(activate(X))
   #21: #activate(n__snd(X)) -> #activate(X)
   #22: #U51(tt(),N,XS) -> #head(afterNth(activate(N),activate(XS)))
   #23: #U51(tt(),N,XS) -> #afterNth(activate(N),activate(XS))
   #24: #U51(tt(),N,XS) -> #activate(N)
   #25: #U51(tt(),N,XS) -> #activate(XS)
   #26: #activate(n__cons(X1,X2)) -> #cons(activate(X1),X2)
   #27: #activate(n__cons(X1,X2)) -> #activate(X1)
   #28: #activate(n__s(X)) -> #s(activate(X))
   #29: #activate(n__s(X)) -> #activate(X)
   #30: #activate(n__pair(X1,X2)) -> #pair(activate(X1),activate(X2))
   #31: #activate(n__pair(X1,X2)) -> #activate(X1)
   #32: #activate(n__pair(X1,X2)) -> #activate(X2)
   #33: #and(tt(),X) -> #activate(X)
   #34: #U81(tt(),N,X,XS) -> #U82(splitAt(activate(N),activate(XS)),activate(X))
   #35: #U81(tt(),N,X,XS) -> #splitAt(activate(N),activate(XS))
   #36: #U81(tt(),N,X,XS) -> #activate(N)
   #37: #U81(tt(),N,X,XS) -> #activate(XS)
   #38: #U81(tt(),N,X,XS) -> #activate(X)
   #39: #U91(tt(),XS) -> #activate(XS)
   #40: #activate(n__nil()) -> #nil()
   #41: #activate(n__isNatural(X)) -> #isNatural(X)
   #42: #isLNat(n__take(V1,V2)) -> #and(isNatural(activate(V1)),n__isLNat(activate(V2)))
   #43: #isLNat(n__take(V1,V2)) -> #isNatural(activate(V1))
   #44: #isLNat(n__take(V1,V2)) -> #activate(V1)
   #45: #isLNat(n__take(V1,V2)) -> #activate(V2)
   #46: #activate(n__and(X1,X2)) -> #and(activate(X1),X2)
   #47: #activate(n__and(X1,X2)) -> #activate(X1)
   #48: #afterNth(N,XS) -> #U11(and(isNatural(N),n__isLNat(XS)),N,XS)
   #49: #afterNth(N,XS) -> #and(isNatural(N),n__isLNat(XS))
   #50: #afterNth(N,XS) -> #isNatural(N)
   #51: #sel(N,XS) -> #U51(and(isNatural(N),n__isLNat(XS)),N,XS)
   #52: #sel(N,XS) -> #and(isNatural(N),n__isLNat(XS))
   #53: #sel(N,XS) -> #isNatural(N)
   #54: #activate(n__isLNat(X)) -> #isLNat(X)
   #55: #fst(pair(X,Y)) -> #U21(and(isLNat(X),n__isLNat(Y)),X)
   #56: #fst(pair(X,Y)) -> #and(isLNat(X),n__isLNat(Y))
   #57: #fst(pair(X,Y)) -> #isLNat(X)
   #58: #activate(n__tail(X)) -> #tail(activate(X))
   #59: #activate(n__tail(X)) -> #activate(X)
   #60: #natsFrom(N) -> #U41(isNatural(N),N)
   #61: #natsFrom(N) -> #isNatural(N)
   #62: #isNatural(n__head(V1)) -> #isLNat(activate(V1))
   #63: #isNatural(n__head(V1)) -> #activate(V1)
   #64: #isLNat(n__natsFrom(V1)) -> #isNatural(activate(V1))
   #65: #isLNat(n__natsFrom(V1)) -> #activate(V1)
   #66: #U61(tt(),Y) -> #activate(Y)
   #67: #U82(pair(YS,ZS),X) -> #pair(cons(activate(X),YS),ZS)
   #68: #U82(pair(YS,ZS),X) -> #cons(activate(X),YS)
   #69: #U82(pair(YS,ZS),X) -> #activate(X)
   #70: #activate(n__0()) -> #0()
   #71: #splitAt(0(),XS) -> #U71(isLNat(XS),XS)
   #72: #splitAt(0(),XS) -> #isLNat(XS)
   #73: #U41(tt(),N) -> #cons(activate(N),n__natsFrom(n__s(activate(N))))
   #74: #U41(tt(),N) -> #activate(N)
   #75: #U41(tt(),N) -> #activate(N)
   #76: #activate(n__head(X)) -> #head(activate(X))
   #77: #activate(n__head(X)) -> #activate(X)
   #78: #isPLNat(n__pair(V1,V2)) -> #and(isLNat(activate(V1)),n__isLNat(activate(V2)))
   #79: #isPLNat(n__pair(V1,V2)) -> #isLNat(activate(V1))
   #80: #isPLNat(n__pair(V1,V2)) -> #activate(V1)
   #81: #isPLNat(n__pair(V1,V2)) -> #activate(V2)
   #82: #isLNat(n__tail(V1)) -> #isLNat(activate(V1))
   #83: #isLNat(n__tail(V1)) -> #activate(V1)
   #84: #splitAt(s(N),cons(X,XS)) -> #U81(and(isNatural(N),n__and(n__isNatural(X),n__isLNat(activate(XS)))),N,X,activate(XS))
   #85: #splitAt(s(N),cons(X,XS)) -> #and(isNatural(N),n__and(n__isNatural(X),n__isLNat(activate(XS))))
   #86: #splitAt(s(N),cons(X,XS)) -> #isNatural(N)
   #87: #splitAt(s(N),cons(X,XS)) -> #activate(XS)
   #88: #splitAt(s(N),cons(X,XS)) -> #activate(XS)
   #89: #isNatural(n__sel(V1,V2)) -> #and(isNatural(activate(V1)),n__isLNat(activate(V2)))
   #90: #isNatural(n__sel(V1,V2)) -> #isNatural(activate(V1))
   #91: #isNatural(n__sel(V1,V2)) -> #activate(V1)
   #92: #isNatural(n__sel(V1,V2)) -> #activate(V2)
   #93: #activate(n__fst(X)) -> #fst(activate(X))
   #94: #activate(n__fst(X)) -> #activate(X)
   #95: #isLNat(n__afterNth(V1,V2)) -> #and(isNatural(activate(V1)),n__isLNat(activate(V2)))
   #96: #isLNat(n__afterNth(V1,V2)) -> #isNatural(activate(V1))
   #97: #isLNat(n__afterNth(V1,V2)) -> #activate(V1)
   #98: #isLNat(n__afterNth(V1,V2)) -> #activate(V2)
   #99: #snd(pair(X,Y)) -> #U61(and(isLNat(X),n__isLNat(Y)),Y)
   #100: #snd(pair(X,Y)) -> #and(isLNat(X),n__isLNat(Y))
   #101: #snd(pair(X,Y)) -> #isLNat(X)
   #102: #isLNat(n__fst(V1)) -> #isPLNat(activate(V1))
   #103: #isLNat(n__fst(V1)) -> #activate(V1)
   #104: #activate(n__take(X1,X2)) -> #take(activate(X1),activate(X2))
   #105: #activate(n__take(X1,X2)) -> #activate(X1)
   #106: #activate(n__take(X1,X2)) -> #activate(X2)
   #107: #isNatural(n__s(V1)) -> #isNatural(activate(V1))
   #108: #isNatural(n__s(V1)) -> #activate(V1)
   #109: #activate(n__splitAt(X1,X2)) -> #splitAt(activate(X1),activate(X2))
   #110: #activate(n__splitAt(X1,X2)) -> #activate(X1)
   #111: #activate(n__splitAt(X1,X2)) -> #activate(X2)
   #112: #take(N,XS) -> #U101(and(isNatural(N),n__isLNat(XS)),N,XS)
   #113: #take(N,XS) -> #and(isNatural(N),n__isLNat(XS))
   #114: #take(N,XS) -> #isNatural(N)
   #115: #isLNat(n__snd(V1)) -> #isPLNat(activate(V1))
   #116: #isLNat(n__snd(V1)) -> #activate(V1)
   #117: #U21(tt(),X) -> #activate(X)
   #118: #U101(tt(),N,XS) -> #fst(splitAt(activate(N),activate(XS)))
   #119: #U101(tt(),N,XS) -> #splitAt(activate(N),activate(XS))
   #120: #U101(tt(),N,XS) -> #activate(N)
   #121: #U101(tt(),N,XS) -> #activate(XS)
   #122: #activate(n__natsFrom(X)) -> #natsFrom(activate(X))
   #123: #activate(n__natsFrom(X)) -> #activate(X)
   #124: #U71(tt(),XS) -> #pair(nil(),activate(XS))
   #125: #U71(tt(),XS) -> #nil()
   #126: #U71(tt(),XS) -> #activate(XS)
   #127: #head(cons(N,XS)) -> #U31(and(isNatural(N),n__isLNat(activate(XS))),N)
   #128: #head(cons(N,XS)) -> #and(isNatural(N),n__isLNat(activate(XS)))
   #129: #head(cons(N,XS)) -> #isNatural(N)
   #130: #head(cons(N,XS)) -> #activate(XS)
   #131: #U31(tt(),N) -> #activate(N)
   #132: #isLNat(n__cons(V1,V2)) -> #and(isNatural(activate(V1)),n__isLNat(activate(V2)))
   #133: #isLNat(n__cons(V1,V2)) -> #isNatural(activate(V1))
   #134: #isLNat(n__cons(V1,V2)) -> #activate(V1)
   #135: #isLNat(n__cons(V1,V2)) -> #activate(V2)
Number of SCCs: 1, DPs: 125, edges: 2153
	SCC { #1..25 #27 #29 #31..39 #41..66 #69 #71 #72 #74..123 #126..135 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... succeeded.
   #0()	weight: 0
   U21(x1,x2)	weight: max{0, x2}
   U11(x1,x2,x3)	weight: max{0, x3, x2}
#cons(x1,x2)	weight: 0
     s(x1)	weight: x1
n__pair(x1,x2)	weight: max{x2, x1}
#take(x1,x2)	weight: max{x2, x1}
isPLNat(x1)	weight: x1
   U91(x1,x2)	weight: max{0, x2}
#U101(x1,x2,x3)	weight: max{0, x3, x2}
activate(x1)	weight: x1
n__isLNat(x1)	weight: x1
 #U82(x1,x2)	weight: max{0, x2}
  take(x1,x2)	weight: max{x2, x1}
   U71(x1,x2)	weight: max{0, x2}
 #U81(x1,x2,x3,x4)	weight: max{0, x4, x3, x2}
   and(x1,x2)	weight: max{x2, x1}
  U101(x1,x2,x3)	weight: max{x3, x2, x1}
  pair(x1,x2)	weight: max{x2, x1}
   fst(x1)	weight: x1
#activate(x1)	weight: x1
natsFrom(x1)	weight: x1
#head(x1)	weight: x1
splitAt(x1,x2)	weight: max{x2, x1}
 #fst(x1)	weight: x1
n__nil()	weight: 0
n__natsFrom(x1)	weight: x1
isNatural(x1)	weight: x1
n__snd(x1)	weight: x1
  n__s(x1)	weight: x1
n__splitAt(x1,x2)	weight: max{x2, x1}
  tail(x1)	weight: x1
     0()	weight: (/ 1 4)
n__take(x1,x2)	weight: max{x2, x1}
 #sel(x1,x2)	weight: max{x2, (/ 1 4) + x1}
#isLNat(x1)	weight: x1
   sel(x1,x2)	weight: max{x2, (/ 1 2) + x1}
   #s(x1)	weight: 0
afterNth(x1,x2)	weight: max{x2, x1}
n__cons(x1,x2)	weight: max{x2, x1}
#isPLNat(x1)	weight: x1
   nil()	weight: 0
isLNat(x1)	weight: x1
n__sel(x1,x2)	weight: max{x2, (/ 1 2) + x1}
#tail(x1)	weight: x1
#splitAt(x1,x2)	weight: max{x2, x1}
 #nil()	weight: 0
n__tail(x1)	weight: x1
#afterNth(x1,x2)	weight: max{x2, x1}
n__isNatural(x1)	weight: x1
  n__0()	weight: (/ 1 4)
n__afterNth(x1,x2)	weight: max{x2, x1}
   U61(x1,x2)	weight: max{0, x2}
 #U51(x1,x2,x3)	weight: max{0, x3, (/ 1 4) + x2}
n__fst(x1)	weight: x1
 #U11(x1,x2,x3)	weight: max{0, x3, x2}
   U31(x1,x2)	weight: max{0, x2}
  head(x1)	weight: x1
 #snd(x1)	weight: x1
 #U41(x1,x2)	weight: max{0, x2}
  cons(x1,x2)	weight: max{x2, x1}
#natsFrom(x1)	weight: x1
   snd(x1)	weight: x1
 #U21(x1,x2)	weight: max{0, x2}
   U81(x1,x2,x3,x4)	weight: max{0, x4, x3, x2}
   U82(x1,x2)	weight: max{x2, x1}
    tt()	weight: 0
n__and(x1,x2)	weight: max{x2, x1}
 #U71(x1,x2)	weight: max{0, x2}
#isNatural(x1)	weight: x1
#pair(x1,x2)	weight: 0
n__head(x1)	weight: x1
   U51(x1,x2,x3)	weight: max{x3, (/ 1 4) + x2, x1}
   U41(x1,x2)	weight: max{0, x2}
 #U31(x1,x2)	weight: max{0, x2}
 #and(x1,x2)	weight: max{0, x2}
 #U91(x1,x2)	weight: max{0, x2}
 #U61(x1,x2)	weight: max{0, x2}
    Usable rules: { 1..71 }
    Removed DPs: #15 #24 #53 #90 #91
Number of SCCs: 1, DPs: 120, edges: 1963
	SCC { #1..14 #16..23 #25 #27 #29 #31..39 #41..52 #54..66 #69 #71 #72 #74..89 #92..123 #126..135 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... succeeded.
   #0()	weight: 0
   U21(x1,x2)	weight: max{0, x2}
   U11(x1,x2,x3)	weight: max{0, (/ 13 32) + x3, (/ 11 32) + x2}
#cons(x1,x2)	weight: 0
     s(x1)	weight: x1
n__pair(x1,x2)	weight: max{(/ 5 16) + x2, (/ 11 32) + x1}
#take(x1,x2)	weight: max{(/ 17 32) + x2, (/ 7 16) + x1}
isPLNat(x1)	weight: x1
   U91(x1,x2)	weight: max{0, x2}
#U101(x1,x2,x3)	weight: max{(/ 13 32) + x3, (/ 13 32) + x2, (/ 13 32) + x1}
activate(x1)	weight: x1
n__isLNat(x1)	weight: (/ 3 32) + x1
 #U82(x1,x2)	weight: max{0, (/ 7 32) + x2}
  take(x1,x2)	weight: max{(/ 13 32) + x2, (/ 3 8) + x1}
   U71(x1,x2)	weight: max{(/ 3 8) + x2, (/ 7 32) + x1}
 #U81(x1,x2,x3,x4)	weight: max{0, (/ 3 8) + x4, (/ 9 32) + x3, (/ 1 4) + x2}
   and(x1,x2)	weight: max{x2, x1}
  U101(x1,x2,x3)	weight: max{(/ 13 32) + x3, (/ 1 4) + x2, x1}
  pair(x1,x2)	weight: max{(/ 5 16) + x2, (/ 11 32) + x1}
   fst(x1)	weight: (/ 1 32) + x1
#activate(x1)	weight: (/ 3 16) + x1
natsFrom(x1)	weight: (/ 1 8) + x1
#head(x1)	weight: (/ 5 16) + x1
splitAt(x1,x2)	weight: max{(/ 3 8) + x2, (/ 7 32) + x1}
 #fst(x1)	weight: x1
n__nil()	weight: (/ 1 32)
n__natsFrom(x1)	weight: (/ 1 8) + x1
isNatural(x1)	weight: x1
n__snd(x1)	weight: (/ 1 32) + x1
  n__s(x1)	weight: x1
n__splitAt(x1,x2)	weight: max{(/ 3 8) + x2, (/ 7 32) + x1}
  tail(x1)	weight: (/ 1 8) + x1
     0()	weight: (/ 1 16)
n__take(x1,x2)	weight: max{(/ 13 32) + x2, (/ 3 8) + x1}
 #sel(x1,x2)	weight: max{(/ 27 32) + x2, (/ 25 32) + x1}
#isLNat(x1)	weight: (/ 9 32) + x1
   sel(x1,x2)	weight: max{(/ 11 16) + x2, (/ 11 16) + x1}
   #s(x1)	weight: 0
afterNth(x1,x2)	weight: max{(/ 13 32) + x2, (/ 11 32) + x1}
n__cons(x1,x2)	weight: max{x2, x1}
#isPLNat(x1)	weight: (/ 3 32) + x1
   nil()	weight: (/ 1 32)
isLNat(x1)	weight: (/ 3 32) + x1
n__sel(x1,x2)	weight: max{(/ 11 16) + x2, (/ 11 16) + x1}
#tail(x1)	weight: (/ 9 32) + x1
#splitAt(x1,x2)	weight: max{(/ 3 8) + x2, (/ 1 4) + x1}
 #nil()	weight: 0
n__tail(x1)	weight: (/ 1 8) + x1
#afterNth(x1,x2)	weight: max{(/ 1 2) + x2, (/ 7 16) + x1}
n__isNatural(x1)	weight: x1
  n__0()	weight: (/ 1 16)
n__afterNth(x1,x2)	weight: max{(/ 13 32) + x2, (/ 11 32) + x1}
   U61(x1,x2)	weight: max{0, x2}
 #U51(x1,x2,x3)	weight: max{(/ 3 4) + x3, (/ 3 4) + x2, (/ 23 32) + x1}
n__fst(x1)	weight: (/ 1 32) + x1
 #U11(x1,x2,x3)	weight: max{(/ 13 32) + x3, (/ 13 32) + x2, (/ 3 8) + x1}
   U31(x1,x2)	weight: max{0, x2}
  head(x1)	weight: (/ 5 32) + x1
 #snd(x1)	weight: x1
 #U41(x1,x2)	weight: max{(/ 7 32) + x2, (/ 5 32) + x1}
  cons(x1,x2)	weight: max{x2, x1}
#natsFrom(x1)	weight: (/ 1 4) + x1
   snd(x1)	weight: (/ 1 32) + x1
 #U21(x1,x2)	weight: max{0, (/ 7 32) + x2}
   U81(x1,x2,x3,x4)	weight: max{(/ 3 8) + x4, (/ 3 8) + x3, (/ 7 32) + x2, (/ 7 32) + x1}
   U82(x1,x2)	weight: max{(/ 11 32) + x2, x1}
    tt()	weight: (/ 1 16)
n__and(x1,x2)	weight: max{x2, x1}
 #U71(x1,x2)	weight: max{(/ 7 32) + x2, (/ 1 4) + x1}
#isNatural(x1)	weight: (/ 3 16) + x1
#pair(x1,x2)	weight: 0
n__head(x1)	weight: (/ 5 32) + x1
   U51(x1,x2,x3)	weight: max{0, (/ 9 16) + x3, (/ 11 16) + x2}
   U41(x1,x2)	weight: max{(/ 1 8) + x2, (/ 1 32) + x1}
 #U31(x1,x2)	weight: max{0, (/ 7 32) + x2}
 #and(x1,x2)	weight: max{0, (/ 3 16) + x2}
 #U91(x1,x2)	weight: max{(/ 7 32) + x2, (/ 5 32) + x1}
 #U61(x1,x2)	weight: max{(/ 9 32) + x2, (/ 3 16) + x1}
    Usable rules: { 1..71 }
    Removed DPs: #1..9 #11..14 #16..23 #25 #31 #32 #34 #36..39 #42..45 #48..52 #55..66 #69 #71 #72 #74..83 #85..89 #92..106 #109..123 #126..131 #133..135
Number of SCCs: 2, DPs: 12, edges: 39
	SCC { #35 #84 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... succeeded.
   #0()	weight: 0	status: []	precedence above:
   U21(x1,x2)	weight: max{0, (/ 7 32) + x2}	status: []	precedence above:
   U11(x1,x2,x3)	weight: max{(/ 7 16) + x3, (/ 3 8) + x2, (/ 1 4) + x1}	status: [x1,x2]	precedence above: n__snd U61 snd
#cons(x1,x2)	weight: x2	status: [x2]	precedence above:
     s(x1)	weight: x1	status: [x1]	precedence above: activate and n__s n__cons U31 head cons n__and n__head
n__pair(x1,x2)	weight: max{(/ 3 32) + x2, (/ 5 32) + x1}	status: [x1]	precedence above: activate and pair n__cons U31 head cons n__and n__head
#take(x1,x2)	weight: (/ 1 32) + x2 + x1	status: [x2,x1]	precedence above:
isPLNat(x1)	weight: (/ 1 16)	status: []	precedence above: n__isLNat isNatural isLNat n__isNatural tt
   U91(x1,x2)	weight: max{0, (/ 1 32) + x2}	status: []	precedence above:
#U101(x1,x2,x3)	weight: x1	status: [x1]	precedence above:
activate(x1)	weight: x1	status: x1
n__isLNat(x1)	weight: (/ 1 16)	status: []	precedence above: isPLNat isNatural isLNat n__isNatural tt
 #U82(x1,x2)	weight: (/ 1 32) + x2 + x1	status: []	precedence above:
  take(x1,x2)	weight: (/ 7 16) + x2 + x1	status: [x1,x2]	precedence above: U21 U101 fst n__take n__fst
   U71(x1,x2)	weight: max{(/ 3 32) + x2, (/ 5 32) + x1}	status: [x1]	precedence above: n__pair activate and pair n__nil n__cons nil U31 head cons n__and n__head
 #U81(x1,x2,x3,x4)	weight: max{0, (/ 3 32) + x2, (/ 1 32) + x1}	status: [x2,x1]	precedence above: U21 activate fst n__cons #splitAt n__fst U31 head cons n__head
   and(x1,x2)	weight: max{0, x2}	status: x2
  U101(x1,x2,x3)	weight: max{(/ 13 32) + x3, (/ 13 32) + x2, (/ 11 32) + x1}	status: [x2,x3]	precedence above: U21 fst n__fst
  pair(x1,x2)	weight: max{(/ 3 32) + x2, (/ 5 32) + x1}	status: [x1]	precedence above: n__pair activate and n__cons U31 head cons n__and n__head
   fst(x1)	weight: (/ 3 32) + x1	status: []	precedence above: U21 n__fst
#activate(x1)	weight: x1	status: []	precedence above:
natsFrom(x1)	weight: (/ 3 32) + x1	status: []	precedence above: isPLNat n__isLNat n__natsFrom isNatural n__cons isLNat n__isNatural cons tt U41
#head(x1)	weight: x1	status: []	precedence above:
splitAt(x1,x2)	weight: max{(/ 1 4) + x2, (/ 9 32) + x1}	status: []	precedence above: n__pair isPLNat activate n__isLNat U71 and pair n__nil isNatural n__splitAt n__cons nil isLNat n__isNatural U31 head cons U81 U82 tt n__and n__head
 #fst(x1)	weight: x1	status: []	precedence above:
n__nil()	weight: (/ 1 32)	status: []	precedence above: nil
n__natsFrom(x1)	weight: (/ 3 32) + x1	status: []	precedence above: isPLNat n__isLNat natsFrom isNatural n__cons isLNat n__isNatural cons tt U41
isNatural(x1)	weight: (/ 1 16)	status: []	precedence above: isPLNat n__isLNat isLNat n__isNatural tt
n__snd(x1)	weight: (/ 3 32) + x1	status: []	precedence above: U61 snd
  n__s(x1)	weight: x1	status: [x1]	precedence above: s activate and n__cons U31 head cons n__and n__head
n__splitAt(x1,x2)	weight: max{(/ 1 4) + x2, (/ 9 32) + x1}	status: []	precedence above: n__pair isPLNat activate n__isLNat U71 and pair splitAt n__nil isNatural n__cons nil isLNat n__isNatural U31 head cons U81 U82 tt n__and n__head
  tail(x1)	weight: (/ 3 32) + x1	status: []	precedence above: U91 n__tail
     0()	weight: (/ 1 8)	status: []	precedence above: n__0
n__take(x1,x2)	weight: (/ 7 16) + x2 + x1	status: [x1,x2]	precedence above: U21 take U101 fst n__fst
 #sel(x1,x2)	weight: (/ 1 32) + x2 + x1	status: [x2,x1]	precedence above:
#isLNat(x1)	weight: (/ 1 32)	status: []	precedence above:
   sel(x1,x2)	weight: (/ 5 8) + x2 + x1	status: []	precedence above: isPLNat activate n__isLNat and isNatural n__cons isLNat n__sel n__isNatural U31 head cons tt n__and n__head U51
   #s(x1)	weight: x1	status: []	precedence above:
afterNth(x1,x2)	weight: max{(/ 15 32) + x2, (/ 13 32) + x1}	status: []	precedence above: U11 n__snd n__afterNth U61 snd
n__cons(x1,x2)	weight: max{x2, x1}	status: []	precedence above: cons
#isPLNat(x1)	weight: x1	status: []	precedence above:
   nil()	weight: (/ 1 32)	status: []	precedence above: n__nil
isLNat(x1)	weight: (/ 1 16)	status: []	precedence above: isPLNat n__isLNat isNatural n__isNatural tt
n__sel(x1,x2)	weight: (/ 5 8) + x2 + x1	status: []	precedence above: isPLNat activate n__isLNat and isNatural sel n__cons isLNat n__isNatural U31 head cons tt n__and n__head U51
#tail(x1)	weight: x1	status: []	precedence above:
#splitAt(x1,x2)	weight: max{0, (/ 3 32) + x1}	status: [x1]	precedence above: U21 activate #U81 fst n__cons n__fst U31 head cons n__head
 #nil()	weight: 0	status: []	precedence above:
n__tail(x1)	weight: (/ 3 32) + x1	status: []	precedence above: U91 tail
#afterNth(x1,x2)	weight: (/ 1 32) + x2 + x1	status: [x2,x1]	precedence above:
n__isNatural(x1)	weight: (/ 1 16)	status: []	precedence above: isPLNat n__isLNat isNatural isLNat tt
  n__0()	weight: (/ 1 8)	status: []	precedence above: 0
n__afterNth(x1,x2)	weight: max{(/ 15 32) + x2, (/ 13 32) + x1}	status: []	precedence above: U11 n__snd afterNth U61 snd
   U61(x1,x2)	weight: max{(/ 1 32) + x2, x1}	status: []	precedence above:
 #U51(x1,x2,x3)	weight: (/ 1 32) + x3 + x2	status: [x2,x3]	precedence above:
n__fst(x1)	weight: (/ 3 32) + x1	status: []	precedence above: U21 fst
 #U11(x1,x2,x3)	weight: x3	status: [x3]	precedence above:
   U31(x1,x2)	weight: max{(/ 1 32) + x2, x1}	status: [x1,x2]	precedence above:
  head(x1)	weight: (/ 3 32) + x1	status: []	precedence above: U31 n__head
 #snd(x1)	weight: x1	status: []	precedence above:
 #U41(x1,x2)	weight: x2 + x1	status: []	precedence above:
  cons(x1,x2)	weight: max{x2, x1}	status: []	precedence above: n__cons
#natsFrom(x1)	weight: (/ 1 32)	status: []	precedence above:
   snd(x1)	weight: (/ 3 32) + x1	status: []	precedence above: n__snd U61
 #U21(x1,x2)	weight: (/ 1 32) + x1	status: [x1]	precedence above:
   U81(x1,x2,x3,x4)	weight: max{(/ 1 4) + x4, (/ 1 4) + x3, (/ 9 32) + x2, (/ 5 32) + x1}	status: []	precedence above: n__pair isPLNat activate n__isLNat and pair isNatural n__cons isLNat n__isNatural U31 head cons U82 tt n__and n__head
   U82(x1,x2)	weight: max{(/ 3 16) + x2, x1}	status: []	precedence above: n__pair activate and pair n__cons U31 head cons n__and n__head
    tt()	weight: (/ 1 16)	status: []	precedence above:
n__and(x1,x2)	weight: max{0, x2}	status: x2
 #U71(x1,x2)	weight: (/ 1 32) + x2	status: [x2]	precedence above:
#isNatural(x1)	weight: x1	status: []	precedence above:
#pair(x1,x2)	weight: x1	status: [x1]	precedence above:
n__head(x1)	weight: (/ 3 32) + x1	status: []	precedence above: U31 head
   U51(x1,x2,x3)	weight: max{0, (/ 19 32) + x3, (/ 19 32) + x2}	status: []	precedence above: U31 head n__head
   U41(x1,x2)	weight: max{(/ 3 32) + x2, (/ 1 32) + x1}	status: []	precedence above: isPLNat n__isLNat isNatural n__cons isLNat n__isNatural cons tt
 #U31(x1,x2)	weight: (/ 1 32) + x2 + x1	status: [x1,x2]	precedence above:
 #and(x1,x2)	weight: max{0, (/ 1 32) + x2}	status: [x2]	precedence above:
 #U91(x1,x2)	weight: (/ 1 32) + x2 + x1	status: []	precedence above:
 #U61(x1,x2)	weight: (/ 1 32) + x2 + x1	status: [x1,x2]	precedence above:
    Usable rules: { 1..71 }
    Removed DPs: #35 #84
Number of SCCs: 1, DPs: 10, edges: 37
	SCC { #27 #29 #33 #41 #46 #47 #54 #107 #108 #132 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... succeeded.
   #0()	weight: 0
   U21(x1,x2)	weight: max{0, x2}
   U11(x1,x2,x3)	weight: max{0, (/ 1 32) + x3, x2}
#cons(x1,x2)	weight: 0
     s(x1)	weight: x1
n__pair(x1,x2)	weight: max{x2, x1}
#take(x1,x2)	weight: 0
isPLNat(x1)	weight: x1
   U91(x1,x2)	weight: max{0, x2}
#U101(x1,x2,x3)	weight: 0
activate(x1)	weight: x1
n__isLNat(x1)	weight: x1
 #U82(x1,x2)	weight: 0
  take(x1,x2)	weight: max{(/ 1 32) + x2, x1}
   U71(x1,x2)	weight: max{0, (/ 1 32) + x2}
 #U81(x1,x2,x3,x4)	weight: 0
   and(x1,x2)	weight: max{x2, x1}
  U101(x1,x2,x3)	weight: max{0, (/ 1 32) + x3, x2}
  pair(x1,x2)	weight: max{x2, x1}
   fst(x1)	weight: x1
#activate(x1)	weight: x1
natsFrom(x1)	weight: (/ 1 32) + x1
#head(x1)	weight: (/ 5 16)
splitAt(x1,x2)	weight: max{(/ 1 32) + x2, x1}
 #fst(x1)	weight: 0
n__nil()	weight: 0
n__natsFrom(x1)	weight: (/ 1 32) + x1
isNatural(x1)	weight: x1
n__snd(x1)	weight: x1
  n__s(x1)	weight: x1
n__splitAt(x1,x2)	weight: max{(/ 1 32) + x2, x1}
  tail(x1)	weight: (/ 1 8) + x1
     0()	weight: 0
n__take(x1,x2)	weight: max{(/ 1 32) + x2, x1}
 #sel(x1,x2)	weight: 0
#isLNat(x1)	weight: x1
   sel(x1,x2)	weight: max{(/ 1 32) + x2, (/ 1 32) + x1}
   #s(x1)	weight: 0
afterNth(x1,x2)	weight: max{(/ 1 32) + x2, (/ 1 32) + x1}
n__cons(x1,x2)	weight: max{x2, (/ 1 32) + x1}
#isPLNat(x1)	weight: (/ 3 32)
   nil()	weight: 0
isLNat(x1)	weight: x1
n__sel(x1,x2)	weight: max{(/ 1 32) + x2, (/ 1 32) + x1}
#tail(x1)	weight: (/ 9 32)
#splitAt(x1,x2)	weight: 0
 #nil()	weight: 0
n__tail(x1)	weight: (/ 1 8) + x1
#afterNth(x1,x2)	weight: 0
n__isNatural(x1)	weight: x1
  n__0()	weight: 0
n__afterNth(x1,x2)	weight: max{(/ 1 32) + x2, (/ 1 32) + x1}
   U61(x1,x2)	weight: max{0, x2}
 #U51(x1,x2,x3)	weight: 0
n__fst(x1)	weight: x1
 #U11(x1,x2,x3)	weight: 0
   U31(x1,x2)	weight: max{0, x2}
  head(x1)	weight: x1
 #snd(x1)	weight: 0
 #U41(x1,x2)	weight: 0
  cons(x1,x2)	weight: max{x2, (/ 1 32) + x1}
#natsFrom(x1)	weight: (/ 1 4)
   snd(x1)	weight: x1
 #U21(x1,x2)	weight: 0
   U81(x1,x2,x3,x4)	weight: max{0, (/ 1 32) + x4, (/ 1 32) + x3, x2}
   U82(x1,x2)	weight: max{(/ 1 32) + x2, x1}
    tt()	weight: 0
n__and(x1,x2)	weight: max{x2, x1}
 #U71(x1,x2)	weight: 0
#isNatural(x1)	weight: x1
#pair(x1,x2)	weight: 0
n__head(x1)	weight: x1
   U51(x1,x2,x3)	weight: max{(/ 1 32) + x3, (/ 1 32) + x2, (/ 1 32) + x1}
   U41(x1,x2)	weight: max{(/ 1 32) + x2, (/ 1 32) + x1}
 #U31(x1,x2)	weight: 0
 #and(x1,x2)	weight: max{0, x2}
 #U91(x1,x2)	weight: 0
 #U61(x1,x2)	weight: 0
    Usable rules: { 1..71 }
    Removed DPs: #27
Number of SCCs: 1, DPs: 9, edges: 27
	SCC { #29 #33 #41 #46 #47 #54 #107 #108 #132 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... succeeded.
   #0()	weight: 0
   U21(x1,x2)	weight: max{0, x2}
   U11(x1,x2,x3)	weight: max{0, (/ 5 32) + x3, (/ 1 16) + x2}
#cons(x1,x2)	weight: 0
     s(x1)	weight: x1
n__pair(x1,x2)	weight: max{(/ 1 16) + x2, (/ 3 32) + x1}
#take(x1,x2)	weight: 0
isPLNat(x1)	weight: x1
   U91(x1,x2)	weight: max{0, x2}
#U101(x1,x2,x3)	weight: 0
activate(x1)	weight: x1
n__isLNat(x1)	weight: (/ 1 16) + x1
 #U82(x1,x2)	weight: 0
  take(x1,x2)	weight: max{(/ 5 32) + x2, (/ 1 16) + x1}
   U71(x1,x2)	weight: max{(/ 1 16) + x2, (/ 3 32) + x1}
 #U81(x1,x2,x3,x4)	weight: 0
   and(x1,x2)	weight: max{x2, (/ 1 32) + x1}
  U101(x1,x2,x3)	weight: max{0, (/ 5 32) + x3, (/ 1 16) + x2}
  pair(x1,x2)	weight: max{(/ 1 16) + x2, (/ 3 32) + x1}
   fst(x1)	weight: x1
#activate(x1)	weight: x1
natsFrom(x1)	weight: x1
#head(x1)	weight: (/ 5 16)
splitAt(x1,x2)	weight: max{(/ 5 32) + x2, (/ 1 16) + x1}
 #fst(x1)	weight: 0
n__nil()	weight: 0
n__natsFrom(x1)	weight: x1
isNatural(x1)	weight: (/ 1 32) + x1
n__snd(x1)	weight: x1
  n__s(x1)	weight: x1
n__splitAt(x1,x2)	weight: max{(/ 5 32) + x2, (/ 1 16) + x1}
  tail(x1)	weight: (/ 1 8) + x1
     0()	weight: 0
n__take(x1,x2)	weight: max{(/ 5 32) + x2, (/ 1 16) + x1}
 #sel(x1,x2)	weight: 0
#isLNat(x1)	weight: (/ 1 16) + x1
   sel(x1,x2)	weight: max{(/ 3 16) + x2, (/ 3 32) + x1}
   #s(x1)	weight: 0
afterNth(x1,x2)	weight: max{(/ 5 32) + x2, (/ 1 16) + x1}
n__cons(x1,x2)	weight: max{x2, x1}
#isPLNat(x1)	weight: (/ 3 32)
   nil()	weight: 0
isLNat(x1)	weight: (/ 1 16) + x1
n__sel(x1,x2)	weight: max{(/ 3 16) + x2, (/ 3 32) + x1}
#tail(x1)	weight: (/ 9 32)
#splitAt(x1,x2)	weight: 0
 #nil()	weight: 0
n__tail(x1)	weight: (/ 1 8) + x1
#afterNth(x1,x2)	weight: 0
n__isNatural(x1)	weight: (/ 1 32) + x1
  n__0()	weight: 0
n__afterNth(x1,x2)	weight: max{(/ 5 32) + x2, (/ 1 16) + x1}
   U61(x1,x2)	weight: max{0, x2}
 #U51(x1,x2,x3)	weight: 0
n__fst(x1)	weight: x1
 #U11(x1,x2,x3)	weight: 0
   U31(x1,x2)	weight: max{0, x2}
  head(x1)	weight: (/ 1 32) + x1
 #snd(x1)	weight: 0
 #U41(x1,x2)	weight: 0
  cons(x1,x2)	weight: max{x2, x1}
#natsFrom(x1)	weight: (/ 1 4)
   snd(x1)	weight: x1
 #U21(x1,x2)	weight: 0
   U81(x1,x2,x3,x4)	weight: max{0, (/ 5 32) + x4, (/ 3 32) + x3, (/ 1 16) + x2}
   U82(x1,x2)	weight: max{(/ 3 32) + x2, x1}
    tt()	weight: 0
n__and(x1,x2)	weight: max{x2, (/ 1 32) + x1}
 #U71(x1,x2)	weight: 0
#isNatural(x1)	weight: x1
#pair(x1,x2)	weight: 0
n__head(x1)	weight: (/ 1 32) + x1
   U51(x1,x2,x3)	weight: max{(/ 3 16) + x3, (/ 3 32) + x2, (/ 1 32) + x1}
   U41(x1,x2)	weight: max{0, x2}
 #U31(x1,x2)	weight: 0
 #and(x1,x2)	weight: max{0, x2}
 #U91(x1,x2)	weight: 0
 #U61(x1,x2)	weight: 0
    Usable rules: { 1..71 }
    Removed DPs: #41 #47
Number of SCCs: 2, DPs: 6, edges: 10
	SCC { #107 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... succeeded.
   #0()	weight: 0	status: []	precedence above:
   U21(x1,x2)	weight: max{0, (/ 7 32) + x2}	status: []	precedence above:
   U11(x1,x2,x3)	weight: max{(/ 7 16) + x3, (/ 3 8) + x2, (/ 1 4) + x1}	status: [x1,x2]	precedence above: n__snd U61 snd
#cons(x1,x2)	weight: x2	status: [x2]	precedence above:
     s(x1)	weight: x1	status: [x1]	precedence above: activate and n__s n__cons U31 head cons n__and n__head
n__pair(x1,x2)	weight: max{(/ 3 32) + x2, (/ 5 32) + x1}	status: [x1]	precedence above: activate and pair n__cons U31 head cons n__and n__head
#take(x1,x2)	weight: (/ 1 32) + x2 + x1	status: [x2,x1]	precedence above:
isPLNat(x1)	weight: (/ 1 16)	status: []	precedence above: n__isLNat isNatural isLNat n__isNatural tt
   U91(x1,x2)	weight: max{0, (/ 1 32) + x2}	status: []	precedence above:
#U101(x1,x2,x3)	weight: x1	status: [x1]	precedence above:
activate(x1)	weight: x1	status: x1
n__isLNat(x1)	weight: (/ 1 16)	status: []	precedence above: isPLNat isNatural isLNat n__isNatural tt
 #U82(x1,x2)	weight: (/ 1 32) + x2 + x1	status: []	precedence above:
  take(x1,x2)	weight: (/ 7 16) + x2 + x1	status: [x1,x2]	precedence above: U21 U101 fst n__take n__fst
   U71(x1,x2)	weight: max{(/ 3 32) + x2, (/ 5 32) + x1}	status: [x1]	precedence above: n__pair activate and pair n__nil n__cons nil U31 head cons n__and n__head
 #U81(x1,x2,x3,x4)	weight: max{0, (/ 3 32) + x2, (/ 1 32) + x1}	status: [x2,x1]	precedence above: U21 activate fst n__cons #splitAt n__fst U31 head cons n__head
   and(x1,x2)	weight: max{0, x2}	status: x2
  U101(x1,x2,x3)	weight: max{(/ 13 32) + x3, (/ 13 32) + x2, (/ 11 32) + x1}	status: [x2,x3]	precedence above: U21 fst n__fst
  pair(x1,x2)	weight: max{(/ 3 32) + x2, (/ 5 32) + x1}	status: [x1]	precedence above: n__pair activate and n__cons U31 head cons n__and n__head
   fst(x1)	weight: (/ 3 32) + x1	status: []	precedence above: U21 n__fst
#activate(x1)	weight: x1	status: []	precedence above:
natsFrom(x1)	weight: (/ 3 32) + x1	status: []	precedence above: isPLNat n__isLNat n__natsFrom isNatural n__cons isLNat n__isNatural cons tt U41
#head(x1)	weight: x1	status: []	precedence above:
splitAt(x1,x2)	weight: max{(/ 1 4) + x2, (/ 9 32) + x1}	status: []	precedence above: n__pair isPLNat activate n__isLNat U71 and pair n__nil isNatural n__splitAt n__cons nil isLNat n__isNatural U31 head cons U81 U82 tt n__and n__head
 #fst(x1)	weight: x1	status: []	precedence above:
n__nil()	weight: (/ 1 32)	status: []	precedence above: nil
n__natsFrom(x1)	weight: (/ 3 32) + x1	status: []	precedence above: isPLNat n__isLNat natsFrom isNatural n__cons isLNat n__isNatural cons tt U41
isNatural(x1)	weight: (/ 1 16)	status: []	precedence above: isPLNat n__isLNat isLNat n__isNatural tt
n__snd(x1)	weight: (/ 3 32) + x1	status: []	precedence above: U61 snd
  n__s(x1)	weight: x1	status: [x1]	precedence above: s activate and n__cons U31 head cons n__and n__head
n__splitAt(x1,x2)	weight: max{(/ 1 4) + x2, (/ 9 32) + x1}	status: []	precedence above: n__pair isPLNat activate n__isLNat U71 and pair splitAt n__nil isNatural n__cons nil isLNat n__isNatural U31 head cons U81 U82 tt n__and n__head
  tail(x1)	weight: (/ 3 32) + x1	status: []	precedence above: U91 n__tail
     0()	weight: (/ 1 8)	status: []	precedence above: n__0
n__take(x1,x2)	weight: (/ 7 16) + x2 + x1	status: [x1,x2]	precedence above: U21 take U101 fst n__fst
 #sel(x1,x2)	weight: (/ 1 32) + x2 + x1	status: [x2,x1]	precedence above:
#isLNat(x1)	weight: (/ 1 32)	status: []	precedence above:
   sel(x1,x2)	weight: (/ 5 8) + x2 + x1	status: []	precedence above: isPLNat activate n__isLNat and isNatural n__cons isLNat n__sel n__isNatural U31 head cons tt n__and n__head U51
   #s(x1)	weight: x1	status: []	precedence above:
afterNth(x1,x2)	weight: max{(/ 15 32) + x2, (/ 13 32) + x1}	status: []	precedence above: U11 n__snd n__afterNth U61 snd
n__cons(x1,x2)	weight: max{x2, x1}	status: []	precedence above: cons
#isPLNat(x1)	weight: x1	status: []	precedence above:
   nil()	weight: (/ 1 32)	status: []	precedence above: n__nil
isLNat(x1)	weight: (/ 1 16)	status: []	precedence above: isPLNat n__isLNat isNatural n__isNatural tt
n__sel(x1,x2)	weight: (/ 5 8) + x2 + x1	status: []	precedence above: isPLNat activate n__isLNat and isNatural sel n__cons isLNat n__isNatural U31 head cons tt n__and n__head U51
#tail(x1)	weight: x1	status: []	precedence above:
#splitAt(x1,x2)	weight: max{0, (/ 3 32) + x1}	status: [x1]	precedence above: U21 activate #U81 fst n__cons n__fst U31 head cons n__head
 #nil()	weight: 0	status: []	precedence above:
n__tail(x1)	weight: (/ 3 32) + x1	status: []	precedence above: U91 tail
#afterNth(x1,x2)	weight: (/ 1 32) + x2 + x1	status: [x2,x1]	precedence above:
n__isNatural(x1)	weight: (/ 1 16)	status: []	precedence above: isPLNat n__isLNat isNatural isLNat tt
  n__0()	weight: (/ 1 8)	status: []	precedence above: 0
n__afterNth(x1,x2)	weight: max{(/ 15 32) + x2, (/ 13 32) + x1}	status: []	precedence above: U11 n__snd afterNth U61 snd
   U61(x1,x2)	weight: max{(/ 1 32) + x2, x1}	status: []	precedence above:
 #U51(x1,x2,x3)	weight: (/ 1 32) + x3 + x2	status: [x2,x3]	precedence above:
n__fst(x1)	weight: (/ 3 32) + x1	status: []	precedence above: U21 fst
 #U11(x1,x2,x3)	weight: x3	status: [x3]	precedence above:
   U31(x1,x2)	weight: max{(/ 1 32) + x2, x1}	status: [x1,x2]	precedence above:
  head(x1)	weight: (/ 3 32) + x1	status: []	precedence above: U31 n__head
 #snd(x1)	weight: x1	status: []	precedence above:
 #U41(x1,x2)	weight: x2 + x1	status: []	precedence above:
  cons(x1,x2)	weight: max{x2, x1}	status: []	precedence above: n__cons
#natsFrom(x1)	weight: (/ 1 32)	status: []	precedence above:
   snd(x1)	weight: (/ 3 32) + x1	status: []	precedence above: n__snd U61
 #U21(x1,x2)	weight: (/ 1 32) + x1	status: [x1]	precedence above:
   U81(x1,x2,x3,x4)	weight: max{(/ 1 4) + x4, (/ 1 4) + x3, (/ 9 32) + x2, (/ 5 32) + x1}	status: []	precedence above: n__pair isPLNat activate n__isLNat and pair isNatural n__cons isLNat n__isNatural U31 head cons U82 tt n__and n__head
   U82(x1,x2)	weight: max{(/ 3 16) + x2, x1}	status: []	precedence above: n__pair activate and pair n__cons U31 head cons n__and n__head
    tt()	weight: (/ 1 16)	status: []	precedence above:
n__and(x1,x2)	weight: max{0, x2}	status: x2
 #U71(x1,x2)	weight: (/ 1 32) + x2	status: [x2]	precedence above:
#isNatural(x1)	weight: x1	status: [x1]	precedence above:
#pair(x1,x2)	weight: x1	status: [x1]	precedence above:
n__head(x1)	weight: (/ 3 32) + x1	status: []	precedence above: U31 head
   U51(x1,x2,x3)	weight: max{0, (/ 19 32) + x3, (/ 19 32) + x2}	status: []	precedence above: U31 head n__head
   U41(x1,x2)	weight: max{(/ 3 32) + x2, (/ 1 32) + x1}	status: []	precedence above: isPLNat n__isLNat isNatural n__cons isLNat n__isNatural cons tt
 #U31(x1,x2)	weight: (/ 1 32) + x2 + x1	status: [x1,x2]	precedence above:
 #and(x1,x2)	weight: max{0, (/ 1 32) + x2}	status: [x2]	precedence above:
 #U91(x1,x2)	weight: (/ 1 32) + x2 + x1	status: []	precedence above:
 #U61(x1,x2)	weight: (/ 1 32) + x2 + x1	status: [x1,x2]	precedence above:
    Usable rules: { 1..71 }
    Removed DPs: #107
Number of SCCs: 1, DPs: 5, edges: 9
	SCC { #29 #33 #46 #54 #132 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
   #0()	weight: 0
   U21(x1,x2)	weight: (/ 1 2) + x1
   U11(x1,x2,x3)	weight: (/ 3 4) + x1 + x3
#cons(x1,x2)	weight: 0
     s(x1)	weight: 0
n__pair(x1,x2)	weight: (/ 3 8)
#take(x1,x2)	weight: 0
isPLNat(x1)	weight: (/ 21 8)
   U91(x1,x2)	weight: (/ 1 2) + x1 + x2
#U101(x1,x2,x3)	weight: 0
activate(x1)	weight: (/ 5 8)
n__isLNat(x1)	weight: (/ 11 8)
 #U82(x1,x2)	weight: 0
  take(x1,x2)	weight: (/ 23 8)
   U71(x1,x2)	weight: x1
 #U81(x1,x2,x3,x4)	weight: 0
   and(x1,x2)	weight: (/ 1 8) + x1 + x2
  U101(x1,x2,x3)	weight: (/ 3 4) + x1 + x3
  pair(x1,x2)	weight: (/ 1 4)
   fst(x1)	weight: (/ 1 8) + x1
#activate(x1)	weight: x1
natsFrom(x1)	weight: (/ 3 4)
#head(x1)	weight: 0
splitAt(x1,x2)	weight: (/ 1 8) + x1
 #fst(x1)	weight: 0
n__nil()	weight: 0
n__natsFrom(x1)	weight: (/ 7 8)
isNatural(x1)	weight: (/ 3 4) + x1
n__snd(x1)	weight: (/ 1 4)
  n__s(x1)	weight: (/ 1 2) + x1
n__splitAt(x1,x2)	weight: (/ 1 4)
  tail(x1)	weight: (/ 3 4)
     0()	weight: 0
n__take(x1,x2)	weight: 3
 #sel(x1,x2)	weight: 0
#isLNat(x1)	weight: (/ 11 8)
   sel(x1,x2)	weight: x1 + x2
   #s(x1)	weight: 0
afterNth(x1,x2)	weight: x1 + x2
n__cons(x1,x2)	weight: (/ 7 8)
#isPLNat(x1)	weight: 0
   nil()	weight: 0
isLNat(x1)	weight: (/ 5 4)
n__sel(x1,x2)	weight: (/ 1 8) + x1 + x2
#tail(x1)	weight: 0
#splitAt(x1,x2)	weight: 0
 #nil()	weight: 0
n__tail(x1)	weight: (/ 7 8) + x1
#afterNth(x1,x2)	weight: 0
n__isNatural(x1)	weight: (/ 7 8)
  n__0()	weight: 0
n__afterNth(x1,x2)	weight: (/ 1 8)
   U61(x1,x2)	weight: (/ 1 2) + x2
 #U51(x1,x2,x3)	weight: 0
n__fst(x1)	weight: (/ 1 4)
 #U11(x1,x2,x3)	weight: 0
   U31(x1,x2)	weight: (/ 1 2) + x1
  head(x1)	weight: (/ 1 8) + x1
 #snd(x1)	weight: 0
 #U41(x1,x2)	weight: 0
  cons(x1,x2)	weight: (/ 3 4)
#natsFrom(x1)	weight: 0
   snd(x1)	weight: (/ 1 8) + x1
 #U21(x1,x2)	weight: 0
   U81(x1,x2,x3,x4)	weight: x1
   U82(x1,x2)	weight: (/ 1 8)
    tt()	weight: 0
n__and(x1,x2)	weight: (/ 1 4) + x2
 #U71(x1,x2)	weight: 0
#isNatural(x1)	weight: 0
#pair(x1,x2)	weight: 0
n__head(x1)	weight: (/ 1 4) + x1
   U51(x1,x2,x3)	weight: (/ 5 4)
   U41(x1,x2)	weight: (/ 5 8) + x1 + x2
 #U31(x1,x2)	weight: 0
 #and(x1,x2)	weight: x2
 #U91(x1,x2)	weight: 0
 #U61(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #29 #46
Number of SCCs: 1, DPs: 3, edges: 3
	SCC { #33 #54 #132 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  failed.
