Input TRS:
    1: function(iszero(),0(),dummy,dummy2) -> true()
    2: function(iszero(),s(x),dummy,dummy2) -> false()
    3: function(p(),0(),dummy,dummy2) -> 0()
    4: function(p(),s(0()),dummy,dummy2) -> 0()
    5: function(p(),s(s(x)),dummy,dummy2) -> s(function(p(),s(x),x,x))
    6: function(plus(),dummy,x,y) -> function(if(),function(iszero(),x,x,x),x,y)
    7: function(if(),true(),x,y) -> y
    8: function(if(),false(),x,y) -> function(plus(),function(third(),x,y,y),function(p(),x,x,y),s(y))
    9: function(third(),x,y,z) -> z
Number of strict rules: 9
Direct Order(PosReal,>,Poly) ... failed.
Freezing function
1: function❆1_iszero(0(),dummy,dummy2) -> true()
2: function❆1_iszero(s(x),dummy,dummy2) -> false()
3: function❆1_p(0(),dummy,dummy2) -> 0()
4: function❆1_p(s(0()),dummy,dummy2) -> 0()
5: function❆1_p(s(s(x)),dummy,dummy2) -> s(function❆1_p(s(x),x,x))
6: function❆1_plus(dummy,x,y) -> function❆1_if(function❆1_iszero(x,x,x),x,y)
7: function❆1_if(true(),x,y) -> y
8: function❆1_if(false(),x,y) -> function❆1_plus(function❆1_third(x,y,y),function❆1_p(x,x,y),s(y))
9: function❆1_third(x,y,z) -> z
10: function(plus(),_3,_4,_5) ->= function❆1_plus(_3,_4,_5)
11: function(p(),_3,_4,_5) ->= function❆1_p(_3,_4,_5)
12: function(if(),_3,_4,_5) ->= function❆1_if(_3,_4,_5)
13: function(third(),_3,_4,_5) ->= function❆1_third(_3,_4,_5)
14: function(iszero(),_3,_4,_5) ->= function❆1_iszero(_3,_4,_5)
Number of strict rules: 9
Direct Order(PosReal,>,Poly) ... failed.
Dependency Pairs:
   #1: #function❆1_plus(dummy,x,y) -> #function❆1_if(function❆1_iszero(x,x,x),x,y)
   #2: #function❆1_plus(dummy,x,y) -> #function❆1_iszero(x,x,x)
   #3: #function(third(),_3,_4,_5) ->? #function❆1_third(_3,_4,_5)
   #4: #function(p(),_3,_4,_5) ->? #function❆1_p(_3,_4,_5)
   #5: #function(if(),_3,_4,_5) ->? #function❆1_if(_3,_4,_5)
   #6: #function(iszero(),_3,_4,_5) ->? #function❆1_iszero(_3,_4,_5)
   #7: #function(plus(),_3,_4,_5) ->? #function❆1_plus(_3,_4,_5)
   #8: #function❆1_p(s(s(x)),dummy,dummy2) -> #function❆1_p(s(x),x,x)
   #9: #function❆1_if(false(),x,y) -> #function❆1_plus(function❆1_third(x,y,y),function❆1_p(x,x,y),s(y))
   #10: #function❆1_if(false(),x,y) -> #function❆1_third(x,y,y)
   #11: #function❆1_if(false(),x,y) -> #function❆1_p(x,x,y)
Number of SCCs: 2, DPs: 3, edges: 3
	SCC { #8 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
     s(x1)	weight: (/ 1 4) + x1
function❆1_third(x1,x2,x3)	weight: 0
#function❆1_iszero(x1,x2,x3)	weight: 0
#function❆1_plus(x1,x2,x3)	weight: 0
function❆1_p(x1,x2,x3)	weight: 0
 false()	weight: 0
#function(x1,x2,x3,x4)	weight: 0
 third()	weight: 0
#function❆1_third(x1,x2,x3)	weight: 0
iszero()	weight: 0
#function❆1_if(x1,x2,x3)	weight: 0
function❆1_if(x1,x2,x3)	weight: 0
  true()	weight: 0
function(x1,x2,x3,x4)	weight: 0
function❆1_plus(x1,x2,x3)	weight: 0
     p()	weight: 0
#function❆1_p(x1,x2,x3)	weight: x1
     0()	weight: 0
    if()	weight: 0
function❆1_iszero(x1,x2,x3)	weight: 0
  plus()	weight: 0
    Usable rules: { }
    Removed DPs: #8
Number of SCCs: 1, DPs: 2, edges: 2
	SCC { #1 #9 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... succeeded.
     s(x1)	weight: max{0, (/ 5 8) + x1}
function❆1_third(x1,x2,x3)	weight: max{0, (- (/ 1 8)) + x1, (- (/ 1 8)) + x2}
#function❆1_iszero(x1,x2,x3)	weight: 0
#function❆1_plus(x1,x2,x3)	weight: max{0, (/ 1 4) + x2}
function❆1_p(x1,x2,x3)	weight: max{0, (- (/ 1 8)) + x1}
 false()	weight: (/ 3 4)
#function(x1,x2,x3,x4)	weight: 0
 third()	weight: 0
#function❆1_third(x1,x2,x3)	weight: 0
iszero()	weight: 0
#function❆1_if(x1,x2,x3)	weight: max{0, (- (/ 3 8)) + x1, (/ 1 8) + x2}
function❆1_if(x1,x2,x3)	weight: 0
  true()	weight: (/ 1 4)
function(x1,x2,x3,x4)	weight: 0
function❆1_plus(x1,x2,x3)	weight: 0
     p()	weight: 0
#function❆1_p(x1,x2,x3)	weight: 0
     0()	weight: 0
    if()	weight: 0
function❆1_iszero(x1,x2,x3)	weight: max{0, (/ 1 8) + x1, (/ 1 4) + x2}
  plus()	weight: 0
    Usable rules: { 1..5 }
    Removed DPs: #1
Number of SCCs: 0, DPs: 0, edges: 0
