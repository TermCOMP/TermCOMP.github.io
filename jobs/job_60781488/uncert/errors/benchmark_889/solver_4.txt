Input TRS:
    1: from(X) -> cons(X,n__from(n__s(X)))
    2: length(n__nil()) -> 0()
    3: length(n__cons(X,Y)) -> s(length1(activate(Y)))
    4: length1(X) -> length(activate(X))
    5: from(X) -> n__from(X)
    6: s(X) -> n__s(X)
    7: nil() -> n__nil()
    8: cons(X1,X2) -> n__cons(X1,X2)
    9: activate(n__from(X)) -> from(activate(X))
    10: activate(n__s(X)) -> s(activate(X))
    11: activate(n__nil()) -> nil()
    12: activate(n__cons(X1,X2)) -> cons(activate(X1),X2)
    13: activate(X) -> X
Number of strict rules: 13
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #activate(n__from(X)) -> #from(activate(X))
   #2: #activate(n__from(X)) -> #activate(X)
   #3: #activate(n__nil()) -> #nil()
   #4: #activate(n__cons(X1,X2)) -> #cons(activate(X1),X2)
   #5: #activate(n__cons(X1,X2)) -> #activate(X1)
   #6: #activate(n__s(X)) -> #s(activate(X))
   #7: #activate(n__s(X)) -> #activate(X)
   #8: #length(n__cons(X,Y)) -> #s(length1(activate(Y)))
   #9: #length(n__cons(X,Y)) -> #length1(activate(Y))
   #10: #length(n__cons(X,Y)) -> #activate(Y)
   #11: #from(X) -> #cons(X,n__from(n__s(X)))
   #12: #length1(X) -> #length(activate(X))
   #13: #length1(X) -> #activate(X)
Number of SCCs: 2, DPs: 5, edges: 11
	SCC { #9 #12 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  found.
  #length(n__cons(X,n__from(X_{i15})))	-#9->
  #length1(activate(n__from(X_{i15})))	--->*
  #length1(activate(n__from(X_{i15})))	-#12->
  #length(activate(activate(n__from(X_{i15}))))	--->*
  #length(n__cons(activate(X_{i15}),n__from(n__s(activate(X_{i15})))))
  Looping with: [ X_{i15} := n__s(activate(X_{i15})); X := activate(X_{i15}); ]
