Input TRS:
    1: half(0()) -> 0()
    2: half(s(0())) -> 0()
    3: half(s(s(x))) -> s(half(x))
    4: le(0(),y) -> true()
    5: le(s(x),0()) -> false()
    6: le(s(x),s(y)) -> le(x,y)
    7: inc(s(x)) -> s(inc(x))
    8: inc(0()) -> s(0())
    9: logarithm(x) -> logIter(x,0())
    10: logIter(x,y) -> if(le(s(0()),x),le(s(s(0())),x),half(x),inc(y))
    11: if(false(),b,x,y) -> logZeroError()
    12: if(true(),false(),x,s(y)) -> y
    13: if(true(),true(),x,y) -> logIter(x,y)
    14: f() -> g()
    15: f() -> h()
Number of strict rules: 15
Direct Order(PosReal,>,Poly) ... failed.
Freezing le
1: half(0()) -> 0()
2: half(s(0())) -> 0()
3: half(s(s(x))) -> s(half(x))
4: le❆1_0(y) -> true()
5: le❆1_s(x,0()) -> false()
6: le❆1_s(x,s(y)) -> le(x,y)
7: inc(s(x)) -> s(inc(x))
8: inc(0()) -> s(0())
9: logarithm(x) -> logIter(x,0())
10: logIter(x,y) -> if(le❆1_s(0(),x),le❆1_s(s(0()),x),half(x),inc(y))
11: if(false(),b,x,y) -> logZeroError()
12: if(true(),false(),x,s(y)) -> y
13: if(true(),true(),x,y) -> logIter(x,y)
14: f() -> g()
15: f() -> h()
16: le(0(),_1) ->= le❆1_0(_1)
17: le(s(_1),_2) ->= le❆1_s(_1,_2)
Number of strict rules: 15
Direct Order(PosReal,>,Poly) ... failed.
Dependency Pairs:
   #1: #le❆1_s(x,s(y)) -> #le(x,y)
   #2: #if(true(),true(),x,y) -> #logIter(x,y)
   #3: #logarithm(x) -> #logIter(x,0())
   #4: #inc(s(x)) -> #inc(x)
   #5: #logIter(x,y) -> #if(le❆1_s(0(),x),le❆1_s(s(0()),x),half(x),inc(y))
   #6: #logIter(x,y) -> #le❆1_s(0(),x)
   #7: #logIter(x,y) -> #le❆1_s(s(0()),x)
   #8: #logIter(x,y) -> #half(x)
   #9: #logIter(x,y) -> #inc(y)
   #10: #le(s(_1),_2) ->? #le❆1_s(_1,_2)
   #11: #le(0(),_1) ->? #le❆1_0(_1)
   #12: #half(s(s(x))) -> #half(x)
Number of SCCs: 4, DPs: 6, edges: 6
	SCC { #4 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
     h()	weight: 0
    le(x1,x2)	weight: 0
     s(x1)	weight: (/ 1 2) + x1
  #le(x1,x2)	weight: 0
 false()	weight: 0
logZeroError()	weight: 0
#half(x1)	weight: 0
 #inc(x1)	weight: x1
   inc(x1)	weight: 0
  true()	weight: 0
     f()	weight: 0
#le❆1_0(x1)	weight: 0
le❆1_s(x1,x2)	weight: 0
  half(x1)	weight: 0
     0()	weight: 0
    if(x1,x2,x3,x4)	weight: 0
   #f()	weight: 0
#le❆1_s(x1,x2)	weight: 0
logIter(x1,x2)	weight: 0
logarithm(x1)	weight: 0
#logIter(x1,x2)	weight: 0
  #if(x1,x2,x3,x4)	weight: 0
#logarithm(x1)	weight: 0
le❆1_0(x1)	weight: 0
     g()	weight: 0
    Usable rules: { }
    Removed DPs: #4
Number of SCCs: 3, DPs: 5, edges: 5
	SCC { #12 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
     h()	weight: 0
    le(x1,x2)	weight: 0
     s(x1)	weight: (/ 1 4) + x1
  #le(x1,x2)	weight: 0
 false()	weight: 0
logZeroError()	weight: 0
#half(x1)	weight: x1
 #inc(x1)	weight: 0
   inc(x1)	weight: 0
  true()	weight: 0
     f()	weight: 0
#le❆1_0(x1)	weight: 0
le❆1_s(x1,x2)	weight: 0
  half(x1)	weight: 0
     0()	weight: 0
    if(x1,x2,x3,x4)	weight: 0
   #f()	weight: 0
#le❆1_s(x1,x2)	weight: 0
logIter(x1,x2)	weight: 0
logarithm(x1)	weight: 0
#logIter(x1,x2)	weight: 0
  #if(x1,x2,x3,x4)	weight: 0
#logarithm(x1)	weight: 0
le❆1_0(x1)	weight: 0
     g()	weight: 0
    Usable rules: { }
    Removed DPs: #12
Number of SCCs: 2, DPs: 4, edges: 4
	SCC { #1 #10 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
     h()	weight: 0
    le(x1,x2)	weight: 0
     s(x1)	weight: (/ 1 2) + x1
  #le(x1,x2)	weight: x1
 false()	weight: 0
logZeroError()	weight: 0
#half(x1)	weight: 0
 #inc(x1)	weight: 0
   inc(x1)	weight: 0
  true()	weight: 0
     f()	weight: 0
#le❆1_0(x1)	weight: 0
le❆1_s(x1,x2)	weight: 0
  half(x1)	weight: 0
     0()	weight: 0
    if(x1,x2,x3,x4)	weight: 0
   #f()	weight: 0
#le❆1_s(x1,x2)	weight: (/ 1 4) + x1
logIter(x1,x2)	weight: 0
logarithm(x1)	weight: 0
#logIter(x1,x2)	weight: 0
  #if(x1,x2,x3,x4)	weight: 0
#logarithm(x1)	weight: 0
le❆1_0(x1)	weight: 0
     g()	weight: 0
    Usable rules: { }
    Removed DPs: #1 #10
Number of SCCs: 1, DPs: 2, edges: 2
	SCC { #2 #5 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... succeeded.
     h()	weight: 0
    le(x1,x2)	weight: max{0, (/ 1 2) + x2}
     s(x1)	weight: max{0, (/ 3 8) + x1}
  #le(x1,x2)	weight: 0
 false()	weight: (/ 1 8)
logZeroError()	weight: 0
#half(x1)	weight: 0
 #inc(x1)	weight: 0
   inc(x1)	weight: (max (/ 1 4) 0)
  true()	weight: (/ 1 2)
     f()	weight: 0
#le❆1_0(x1)	weight: 0
le❆1_s(x1,x2)	weight: max{0, (/ 1 8) + x2}
  half(x1)	weight: max{0, (- (/ 1 4)) + x1}
     0()	weight: 0
    if(x1,x2,x3,x4)	weight: 0
   #f()	weight: 0
#le❆1_s(x1,x2)	weight: 0
logIter(x1,x2)	weight: 0
logarithm(x1)	weight: 0
#logIter(x1,x2)	weight: max{0, (- (/ 1 8)) + x1}
  #if(x1,x2,x3,x4)	weight: max{0, (- (/ 1 4)) + x1, (- (/ 3 8)) + x2, x3}
#logarithm(x1)	weight: 0
le❆1_0(x1)	weight: (max (/ 1 2) 0)
     g()	weight: 0
    Usable rules: { 1..6 16 17 }
    Removed DPs: #2
Number of SCCs: 0, DPs: 0, edges: 0
