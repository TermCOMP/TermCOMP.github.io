Input TRS:
    1: a__U11(tt(),N,X,XS) -> a__U12(a__splitAt(mark(N),mark(XS)),X)
    2: a__U12(pair(YS,ZS),X) -> pair(cons(mark(X),YS),mark(ZS))
    3: a__afterNth(N,XS) -> a__snd(a__splitAt(mark(N),mark(XS)))
    4: a__and(tt(),X) -> mark(X)
    5: a__fst(pair(X,Y)) -> mark(X)
    6: a__head(cons(N,XS)) -> mark(N)
    7: a__natsFrom(N) -> cons(mark(N),natsFrom(s(N)))
    8: a__sel(N,XS) -> a__head(a__afterNth(mark(N),mark(XS)))
    9: a__snd(pair(X,Y)) -> mark(Y)
    10: a__splitAt(0(),XS) -> pair(nil(),mark(XS))
    11: a__splitAt(s(N),cons(X,XS)) -> a__U11(tt(),N,X,XS)
    12: a__tail(cons(N,XS)) -> mark(XS)
    13: a__take(N,XS) -> a__fst(a__splitAt(mark(N),mark(XS)))
    14: mark(U11(X1,X2,X3,X4)) -> a__U11(mark(X1),X2,X3,X4)
    15: mark(U12(X1,X2)) -> a__U12(mark(X1),X2)
    16: mark(splitAt(X1,X2)) -> a__splitAt(mark(X1),mark(X2))
    17: mark(afterNth(X1,X2)) -> a__afterNth(mark(X1),mark(X2))
    18: mark(snd(X)) -> a__snd(mark(X))
    19: mark(and(X1,X2)) -> a__and(mark(X1),X2)
    20: mark(fst(X)) -> a__fst(mark(X))
    21: mark(head(X)) -> a__head(mark(X))
    22: mark(natsFrom(X)) -> a__natsFrom(mark(X))
    23: mark(sel(X1,X2)) -> a__sel(mark(X1),mark(X2))
    24: mark(tail(X)) -> a__tail(mark(X))
    25: mark(take(X1,X2)) -> a__take(mark(X1),mark(X2))
    26: mark(tt()) -> tt()
    27: mark(pair(X1,X2)) -> pair(mark(X1),mark(X2))
    28: mark(cons(X1,X2)) -> cons(mark(X1),X2)
    29: mark(s(X)) -> s(mark(X))
    30: mark(0()) -> 0()
    31: mark(nil()) -> nil()
    32: a__U11(X1,X2,X3,X4) -> U11(X1,X2,X3,X4)
    33: a__U12(X1,X2) -> U12(X1,X2)
    34: a__splitAt(X1,X2) -> splitAt(X1,X2)
    35: a__afterNth(X1,X2) -> afterNth(X1,X2)
    36: a__snd(X) -> snd(X)
    37: a__and(X1,X2) -> and(X1,X2)
    38: a__fst(X) -> fst(X)
    39: a__head(X) -> head(X)
    40: a__natsFrom(X) -> natsFrom(X)
    41: a__sel(X1,X2) -> sel(X1,X2)
    42: a__tail(X) -> tail(X)
    43: a__take(X1,X2) -> take(X1,X2)
Number of strict rules: 43
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #a__U12(pair(YS,ZS),X) -> #mark(X)
   #2: #a__U12(pair(YS,ZS),X) -> #mark(ZS)
   #3: #mark(s(X)) -> #mark(X)
   #4: #a__head(cons(N,XS)) -> #mark(N)
   #5: #a__take(N,XS) -> #a__fst(a__splitAt(mark(N),mark(XS)))
   #6: #a__take(N,XS) -> #a__splitAt(mark(N),mark(XS))
   #7: #a__take(N,XS) -> #mark(N)
   #8: #a__take(N,XS) -> #mark(XS)
   #9: #a__snd(pair(X,Y)) -> #mark(Y)
   #10: #a__splitAt(s(N),cons(X,XS)) -> #a__U11(tt(),N,X,XS)
   #11: #mark(tail(X)) -> #a__tail(mark(X))
   #12: #mark(tail(X)) -> #mark(X)
   #13: #mark(sel(X1,X2)) -> #a__sel(mark(X1),mark(X2))
   #14: #mark(sel(X1,X2)) -> #mark(X1)
   #15: #mark(sel(X1,X2)) -> #mark(X2)
   #16: #a__tail(cons(N,XS)) -> #mark(XS)
   #17: #mark(U11(X1,X2,X3,X4)) -> #a__U11(mark(X1),X2,X3,X4)
   #18: #mark(U11(X1,X2,X3,X4)) -> #mark(X1)
   #19: #mark(take(X1,X2)) -> #a__take(mark(X1),mark(X2))
   #20: #mark(take(X1,X2)) -> #mark(X1)
   #21: #mark(take(X1,X2)) -> #mark(X2)
   #22: #mark(fst(X)) -> #a__fst(mark(X))
   #23: #mark(fst(X)) -> #mark(X)
   #24: #a__natsFrom(N) -> #mark(N)
   #25: #a__splitAt(0(),XS) -> #mark(XS)
   #26: #a__fst(pair(X,Y)) -> #mark(X)
   #27: #mark(cons(X1,X2)) -> #mark(X1)
   #28: #mark(natsFrom(X)) -> #a__natsFrom(mark(X))
   #29: #mark(natsFrom(X)) -> #mark(X)
   #30: #mark(pair(X1,X2)) -> #mark(X1)
   #31: #mark(pair(X1,X2)) -> #mark(X2)
   #32: #mark(afterNth(X1,X2)) -> #a__afterNth(mark(X1),mark(X2))
   #33: #mark(afterNth(X1,X2)) -> #mark(X1)
   #34: #mark(afterNth(X1,X2)) -> #mark(X2)
   #35: #mark(and(X1,X2)) -> #a__and(mark(X1),X2)
   #36: #mark(and(X1,X2)) -> #mark(X1)
   #37: #mark(head(X)) -> #a__head(mark(X))
   #38: #mark(head(X)) -> #mark(X)
   #39: #mark(splitAt(X1,X2)) -> #a__splitAt(mark(X1),mark(X2))
   #40: #mark(splitAt(X1,X2)) -> #mark(X1)
   #41: #mark(splitAt(X1,X2)) -> #mark(X2)
   #42: #a__afterNth(N,XS) -> #a__snd(a__splitAt(mark(N),mark(XS)))
   #43: #a__afterNth(N,XS) -> #a__splitAt(mark(N),mark(XS))
   #44: #a__afterNth(N,XS) -> #mark(N)
   #45: #a__afterNth(N,XS) -> #mark(XS)
   #46: #a__U11(tt(),N,X,XS) -> #a__U12(a__splitAt(mark(N),mark(XS)),X)
   #47: #a__U11(tt(),N,X,XS) -> #a__splitAt(mark(N),mark(XS))
   #48: #a__U11(tt(),N,X,XS) -> #mark(N)
   #49: #a__U11(tt(),N,X,XS) -> #mark(XS)
   #50: #a__sel(N,XS) -> #a__head(a__afterNth(mark(N),mark(XS)))
   #51: #a__sel(N,XS) -> #a__afterNth(mark(N),mark(XS))
   #52: #a__sel(N,XS) -> #mark(N)
   #53: #a__sel(N,XS) -> #mark(XS)
   #54: #mark(U12(X1,X2)) -> #a__U12(mark(X1),X2)
   #55: #mark(U12(X1,X2)) -> #mark(X1)
   #56: #a__and(tt(),X) -> #mark(X)
   #57: #mark(snd(X)) -> #a__snd(mark(X))
   #58: #mark(snd(X)) -> #mark(X)
Number of SCCs: 1, DPs: 58, edges: 1229
	SCC { #1..58 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... succeeded.
   U11(x1,x2,x3,x4)	weight: max{x4, (/ 3 8) + x3, x2, (/ 1 8) + x1}
     s(x1)	weight: x1
#a__head(x1)	weight: (/ 1 8) + x1
#a__natsFrom(x1)	weight: (/ 1 8) + x1
#a__snd(x1)	weight: x1
a__afterNth(x1,x2)	weight: max{(/ 1 8) + x2, (/ 1 4) + x1}
  take(x1,x2)	weight: max{(/ 5 8) + x2, (/ 3 8) + x1}
   and(x1,x2)	weight: max{(/ 1 4) + x2, x1}
  pair(x1,x2)	weight: max{x2, x1}
   fst(x1)	weight: (/ 1 4) + x1
natsFrom(x1)	weight: (/ 3 8) + x1
a__snd(x1)	weight: (/ 1 8) + x1
splitAt(x1,x2)	weight: max{x2, x1}
#a__U11(x1,x2,x3,x4)	weight: max{0, x4, (/ 3 8) + x3, x2}
#a__take(x1,x2)	weight: max{(/ 1 2) + x2, (/ 1 4) + x1}
   U12(x1,x2)	weight: max{(/ 3 8) + x2, x1}
#a__U12(x1,x2)	weight: max{(/ 1 8) + x2, x1}
a__fst(x1)	weight: (/ 1 4) + x1
a__natsFrom(x1)	weight: (/ 3 8) + x1
  tail(x1)	weight: (/ 1 4) + x1
#mark(x1)	weight: x1
     0()	weight: 0
#a__and(x1,x2)	weight: max{0, (/ 1 8) + x2}
   sel(x1,x2)	weight: max{(/ 5 8) + x2, (/ 3 4) + x1}
afterNth(x1,x2)	weight: max{(/ 1 8) + x2, (/ 1 4) + x1}
   nil()	weight: 0
a__splitAt(x1,x2)	weight: max{x2, x1}
#a__sel(x1,x2)	weight: max{(/ 1 2) + x2, (/ 5 8) + x1}
  mark(x1)	weight: x1
a__U11(x1,x2,x3,x4)	weight: max{x4, (/ 3 8) + x3, x2, (/ 1 8) + x1}
a__sel(x1,x2)	weight: max{(/ 5 8) + x2, (/ 3 4) + x1}
a__U12(x1,x2)	weight: max{(/ 3 8) + x2, x1}
  head(x1)	weight: (/ 1 2) + x1
#a__afterNth(x1,x2)	weight: max{x2, x1}
#a__splitAt(x1,x2)	weight: max{x2, x1}
  cons(x1,x2)	weight: max{x2, (/ 3 8) + x1}
   snd(x1)	weight: (/ 1 8) + x1
a__take(x1,x2)	weight: max{(/ 5 8) + x2, (/ 3 8) + x1}
    tt()	weight: (/ 1 8)
#a__fst(x1)	weight: (/ 1 8) + x1
a__and(x1,x2)	weight: max{(/ 1 4) + x2, x1}
a__tail(x1)	weight: (/ 1 4) + x1
#a__tail(x1)	weight: (/ 1 8) + x1
a__head(x1)	weight: (/ 1 2) + x1
    Usable rules: { 1..43 }
    Removed DPs: #1 #4..8 #11..16 #18..24 #26..29 #32..35 #37 #38 #50..53 #56..58
Number of SCCs: 1, DPs: 17, edges: 124
	SCC { #2 #3 #10 #17 #25 #30 #31 #36 #39..41 #46..49 #54 #55 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... succeeded.
   U11(x1,x2,x3,x4)	weight: max{x4, (/ 3 8) + x3, x2, (/ 1 8) + x1}
     s(x1)	weight: x1
#a__head(x1)	weight: (/ 1 8) + x1
#a__natsFrom(x1)	weight: (/ 1 8) + x1
#a__snd(x1)	weight: x1
a__afterNth(x1,x2)	weight: max{(/ 1 8) + x2, (/ 1 4) + x1}
  take(x1,x2)	weight: max{(/ 5 8) + x2, (/ 3 8) + x1}
   and(x1,x2)	weight: max{(/ 1 4) + x2, (/ 1 8) + x1}
  pair(x1,x2)	weight: max{x2, x1}
   fst(x1)	weight: (/ 1 4) + x1
natsFrom(x1)	weight: (/ 3 8) + x1
a__snd(x1)	weight: (/ 1 8) + x1
splitAt(x1,x2)	weight: max{x2, x1}
#a__U11(x1,x2,x3,x4)	weight: max{0, (/ 1 8) + x4, (/ 1 8) + x2}
#a__take(x1,x2)	weight: max{(/ 1 2) + x2, (/ 1 4) + x1}
   U12(x1,x2)	weight: max{(/ 3 8) + x2, x1}
#a__U12(x1,x2)	weight: max{0, (/ 1 8) + x1}
a__fst(x1)	weight: (/ 1 4) + x1
a__natsFrom(x1)	weight: (/ 3 8) + x1
  tail(x1)	weight: (/ 1 4) + x1
#mark(x1)	weight: (/ 1 8) + x1
     0()	weight: 0
#a__and(x1,x2)	weight: 0
   sel(x1,x2)	weight: max{(/ 5 8) + x2, (/ 3 4) + x1}
afterNth(x1,x2)	weight: max{(/ 1 8) + x2, (/ 1 4) + x1}
   nil()	weight: 0
a__splitAt(x1,x2)	weight: max{x2, x1}
#a__sel(x1,x2)	weight: max{(/ 1 2) + x2, (/ 5 8) + x1}
  mark(x1)	weight: x1
a__U11(x1,x2,x3,x4)	weight: max{x4, (/ 3 8) + x3, x2, (/ 1 8) + x1}
a__sel(x1,x2)	weight: max{(/ 5 8) + x2, (/ 3 4) + x1}
a__U12(x1,x2)	weight: max{(/ 3 8) + x2, x1}
  head(x1)	weight: (/ 1 2) + x1
#a__afterNth(x1,x2)	weight: max{x2, x1}
#a__splitAt(x1,x2)	weight: max{(/ 1 8) + x2, (/ 1 8) + x1}
  cons(x1,x2)	weight: max{x2, (/ 3 8) + x1}
   snd(x1)	weight: (/ 1 8) + x1
a__take(x1,x2)	weight: max{(/ 5 8) + x2, (/ 3 8) + x1}
    tt()	weight: (/ 1 8)
#a__fst(x1)	weight: (/ 1 8) + x1
a__and(x1,x2)	weight: max{(/ 1 4) + x2, (/ 1 8) + x1}
a__tail(x1)	weight: (/ 1 4) + x1
#a__tail(x1)	weight: (/ 1 8) + x1
a__head(x1)	weight: (/ 1 2) + x1
    Usable rules: { 1..43 }
    Removed DPs: #36
Number of SCCs: 1, DPs: 16, edges: 104
	SCC { #2 #3 #10 #17 #25 #30 #31 #39..41 #46..49 #54 #55 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... succeeded.
   U11(x1,x2,x3,x4)	weight: max{x4, (/ 3 8) + x3, (/ 3 16) + x2, (/ 1 4) + x1}
     s(x1)	weight: x1
#a__head(x1)	weight: (/ 1 16)
#a__natsFrom(x1)	weight: (/ 1 16)
#a__snd(x1)	weight: 0
a__afterNth(x1,x2)	weight: max{(/ 1 16) + x2, (/ 1 4) + x1}
  take(x1,x2)	weight: max{(/ 3 8) + x2, (/ 5 16) + x1}
   and(x1,x2)	weight: max{(/ 1 8) + x2, (/ 1 16) + x1}
  pair(x1,x2)	weight: max{x2, x1}
   fst(x1)	weight: (/ 1 8) + x1
natsFrom(x1)	weight: (/ 3 8) + x1
a__snd(x1)	weight: (/ 1 16) + x1
splitAt(x1,x2)	weight: max{x2, (/ 3 16) + x1}
#a__U11(x1,x2,x3,x4)	weight: max{x4, (/ 3 8) + x3, (/ 3 16) + x2, (/ 1 16) + x1}
#a__take(x1,x2)	weight: 0
   U12(x1,x2)	weight: max{(/ 3 8) + x2, x1}
#a__U12(x1,x2)	weight: max{0, x1}
a__fst(x1)	weight: (/ 1 8) + x1
a__natsFrom(x1)	weight: (/ 3 8) + x1
  tail(x1)	weight: (/ 1 16) + x1
#mark(x1)	weight: x1
     0()	weight: (/ 1 16)
#a__and(x1,x2)	weight: 0
   sel(x1,x2)	weight: max{(/ 5 16) + x2, (/ 1 2) + x1}
afterNth(x1,x2)	weight: max{(/ 1 16) + x2, (/ 1 4) + x1}
   nil()	weight: 0
a__splitAt(x1,x2)	weight: max{x2, (/ 3 16) + x1}
#a__sel(x1,x2)	weight: 0
  mark(x1)	weight: x1
a__U11(x1,x2,x3,x4)	weight: max{x4, (/ 3 8) + x3, (/ 3 16) + x2, (/ 1 4) + x1}
a__sel(x1,x2)	weight: max{(/ 5 16) + x2, (/ 1 2) + x1}
a__U12(x1,x2)	weight: max{(/ 3 8) + x2, x1}
  head(x1)	weight: (/ 1 4) + x1
#a__afterNth(x1,x2)	weight: 0
#a__splitAt(x1,x2)	weight: max{x2, (/ 3 16) + x1}
  cons(x1,x2)	weight: max{x2, (/ 3 8) + x1}
   snd(x1)	weight: (/ 1 16) + x1
a__take(x1,x2)	weight: max{(/ 3 8) + x2, (/ 5 16) + x1}
    tt()	weight: (/ 1 16)
#a__fst(x1)	weight: (/ 1 16)
a__and(x1,x2)	weight: max{(/ 1 8) + x2, (/ 1 16) + x1}
a__tail(x1)	weight: (/ 1 16) + x1
#a__tail(x1)	weight: (/ 1 16)
a__head(x1)	weight: (/ 1 4) + x1
    Usable rules: { 1..43 }
    Removed DPs: #40 #48
Number of SCCs: 1, DPs: 14, edges: 76
	SCC { #2 #3 #10 #17 #25 #30 #31 #39 #41 #46 #47 #49 #54 #55 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... succeeded.
   U11(x1,x2,x3,x4)	weight: max{(/ 88459 4) + x4, (/ 353835 8) + x3, 44229 + x2, (/ 353833 8) + x1}
     s(x1)	weight: x1
#a__head(x1)	weight: (/ 1 8)
#a__natsFrom(x1)	weight: (/ 1 8)
#a__snd(x1)	weight: 0
a__afterNth(x1,x2)	weight: max{(/ 176919 8) + x2, (/ 353833 8) + x1}
  take(x1,x2)	weight: max{(/ 353835 8) + x2, (/ 176917 4) + x1}
   and(x1,x2)	weight: max{(/ 1 4) + x2, (/ 1 8) + x1}
  pair(x1,x2)	weight: max{(/ 176917 8) + x2, (/ 88459 4) + x1}
   fst(x1)	weight: (/ 1 4) + x1
natsFrom(x1)	weight: (/ 176917 8) + x1
a__snd(x1)	weight: (/ 1 8) + x1
splitAt(x1,x2)	weight: max{(/ 88459 4) + x2, 44229 + x1}
#a__U11(x1,x2,x3,x4)	weight: max{(/ 176917 4) + x4, (/ 44229 2) + x3, (/ 88459 2) + x2, (/ 176917 8) + x1}
#a__take(x1,x2)	weight: 0
   U12(x1,x2)	weight: max{(/ 353835 8) + x2, x1}
#a__U12(x1,x2)	weight: max{(/ 176915 8) + x2, (/ 1 8) + x1}
a__fst(x1)	weight: (/ 1 4) + x1
a__natsFrom(x1)	weight: (/ 176917 8) + x1
  tail(x1)	weight: (/ 1 8) + x1
#mark(x1)	weight: (/ 176917 8) + x1
     0()	weight: (/ 1 8)
#a__and(x1,x2)	weight: 0
   sel(x1,x2)	weight: max{22115 + x2, (/ 176917 4) + x1}
afterNth(x1,x2)	weight: max{(/ 176919 8) + x2, (/ 353833 8) + x1}
   nil()	weight: (/ 1 8)
a__splitAt(x1,x2)	weight: max{(/ 88459 4) + x2, 44229 + x1}
#a__sel(x1,x2)	weight: 0
  mark(x1)	weight: x1
a__U11(x1,x2,x3,x4)	weight: max{(/ 88459 4) + x4, (/ 353835 8) + x3, 44229 + x2, (/ 353833 8) + x1}
a__sel(x1,x2)	weight: max{22115 + x2, (/ 176917 4) + x1}
a__U12(x1,x2)	weight: max{(/ 353835 8) + x2, x1}
  head(x1)	weight: (/ 1 8) + x1
#a__afterNth(x1,x2)	weight: 0
#a__splitAt(x1,x2)	weight: max{(/ 176917 4) + x2, (/ 88459 2) + x1}
  cons(x1,x2)	weight: max{x2, (/ 176917 8) + x1}
   snd(x1)	weight: (/ 1 8) + x1
a__take(x1,x2)	weight: max{(/ 353835 8) + x2, (/ 176917 4) + x1}
    tt()	weight: (/ 1 8)
#a__fst(x1)	weight: (/ 1 8)
a__and(x1,x2)	weight: max{(/ 1 4) + x2, (/ 1 8) + x1}
a__tail(x1)	weight: (/ 1 8) + x1
#a__tail(x1)	weight: (/ 1 8)
a__head(x1)	weight: (/ 1 8) + x1
    Usable rules: { 1..43 }
    Removed DPs: #2 #17 #25 #30 #31 #39 #41 #46 #49 #54
Number of SCCs: 2, DPs: 4, edges: 6
	SCC { #3 #55 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
   U11(x1,x2,x3,x4)	weight: (/ 5 8) + x1 + x3
     s(x1)	weight: (/ 1 8) + x1
#a__head(x1)	weight: 0
#a__natsFrom(x1)	weight: 0
#a__snd(x1)	weight: 0
a__afterNth(x1,x2)	weight: (/ 3 8) + x1 + x2
  take(x1,x2)	weight: (/ 1 8) + x1
   and(x1,x2)	weight: (/ 1 2) + x1 + x2
  pair(x1,x2)	weight: (/ 1 2)
   fst(x1)	weight: (/ 1 4) + x1
natsFrom(x1)	weight: (/ 1 2)
a__snd(x1)	weight: (/ 1 8) + x1
splitAt(x1,x2)	weight: (/ 1 2)
#a__U11(x1,x2,x3,x4)	weight: (/ 1 8)
#a__take(x1,x2)	weight: 0
   U12(x1,x2)	weight: (/ 3 8) + x1 + x2
#a__U12(x1,x2)	weight: 0
a__fst(x1)	weight: (/ 1 8)
a__natsFrom(x1)	weight: (/ 3 8)
  tail(x1)	weight: (/ 1 4)
#mark(x1)	weight: x1
     0()	weight: 0
#a__and(x1,x2)	weight: 0
   sel(x1,x2)	weight: (/ 1 4) + x1
afterNth(x1,x2)	weight: (/ 1 2)
   nil()	weight: 0
a__splitAt(x1,x2)	weight: (/ 3 8)
#a__sel(x1,x2)	weight: 0
  mark(x1)	weight: (/ 1 4)
a__U11(x1,x2,x3,x4)	weight: (/ 1 2) + x2
a__sel(x1,x2)	weight: (/ 1 8) + x2
a__U12(x1,x2)	weight: (/ 1 4) + x1
  head(x1)	weight: (/ 1 2) + x1
#a__afterNth(x1,x2)	weight: 0
#a__splitAt(x1,x2)	weight: 0
  cons(x1,x2)	weight: (/ 1 2)
   snd(x1)	weight: (/ 1 4)
a__take(x1,x2)	weight: x1 + x2
    tt()	weight: 0
#a__fst(x1)	weight: 0
a__and(x1,x2)	weight: (/ 3 8)
a__tail(x1)	weight: (/ 1 8)
#a__tail(x1)	weight: 0
a__head(x1)	weight: (/ 3 8)
    Usable rules: { }
    Removed DPs: #3 #55
Number of SCCs: 1, DPs: 2, edges: 2
	SCC { #10 #47 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... succeeded.
   U11(x1,x2,x3,x4)	weight: max{0, (/ 1 2) + x4, (/ 1 4) + x3, (/ 1 8) + x1}	status: []	precedence above: pair U12 a__U11 a__U12 cons
     s(x1)	weight: x1	status: [x1]	precedence above: pair mark tt
#a__head(x1)	weight: x1	status: []	precedence above:
#a__natsFrom(x1)	weight: x1	status: []	precedence above:
#a__snd(x1)	weight: (/ 1 8)	status: []	precedence above:
a__afterNth(x1,x2)	weight: (/ 5 8) + x2	status: [x2]	precedence above: afterNth
  take(x1,x2)	weight: (/ 3 4) + x2 + x1	status: [x1,x2]	precedence above: fst a__fst a__take
   and(x1,x2)	weight: (/ 1 8) + x2 + x1	status: [x2,x1]	precedence above: a__and
  pair(x1,x2)	weight: max{(/ 3 8) + x2, x1}	status: []	precedence above:
   fst(x1)	weight: (/ 1 8) + x1	status: [x1]	precedence above: a__fst
natsFrom(x1)	weight: x1	status: []	precedence above: a__natsFrom cons
a__snd(x1)	weight: x1	status: x1
splitAt(x1,x2)	weight: max{0, (/ 1 2) + x2}	status: []	precedence above: U11 take pair fst U12 a__fst nil a__splitAt mark a__U11 a__U12 cons a__take tt
#a__U11(x1,x2,x3,x4)	weight: max{0, (/ 1 4) + x2, (/ 1 8) + x1}	status: [x2]	precedence above: #a__splitAt
#a__take(x1,x2)	weight: x2 + x1	status: [x1,x2]	precedence above:
   U12(x1,x2)	weight: max{(/ 1 4) + x2, x1}	status: []	precedence above: pair a__U12
#a__U12(x1,x2)	weight: (/ 1 8) + x2 + x1	status: [x1,x2]	precedence above:
a__fst(x1)	weight: (/ 1 8) + x1	status: [x1]	precedence above: fst
a__natsFrom(x1)	weight: x1	status: []	precedence above: natsFrom cons
  tail(x1)	weight: (/ 1 8) + x1	status: []	precedence above: a__tail
#mark(x1)	weight: (/ 1 8)	status: []	precedence above:
     0()	weight: (/ 1 4)	status: []	precedence above:
#a__and(x1,x2)	weight: x1	status: []	precedence above:
   sel(x1,x2)	weight: (/ 7 8) + x2	status: [x2]	precedence above: a__afterNth afterNth a__sel head a__head
afterNth(x1,x2)	weight: (/ 5 8) + x2	status: [x2]	precedence above: a__afterNth
   nil()	weight: (/ 1 8)	status: []	precedence above:
a__splitAt(x1,x2)	weight: max{0, (/ 1 2) + x2}	status: []	precedence above: U11 take pair fst splitAt U12 a__fst nil mark a__U11 a__U12 cons a__take tt
#a__sel(x1,x2)	weight: (/ 1 8) + x2 + x1	status: [x1,x2]	precedence above:
  mark(x1)	weight: x1	status: x1
a__U11(x1,x2,x3,x4)	weight: max{0, (/ 1 2) + x4, (/ 1 4) + x3, (/ 1 8) + x1}	status: []	precedence above: U11 pair U12 a__U12 cons
a__sel(x1,x2)	weight: (/ 7 8) + x2	status: [x2]	precedence above: a__afterNth sel afterNth head a__head
a__U12(x1,x2)	weight: max{(/ 1 4) + x2, x1}	status: []	precedence above: pair U12
  head(x1)	weight: (/ 1 8) + x1	status: [x1]	precedence above: a__head
#a__afterNth(x1,x2)	weight: (/ 1 8) + x1	status: [x1]	precedence above:
#a__splitAt(x1,x2)	weight: max{0, (/ 1 4) + x1}	status: [x1]	precedence above: #a__U11
  cons(x1,x2)	weight: max{x2, x1}	status: []	precedence above:
   snd(x1)	weight: x1	status: x1
a__take(x1,x2)	weight: (/ 3 4) + x2 + x1	status: [x1,x2]	precedence above: take fst a__fst
    tt()	weight: 0	status: []	precedence above: pair mark
#a__fst(x1)	weight: x1	status: []	precedence above:
a__and(x1,x2)	weight: (/ 1 8) + x2 + x1	status: [x2,x1]	precedence above: and
a__tail(x1)	weight: (/ 1 8) + x1	status: []	precedence above: tail
#a__tail(x1)	weight: x1	status: []	precedence above:
a__head(x1)	weight: (/ 1 8) + x1	status: [x1]	precedence above: head
    Usable rules: { 1..43 }
    Removed DPs: #10
Number of SCCs: 0, DPs: 0, edges: 0
