Input TRS:
    1: numbers() -> d(0())
    2: d(x) -> if(le(x,nr()),x)
    3: if(true(),x) -> cons(x,d(s(x)))
    4: if(false(),x) -> nil()
    5: le(0(),y) -> true()
    6: le(s(x),0()) -> false()
    7: le(s(x),s(y)) -> le(x,y)
    8: nr() -> ack(s(s(s(s(s(s(0())))))),0())
    9: ack(0(),x) -> s(x)
    10: ack(s(x),0()) -> ack(x,s(0()))
    11: ack(s(x),s(y)) -> ack(x,ack(s(x),y))
Number of strict rules: 11
Direct Order(PosReal,>,Poly) ... failed.
Freezing ack
1: numbers() -> d(0())
2: d(x) -> if(le(x,nr()),x)
3: if(true(),x) -> cons(x,d(s(x)))
4: if(false(),x) -> nil()
5: le(0(),y) -> true()
6: le(s(x),0()) -> false()
7: le(s(x),s(y)) -> le(x,y)
8: nr() -> ack❆1_s(s(s(s(s(s(0()))))),0())
9: ack❆1_0(x) -> s(x)
10: ack❆1_s(x,0()) -> ack(x,s(0()))
11: ack❆1_s(x,s(y)) -> ack(x,ack❆1_s(x,y))
12: ack(0(),_1) ->= ack❆1_0(_1)
13: ack(s(_1),_2) ->= ack❆1_s(_1,_2)
Number of strict rules: 11
Direct Order(PosReal,>,Poly) ... failed.
Dependency Pairs:
   #1: #d(x) -> #if(le(x,nr()),x)
   #2: #d(x) -> #le(x,nr())
   #3: #d(x) -> #nr()
   #4: #ack(s(_1),_2) ->? #ack❆1_s(_1,_2)
   #5: #ack❆1_s(x,s(y)) -> #ack(x,ack❆1_s(x,y))
   #6: #ack❆1_s(x,s(y)) -> #ack❆1_s(x,y)
   #7: #ack(0(),_1) ->? #ack❆1_0(_1)
   #8: #le(s(x),s(y)) -> #le(x,y)
   #9: #ack❆1_s(x,0()) -> #ack(x,s(0()))
   #10: #if(true(),x) -> #d(s(x))
   #11: #numbers() -> #d(0())
   #12: #nr() -> #ack❆1_s(s(s(s(s(s(0()))))),0())
Number of SCCs: 3, DPs: 7, edges: 11
	SCC { #8 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
    le(x1,x2)	weight: 0
     d(x1)	weight: 0
     s(x1)	weight: (/ 1 2) + x1
  #le(x1,x2)	weight: x2
   ack(x1,x2)	weight: 0
 false()	weight: 0
#ack❆1_0(x1)	weight: 0
#numbers()	weight: 0
  true()	weight: 0
     0()	weight: 0
    if(x1,x2)	weight: 0
    nr()	weight: 0
   nil()	weight: 0
   #d(x1)	weight: 0
  #nr()	weight: 0
ack❆1_0(x1)	weight: 0
 #ack(x1,x2)	weight: 0
  cons(x1,x2)	weight: 0
  #if(x1,x2)	weight: 0
ack❆1_s(x1,x2)	weight: 0
#ack❆1_s(x1,x2)	weight: 0
numbers()	weight: 0
    Usable rules: { }
    Removed DPs: #8
Number of SCCs: 2, DPs: 6, edges: 10
	SCC { #1 #10 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  failed.
