Input TRS:
    1: a(a(divides(),0()),a(s(),y)) -> true()
    2: a(a(divides(),a(s(),x)),a(s(),y)) -> a(a(a(div2(),x),a(s(),y)),y)
    3: a(a(a(div2(),x),y),0()) -> a(a(divides(),x),y)
    4: a(a(a(div2(),0()),y),a(s(),z)) -> false()
    5: a(a(a(div2(),a(s(),x)),y),a(s(),z)) -> a(a(a(div2(),x),y),z)
    6: a(a(filter(),f),nil()) -> nil()
    7: a(a(filter(),f),a(a(cons(),x),xs)) -> a(a(a(if(),a(f,x)),x),a(a(filter(),f),xs))
    8: a(a(a(if(),true()),x),xs) -> a(a(cons(),x),xs)
    9: a(a(a(if(),false()),x),xs) -> xs
    10: a(a(not(),f),x) -> a(not2(),a(f,x))
    11: a(not2(),true()) -> false()
    12: a(not2(),false()) -> true()
    13: a(sieve(),nil()) -> nil()
    14: a(sieve(),a(a(cons(),x),xs)) -> a(a(cons(),x),a(sieve(),a(a(filter(),a(not(),a(divides(),x))),xs)))
Number of strict rules: 14
Direct Order(PosReal,>,Poly) ... failed.
Freezing a
1: a❆2_divides(0(),a❆1_s(y)) -> true()
2: a❆2_divides(a❆1_s(x),a❆1_s(y)) -> a❆3_div2(x,a❆1_s(y),y)
3: a❆3_div2(x,y,0()) -> a❆2_divides(x,y)
4: a❆3_div2(0(),y,a❆1_s(z)) -> false()
5: a❆3_div2(a❆1_s(x),y,a❆1_s(z)) -> a❆3_div2(x,y,z)
6: a❆2_filter(f,nil()) -> nil()
7: a❆2_filter(f,a❆2_cons(x,xs)) -> a❆3_if(a(f,x),x,a❆2_filter(f,xs))
8: a❆3_if(true(),x,xs) -> a❆2_cons(x,xs)
9: a❆3_if(false(),x,xs) -> xs
10: a❆2_not(f,x) -> a❆1_not2(a(f,x))
11: a❆1_not2(true()) -> false()
12: a❆1_not2(false()) -> true()
13: a❆1_sieve(nil()) -> nil()
14: a❆1_sieve(a❆2_cons(x,xs)) -> a❆2_cons(x,a❆1_sieve(a❆2_filter(a❆1_not(a❆1_divides(x)),xs)))
15: a(if(),_1) ->= a❆1_if(_1)
16: a(a❆1_if(_1),_2) ->= a❆2_if(_1,_2)
17: a(a❆2_if(_1,_2),_3) ->= a❆3_if(_1,_2,_3)
18: a(cons(),_1) ->= a❆1_cons(_1)
19: a(a❆1_cons(_1),_2) ->= a❆2_cons(_1,_2)
20: a(s(),_1) ->= a❆1_s(_1)
21: a(div2(),_1) ->= a❆1_div2(_1)
22: a(a❆1_div2(_1),_2) ->= a❆2_div2(_1,_2)
23: a(a❆2_div2(_1,_2),_3) ->= a❆3_div2(_1,_2,_3)
24: a(filter(),_1) ->= a❆1_filter(_1)
25: a(a❆1_filter(_1),_2) ->= a❆2_filter(_1,_2)
26: a(not2(),_1) ->= a❆1_not2(_1)
27: a(divides(),_1) ->= a❆1_divides(_1)
28: a(a❆1_divides(_1),_2) ->= a❆2_divides(_1,_2)
29: a(sieve(),_1) ->= a❆1_sieve(_1)
30: a(not(),_1) ->= a❆1_not(_1)
31: a(a❆1_not(_1),_2) ->= a❆2_not(_1,_2)
Number of strict rules: 14
Direct Order(PosReal,>,Poly) ... failed.
Dependency Pairs:
   #1: #a❆2_divides(a❆1_s(x),a❆1_s(y)) -> #a❆3_div2(x,a❆1_s(y),y)
   #2: #a(sieve(),_1) ->? #a❆1_sieve(_1)
   #3: #a(a❆2_div2(_1,_2),_3) ->? #a❆3_div2(_1,_2,_3)
   #4: #a(a❆1_not(_1),_2) ->? #a❆2_not(_1,_2)
   #5: #a❆1_sieve(a❆2_cons(x,xs)) -> #a❆1_sieve(a❆2_filter(a❆1_not(a❆1_divides(x)),xs))
   #6: #a❆1_sieve(a❆2_cons(x,xs)) -> #a❆2_filter(a❆1_not(a❆1_divides(x)),xs)
   #7: #a(a❆1_filter(_1),_2) ->? #a❆2_filter(_1,_2)
   #8: #a❆2_filter(f,a❆2_cons(x,xs)) -> #a❆3_if(a(f,x),x,a❆2_filter(f,xs))
   #9: #a❆2_filter(f,a❆2_cons(x,xs)) -> #a(f,x)
   #10: #a❆2_filter(f,a❆2_cons(x,xs)) -> #a❆2_filter(f,xs)
   #11: #a❆2_not(f,x) -> #a❆1_not2(a(f,x))
   #12: #a❆2_not(f,x) -> #a(f,x)
   #13: #a❆3_div2(a❆1_s(x),y,a❆1_s(z)) -> #a❆3_div2(x,y,z)
   #14: #a(a❆1_divides(_1),_2) ->? #a❆2_divides(_1,_2)
   #15: #a(a❆2_if(_1,_2),_3) ->? #a❆3_if(_1,_2,_3)
   #16: #a(not2(),_1) ->? #a❆1_not2(_1)
   #17: #a❆3_div2(x,y,0()) -> #a❆2_divides(x,y)
Number of SCCs: 2, DPs: 11, edges: 22
	SCC { #1 #13 #17 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
     a(x1,x2)	weight: 0
a❆1_filter(x1)	weight: 0
a❆1_div2(x1)	weight: 0
#a❆3_if(x1,x2,x3)	weight: 0
     s()	weight: 0
a❆2_div2(x1,x2)	weight: 0
a❆3_if(x1,x2,x3)	weight: 0
a❆1_divides(x1)	weight: 0
 false()	weight: 0
a❆1_cons(x1)	weight: 0
  true()	weight: 0
#a❆1_not2(x1)	weight: 0
a❆2_if(x1,x2)	weight: 0
#a❆2_divides(x1,x2)	weight: x1 + x2
a❆3_div2(x1,x2,x3)	weight: 0
a❆2_divides(x1,x2)	weight: 0
a❆1_s(x1)	weight: (/ 1 2) + x1
a❆2_filter(x1,x2)	weight: 0
     0()	weight: 0
    if()	weight: 0
a❆1_sieve(x1)	weight: 0
a❆2_cons(x1,x2)	weight: 0
a❆1_if(x1)	weight: 0
  div2()	weight: 0
   nil()	weight: 0
  not2()	weight: 0
 sieve()	weight: 0
#a❆1_sieve(x1)	weight: 0
a❆1_not(x1)	weight: 0
#a❆2_not(x1,x2)	weight: 0
  cons()	weight: 0
   #a(x1,x2)	weight: 0
#a❆3_div2(x1,x2,x3)	weight: (/ 1 4) + x1 + x2
a❆2_not(x1,x2)	weight: 0
filter()	weight: 0
#a❆2_filter(x1,x2)	weight: 0
a❆1_not2(x1)	weight: 0
divides()	weight: 0
   not()	weight: 0
    Usable rules: { }
    Removed DPs: #1 #13 #17
Number of SCCs: 1, DPs: 8, edges: 17
	SCC { #2 #4..7 #9 #10 #12 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
     a(x1,x2)	weight: (/ 1 8) + x1
a❆1_filter(x1)	weight: (/ 1 4) + x1
a❆1_div2(x1)	weight: (/ 1 4) + x1
#a❆3_if(x1,x2,x3)	weight: 0
     s()	weight: 0
a❆2_div2(x1,x2)	weight: (/ 1 2)
a❆3_if(x1,x2,x3)	weight: (/ 3 4) + x2 + x3
a❆1_divides(x1)	weight: (/ 1 4)
 false()	weight: 0
a❆1_cons(x1)	weight: (/ 1 4)
  true()	weight: 0
#a❆1_not2(x1)	weight: 0
a❆2_if(x1,x2)	weight: (/ 1 2) + x1
#a❆2_divides(x1,x2)	weight: 0
a❆3_div2(x1,x2,x3)	weight: (/ 3 4) + x1 + x2
a❆2_divides(x1,x2)	weight: (/ 1 2) + x1
a❆1_s(x1)	weight: (/ 1 4) + x1
a❆2_filter(x1,x2)	weight: (/ 1 2) + x2
     0()	weight: 0
    if()	weight: 0
a❆1_sieve(x1)	weight: (/ 1 4) + x1
a❆2_cons(x1,x2)	weight: (/ 3 4) + x1 + x2
a❆1_if(x1)	weight: (/ 1 4) + x1
  div2()	weight: 0
   nil()	weight: 0
  not2()	weight: 0
 sieve()	weight: 0
#a❆1_sieve(x1)	weight: x1
a❆1_not(x1)	weight: (/ 1 4) + x1
#a❆2_not(x1,x2)	weight: (/ 1 8) + x2
  cons()	weight: 0
   #a(x1,x2)	weight: (/ 1 8) + x2
#a❆3_div2(x1,x2,x3)	weight: (/ 1 8)
a❆2_not(x1,x2)	weight: (/ 1 2)
filter()	weight: 0
#a❆2_filter(x1,x2)	weight: x2
a❆1_not2(x1)	weight: (/ 5 8)
divides()	weight: 0
   not()	weight: 0
    Usable rules: { 6..9 }
    Removed DPs: #2 #5..7 #9 #10
Number of SCCs: 1, DPs: 2, edges: 2
	SCC { #4 #12 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
     a(x1,x2)	weight: (/ 1 8) + x1
a❆1_filter(x1)	weight: (/ 1 4) + x1
a❆1_div2(x1)	weight: (/ 1 4) + x1
#a❆3_if(x1,x2,x3)	weight: 0
     s()	weight: 0
a❆2_div2(x1,x2)	weight: (/ 1 2)
a❆3_if(x1,x2,x3)	weight: (/ 3 4) + x2 + x3
a❆1_divides(x1)	weight: (/ 1 4)
 false()	weight: 0
a❆1_cons(x1)	weight: (/ 1 4)
  true()	weight: 0
#a❆1_not2(x1)	weight: 0
a❆2_if(x1,x2)	weight: (/ 1 2) + x1
#a❆2_divides(x1,x2)	weight: 0
a❆3_div2(x1,x2,x3)	weight: (/ 3 4) + x1 + x2
a❆2_divides(x1,x2)	weight: (/ 1 2) + x1
a❆1_s(x1)	weight: (/ 1 4) + x1
a❆2_filter(x1,x2)	weight: (/ 1 2) + x2
     0()	weight: 0
    if()	weight: 0
a❆1_sieve(x1)	weight: (/ 1 4) + x1
a❆2_cons(x1,x2)	weight: (/ 3 4) + x1 + x2
a❆1_if(x1)	weight: (/ 1 4) + x1
  div2()	weight: 0
   nil()	weight: 0
  not2()	weight: 0
 sieve()	weight: 0
#a❆1_sieve(x1)	weight: x1
a❆1_not(x1)	weight: (/ 1 4) + x1
#a❆2_not(x1,x2)	weight: (/ 1 8) + x1
  cons()	weight: 0
   #a(x1,x2)	weight: x1
#a❆3_div2(x1,x2,x3)	weight: (/ 1 8)
a❆2_not(x1,x2)	weight: (/ 1 2)
filter()	weight: 0
#a❆2_filter(x1,x2)	weight: 0
a❆1_not2(x1)	weight: (/ 5 8)
divides()	weight: 0
   not()	weight: 0
    Usable rules: { }
    Removed DPs: #4 #12
Number of SCCs: 0, DPs: 0, edges: 0
