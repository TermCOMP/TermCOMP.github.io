Input TRS:
    1: and(tt(),T) -> T
    2: isNatIList(IL) -> isNatList(activate(IL))
    3: isNat(n__0()) -> tt()
    4: isNat(n__s(N)) -> isNat(activate(N))
    5: isNat(n__length(L)) -> isNatList(activate(L))
    6: isNatIList(n__zeros()) -> tt()
    7: isNatIList(n__cons(N,IL)) -> and(isNat(activate(N)),isNatIList(activate(IL)))
    8: isNatList(n__nil()) -> tt()
    9: isNatList(n__cons(N,L)) -> and(isNat(activate(N)),isNatList(activate(L)))
    10: isNatList(n__take(N,IL)) -> and(isNat(activate(N)),isNatIList(activate(IL)))
    11: zeros() -> cons(0(),n__zeros())
    12: take(0(),IL) -> uTake1(isNatIList(IL))
    13: uTake1(tt()) -> nil()
    14: take(s(M),cons(N,IL)) -> uTake2(and(isNat(M),and(isNat(N),isNatIList(activate(IL)))),M,N,activate(IL))
    15: uTake2(tt(),M,N,IL) -> cons(activate(N),n__take(activate(M),activate(IL)))
    16: length(cons(N,L)) -> uLength(and(isNat(N),isNatList(activate(L))),activate(L))
    17: uLength(tt(),L) -> s(length(activate(L)))
    18: 0() -> n__0()
    19: s(X) -> n__s(X)
    20: length(X) -> n__length(X)
    21: zeros() -> n__zeros()
    22: cons(X1,X2) -> n__cons(X1,X2)
    23: nil() -> n__nil()
    24: take(X1,X2) -> n__take(X1,X2)
    25: activate(n__0()) -> 0()
    26: activate(n__s(X)) -> s(activate(X))
    27: activate(n__length(X)) -> length(activate(X))
    28: activate(n__zeros()) -> zeros()
    29: activate(n__cons(X1,X2)) -> cons(activate(X1),X2)
    30: activate(n__nil()) -> nil()
    31: activate(n__take(X1,X2)) -> take(activate(X1),activate(X2))
    32: activate(X) -> X
Number of strict rules: 32
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #isNatIList(IL) -> #isNatList(activate(IL))
   #2: #isNatIList(IL) -> #activate(IL)
   #3: #activate(n__cons(X1,X2)) -> #cons(activate(X1),X2)
   #4: #activate(n__cons(X1,X2)) -> #activate(X1)
   #5: #uTake1(tt()) -> #nil()
   #6: #isNatList(n__cons(N,L)) -> #and(isNat(activate(N)),isNatList(activate(L)))
   #7: #isNatList(n__cons(N,L)) -> #isNat(activate(N))
   #8: #isNatList(n__cons(N,L)) -> #activate(N)
   #9: #isNatList(n__cons(N,L)) -> #isNatList(activate(L))
   #10: #isNatList(n__cons(N,L)) -> #activate(L)
   #11: #zeros() -> #cons(0(),n__zeros())
   #12: #zeros() -> #0()
   #13: #take(0(),IL) -> #uTake1(isNatIList(IL))
   #14: #take(0(),IL) -> #isNatIList(IL)
   #15: #activate(n__take(X1,X2)) -> #take(activate(X1),activate(X2))
   #16: #activate(n__take(X1,X2)) -> #activate(X1)
   #17: #activate(n__take(X1,X2)) -> #activate(X2)
   #18: #take(s(M),cons(N,IL)) -> #uTake2(and(isNat(M),and(isNat(N),isNatIList(activate(IL)))),M,N,activate(IL))
   #19: #take(s(M),cons(N,IL)) -> #and(isNat(M),and(isNat(N),isNatIList(activate(IL))))
   #20: #take(s(M),cons(N,IL)) -> #isNat(M)
   #21: #take(s(M),cons(N,IL)) -> #and(isNat(N),isNatIList(activate(IL)))
   #22: #take(s(M),cons(N,IL)) -> #isNat(N)
   #23: #take(s(M),cons(N,IL)) -> #isNatIList(activate(IL))
   #24: #take(s(M),cons(N,IL)) -> #activate(IL)
   #25: #take(s(M),cons(N,IL)) -> #activate(IL)
   #26: #activate(n__nil()) -> #nil()
   #27: #activate(n__0()) -> #0()
   #28: #isNatIList(n__cons(N,IL)) -> #and(isNat(activate(N)),isNatIList(activate(IL)))
   #29: #isNatIList(n__cons(N,IL)) -> #isNat(activate(N))
   #30: #isNatIList(n__cons(N,IL)) -> #activate(N)
   #31: #isNatIList(n__cons(N,IL)) -> #isNatIList(activate(IL))
   #32: #isNatIList(n__cons(N,IL)) -> #activate(IL)
   #33: #isNatList(n__take(N,IL)) -> #and(isNat(activate(N)),isNatIList(activate(IL)))
   #34: #isNatList(n__take(N,IL)) -> #isNat(activate(N))
   #35: #isNatList(n__take(N,IL)) -> #activate(N)
   #36: #isNatList(n__take(N,IL)) -> #isNatIList(activate(IL))
   #37: #isNatList(n__take(N,IL)) -> #activate(IL)
   #38: #isNat(n__length(L)) -> #isNatList(activate(L))
   #39: #isNat(n__length(L)) -> #activate(L)
   #40: #activate(n__zeros()) -> #zeros()
   #41: #activate(n__length(X)) -> #length(activate(X))
   #42: #activate(n__length(X)) -> #activate(X)
   #43: #uLength(tt(),L) -> #s(length(activate(L)))
   #44: #uLength(tt(),L) -> #length(activate(L))
   #45: #uLength(tt(),L) -> #activate(L)
   #46: #activate(n__s(X)) -> #s(activate(X))
   #47: #activate(n__s(X)) -> #activate(X)
   #48: #length(cons(N,L)) -> #uLength(and(isNat(N),isNatList(activate(L))),activate(L))
   #49: #length(cons(N,L)) -> #and(isNat(N),isNatList(activate(L)))
   #50: #length(cons(N,L)) -> #isNat(N)
   #51: #length(cons(N,L)) -> #isNatList(activate(L))
   #52: #length(cons(N,L)) -> #activate(L)
   #53: #length(cons(N,L)) -> #activate(L)
   #54: #uTake2(tt(),M,N,IL) -> #cons(activate(N),n__take(activate(M),activate(IL)))
   #55: #uTake2(tt(),M,N,IL) -> #activate(N)
   #56: #uTake2(tt(),M,N,IL) -> #activate(M)
   #57: #uTake2(tt(),M,N,IL) -> #activate(IL)
   #58: #isNat(n__s(N)) -> #isNat(activate(N))
   #59: #isNat(n__s(N)) -> #activate(N)
Number of SCCs: 1, DPs: 42, edges: 260
	SCC { #1 #2 #4 #7..10 #14..18 #20 #22..25 #29..32 #34..39 #41 #42 #44 #45 #47 #48 #50..53 #55..59 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#uTake2(x1,x2,x3,x4)	weight: x2 + x3 + x4
   #0()	weight: 0
isNatList(x1)	weight: (/ 1 2)
#cons(x1,x2)	weight: 0
     s(x1)	weight: x1
#isNat(x1)	weight: x1
#take(x1,x2)	weight: x1 + x2
activate(x1)	weight: x1
  take(x1,x2)	weight: (/ 1 4) + x1 + x2
#uTake1(x1)	weight: 0
   and(x1,x2)	weight: x2
n__zeros()	weight: 0
isNatIList(x1)	weight: (/ 1 2)
#activate(x1)	weight: x1
 zeros()	weight: 0
n__nil()	weight: 0
uTake2(x1,x2,x3,x4)	weight: (/ 1 4) + x2 + x3 + x4
  n__s(x1)	weight: x1
uLength(x1,x2)	weight: (/ 1 2) + x2
     0()	weight: 0
#zeros()	weight: 0
n__take(x1,x2)	weight: (/ 1 4) + x1 + x2
#isNatList(x1)	weight: x1
   #s(x1)	weight: 0
n__cons(x1,x2)	weight: x1 + x2
   nil()	weight: 0
 #nil()	weight: 0
  n__0()	weight: 0
n__length(x1)	weight: (/ 1 2) + x1
 isNat(x1)	weight: (/ 1 4)
  cons(x1,x2)	weight: x1 + x2
#isNatIList(x1)	weight: x1
    tt()	weight: 0
uTake1(x1)	weight: 0
length(x1)	weight: (/ 1 2) + x1
#length(x1)	weight: (/ 1 4) + x1
 #and(x1,x2)	weight: 0
#uLength(x1,x2)	weight: (/ 1 4) + x2
    Usable rules: { 1 2 6..32 }
    Removed DPs: #15..17 #34..39 #41 #42 #45 #50..53
Number of SCCs: 5, DPs: 7, edges: 9
	SCC { #58 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... succeeded.
#uTake2(x1,x2,x3,x4)	weight: 0; 0
   #0()	weight: 0; 0
isNatList(x1)	weight: x1_2; (/ 1 8)
#cons(x1,x2)	weight: 0; 0
     s(x1)	weight: (/ 1 8); (/ 3 8) + x1_2
#isNat(x1)	weight: x1_2; 0
#take(x1,x2)	weight: 0; 0
activate(x1)	weight: x1_1; x1_2
  take(x1,x2)	weight: (/ 1 8) + x2_1 + x1_2; (/ 3 8) + x2_2
#uTake1(x1)	weight: 0; 0
   and(x1,x2)	weight: x2_1; x2_2
n__zeros()	weight: (/ 1 8); 0
isNatIList(x1)	weight: (/ 3 8) + x1_2; (/ 1 8)
#activate(x1)	weight: 0; 0
 zeros()	weight: (/ 1 8); 0
n__nil()	weight: (/ 1 8); (/ 3 8)
uTake2(x1,x2,x3,x4)	weight: (/ 1 2) + x4_1 + x4_2 + x2_2; (/ 3 8) + x4_2
  n__s(x1)	weight: (/ 1 8); (/ 3 8) + x1_2
uLength(x1,x2)	weight: (/ 1 8) + x2_2 + x1_2; x2_1 + x1_1
     0()	weight: (/ 1 8); (/ 1 8)
#zeros()	weight: 0; 0
n__take(x1,x2)	weight: (/ 1 8) + x2_1 + x1_2; (/ 3 8) + x2_2
#isNatList(x1)	weight: 0; 0
   #s(x1)	weight: 0; 0
n__cons(x1,x2)	weight: x2_1 + x2_2; x2_2
   nil()	weight: (/ 1 8); (/ 3 8)
 #nil()	weight: 0; 0
  n__0()	weight: (/ 1 8); (/ 1 8)
n__length(x1)	weight: (/ 1 4) + x1_1; x1_1
 isNat(x1)	weight: (/ 1 8) + x1_1; (/ 1 8) + x1_1 + x1_2
  cons(x1,x2)	weight: x2_1 + x2_2; x2_2
#isNatIList(x1)	weight: 0; 0
    tt()	weight: (/ 3 8); 0
uTake1(x1)	weight: (/ 1 8); (/ 3 8)
length(x1)	weight: (/ 1 4) + x1_1; x1_1
#length(x1)	weight: 0; 0
 #and(x1,x2)	weight: 0; 0
#uLength(x1,x2)	weight: 0; 0
    Usable rules: { 1 2 6..32 }
    Removed DPs: #58
Number of SCCs: 4, DPs: 6, edges: 8
	SCC { #9 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  found.
  #isNatList(n__cons(N,n__zeros()))	-#9->
  #isNatList(activate(n__zeros()))	--->*
  #isNatList(n__cons(0(),n__zeros()))
  Looping with: [ N := 0(); ]
