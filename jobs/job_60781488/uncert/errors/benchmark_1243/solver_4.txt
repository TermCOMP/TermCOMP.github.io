Input TRS:
    1: U11(tt(),N,X,XS) -> U12(splitAt(activate(N),activate(XS)),activate(X))
    2: U12(pair(YS,ZS),X) -> pair(cons(activate(X),YS),ZS)
    3: afterNth(N,XS) -> snd(splitAt(N,XS))
    4: and(tt(),X) -> activate(X)
    5: fst(pair(X,Y)) -> X
    6: head(cons(N,XS)) -> N
    7: natsFrom(N) -> cons(N,n__natsFrom(n__s(N)))
    8: sel(N,XS) -> head(afterNth(N,XS))
    9: snd(pair(X,Y)) -> Y
    10: splitAt(0(),XS) -> pair(nil(),XS)
    11: splitAt(s(N),cons(X,XS)) -> U11(tt(),N,X,activate(XS))
    12: tail(cons(N,XS)) -> activate(XS)
    13: take(N,XS) -> fst(splitAt(N,XS))
    14: natsFrom(X) -> n__natsFrom(X)
    15: s(X) -> n__s(X)
    16: activate(n__natsFrom(X)) -> natsFrom(activate(X))
    17: activate(n__s(X)) -> s(activate(X))
    18: activate(X) -> X
Number of strict rules: 18
Direct Order(PosReal,>,Poly) ... failed.
Freezing U11
1: U11❆1_tt(N,X,XS) -> U12(splitAt(activate(N),activate(XS)),activate(X))
2: U12(pair(YS,ZS),X) -> pair(cons(activate(X),YS),ZS)
3: afterNth(N,XS) -> snd(splitAt(N,XS))
4: and(tt(),X) -> activate(X)
5: fst(pair(X,Y)) -> X
6: head(cons(N,XS)) -> N
7: natsFrom(N) -> cons(N,n__natsFrom(n__s(N)))
8: sel(N,XS) -> head(afterNth(N,XS))
9: snd(pair(X,Y)) -> Y
10: splitAt(0(),XS) -> pair(nil(),XS)
11: splitAt(s(N),cons(X,XS)) -> U11❆1_tt(N,X,activate(XS))
12: tail(cons(N,XS)) -> activate(XS)
13: take(N,XS) -> fst(splitAt(N,XS))
14: natsFrom(X) -> n__natsFrom(X)
15: s(X) -> n__s(X)
16: activate(n__natsFrom(X)) -> natsFrom(activate(X))
17: activate(n__s(X)) -> s(activate(X))
18: activate(X) -> X
19: U11(tt(),_3,_4,_5) ->= U11❆1_tt(_3,_4,_5)
Number of strict rules: 18
Direct Order(PosReal,>,Poly) ... failed.
Dependency Pairs:
   #1: #U12(pair(YS,ZS),X) -> #activate(X)
   #2: #take(N,XS) -> #fst(splitAt(N,XS))
   #3: #take(N,XS) -> #splitAt(N,XS)
   #4: #splitAt(s(N),cons(X,XS)) -> #U11❆1_tt(N,X,activate(XS))
   #5: #splitAt(s(N),cons(X,XS)) -> #activate(XS)
   #6: #tail(cons(N,XS)) -> #activate(XS)
   #7: #activate(n__s(X)) -> #s(activate(X))
   #8: #activate(n__s(X)) -> #activate(X)
   #9: #U11(tt(),_3,_4,_5) ->? #U11❆1_tt(_3,_4,_5)
   #10: #activate(n__natsFrom(X)) -> #natsFrom(activate(X))
   #11: #activate(n__natsFrom(X)) -> #activate(X)
   #12: #afterNth(N,XS) -> #snd(splitAt(N,XS))
   #13: #afterNth(N,XS) -> #splitAt(N,XS)
   #14: #U11❆1_tt(N,X,XS) -> #U12(splitAt(activate(N),activate(XS)),activate(X))
   #15: #U11❆1_tt(N,X,XS) -> #splitAt(activate(N),activate(XS))
   #16: #U11❆1_tt(N,X,XS) -> #activate(N)
   #17: #U11❆1_tt(N,X,XS) -> #activate(XS)
   #18: #U11❆1_tt(N,X,XS) -> #activate(X)
   #19: #sel(N,XS) -> #head(afterNth(N,XS))
   #20: #sel(N,XS) -> #afterNth(N,XS)
   #21: #and(tt(),X) -> #activate(X)
Number of SCCs: 2, DPs: 4, edges: 6
	SCC { #8 #11 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
   U11(x1,x2,x3,x4)	weight: 0
     s(x1)	weight: 0
#take(x1,x2)	weight: 0
activate(x1)	weight: 0
  take(x1,x2)	weight: 0
   and(x1,x2)	weight: 0
  pair(x1,x2)	weight: 0
   fst(x1)	weight: 0
#activate(x1)	weight: x1
natsFrom(x1)	weight: 0
#head(x1)	weight: 0
splitAt(x1,x2)	weight: 0
 #fst(x1)	weight: 0
   U12(x1,x2)	weight: 0
U11❆1_tt(x1,x2,x3)	weight: 0
n__natsFrom(x1)	weight: (/ 1 2) + x1
  n__s(x1)	weight: (/ 1 2) + x1
 #U12(x1,x2)	weight: 0
  tail(x1)	weight: 0
     0()	weight: 0
 #sel(x1,x2)	weight: 0
   sel(x1,x2)	weight: 0
   #s(x1)	weight: 0
afterNth(x1,x2)	weight: 0
   nil()	weight: 0
#tail(x1)	weight: 0
#splitAt(x1,x2)	weight: 0
#afterNth(x1,x2)	weight: 0
#U11❆1_tt(x1,x2,x3)	weight: 0
 #U11(x1,x2,x3,x4)	weight: 0
  head(x1)	weight: 0
 #snd(x1)	weight: 0
  cons(x1,x2)	weight: 0
#natsFrom(x1)	weight: 0
   snd(x1)	weight: 0
    tt()	weight: 0
 #and(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #8 #11
Number of SCCs: 1, DPs: 2, edges: 2
	SCC { #4 #15 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
   U11(x1,x2,x3,x4)	weight: 0
     s(x1)	weight: (/ 3 4) + x1
#take(x1,x2)	weight: 0
activate(x1)	weight: (/ 1 4) + x1
  take(x1,x2)	weight: 0
   and(x1,x2)	weight: 0
  pair(x1,x2)	weight: 0
   fst(x1)	weight: 0
#activate(x1)	weight: 0
natsFrom(x1)	weight: (/ 1 4)
#head(x1)	weight: 0
splitAt(x1,x2)	weight: 0
 #fst(x1)	weight: 0
   U12(x1,x2)	weight: 0
U11❆1_tt(x1,x2,x3)	weight: 0
n__natsFrom(x1)	weight: (/ 1 4)
  n__s(x1)	weight: (/ 3 4) + x1
 #U12(x1,x2)	weight: 0
  tail(x1)	weight: 0
     0()	weight: 0
 #sel(x1,x2)	weight: 0
   sel(x1,x2)	weight: 0
   #s(x1)	weight: 0
afterNth(x1,x2)	weight: 0
   nil()	weight: 0
#tail(x1)	weight: 0
#splitAt(x1,x2)	weight: x1
#afterNth(x1,x2)	weight: 0
#U11❆1_tt(x1,x2,x3)	weight: (/ 1 2) + x1
 #U11(x1,x2,x3,x4)	weight: 0
  head(x1)	weight: 0
 #snd(x1)	weight: 0
  cons(x1,x2)	weight: (/ 1 4)
#natsFrom(x1)	weight: 0
   snd(x1)	weight: 0
    tt()	weight: 0
 #and(x1,x2)	weight: 0
    Usable rules: { 7 14..18 }
    Removed DPs: #4 #15
Number of SCCs: 0, DPs: 0, edges: 0
