Input TRS:
    1: lcm(x,y) -> lcmIter(x,y,0(),times(x,y))
    2: lcmIter(x,y,z,u) -> if(or(ge(0(),x),ge(z,u)),x,y,z,u)
    3: if(true(),x,y,z,u) -> z
    4: if(false(),x,y,z,u) -> if2(divisible(z,y),x,y,z,u)
    5: if2(true(),x,y,z,u) -> z
    6: if2(false(),x,y,z,u) -> lcmIter(x,y,plus(x,z),u)
    7: plus(0(),y) -> y
    8: plus(s(x),y) -> s(plus(x,y))
    9: times(x,y) -> ifTimes(ge(0(),x),x,y)
    10: ifTimes(true(),x,y) -> 0()
    11: ifTimes(false(),x,y) -> plus(y,times(y,p(x)))
    12: p(s(x)) -> x
    13: p(0()) -> s(s(0()))
    14: ge(x,0()) -> true()
    15: ge(0(),s(y)) -> false()
    16: ge(s(x),s(y)) -> ge(x,y)
    17: or(true(),y) -> true()
    18: or(false(),y) -> y
    19: divisible(0(),s(y)) -> true()
    20: divisible(s(x),s(y)) -> div(s(x),s(y),s(y))
    21: div(x,y,0()) -> divisible(x,y)
    22: div(0(),y,s(z)) -> false()
    23: div(s(x),y,s(z)) -> div(x,y,z)
    24: a() -> b()
    25: a() -> c()
Number of strict rules: 25
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #lcmIter(x,y,z,u) -> #if(or(ge(0(),x),ge(z,u)),x,y,z,u)
   #2: #lcmIter(x,y,z,u) -> #or(ge(0(),x),ge(z,u))
   #3: #lcmIter(x,y,z,u) -> #ge(0(),x)
   #4: #lcmIter(x,y,z,u) -> #ge(z,u)
   #5: #if2(false(),x,y,z,u) -> #lcmIter(x,y,plus(x,z),u)
   #6: #if2(false(),x,y,z,u) -> #plus(x,z)
   #7: #times(x,y) -> #ifTimes(ge(0(),x),x,y)
   #8: #times(x,y) -> #ge(0(),x)
   #9: #ifTimes(false(),x,y) -> #plus(y,times(y,p(x)))
   #10: #ifTimes(false(),x,y) -> #times(y,p(x))
   #11: #ifTimes(false(),x,y) -> #p(x)
   #12: #div(s(x),y,s(z)) -> #div(x,y,z)
   #13: #divisible(s(x),s(y)) -> #div(s(x),s(y),s(y))
   #14: #div(x,y,0()) -> #divisible(x,y)
   #15: #ge(s(x),s(y)) -> #ge(x,y)
   #16: #lcm(x,y) -> #lcmIter(x,y,0(),times(x,y))
   #17: #lcm(x,y) -> #times(x,y)
   #18: #plus(s(x),y) -> #plus(x,y)
   #19: #if(false(),x,y,z,u) -> #if2(divisible(z,y),x,y,z,u)
   #20: #if(false(),x,y,z,u) -> #divisible(z,y)
Number of SCCs: 5, DPs: 10, edges: 11
	SCC { #18 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#lcmIter(x1,x2,x3,x4)	weight: 0
     a()	weight: 0
ifTimes(x1,x2,x3)	weight: 0
 #div(x1,x2,x3)	weight: 0
     s(x1)	weight: (/ 1 2) + x1
     b()	weight: 0
#plus(x1,x2)	weight: x1
divisible(x1,x2)	weight: 0
#divisible(x1,x2)	weight: 0
 false()	weight: 0
   div(x1,x2,x3)	weight: 0
  #ge(x1,x2)	weight: 0
     c()	weight: 0
   #p(x1)	weight: 0
lcmIter(x1,x2,x3,x4)	weight: 0
  true()	weight: 0
   if2(x1,x2,x3,x4,x5)	weight: 0
     p(x1)	weight: 0
#times(x1,x2)	weight: 0
     0()	weight: 0
    if(x1,x2,x3,x4,x5)	weight: 0
 #lcm(x1,x2)	weight: 0
    ge(x1,x2)	weight: 0
 times(x1,x2)	weight: 0
    or(x1,x2)	weight: 0
  plus(x1,x2)	weight: 0
  #if(x1,x2,x3,x4,x5)	weight: 0
   #a()	weight: 0
  #or(x1,x2)	weight: 0
 #if2(x1,x2,x3,x4,x5)	weight: 0
#ifTimes(x1,x2,x3)	weight: 0
   lcm(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #18
Number of SCCs: 4, DPs: 9, edges: 10
	SCC { #15 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#lcmIter(x1,x2,x3,x4)	weight: 0
     a()	weight: 0
ifTimes(x1,x2,x3)	weight: 0
 #div(x1,x2,x3)	weight: 0
     s(x1)	weight: (/ 1 2) + x1
     b()	weight: 0
#plus(x1,x2)	weight: 0
divisible(x1,x2)	weight: 0
#divisible(x1,x2)	weight: 0
 false()	weight: 0
   div(x1,x2,x3)	weight: 0
  #ge(x1,x2)	weight: x2
     c()	weight: 0
   #p(x1)	weight: 0
lcmIter(x1,x2,x3,x4)	weight: 0
  true()	weight: 0
   if2(x1,x2,x3,x4,x5)	weight: 0
     p(x1)	weight: 0
#times(x1,x2)	weight: 0
     0()	weight: 0
    if(x1,x2,x3,x4,x5)	weight: 0
 #lcm(x1,x2)	weight: 0
    ge(x1,x2)	weight: 0
 times(x1,x2)	weight: 0
    or(x1,x2)	weight: 0
  plus(x1,x2)	weight: 0
  #if(x1,x2,x3,x4,x5)	weight: 0
   #a()	weight: 0
  #or(x1,x2)	weight: 0
 #if2(x1,x2,x3,x4,x5)	weight: 0
#ifTimes(x1,x2,x3)	weight: 0
   lcm(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #15
Number of SCCs: 3, DPs: 8, edges: 9
	SCC { #7 #10 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  failed.
