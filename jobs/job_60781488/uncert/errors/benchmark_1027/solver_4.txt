Input TRS:
    1: active(from(X)) -> mark(cons(X,from(s(X))))
    2: active(sel(0(),cons(X,XS))) -> mark(X)
    3: active(sel(s(N),cons(X,XS))) -> mark(sel(N,XS))
    4: active(minus(X,0())) -> mark(0())
    5: active(minus(s(X),s(Y))) -> mark(minus(X,Y))
    6: active(quot(0(),s(Y))) -> mark(0())
    7: active(quot(s(X),s(Y))) -> mark(s(quot(minus(X,Y),s(Y))))
    8: active(zWquot(XS,nil())) -> mark(nil())
    9: active(zWquot(nil(),XS)) -> mark(nil())
    10: active(zWquot(cons(X,XS),cons(Y,YS))) -> mark(cons(quot(X,Y),zWquot(XS,YS)))
    11: active(from(X)) -> from(active(X))
    12: active(cons(X1,X2)) -> cons(active(X1),X2)
    13: active(s(X)) -> s(active(X))
    14: active(sel(X1,X2)) -> sel(active(X1),X2)
    15: active(sel(X1,X2)) -> sel(X1,active(X2))
    16: active(minus(X1,X2)) -> minus(active(X1),X2)
    17: active(minus(X1,X2)) -> minus(X1,active(X2))
    18: active(quot(X1,X2)) -> quot(active(X1),X2)
    19: active(quot(X1,X2)) -> quot(X1,active(X2))
    20: active(zWquot(X1,X2)) -> zWquot(active(X1),X2)
    21: active(zWquot(X1,X2)) -> zWquot(X1,active(X2))
    22: from(mark(X)) -> mark(from(X))
    23: cons(mark(X1),X2) -> mark(cons(X1,X2))
    24: s(mark(X)) -> mark(s(X))
    25: sel(mark(X1),X2) -> mark(sel(X1,X2))
    26: sel(X1,mark(X2)) -> mark(sel(X1,X2))
    27: minus(mark(X1),X2) -> mark(minus(X1,X2))
    28: minus(X1,mark(X2)) -> mark(minus(X1,X2))
    29: quot(mark(X1),X2) -> mark(quot(X1,X2))
    30: quot(X1,mark(X2)) -> mark(quot(X1,X2))
    31: zWquot(mark(X1),X2) -> mark(zWquot(X1,X2))
    32: zWquot(X1,mark(X2)) -> mark(zWquot(X1,X2))
    33: proper(from(X)) -> from(proper(X))
    34: proper(cons(X1,X2)) -> cons(proper(X1),proper(X2))
    35: proper(s(X)) -> s(proper(X))
    36: proper(sel(X1,X2)) -> sel(proper(X1),proper(X2))
    37: proper(0()) -> ok(0())
    38: proper(minus(X1,X2)) -> minus(proper(X1),proper(X2))
    39: proper(quot(X1,X2)) -> quot(proper(X1),proper(X2))
    40: proper(zWquot(X1,X2)) -> zWquot(proper(X1),proper(X2))
    41: proper(nil()) -> ok(nil())
    42: from(ok(X)) -> ok(from(X))
    43: cons(ok(X1),ok(X2)) -> ok(cons(X1,X2))
    44: s(ok(X)) -> ok(s(X))
    45: sel(ok(X1),ok(X2)) -> ok(sel(X1,X2))
    46: minus(ok(X1),ok(X2)) -> ok(minus(X1,X2))
    47: quot(ok(X1),ok(X2)) -> ok(quot(X1,X2))
    48: zWquot(ok(X1),ok(X2)) -> ok(zWquot(X1,X2))
    49: top(mark(X)) -> top(proper(X))
    50: top(ok(X)) -> top(active(X))
Number of strict rules: 50
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #cons(ok(X1),ok(X2)) -> #cons(X1,X2)
   #2: #quot(mark(X1),X2) -> #quot(X1,X2)
   #3: #proper(s(X)) -> #s(proper(X))
   #4: #proper(s(X)) -> #proper(X)
   #5: #minus(ok(X1),ok(X2)) -> #minus(X1,X2)
   #6: #from(ok(X)) -> #from(X)
   #7: #quot(ok(X1),ok(X2)) -> #quot(X1,X2)
   #8: #zWquot(ok(X1),ok(X2)) -> #zWquot(X1,X2)
   #9: #proper(minus(X1,X2)) -> #minus(proper(X1),proper(X2))
   #10: #proper(minus(X1,X2)) -> #proper(X1)
   #11: #proper(minus(X1,X2)) -> #proper(X2)
   #12: #proper(zWquot(X1,X2)) -> #zWquot(proper(X1),proper(X2))
   #13: #proper(zWquot(X1,X2)) -> #proper(X1)
   #14: #proper(zWquot(X1,X2)) -> #proper(X2)
   #15: #active(s(X)) -> #s(active(X))
   #16: #active(s(X)) -> #active(X)
   #17: #active(from(X)) -> #from(active(X))
   #18: #active(from(X)) -> #active(X)
   #19: #s(mark(X)) -> #s(X)
   #20: #cons(mark(X1),X2) -> #cons(X1,X2)
   #21: #sel(ok(X1),ok(X2)) -> #sel(X1,X2)
   #22: #active(cons(X1,X2)) -> #cons(active(X1),X2)
   #23: #active(cons(X1,X2)) -> #active(X1)
   #24: #zWquot(mark(X1),X2) -> #zWquot(X1,X2)
   #25: #active(sel(X1,X2)) -> #sel(active(X1),X2)
   #26: #active(sel(X1,X2)) -> #active(X1)
   #27: #quot(X1,mark(X2)) -> #quot(X1,X2)
   #28: #top(mark(X)) -> #top(proper(X))
   #29: #top(mark(X)) -> #proper(X)
   #30: #sel(mark(X1),X2) -> #sel(X1,X2)
   #31: #active(zWquot(X1,X2)) -> #zWquot(active(X1),X2)
   #32: #active(zWquot(X1,X2)) -> #active(X1)
   #33: #active(quot(s(X),s(Y))) -> #s(quot(minus(X,Y),s(Y)))
   #34: #active(quot(s(X),s(Y))) -> #quot(minus(X,Y),s(Y))
   #35: #active(quot(s(X),s(Y))) -> #minus(X,Y)
   #36: #proper(quot(X1,X2)) -> #quot(proper(X1),proper(X2))
   #37: #proper(quot(X1,X2)) -> #proper(X1)
   #38: #proper(quot(X1,X2)) -> #proper(X2)
   #39: #active(zWquot(cons(X,XS),cons(Y,YS))) -> #cons(quot(X,Y),zWquot(XS,YS))
   #40: #active(zWquot(cons(X,XS),cons(Y,YS))) -> #quot(X,Y)
   #41: #active(zWquot(cons(X,XS),cons(Y,YS))) -> #zWquot(XS,YS)
   #42: #proper(from(X)) -> #from(proper(X))
   #43: #proper(from(X)) -> #proper(X)
   #44: #active(minus(s(X),s(Y))) -> #minus(X,Y)
   #45: #s(ok(X)) -> #s(X)
   #46: #minus(X1,mark(X2)) -> #minus(X1,X2)
   #47: #from(mark(X)) -> #from(X)
   #48: #proper(cons(X1,X2)) -> #cons(proper(X1),proper(X2))
   #49: #proper(cons(X1,X2)) -> #proper(X1)
   #50: #proper(cons(X1,X2)) -> #proper(X2)
   #51: #minus(mark(X1),X2) -> #minus(X1,X2)
   #52: #active(minus(X1,X2)) -> #minus(X1,active(X2))
   #53: #active(minus(X1,X2)) -> #active(X2)
   #54: #zWquot(X1,mark(X2)) -> #zWquot(X1,X2)
   #55: #active(quot(X1,X2)) -> #quot(X1,active(X2))
   #56: #active(quot(X1,X2)) -> #active(X2)
   #57: #sel(X1,mark(X2)) -> #sel(X1,X2)
   #58: #proper(sel(X1,X2)) -> #sel(proper(X1),proper(X2))
   #59: #proper(sel(X1,X2)) -> #proper(X1)
   #60: #proper(sel(X1,X2)) -> #proper(X2)
   #61: #active(zWquot(X1,X2)) -> #zWquot(X1,active(X2))
   #62: #active(zWquot(X1,X2)) -> #active(X2)
   #63: #active(minus(X1,X2)) -> #minus(active(X1),X2)
   #64: #active(minus(X1,X2)) -> #active(X1)
   #65: #active(sel(s(N),cons(X,XS))) -> #sel(N,XS)
   #66: #active(from(X)) -> #cons(X,from(s(X)))
   #67: #active(from(X)) -> #from(s(X))
   #68: #active(from(X)) -> #s(X)
   #69: #active(sel(X1,X2)) -> #sel(X1,active(X2))
   #70: #active(sel(X1,X2)) -> #active(X2)
   #71: #top(ok(X)) -> #top(active(X))
   #72: #top(ok(X)) -> #active(X)
   #73: #active(quot(X1,X2)) -> #quot(active(X1),X2)
   #74: #active(quot(X1,X2)) -> #active(X1)
Number of SCCs: 10, DPs: 43, edges: 317
	SCC { #6 #47 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: 0
#zWquot(x1,x2)	weight: 0
 minus(x1,x2)	weight: 0
   top(x1)	weight: 0
 #top(x1)	weight: 0
zWquot(x1,x2)	weight: 0
proper(x1)	weight: 0
    ok(x1)	weight: (/ 1 2) + x1
     0()	weight: 0
  quot(x1,x2)	weight: 0
 #sel(x1,x2)	weight: 0
  from(x1)	weight: 0
   sel(x1,x2)	weight: 0
   #s(x1)	weight: 0
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#minus(x1,x2)	weight: 0
#proper(x1)	weight: 0
#from(x1)	weight: x1
active(x1)	weight: 0
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
#quot(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #6 #47
Number of SCCs: 9, DPs: 41, edges: 313
	SCC { #19 #45 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: 0
#zWquot(x1,x2)	weight: 0
 minus(x1,x2)	weight: 0
   top(x1)	weight: 0
 #top(x1)	weight: 0
zWquot(x1,x2)	weight: 0
proper(x1)	weight: 0
    ok(x1)	weight: (/ 1 2) + x1
     0()	weight: 0
  quot(x1,x2)	weight: 0
 #sel(x1,x2)	weight: 0
  from(x1)	weight: 0
   sel(x1,x2)	weight: 0
   #s(x1)	weight: x1
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#minus(x1,x2)	weight: 0
#proper(x1)	weight: 0
#from(x1)	weight: 0
active(x1)	weight: 0
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
#quot(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #19 #45
Number of SCCs: 8, DPs: 39, edges: 309
	SCC { #28 #71 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  failed.
