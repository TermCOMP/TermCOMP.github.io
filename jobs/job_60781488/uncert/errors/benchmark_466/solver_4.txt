Input TRS:
    1: o(x) -> a(l(x))
    2: a(l(x)) -> l(a(a(x)))
    3: l(o(x)) -> o(l(x))
    4: a(x) -> x
    5: H(0(),x) -> o(x)
    6: a(H(H(0(),y),z)) -> c1(y,z)
    7: a(H(H(H(0(),x),y),z)) -> c2(x,y,z)
    8: c2(x,y,z) -> o(H(y,z))
    9: a(c1(x,y)) -> c1(x,H(x,y))
    10: a(c2(x,y,z)) -> c2(x,H(x,y),z)
    11: c1(y,z) -> o(z)
Number of strict rules: 11
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #a(l(x)) -> #l(a(a(x)))
   #2: #a(l(x)) -> #a(a(x))
   #3: #a(l(x)) -> #a(x)
   #4: #a(H(H(0(),y),z)) -> #c1(y,z)
   #5: #a(c1(x,y)) -> #c1(x,H(x,y))
   #6: #a(c1(x,y)) -> #H(x,y)
   #7: #c1(y,z) -> #o(z)
   #8: #a(H(H(H(0(),x),y),z)) -> #c2(x,y,z)
   #9: #a(c2(x,y,z)) -> #c2(x,H(x,y),z)
   #10: #a(c2(x,y,z)) -> #H(x,y)
   #11: #H(0(),x) -> #o(x)
   #12: #l(o(x)) -> #o(l(x))
   #13: #l(o(x)) -> #l(x)
   #14: #o(x) -> #a(l(x))
   #15: #o(x) -> #l(x)
   #16: #c2(x,y,z) -> #o(H(y,z))
   #17: #c2(x,y,z) -> #H(y,z)
Number of SCCs: 1, DPs: 17, edges: 50
	SCC { #1..17 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... succeeded.
     a(x1)	weight: x1
    c1(x1,x2)	weight: max{x2, (/ 1 4) + x1}
     l(x1)	weight: x1
     H(x1,x2)	weight: max{x2, (/ 1 4) + x1}
     o(x1)	weight: x1
     0()	weight: 0
    c2(x1,x2,x3)	weight: max{x3, (/ 1 4) + x2, (/ 1 2) + x1}
   #o(x1)	weight: (/ 1 8) + x1
   #H(x1,x2)	weight: max{(/ 1 8) + x2, (/ 3 8) + x1}
   #l(x1)	weight: (/ 1 8) + x1
   #a(x1)	weight: (/ 1 8) + x1
  #c1(x1,x2)	weight: max{(/ 1 8) + x2, (/ 1 4) + x1}
  #c2(x1,x2,x3)	weight: max{0, (/ 1 8) + x3, (/ 3 8) + x2}
    Usable rules: { 1..11 }
    Removed DPs: #10
Number of SCCs: 1, DPs: 16, edges: 46
	SCC { #1..9 #11..17 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  failed.
