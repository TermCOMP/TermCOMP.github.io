Input TRS:
    1: top1(free(x),y) -> top2(check(new(x)),y)
    2: top1(free(x),y) -> top2(new(x),check(y))
    3: top1(free(x),y) -> top2(check(x),new(y))
    4: top1(free(x),y) -> top2(x,check(new(y)))
    5: top2(x,free(y)) -> top1(check(new(x)),y)
    6: top2(x,free(y)) -> top1(new(x),check(y))
    7: top2(x,free(y)) -> top1(check(x),new(y))
    8: top2(x,free(y)) -> top1(x,check(new(y)))
    9: new(free(x)) -> free(new(x))
    10: old(free(x)) -> free(old(x))
    11: new(serve()) -> free(serve())
    12: old(serve()) -> free(serve())
    13: check(free(x)) -> free(check(x))
    14: check(new(x)) -> new(check(x))
    15: check(old(x)) -> old(check(x))
    16: check(old(x)) -> old(x)
Number of strict rules: 16
Direct Order(PosReal,>,Poly) ... removes: 10 12
   new(x1)	weight: (/ 1 8) + x1
  top1(x1,x2)	weight: x1 + x2
 serve()	weight: 0
  free(x1)	weight: (/ 1 8) + x1
  top2(x1,x2)	weight: x1 + x2
 check(x1)	weight: x1
   old(x1)	weight: (/ 1 4) + 2 * x1
Number of strict rules: 14
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #top1(free(x),y) -> #top2(new(x),check(y))
   #2: #top1(free(x),y) -> #new(x)
   #3: #top1(free(x),y) -> #check(y)
   #4: #top2(x,free(y)) -> #top1(new(x),check(y))
   #5: #top2(x,free(y)) -> #new(x)
   #6: #top2(x,free(y)) -> #check(y)
   #7: #check(free(x)) -> #check(x)
   #8: #new(free(x)) -> #new(x)
   #9: #check(new(x)) -> #new(check(x))
   #10: #check(new(x)) -> #check(x)
   #11: #top2(x,free(y)) -> #top1(check(x),new(y))
   #12: #top2(x,free(y)) -> #check(x)
   #13: #top2(x,free(y)) -> #new(y)
   #14: #top2(x,free(y)) -> #top1(check(new(x)),y)
   #15: #top2(x,free(y)) -> #check(new(x))
   #16: #top2(x,free(y)) -> #new(x)
   #17: #top1(free(x),y) -> #top2(check(x),new(y))
   #18: #top1(free(x),y) -> #check(x)
   #19: #top1(free(x),y) -> #new(y)
   #20: #top1(free(x),y) -> #top2(check(new(x)),y)
   #21: #top1(free(x),y) -> #check(new(x))
   #22: #top1(free(x),y) -> #new(x)
   #23: #top2(x,free(y)) -> #top1(x,check(new(y)))
   #24: #top2(x,free(y)) -> #check(new(y))
   #25: #top2(x,free(y)) -> #new(y)
   #26: #check(old(x)) -> #check(x)
   #27: #top1(free(x),y) -> #top2(x,check(new(y)))
   #28: #top1(free(x),y) -> #check(new(y))
   #29: #top1(free(x),y) -> #new(y)
Number of SCCs: 3, DPs: 12, edges: 42
	SCC { #8 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
   new(x1)	weight: 0
#top2(x1,x2)	weight: 0
  top1(x1,x2)	weight: 0
#check(x1)	weight: 0
#top1(x1,x2)	weight: 0
 serve()	weight: 0
  free(x1)	weight: (/ 1 2) + x1
  top2(x1,x2)	weight: 0
 check(x1)	weight: 0
 #new(x1)	weight: x1
   old(x1)	weight: 0
    Usable rules: { }
    Removed DPs: #8
Number of SCCs: 2, DPs: 11, edges: 41
	SCC { #7 #10 #26 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
   new(x1)	weight: (/ 1 2) + x1
#top2(x1,x2)	weight: 0
  top1(x1,x2)	weight: 0
#check(x1)	weight: x1
#top1(x1,x2)	weight: 0
 serve()	weight: 0
  free(x1)	weight: (/ 1 2) + x1
  top2(x1,x2)	weight: 0
 check(x1)	weight: 0
 #new(x1)	weight: 0
   old(x1)	weight: (/ 1 2) + x1
    Usable rules: { }
    Removed DPs: #7 #10 #26
Number of SCCs: 1, DPs: 8, edges: 32
	SCC { #1 #4 #11 #14 #17 #20 #23 #27 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  failed.
