Input TRS:
    1: max(nil()) -> 0()
    2: max(cons(x,nil())) -> x
    3: max(cons(x,cons(y,xs))) -> if1(ge(x,y),x,y,xs)
    4: if1(true(),x,y,xs) -> max(cons(x,xs))
    5: if1(false(),x,y,xs) -> max(cons(y,xs))
    6: del(x,nil()) -> nil()
    7: del(x,cons(y,xs)) -> if2(eq(x,y),x,y,xs)
    8: if2(true(),x,y,xs) -> xs
    9: if2(false(),x,y,xs) -> cons(y,del(x,xs))
    10: eq(0(),0()) -> true()
    11: eq(0(),s(y)) -> false()
    12: eq(s(x),0()) -> false()
    13: eq(s(x),s(y)) -> eq(x,y)
    14: sort(xs) -> if3(empty(xs),xs)
    15: if3(true(),xs) -> nil()
    16: if3(false(),xs) -> sort(del(max(xs),xs))
    17: empty(nil()) -> true()
    18: empty(cons(x,xs)) -> false()
    19: ge(x,0()) -> true()
    20: ge(0(),s(x)) -> false()
    21: ge(s(x),s(y)) -> ge(x,y)
Number of strict rules: 21
Direct Order(PosReal,>,Poly) ... failed.
Freezing max
1: max❆1_nil() -> 0()
2: max❆1_cons(x,nil()) -> x
3: max❆1_cons(x,cons(y,xs)) -> if1(ge(x,y),x,y,xs)
4: if1(true(),x,y,xs) -> max❆1_cons(x,xs)
5: if1(false(),x,y,xs) -> max❆1_cons(y,xs)
6: del(x,nil()) -> nil()
7: del(x,cons(y,xs)) -> if2(eq(x,y),x,y,xs)
8: if2(true(),x,y,xs) -> xs
9: if2(false(),x,y,xs) -> cons(y,del(x,xs))
10: eq(0(),0()) -> true()
11: eq(0(),s(y)) -> false()
12: eq(s(x),0()) -> false()
13: eq(s(x),s(y)) -> eq(x,y)
14: sort(xs) -> if3(empty(xs),xs)
15: if3(true(),xs) -> nil()
16: if3(false(),xs) -> sort(del(max(xs),xs))
17: empty(nil()) -> true()
18: empty(cons(x,xs)) -> false()
19: ge(x,0()) -> true()
20: ge(0(),s(x)) -> false()
21: ge(s(x),s(y)) -> ge(x,y)
22: max(cons(_1,_2)) ->= max❆1_cons(_1,_2)
23: max(nil()) ->= max❆1_nil()
Number of strict rules: 21
Direct Order(PosReal,>,Poly) ... failed.
Dependency Pairs:
   #1: #eq(s(x),s(y)) -> #eq(x,y)
   #2: #if2(false(),x,y,xs) -> #del(x,xs)
   #3: #max(nil()) ->? #max❆1_nil()
   #4: #sort(xs) -> #if3(empty(xs),xs)
   #5: #sort(xs) -> #empty(xs)
   #6: #del(x,cons(y,xs)) -> #if2(eq(x,y),x,y,xs)
   #7: #del(x,cons(y,xs)) -> #eq(x,y)
   #8: #if1(false(),x,y,xs) -> #max❆1_cons(y,xs)
   #9: #max(cons(_1,_2)) ->? #max❆1_cons(_1,_2)
   #10: #ge(s(x),s(y)) -> #ge(x,y)
   #11: #if3(false(),xs) -> #sort(del(max(xs),xs))
   #12: #if3(false(),xs) -> #del(max(xs),xs)
   #13: #if3(false(),xs) -> #max(xs)
   #14: #max❆1_cons(x,cons(y,xs)) -> #if1(ge(x,y),x,y,xs)
   #15: #max❆1_cons(x,cons(y,xs)) -> #ge(x,y)
   #16: #if1(true(),x,y,xs) -> #max❆1_cons(x,xs)
Number of SCCs: 5, DPs: 9, edges: 10
	SCC { #1 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
 #del(x1,x2)	weight: 0
#empty(x1)	weight: 0
     s(x1)	weight: (/ 1 2) + x1
    eq(x1,x2)	weight: 0
   if1(x1,x2,x3,x4)	weight: 0
 false()	weight: 0
  #ge(x1,x2)	weight: 0
  true()	weight: 0
  #eq(x1,x2)	weight: x1
 #if1(x1,x2,x3,x4)	weight: 0
#sort(x1)	weight: 0
#max❆1_cons(x1,x2)	weight: 0
   if2(x1,x2,x3,x4)	weight: 0
max❆1_cons(x1,x2)	weight: 0
 #if3(x1,x2)	weight: 0
     0()	weight: 0
    ge(x1,x2)	weight: 0
   del(x1,x2)	weight: 0
   max(x1)	weight: 0
   nil()	weight: 0
 #max(x1)	weight: 0
  sort(x1)	weight: 0
   if3(x1,x2)	weight: 0
  cons(x1,x2)	weight: 0
 empty(x1)	weight: 0
max❆1_nil()	weight: 0
 #if2(x1,x2,x3,x4)	weight: 0
#max❆1_nil()	weight: 0
    Usable rules: { }
    Removed DPs: #1
Number of SCCs: 4, DPs: 8, edges: 9
	SCC { #10 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
 #del(x1,x2)	weight: 0
#empty(x1)	weight: 0
     s(x1)	weight: (/ 1 2) + x1
    eq(x1,x2)	weight: 0
   if1(x1,x2,x3,x4)	weight: 0
 false()	weight: 0
  #ge(x1,x2)	weight: x2
  true()	weight: 0
  #eq(x1,x2)	weight: 0
 #if1(x1,x2,x3,x4)	weight: 0
#sort(x1)	weight: 0
#max❆1_cons(x1,x2)	weight: 0
   if2(x1,x2,x3,x4)	weight: 0
max❆1_cons(x1,x2)	weight: 0
 #if3(x1,x2)	weight: 0
     0()	weight: 0
    ge(x1,x2)	weight: 0
   del(x1,x2)	weight: 0
   max(x1)	weight: 0
   nil()	weight: 0
 #max(x1)	weight: 0
  sort(x1)	weight: 0
   if3(x1,x2)	weight: 0
  cons(x1,x2)	weight: 0
 empty(x1)	weight: 0
max❆1_nil()	weight: 0
 #if2(x1,x2,x3,x4)	weight: 0
#max❆1_nil()	weight: 0
    Usable rules: { }
    Removed DPs: #10
Number of SCCs: 3, DPs: 7, edges: 8
	SCC { #4 #11 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  failed.
