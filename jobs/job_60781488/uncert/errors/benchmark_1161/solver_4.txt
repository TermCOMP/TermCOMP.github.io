Input TRS:
    1: fact(X) -> if(zero(X),n__s(n__0()),n__prod(X,n__fact(n__p(X))))
    2: add(0(),X) -> X
    3: add(s(X),Y) -> s(add(X,Y))
    4: prod(0(),X) -> 0()
    5: prod(s(X),Y) -> add(Y,prod(X,Y))
    6: if(true(),X,Y) -> activate(X)
    7: if(false(),X,Y) -> activate(Y)
    8: zero(0()) -> true()
    9: zero(s(X)) -> false()
    10: p(s(X)) -> X
    11: s(X) -> n__s(X)
    12: 0() -> n__0()
    13: prod(X1,X2) -> n__prod(X1,X2)
    14: fact(X) -> n__fact(X)
    15: p(X) -> n__p(X)
    16: activate(n__s(X)) -> s(activate(X))
    17: activate(n__0()) -> 0()
    18: activate(n__prod(X1,X2)) -> prod(activate(X1),activate(X2))
    19: activate(n__fact(X)) -> fact(activate(X))
    20: activate(n__p(X)) -> p(activate(X))
    21: activate(X) -> X
Number of strict rules: 21
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #if(true(),X,Y) -> #activate(X)
   #2: #activate(n__p(X)) -> #p(activate(X))
   #3: #activate(n__p(X)) -> #activate(X)
   #4: #if(false(),X,Y) -> #activate(Y)
   #5: #prod(s(X),Y) -> #add(Y,prod(X,Y))
   #6: #prod(s(X),Y) -> #prod(X,Y)
   #7: #activate(n__0()) -> #0()
   #8: #activate(n__fact(X)) -> #fact(activate(X))
   #9: #activate(n__fact(X)) -> #activate(X)
   #10: #activate(n__s(X)) -> #s(activate(X))
   #11: #activate(n__s(X)) -> #activate(X)
   #12: #add(s(X),Y) -> #s(add(X,Y))
   #13: #add(s(X),Y) -> #add(X,Y)
   #14: #fact(X) -> #if(zero(X),n__s(n__0()),n__prod(X,n__fact(n__p(X))))
   #15: #fact(X) -> #zero(X)
   #16: #activate(n__prod(X1,X2)) -> #prod(activate(X1),activate(X2))
   #17: #activate(n__prod(X1,X2)) -> #activate(X1)
   #18: #activate(n__prod(X1,X2)) -> #activate(X2)
Number of SCCs: 3, DPs: 11, edges: 47
	SCC { #13 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
  zero(x1)	weight: 0
   #0()	weight: 0
  prod(x1,x2)	weight: 0
n__prod(x1,x2)	weight: 0
     s(x1)	weight: (/ 1 2) + x1
#prod(x1,x2)	weight: 0
activate(x1)	weight: 0
n__fact(x1)	weight: 0
#activate(x1)	weight: 0
 false()	weight: 0
#fact(x1)	weight: 0
   #p(x1)	weight: 0
  true()	weight: 0
  n__s(x1)	weight: 0
     p(x1)	weight: 0
    if(x1,x2,x3)	weight: 0
     0()	weight: 0
   #s(x1)	weight: 0
  fact(x1)	weight: 0
  n__0()	weight: 0
  n__p(x1)	weight: 0
  #if(x1,x2,x3)	weight: 0
 #add(x1,x2)	weight: x1
   add(x1,x2)	weight: 0
#zero(x1)	weight: 0
    Usable rules: { }
    Removed DPs: #13
Number of SCCs: 2, DPs: 10, edges: 46
	SCC { #6 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
  zero(x1)	weight: 0
   #0()	weight: 0
  prod(x1,x2)	weight: 0
n__prod(x1,x2)	weight: 0
     s(x1)	weight: (/ 1 2) + x1
#prod(x1,x2)	weight: x1
activate(x1)	weight: 0
n__fact(x1)	weight: 0
#activate(x1)	weight: 0
 false()	weight: 0
#fact(x1)	weight: 0
   #p(x1)	weight: 0
  true()	weight: 0
  n__s(x1)	weight: 0
     p(x1)	weight: 0
    if(x1,x2,x3)	weight: 0
     0()	weight: 0
   #s(x1)	weight: 0
  fact(x1)	weight: 0
  n__0()	weight: 0
  n__p(x1)	weight: 0
  #if(x1,x2,x3)	weight: 0
 #add(x1,x2)	weight: 0
   add(x1,x2)	weight: 0
#zero(x1)	weight: 0
    Usable rules: { }
    Removed DPs: #6
Number of SCCs: 1, DPs: 9, edges: 45
	SCC { #1 #3 #4 #8 #9 #11 #14 #17 #18 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... succeeded.
  zero(x1)	weight: (/ 1 4)
   #0()	weight: 0
  prod(x1,x2)	weight: max{x2, (/ 1 4) + x1}
n__prod(x1,x2)	weight: max{x2, (/ 1 4) + x1}
     s(x1)	weight: x1
#prod(x1,x2)	weight: 0
activate(x1)	weight: x1
n__fact(x1)	weight: (/ 116971 4) + x1
#activate(x1)	weight: (/ 1 2) + x1
 false()	weight: (/ 1 4)
#fact(x1)	weight: (/ 116973 4) + x1
   #p(x1)	weight: 0
  true()	weight: (/ 1 4)
  n__s(x1)	weight: x1
     p(x1)	weight: x1
    if(x1,x2,x3)	weight: max{0, x3, x2}
     0()	weight: (/ 116969 4)
   #s(x1)	weight: 0
  fact(x1)	weight: (/ 116971 4) + x1
  n__0()	weight: (/ 116969 4)
  n__p(x1)	weight: x1
  #if(x1,x2,x3)	weight: max{(/ 1 2) + x3, (/ 3 4) + x2, x1}
 #add(x1,x2)	weight: 0
   add(x1,x2)	weight: max{0, x2}
#zero(x1)	weight: 0
    Usable rules: { 1..21 }
    Removed DPs: #1 #9 #17
Number of SCCs: 1, DPs: 6, edges: 18
	SCC { #3 #4 #8 #11 #14 #18 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
  zero(x1)	weight: (/ 1 8)
   #0()	weight: 0
  prod(x1,x2)	weight: (/ 1 8) + x1
n__prod(x1,x2)	weight: x2
     s(x1)	weight: (/ 1 8) + x1
#prod(x1,x2)	weight: 0
activate(x1)	weight: (/ 3 8)
n__fact(x1)	weight: (/ 1 4)
#activate(x1)	weight: x1
 false()	weight: 0
#fact(x1)	weight: (/ 1 4)
   #p(x1)	weight: 0
  true()	weight: 0
  n__s(x1)	weight: (/ 1 4) + x1
     p(x1)	weight: (/ 1 2)
    if(x1,x2,x3)	weight: (/ 1 4)
     0()	weight: 0
   #s(x1)	weight: 0
  fact(x1)	weight: (/ 1 8) + x1
  n__0()	weight: 0
  n__p(x1)	weight: (/ 5 8) + x1
  #if(x1,x2,x3)	weight: x3
 #add(x1,x2)	weight: 0
   add(x1,x2)	weight: (/ 3 8)
#zero(x1)	weight: 0
    Usable rules: { }
    Removed DPs: #3 #11
Number of SCCs: 1, DPs: 4, edges: 6
	SCC { #4 #8 #14 #18 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  failed.
