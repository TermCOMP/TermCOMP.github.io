Input TRS:
    1: admit(x,nil()) -> nil()
    2: admit(x,.(u,.(v,.(w(),z)))) -> cond(=(sum(x,u,v),w()),.(u,.(v,.(w(),admit(carry(x,u,v),z)))))
    3: cond(true(),y) -> y
Number of strict rules: 3
Direct Order(PosReal,>,Poly) ... failed.
Freezing cond
1: admit(x,nil()) -> nil()
2: admit(x,.(u,.(v,.(w(),z)))) -> cond❆1_=(sum(x,u,v),w(),.(u,.(v,.(w(),admit(carry(x,u,v),z)))))
3: cond❆1_true(y) -> y
4: cond(=(_1,_2),_3) ->= cond❆1_=(_1,_2,_3)
5: cond(true(),_1) ->= cond❆1_true(_1)
Number of strict rules: 3
Direct Order(PosReal,>,Poly) ... failed.
Dependency Pairs:
   #1: #admit(x,.(u,.(v,.(w(),z)))) -> #admit(carry(x,u,v),z)
   #2: #cond(true(),_1) ->? #cond❆1_true(_1)
Number of SCCs: 1, DPs: 1, edges: 1
	SCC { #1 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
 admit(x1,x2)	weight: 0
     w()	weight: 0
cond❆1_true(x1)	weight: 0
  true()	weight: 0
   sum(x1,x2,x3)	weight: 0
#cond(x1,x2)	weight: 0
     =(x1,x2)	weight: 0
   nil()	weight: 0
     .(x1,x2)	weight: (/ 1 4) + x1 + x2
#admit(x1,x2)	weight: x2
 carry(x1,x2,x3)	weight: (/ 1 2)
#cond❆1_true(x1)	weight: 0
  cond(x1,x2)	weight: 0
cond❆1_=(x1,x2,x3)	weight: 0
    Usable rules: { }
    Removed DPs: #1
Number of SCCs: 0, DPs: 0, edges: 0
