Input TRS:
    1: zeros() -> cons(0(),n__zeros())
    2: U11(tt(),L) -> s(length(activate(L)))
    3: U21(tt()) -> nil()
    4: U31(tt(),IL,M,N) -> cons(activate(N),n__take(activate(M),activate(IL)))
    5: and(tt(),X) -> activate(X)
    6: isNat(n__0()) -> tt()
    7: isNat(n__length(V1)) -> isNatList(activate(V1))
    8: isNat(n__s(V1)) -> isNat(activate(V1))
    9: isNatIList(V) -> isNatList(activate(V))
    10: isNatIList(n__zeros()) -> tt()
    11: isNatIList(n__cons(V1,V2)) -> and(isNat(activate(V1)),n__isNatIList(activate(V2)))
    12: isNatList(n__nil()) -> tt()
    13: isNatList(n__cons(V1,V2)) -> and(isNat(activate(V1)),n__isNatList(activate(V2)))
    14: isNatList(n__take(V1,V2)) -> and(isNat(activate(V1)),n__isNatIList(activate(V2)))
    15: length(nil()) -> 0()
    16: length(cons(N,L)) -> U11(and(isNatList(activate(L)),n__isNat(N)),activate(L))
    17: take(0(),IL) -> U21(isNatIList(IL))
    18: take(s(M),cons(N,IL)) -> U31(and(isNatIList(activate(IL)),n__and(n__isNat(M),n__isNat(N))),activate(IL),M,N)
    19: zeros() -> n__zeros()
    20: take(X1,X2) -> n__take(X1,X2)
    21: 0() -> n__0()
    22: length(X) -> n__length(X)
    23: s(X) -> n__s(X)
    24: cons(X1,X2) -> n__cons(X1,X2)
    25: isNatIList(X) -> n__isNatIList(X)
    26: nil() -> n__nil()
    27: isNatList(X) -> n__isNatList(X)
    28: isNat(X) -> n__isNat(X)
    29: and(X1,X2) -> n__and(X1,X2)
    30: activate(n__zeros()) -> zeros()
    31: activate(n__take(X1,X2)) -> take(activate(X1),activate(X2))
    32: activate(n__0()) -> 0()
    33: activate(n__length(X)) -> length(activate(X))
    34: activate(n__s(X)) -> s(activate(X))
    35: activate(n__cons(X1,X2)) -> cons(activate(X1),X2)
    36: activate(n__isNatIList(X)) -> isNatIList(X)
    37: activate(n__nil()) -> nil()
    38: activate(n__isNatList(X)) -> isNatList(X)
    39: activate(n__isNat(X)) -> isNat(X)
    40: activate(n__and(X1,X2)) -> and(activate(X1),X2)
    41: activate(X) -> X
Number of strict rules: 41
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #U11(tt(),L) -> #s(length(activate(L)))
   #2: #U11(tt(),L) -> #length(activate(L))
   #3: #U11(tt(),L) -> #activate(L)
   #4: #activate(n__cons(X1,X2)) -> #cons(activate(X1),X2)
   #5: #activate(n__cons(X1,X2)) -> #activate(X1)
   #6: #activate(n__nil()) -> #nil()
   #7: #activate(n__isNatList(X)) -> #isNatList(X)
   #8: #activate(n__and(X1,X2)) -> #and(activate(X1),X2)
   #9: #activate(n__and(X1,X2)) -> #activate(X1)
   #10: #isNatList(n__cons(V1,V2)) -> #and(isNat(activate(V1)),n__isNatList(activate(V2)))
   #11: #isNatList(n__cons(V1,V2)) -> #isNat(activate(V1))
   #12: #isNatList(n__cons(V1,V2)) -> #activate(V1)
   #13: #isNatList(n__cons(V1,V2)) -> #activate(V2)
   #14: #isNatIList(V) -> #isNatList(activate(V))
   #15: #isNatIList(V) -> #activate(V)
   #16: #isNatIList(n__cons(V1,V2)) -> #and(isNat(activate(V1)),n__isNatIList(activate(V2)))
   #17: #isNatIList(n__cons(V1,V2)) -> #isNat(activate(V1))
   #18: #isNatIList(n__cons(V1,V2)) -> #activate(V1)
   #19: #isNatIList(n__cons(V1,V2)) -> #activate(V2)
   #20: #activate(n__take(X1,X2)) -> #take(activate(X1),activate(X2))
   #21: #activate(n__take(X1,X2)) -> #activate(X1)
   #22: #activate(n__take(X1,X2)) -> #activate(X2)
   #23: #isNatList(n__take(V1,V2)) -> #and(isNat(activate(V1)),n__isNatIList(activate(V2)))
   #24: #isNatList(n__take(V1,V2)) -> #isNat(activate(V1))
   #25: #isNatList(n__take(V1,V2)) -> #activate(V1)
   #26: #isNatList(n__take(V1,V2)) -> #activate(V2)
   #27: #activate(n__zeros()) -> #zeros()
   #28: #isNat(n__length(V1)) -> #isNatList(activate(V1))
   #29: #isNat(n__length(V1)) -> #activate(V1)
   #30: #activate(n__isNat(X)) -> #isNat(X)
   #31: #activate(n__length(X)) -> #length(activate(X))
   #32: #activate(n__length(X)) -> #activate(X)
   #33: #and(tt(),X) -> #activate(X)
   #34: #activate(n__s(X)) -> #s(activate(X))
   #35: #activate(n__s(X)) -> #activate(X)
   #36: #take(0(),IL) -> #U21(isNatIList(IL))
   #37: #take(0(),IL) -> #isNatIList(IL)
   #38: #activate(n__0()) -> #0()
   #39: #activate(n__isNatIList(X)) -> #isNatIList(X)
   #40: #length(cons(N,L)) -> #U11(and(isNatList(activate(L)),n__isNat(N)),activate(L))
   #41: #length(cons(N,L)) -> #and(isNatList(activate(L)),n__isNat(N))
   #42: #length(cons(N,L)) -> #isNatList(activate(L))
   #43: #length(cons(N,L)) -> #activate(L)
   #44: #length(cons(N,L)) -> #activate(L)
   #45: #U21(tt()) -> #nil()
   #46: #zeros() -> #cons(0(),n__zeros())
   #47: #zeros() -> #0()
   #48: #isNat(n__s(V1)) -> #isNat(activate(V1))
   #49: #isNat(n__s(V1)) -> #activate(V1)
   #50: #length(nil()) -> #0()
   #51: #U31(tt(),IL,M,N) -> #cons(activate(N),n__take(activate(M),activate(IL)))
   #52: #U31(tt(),IL,M,N) -> #activate(N)
   #53: #U31(tt(),IL,M,N) -> #activate(M)
   #54: #U31(tt(),IL,M,N) -> #activate(IL)
   #55: #take(s(M),cons(N,IL)) -> #U31(and(isNatIList(activate(IL)),n__and(n__isNat(M),n__isNat(N))),activate(IL),M,N)
   #56: #take(s(M),cons(N,IL)) -> #and(isNatIList(activate(IL)),n__and(n__isNat(M),n__isNat(N)))
   #57: #take(s(M),cons(N,IL)) -> #isNatIList(activate(IL))
   #58: #take(s(M),cons(N,IL)) -> #activate(IL)
   #59: #take(s(M),cons(N,IL)) -> #activate(IL)
Number of SCCs: 1, DPs: 47, edges: 385
	SCC { #2 #3 #5 #7..26 #28..33 #35 #37 #39..44 #48 #49 #52..59 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
   #0()	weight: 0
   U21(x1)	weight: x1
isNatList(x1)	weight: (/ 1 8) + x1
   U11(x1,x2)	weight: (/ 3 8) + x2
#cons(x1,x2)	weight: 0
     s(x1)	weight: x1
#isNat(x1)	weight: x1
#take(x1,x2)	weight: (/ 3 8) + x1 + x2
activate(x1)	weight: x1
  take(x1,x2)	weight: (/ 1 2) + x1 + x2
   and(x1,x2)	weight: x1 + x2
n__zeros()	weight: 0
isNatIList(x1)	weight: (/ 1 4) + x1
#activate(x1)	weight: x1
 zeros()	weight: 0
n__nil()	weight: 0
  n__s(x1)	weight: x1
     0()	weight: 0
#zeros()	weight: 0
n__take(x1,x2)	weight: (/ 1 2) + x1 + x2
n__isNatList(x1)	weight: (/ 1 8) + x1
#isNatList(x1)	weight: (/ 1 8) + x1
   #s(x1)	weight: 0
n__cons(x1,x2)	weight: x1 + x2
   nil()	weight: 0
n__isNat(x1)	weight: x1
 #nil()	weight: 0
  n__0()	weight: 0
n__length(x1)	weight: (/ 3 8) + x1
 isNat(x1)	weight: x1
 #U11(x1,x2)	weight: (/ 1 4) + x2
   U31(x1,x2,x3,x4)	weight: (/ 1 2) + x2 + x3 + x4
  cons(x1,x2)	weight: x1 + x2
n__isNatIList(x1)	weight: (/ 1 4) + x1
#isNatIList(x1)	weight: (/ 1 4) + x1
 #U21(x1)	weight: 0
    tt()	weight: 0
n__and(x1,x2)	weight: x1 + x2
length(x1)	weight: (/ 3 8) + x1
#length(x1)	weight: (/ 1 4) + x1
 #U31(x1,x2,x3,x4)	weight: (/ 1 8) + x2 + x3 + x4
 #and(x1,x2)	weight: x2
    Usable rules: { 1..41 }
    Removed DPs: #3 #11..15 #17..26 #28 #29 #31 #32 #37 #41..44 #52..59
Number of SCCs: 2, DPs: 14, edges: 46
	SCC { #2 #40 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... succeeded.
   #0()	weight: 0; 0
   U21(x1)	weight: (max (/ 1 4) 0); 0
isNatList(x1)	weight: (max (/ 1 4) 0); x1_2
   U11(x1,x2)	weight: max{0, (/ 3 4) + x2_1 + x1_2}; (- (/ 1 4))
#cons(x1,x2)	weight: 0; 0
     s(x1)	weight: max{0, (/ 1 2) + x1_1}; (- (/ 1 4)) + x1_2
#isNat(x1)	weight: 0; 0
#take(x1,x2)	weight: 0; 0
activate(x1)	weight: max{0, x1_1}; x1_2
  take(x1,x2)	weight: max{0, (/ 1 4) + x1_1}; 0
   and(x1,x2)	weight: max{0, x2_1 + x1_2}; x2_2 + x1_2
n__zeros()	weight: (/ 1 4); (- (/ 1 2))
isNatIList(x1)	weight: (max (/ 1 4) 0); 0
#activate(x1)	weight: 0; 0
 zeros()	weight: (/ 1 4); (- (/ 1 2))
n__nil()	weight: (/ 1 4); 0
  n__s(x1)	weight: max{0, (/ 1 2) + x1_1}; (- (/ 1 4)) + x1_2
     0()	weight: 0; (- (/ 1 4))
#zeros()	weight: 0; 0
n__take(x1,x2)	weight: max{0, (/ 1 4) + x1_1}; 0
n__isNatList(x1)	weight: (max (/ 1 4) 0); x1_2
#isNatList(x1)	weight: 0; 0
   #s(x1)	weight: 0; 0
n__cons(x1,x2)	weight: max{0, (/ 1 2) + x2_1 + x2_2}; x2_2
   nil()	weight: (/ 1 4); 0
n__isNat(x1)	weight: max{0, x1_1}; 0
 #nil()	weight: 0; 0
  n__0()	weight: 0; (- (/ 1 4))
n__length(x1)	weight: max{0, (/ 1 4) + x1_1}; (- (/ 1 4))
 isNat(x1)	weight: max{0, x1_1}; 0
 #U11(x1,x2)	weight: max{0, (/ 1 2) + x2_1 + x1_2}; x2_2 + x1_2
   U31(x1,x2,x3,x4)	weight: max{0, (/ 3 4) + x3_1}; 0
  cons(x1,x2)	weight: max{0, (/ 1 2) + x2_1 + x2_2}; x2_2
n__isNatIList(x1)	weight: (max (/ 1 4) 0); 0
#isNatIList(x1)	weight: 0; 0
 #U21(x1)	weight: 0; 0
    tt()	weight: 0; 0
n__and(x1,x2)	weight: max{0, x2_1 + x1_2}; x2_2 + x1_2
length(x1)	weight: max{0, (/ 1 4) + x1_1}; (- (/ 1 4))
#length(x1)	weight: max{0, (/ 1 4) + x1_1}; x1_2
 #U31(x1,x2,x3,x4)	weight: 0; 0
 #and(x1,x2)	weight: 0; 0
    Usable rules: { 1..41 }
    Removed DPs: #2 #40
Number of SCCs: 1, DPs: 12, edges: 44
	SCC { #5 #7..10 #16 #30 #33 #35 #39 #48 #49 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... succeeded.
   #0()	weight: 0
   U21(x1)	weight: (/ 1 16)
isNatList(x1)	weight: (/ 1 8) + x1
   U11(x1,x2)	weight: max{0, x2}
#cons(x1,x2)	weight: 0
     s(x1)	weight: x1
#isNat(x1)	weight: (/ 5 16) + x1
#take(x1,x2)	weight: 0
activate(x1)	weight: x1
  take(x1,x2)	weight: max{(/ 1 4) + x2, (/ 1 2) + x1}
   and(x1,x2)	weight: max{x2, (/ 1 16) + x1}
n__zeros()	weight: (/ 3 16)
isNatIList(x1)	weight: (/ 1 8) + x1
#activate(x1)	weight: (/ 1 4) + x1
 zeros()	weight: (/ 3 16)
n__nil()	weight: (/ 1 16)
  n__s(x1)	weight: x1
     0()	weight: 0
#zeros()	weight: 0
n__take(x1,x2)	weight: max{(/ 1 4) + x2, (/ 1 2) + x1}
n__isNatList(x1)	weight: (/ 1 8) + x1
#isNatList(x1)	weight: (/ 3 8) + x1
   #s(x1)	weight: 0
n__cons(x1,x2)	weight: max{x2, (/ 3 16) + x1}
   nil()	weight: (/ 1 16)
n__isNat(x1)	weight: (/ 1 4) + x1
 #nil()	weight: 0
  n__0()	weight: 0
n__length(x1)	weight: x1
 isNat(x1)	weight: (/ 1 4) + x1
 #U11(x1,x2)	weight: 0
   U31(x1,x2,x3,x4)	weight: max{(/ 3 16) + x4, (/ 1 2) + x3, (/ 1 4) + x2, (/ 1 16) + x1}
  cons(x1,x2)	weight: max{x2, (/ 3 16) + x1}
n__isNatIList(x1)	weight: (/ 1 8) + x1
#isNatIList(x1)	weight: (/ 3 8) + x1
 #U21(x1)	weight: 0
    tt()	weight: (/ 1 16)
n__and(x1,x2)	weight: max{x2, (/ 1 16) + x1}
length(x1)	weight: x1
#length(x1)	weight: 0
 #U31(x1,x2,x3,x4)	weight: 0
 #and(x1,x2)	weight: max{(/ 1 4) + x2, (/ 1 16) + x1}
    Usable rules: { 1..41 }
    Removed DPs: #5 #9 #30 #49
Number of SCCs: 2, DPs: 8, edges: 14
	SCC { #48 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... succeeded.
   #0()	weight: 0; 0
   U21(x1)	weight: (max (/ 1 4) 0); 0
isNatList(x1)	weight: (max (/ 1 4) 0); x1_2
   U11(x1,x2)	weight: max{0, (/ 1 2) + x2_1 + x1_2}; (- (/ 1 4))
#cons(x1,x2)	weight: 0; 0
     s(x1)	weight: max{0, (/ 1 4) + x1_1}; (- (/ 1 4))
#isNat(x1)	weight: max{0, (/ 1 4) + x1_1}; 0
#take(x1,x2)	weight: 0; 0
activate(x1)	weight: max{0, x1_1}; x1_2
  take(x1,x2)	weight: max{0, (/ 1 4) + x1_1}; 0
   and(x1,x2)	weight: max{0, x2_1 + x1_2}; x2_2 + x1_2
n__zeros()	weight: (/ 1 4); (- (/ 1 4))
isNatIList(x1)	weight: (max (/ 1 4) 0); 0
#activate(x1)	weight: 0; 0
 zeros()	weight: (/ 1 4); (- (/ 1 4))
n__nil()	weight: (/ 1 4); 0
  n__s(x1)	weight: max{0, (/ 1 4) + x1_1}; (- (/ 1 4))
     0()	weight: 0; (- (/ 1 4))
#zeros()	weight: 0; 0
n__take(x1,x2)	weight: max{0, (/ 1 4) + x1_1}; 0
n__isNatList(x1)	weight: (max (/ 1 4) 0); x1_2
#isNatList(x1)	weight: 0; 0
   #s(x1)	weight: 0; 0
n__cons(x1,x2)	weight: max{0, (/ 1 4) + x2_1 + x2_2}; x2_2
   nil()	weight: (/ 1 4); 0
n__isNat(x1)	weight: max{0, x1_1}; 0
 #nil()	weight: 0; 0
  n__0()	weight: 0; (- (/ 1 4))
n__length(x1)	weight: max{0, (/ 1 4) + x1_1}; (- (/ 1 4))
 isNat(x1)	weight: max{0, x1_1}; 0
 #U11(x1,x2)	weight: max{0, x2_1 + x1_2}; x2_2 + x1_2
   U31(x1,x2,x3,x4)	weight: max{0, (/ 1 2) + x3_1}; 0
  cons(x1,x2)	weight: max{0, (/ 1 4) + x2_1 + x2_2}; x2_2
n__isNatIList(x1)	weight: (max (/ 1 4) 0); 0
#isNatIList(x1)	weight: 0; 0
 #U21(x1)	weight: 0; 0
    tt()	weight: 0; 0
n__and(x1,x2)	weight: max{0, x2_1 + x1_2}; x2_2 + x1_2
length(x1)	weight: max{0, (/ 1 4) + x1_1}; (- (/ 1 4))
#length(x1)	weight: max{0, x1_1}; x1_2
 #U31(x1,x2,x3,x4)	weight: 0; 0
 #and(x1,x2)	weight: 0; 0
    Usable rules: { 1..41 }
    Removed DPs: #48
Number of SCCs: 1, DPs: 7, edges: 13
	SCC { #7 #8 #10 #16 #33 #35 #39 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
   #0()	weight: 0
   U21(x1)	weight: (/ 5 16) + x1
isNatList(x1)	weight: (/ 1 8)
   U11(x1,x2)	weight: (/ 3 8)
#cons(x1,x2)	weight: 0
     s(x1)	weight: (/ 7 16)
#isNat(x1)	weight: 0
#take(x1,x2)	weight: (/ 3 16)
activate(x1)	weight: (/ 1 4)
  take(x1,x2)	weight: (/ 5 16)
   and(x1,x2)	weight: (/ 3 16)
n__zeros()	weight: 0
isNatIList(x1)	weight: (/ 1 16)
#activate(x1)	weight: x1
 zeros()	weight: 0
n__nil()	weight: 0
  n__s(x1)	weight: (/ 1 2) + x1
     0()	weight: 0
#zeros()	weight: 0
n__take(x1,x2)	weight: (/ 3 8) + x2
n__isNatList(x1)	weight: (/ 3 16)
#isNatList(x1)	weight: (/ 3 16)
   #s(x1)	weight: 0
n__cons(x1,x2)	weight: (/ 1 4) + x2
   nil()	weight: 0
n__isNat(x1)	weight: (/ 1 8)
 #nil()	weight: 0
  n__0()	weight: 0
n__length(x1)	weight: (/ 3 8)
 isNat(x1)	weight: (/ 1 16)
 #U11(x1,x2)	weight: (/ 1 8)
   U31(x1,x2,x3,x4)	weight: (/ 3 8) + x3 + x4
  cons(x1,x2)	weight: (/ 3 16) + x1
n__isNatIList(x1)	weight: (/ 1 8)
#isNatIList(x1)	weight: (/ 1 8)
 #U21(x1)	weight: 0
    tt()	weight: 0
n__and(x1,x2)	weight: (/ 1 4) + x2
length(x1)	weight: (/ 5 16)
#length(x1)	weight: (/ 1 8)
 #U31(x1,x2,x3,x4)	weight: (/ 1 16)
 #and(x1,x2)	weight: x2
    Usable rules: { }
    Removed DPs: #8 #35
Number of SCCs: 1, DPs: 5, edges: 6
	SCC { #7 #10 #16 #33 #39 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  failed.
