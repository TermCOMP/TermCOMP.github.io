Input TRS:
    1: zeros() -> cons(0(),n__zeros())
    2: U11(tt()) -> tt()
    3: U21(tt()) -> tt()
    4: U31(tt()) -> tt()
    5: U41(tt(),V2) -> U42(isNatIList(activate(V2)))
    6: U42(tt()) -> tt()
    7: U51(tt(),V2) -> U52(isNatList(activate(V2)))
    8: U52(tt()) -> tt()
    9: U61(tt(),V2) -> U62(isNatIList(activate(V2)))
    10: U62(tt()) -> tt()
    11: U71(tt(),L,N) -> U72(isNat(activate(N)),activate(L))
    12: U72(tt(),L) -> s(length(activate(L)))
    13: U81(tt()) -> nil()
    14: U91(tt(),IL,M,N) -> U92(isNat(activate(M)),activate(IL),activate(M),activate(N))
    15: U92(tt(),IL,M,N) -> U93(isNat(activate(N)),activate(IL),activate(M),activate(N))
    16: U93(tt(),IL,M,N) -> cons(activate(N),n__take(activate(M),activate(IL)))
    17: isNat(n__0()) -> tt()
    18: isNat(n__length(V1)) -> U11(isNatList(activate(V1)))
    19: isNat(n__s(V1)) -> U21(isNat(activate(V1)))
    20: isNatIList(V) -> U31(isNatList(activate(V)))
    21: isNatIList(n__zeros()) -> tt()
    22: isNatIList(n__cons(V1,V2)) -> U41(isNat(activate(V1)),activate(V2))
    23: isNatList(n__nil()) -> tt()
    24: isNatList(n__cons(V1,V2)) -> U51(isNat(activate(V1)),activate(V2))
    25: isNatList(n__take(V1,V2)) -> U61(isNat(activate(V1)),activate(V2))
    26: length(nil()) -> 0()
    27: length(cons(N,L)) -> U71(isNatList(activate(L)),activate(L),N)
    28: take(0(),IL) -> U81(isNatIList(IL))
    29: take(s(M),cons(N,IL)) -> U91(isNatIList(activate(IL)),activate(IL),M,N)
    30: zeros() -> n__zeros()
    31: take(X1,X2) -> n__take(X1,X2)
    32: 0() -> n__0()
    33: length(X) -> n__length(X)
    34: s(X) -> n__s(X)
    35: cons(X1,X2) -> n__cons(X1,X2)
    36: nil() -> n__nil()
    37: activate(n__zeros()) -> zeros()
    38: activate(n__take(X1,X2)) -> take(activate(X1),activate(X2))
    39: activate(n__0()) -> 0()
    40: activate(n__length(X)) -> length(activate(X))
    41: activate(n__s(X)) -> s(activate(X))
    42: activate(n__cons(X1,X2)) -> cons(activate(X1),X2)
    43: activate(n__nil()) -> nil()
    44: activate(X) -> X
Number of strict rules: 44
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #activate(n__nil()) -> #nil()
   #2: #take(s(M),cons(N,IL)) -> #U91(isNatIList(activate(IL)),activate(IL),M,N)
   #3: #take(s(M),cons(N,IL)) -> #isNatIList(activate(IL))
   #4: #take(s(M),cons(N,IL)) -> #activate(IL)
   #5: #take(s(M),cons(N,IL)) -> #activate(IL)
   #6: #activate(n__cons(X1,X2)) -> #cons(activate(X1),X2)
   #7: #activate(n__cons(X1,X2)) -> #activate(X1)
   #8: #activate(n__s(X)) -> #s(activate(X))
   #9: #activate(n__s(X)) -> #activate(X)
   #10: #activate(n__zeros()) -> #zeros()
   #11: #activate(n__take(X1,X2)) -> #take(activate(X1),activate(X2))
   #12: #activate(n__take(X1,X2)) -> #activate(X1)
   #13: #activate(n__take(X1,X2)) -> #activate(X2)
   #14: #activate(n__length(X)) -> #length(activate(X))
   #15: #activate(n__length(X)) -> #activate(X)
   #16: #U81(tt()) -> #nil()
   #17: #U61(tt(),V2) -> #U62(isNatIList(activate(V2)))
   #18: #U61(tt(),V2) -> #isNatIList(activate(V2))
   #19: #U61(tt(),V2) -> #activate(V2)
   #20: #U71(tt(),L,N) -> #U72(isNat(activate(N)),activate(L))
   #21: #U71(tt(),L,N) -> #isNat(activate(N))
   #22: #U71(tt(),L,N) -> #activate(N)
   #23: #U71(tt(),L,N) -> #activate(L)
   #24: #isNatList(n__cons(V1,V2)) -> #U51(isNat(activate(V1)),activate(V2))
   #25: #isNatList(n__cons(V1,V2)) -> #isNat(activate(V1))
   #26: #isNatList(n__cons(V1,V2)) -> #activate(V1)
   #27: #isNatList(n__cons(V1,V2)) -> #activate(V2)
   #28: #U72(tt(),L) -> #s(length(activate(L)))
   #29: #U72(tt(),L) -> #length(activate(L))
   #30: #U72(tt(),L) -> #activate(L)
   #31: #U91(tt(),IL,M,N) -> #U92(isNat(activate(M)),activate(IL),activate(M),activate(N))
   #32: #U91(tt(),IL,M,N) -> #isNat(activate(M))
   #33: #U91(tt(),IL,M,N) -> #activate(M)
   #34: #U91(tt(),IL,M,N) -> #activate(IL)
   #35: #U91(tt(),IL,M,N) -> #activate(M)
   #36: #U91(tt(),IL,M,N) -> #activate(N)
   #37: #isNatList(n__take(V1,V2)) -> #U61(isNat(activate(V1)),activate(V2))
   #38: #isNatList(n__take(V1,V2)) -> #isNat(activate(V1))
   #39: #isNatList(n__take(V1,V2)) -> #activate(V1)
   #40: #isNatList(n__take(V1,V2)) -> #activate(V2)
   #41: #isNatIList(V) -> #U31(isNatList(activate(V)))
   #42: #isNatIList(V) -> #isNatList(activate(V))
   #43: #isNatIList(V) -> #activate(V)
   #44: #U51(tt(),V2) -> #U52(isNatList(activate(V2)))
   #45: #U51(tt(),V2) -> #isNatList(activate(V2))
   #46: #U51(tt(),V2) -> #activate(V2)
   #47: #activate(n__0()) -> #0()
   #48: #U41(tt(),V2) -> #U42(isNatIList(activate(V2)))
   #49: #U41(tt(),V2) -> #isNatIList(activate(V2))
   #50: #U41(tt(),V2) -> #activate(V2)
   #51: #take(0(),IL) -> #U81(isNatIList(IL))
   #52: #take(0(),IL) -> #isNatIList(IL)
   #53: #isNatIList(n__cons(V1,V2)) -> #U41(isNat(activate(V1)),activate(V2))
   #54: #isNatIList(n__cons(V1,V2)) -> #isNat(activate(V1))
   #55: #isNatIList(n__cons(V1,V2)) -> #activate(V1)
   #56: #isNatIList(n__cons(V1,V2)) -> #activate(V2)
   #57: #length(cons(N,L)) -> #U71(isNatList(activate(L)),activate(L),N)
   #58: #length(cons(N,L)) -> #isNatList(activate(L))
   #59: #length(cons(N,L)) -> #activate(L)
   #60: #length(cons(N,L)) -> #activate(L)
   #61: #isNat(n__s(V1)) -> #U21(isNat(activate(V1)))
   #62: #isNat(n__s(V1)) -> #isNat(activate(V1))
   #63: #isNat(n__s(V1)) -> #activate(V1)
   #64: #length(nil()) -> #0()
   #65: #U93(tt(),IL,M,N) -> #cons(activate(N),n__take(activate(M),activate(IL)))
   #66: #U93(tt(),IL,M,N) -> #activate(N)
   #67: #U93(tt(),IL,M,N) -> #activate(M)
   #68: #U93(tt(),IL,M,N) -> #activate(IL)
   #69: #zeros() -> #cons(0(),n__zeros())
   #70: #zeros() -> #0()
   #71: #U92(tt(),IL,M,N) -> #U93(isNat(activate(N)),activate(IL),activate(M),activate(N))
   #72: #U92(tt(),IL,M,N) -> #isNat(activate(N))
   #73: #U92(tt(),IL,M,N) -> #activate(N)
   #74: #U92(tt(),IL,M,N) -> #activate(IL)
   #75: #U92(tt(),IL,M,N) -> #activate(M)
   #76: #U92(tt(),IL,M,N) -> #activate(N)
   #77: #isNat(n__length(V1)) -> #U11(isNatList(activate(V1)))
   #78: #isNat(n__length(V1)) -> #isNatList(activate(V1))
   #79: #isNat(n__length(V1)) -> #activate(V1)
Number of SCCs: 1, DPs: 61, edges: 369
	SCC { #2..5 #7 #9 #11..15 #18..27 #29..40 #42 #43 #45 #46 #49 #50 #52..60 #62 #63 #66..68 #71..76 #78 #79 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
   #0()	weight: 0
 #U72(x1,x2)	weight: (/ 3 8) + x2
   U21(x1)	weight: 0
isNatList(x1)	weight: (/ 1 8)
   U11(x1)	weight: 0
#cons(x1,x2)	weight: 0
     s(x1)	weight: x1
#isNat(x1)	weight: (/ 1 8) + x1
#take(x1,x2)	weight: (/ 1 2) + x1 + x2
   U42(x1)	weight: (/ 3 8)
   U91(x1,x2,x3,x4)	weight: (/ 5 8) + x2 + x3 + x4
activate(x1)	weight: x1
  take(x1,x2)	weight: (/ 5 8) + x1 + x2
   U71(x1,x2,x3)	weight: (/ 1 2) + x2
 #U81(x1)	weight: 0
 #U92(x1,x2,x3,x4)	weight: (/ 1 4) + x2 + x3 + x4
n__zeros()	weight: 0
isNatIList(x1)	weight: (/ 1 8)
 #U93(x1,x2,x3,x4)	weight: (/ 1 8) + x2 + x3 + x4
#activate(x1)	weight: x1
   U93(x1,x2,x3,x4)	weight: (/ 5 8) + x2 + x3 + x4
   U72(x1,x2)	weight: (/ 1 2) + x2
 zeros()	weight: 0
n__nil()	weight: 0
 #U52(x1)	weight: 0
  n__s(x1)	weight: x1
 #U42(x1)	weight: 0
 #U62(x1)	weight: 0
     0()	weight: 0
#zeros()	weight: 0
n__take(x1,x2)	weight: (/ 5 8) + x1 + x2
#isNatList(x1)	weight: (/ 1 4) + x1
   #s(x1)	weight: 0
n__cons(x1,x2)	weight: x1 + x2
   nil()	weight: 0
   U62(x1)	weight: (/ 3 8)
 #nil()	weight: 0
  n__0()	weight: 0
n__length(x1)	weight: (/ 1 2) + x1
 isNat(x1)	weight: (/ 1 8)
   U52(x1)	weight: (/ 1 4) + x1
   U61(x1,x2)	weight: (/ 1 4)
 #U51(x1,x2)	weight: (/ 1 4) + x2
 #U11(x1)	weight: 0
   U31(x1)	weight: (/ 1 4)
   U92(x1,x2,x3,x4)	weight: (/ 5 8) + x2 + x3 + x4
 #U41(x1,x2)	weight: (/ 3 8) + x2
  cons(x1,x2)	weight: x1 + x2
#isNatIList(x1)	weight: (/ 3 8) + x1
 #U21(x1)	weight: 0
   U81(x1)	weight: 0
    tt()	weight: 0
 #U71(x1,x2,x3)	weight: (/ 3 8) + x2 + x3
   U51(x1,x2)	weight: (/ 1 4)
length(x1)	weight: (/ 1 2) + x1
#length(x1)	weight: (/ 3 8) + x1
   U41(x1,x2)	weight: (/ 1 4)
 #U31(x1)	weight: 0
 #U91(x1,x2,x3,x4)	weight: (/ 3 8) + x2 + x3 + x4
 #U61(x1,x2)	weight: (/ 1 2) + x2
    Usable rules: { 1..3 11..19 26..44 }
    Removed DPs: #2..5 #11..15 #18 #19 #21..23 #25..27 #30..40 #42 #43 #46 #50 #52 #54..56 #58..60 #63 #66..68 #71..76 #78 #79
Number of SCCs: 5, DPs: 10, edges: 12
	SCC { #62 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... succeeded.
   #0()	weight: 0; 0
 #U72(x1,x2)	weight: 0; 0
   U21(x1)	weight: 0; (/ 1 4)
isNatList(x1)	weight: (/ 1 4) + x1_1; x1_1
   U11(x1)	weight: 0; (/ 1 4)
#cons(x1,x2)	weight: 0; 0
     s(x1)	weight: (/ 1 4) + x1_1; (/ 1 4)
#isNat(x1)	weight: x1_1; 0
#take(x1,x2)	weight: 0; 0
   U42(x1)	weight: 0; (/ 1 4)
   U91(x1,x2,x3,x4)	weight: x1_2; x3_1 + x2_2 + x1_1 + x1_2
activate(x1)	weight: x1_1; x1_2
  take(x1,x2)	weight: (/ 1 4); x2_2 + x1_1
   U71(x1,x2,x3)	weight: (/ 1 4) + x2_2 + x1_2; x2_2 + x1_2
 #U81(x1)	weight: 0; 0
 #U92(x1,x2,x3,x4)	weight: 0; 0
n__zeros()	weight: 0; (/ 1 4)
isNatIList(x1)	weight: 0; (/ 1 4)
 #U93(x1,x2,x3,x4)	weight: 0; 0
#activate(x1)	weight: 0; 0
   U93(x1,x2,x3,x4)	weight: (/ 1 4); x3_1 + x2_2 + x1_2
   U72(x1,x2)	weight: (/ 1 4) + x2_2 + x1_2; x2_2 + x1_2
 zeros()	weight: 0; (/ 1 4)
n__nil()	weight: (/ 1 4); 0
 #U52(x1)	weight: 0; 0
  n__s(x1)	weight: (/ 1 4) + x1_1; (/ 1 4)
 #U42(x1)	weight: 0; 0
 #U62(x1)	weight: 0; 0
     0()	weight: 0; (/ 1 4)
#zeros()	weight: 0; 0
n__take(x1,x2)	weight: (/ 1 4); x2_2 + x1_1
#isNatList(x1)	weight: 0; 0
   #s(x1)	weight: 0; 0
n__cons(x1,x2)	weight: x2_1; x2_1 + x2_2
   nil()	weight: (/ 1 4); 0
   U62(x1)	weight: 0; x1_2
 #nil()	weight: 0; 0
  n__0()	weight: 0; (/ 1 4)
n__length(x1)	weight: (/ 1 4) + x1_2; (/ 1 4) + x1_1 + x1_2
 isNat(x1)	weight: x1_1 + x1_2; (/ 1 4)
   U52(x1)	weight: 0; x1_2
   U61(x1,x2)	weight: 0; (/ 1 4)
 #U51(x1,x2)	weight: 0; 0
 #U11(x1)	weight: 0; 0
   U31(x1)	weight: 0; (/ 1 4)
   U92(x1,x2,x3,x4)	weight: x1_2; x3_1 + x2_2 + x1_2
 #U41(x1,x2)	weight: 0; 0
  cons(x1,x2)	weight: x2_1; x2_1 + x2_2
#isNatIList(x1)	weight: 0; 0
 #U21(x1)	weight: 0; 0
   U81(x1)	weight: (/ 1 4); 0
    tt()	weight: 0; (/ 1 4)
 #U71(x1,x2,x3)	weight: 0; 0
   U51(x1,x2)	weight: 0; x2_1
length(x1)	weight: (/ 1 4) + x1_2; (/ 1 4) + x1_1 + x1_2
#length(x1)	weight: 0; 0
   U41(x1,x2)	weight: 0; (/ 1 4)
 #U31(x1)	weight: 0; 0
 #U91(x1,x2,x3,x4)	weight: 0; 0
 #U61(x1,x2)	weight: 0; 0
    Usable rules: { 1..44 }
    Removed DPs: #62
Number of SCCs: 4, DPs: 9, edges: 11
	SCC { #7 #9 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
   #0()	weight: 0
 #U72(x1,x2)	weight: (/ 3 8)
   U21(x1)	weight: 0
isNatList(x1)	weight: (/ 1 8)
   U11(x1)	weight: 0
#cons(x1,x2)	weight: 0
     s(x1)	weight: (/ 5 8)
#isNat(x1)	weight: (/ 1 8)
#take(x1,x2)	weight: (/ 1 2)
   U42(x1)	weight: (/ 3 8)
   U91(x1,x2,x3,x4)	weight: (/ 7 8) + x3 + x4
activate(x1)	weight: (/ 1 8)
  take(x1,x2)	weight: (/ 1 8) + x1
   U71(x1,x2,x3)	weight: (/ 3 8) + x3
 #U81(x1)	weight: 0
 #U92(x1,x2,x3,x4)	weight: (/ 1 4)
n__zeros()	weight: 0
isNatIList(x1)	weight: (/ 1 8)
 #U93(x1,x2,x3,x4)	weight: (/ 1 8)
#activate(x1)	weight: x1
   U93(x1,x2,x3,x4)	weight: (/ 3 4)
   U72(x1,x2)	weight: (/ 1 2)
 zeros()	weight: 0
n__nil()	weight: 0
 #U52(x1)	weight: 0
  n__s(x1)	weight: (/ 3 4) + x1
 #U42(x1)	weight: 0
 #U62(x1)	weight: 0
     0()	weight: 0
#zeros()	weight: 0
n__take(x1,x2)	weight: (/ 5 8) + x2
#isNatList(x1)	weight: (/ 1 4)
   #s(x1)	weight: 0
n__cons(x1,x2)	weight: (/ 7 8) + x1 + x2
   nil()	weight: 0
   U62(x1)	weight: (/ 3 8)
 #nil()	weight: 0
  n__0()	weight: 0
n__length(x1)	weight: (/ 1 2) + x1
 isNat(x1)	weight: (/ 1 8)
   U52(x1)	weight: (/ 1 4) + x1
   U61(x1,x2)	weight: (/ 1 4)
 #U51(x1,x2)	weight: (/ 1 4)
 #U11(x1)	weight: 0
   U31(x1)	weight: (/ 1 4)
   U92(x1,x2,x3,x4)	weight: (/ 5 8) + x2 + x3 + x4
 #U41(x1,x2)	weight: (/ 3 8)
  cons(x1,x2)	weight: (/ 3 4) + x1
#isNatIList(x1)	weight: (/ 3 8)
 #U21(x1)	weight: 0
   U81(x1)	weight: (/ 1 8) + x1
    tt()	weight: 0
 #U71(x1,x2,x3)	weight: (/ 3 8)
   U51(x1,x2)	weight: (/ 1 4)
length(x1)	weight: (/ 1 4)
#length(x1)	weight: (/ 3 8)
   U41(x1,x2)	weight: (/ 1 4)
 #U31(x1)	weight: 0
 #U91(x1,x2,x3,x4)	weight: (/ 3 8)
 #U61(x1,x2)	weight: (/ 1 2)
    Usable rules: { }
    Removed DPs: #7 #9
Number of SCCs: 3, DPs: 7, edges: 7
	SCC { #24 #45 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  failed.
