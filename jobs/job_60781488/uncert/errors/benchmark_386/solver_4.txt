Input TRS:
    1: f(true(),xs) -> f(isList(xs),append(cons(a(),nil()),xs))
    2: isList(nil()) -> true()
    3: isList(cons(x,xs)) -> isList(xs)
    4: append(nil(),ys) -> ys
    5: append(cons(x,xs),ys) -> cons(x,append(xs,ys))
Number of strict rules: 5
Direct Order(PosReal,>,Poly) ... failed.
Freezing append
1: f(true(),xs) -> f(isList(xs),append❆1_cons(a(),nil(),xs))
2: isList(nil()) -> true()
3: isList(cons(x,xs)) -> isList(xs)
4: append❆1_nil(ys) -> ys
5: append❆1_cons(x,xs,ys) -> cons(x,append(xs,ys))
6: append(cons(_1,_2),_3) ->= append❆1_cons(_1,_2,_3)
7: append(nil(),_1) ->= append❆1_nil(_1)
Number of strict rules: 5
Direct Order(PosReal,>,Poly) ... failed.
Dependency Pairs:
   #1: #append(cons(_1,_2),_3) ->? #append❆1_cons(_1,_2,_3)
   #2: #append(nil(),_1) ->? #append❆1_nil(_1)
   #3: #append❆1_cons(x,xs,ys) -> #append(xs,ys)
   #4: #isList(cons(x,xs)) -> #isList(xs)
   #5: #f(true(),xs) -> #f(isList(xs),append❆1_cons(a(),nil(),xs))
   #6: #f(true(),xs) -> #isList(xs)
   #7: #f(true(),xs) -> #append❆1_cons(a(),nil(),xs)
Number of SCCs: 3, DPs: 4, edges: 4
	SCC { #4 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
     a()	weight: 0
#append(x1,x2)	weight: 0
#append❆1_cons(x1,x2,x3)	weight: 0
append❆1_nil(x1)	weight: 0
  true()	weight: 0
     f(x1,x2)	weight: 0
append(x1,x2)	weight: 0
isList(x1)	weight: 0
   nil()	weight: 0
   #f(x1,x2)	weight: 0
#isList(x1)	weight: x1
  cons(x1,x2)	weight: (/ 1 2) + x2
append❆1_cons(x1,x2,x3)	weight: 0
#append❆1_nil(x1)	weight: 0
    Usable rules: { }
    Removed DPs: #4
Number of SCCs: 2, DPs: 3, edges: 3
	SCC { #5 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  failed.
