Input TRS:
    1: zeros() -> cons(0(),n__zeros())
    2: U11(tt()) -> tt()
    3: U21(tt()) -> tt()
    4: U31(tt()) -> tt()
    5: U41(tt(),V2) -> U42(isNatIList(activate(V2)))
    6: U42(tt()) -> tt()
    7: U51(tt(),V2) -> U52(isNatList(activate(V2)))
    8: U52(tt()) -> tt()
    9: U61(tt(),L,N) -> U62(isNat(activate(N)),activate(L))
    10: U62(tt(),L) -> s(length(activate(L)))
    11: isNat(n__0()) -> tt()
    12: isNat(n__length(V1)) -> U11(isNatList(activate(V1)))
    13: isNat(n__s(V1)) -> U21(isNat(activate(V1)))
    14: isNatIList(V) -> U31(isNatList(activate(V)))
    15: isNatIList(n__zeros()) -> tt()
    16: isNatIList(n__cons(V1,V2)) -> U41(isNat(activate(V1)),activate(V2))
    17: isNatList(n__nil()) -> tt()
    18: isNatList(n__cons(V1,V2)) -> U51(isNat(activate(V1)),activate(V2))
    19: length(nil()) -> 0()
    20: length(cons(N,L)) -> U61(isNatList(activate(L)),activate(L),N)
    21: zeros() -> n__zeros()
    22: 0() -> n__0()
    23: length(X) -> n__length(X)
    24: s(X) -> n__s(X)
    25: cons(X1,X2) -> n__cons(X1,X2)
    26: nil() -> n__nil()
    27: activate(n__zeros()) -> zeros()
    28: activate(n__0()) -> 0()
    29: activate(n__length(X)) -> length(X)
    30: activate(n__s(X)) -> s(X)
    31: activate(n__cons(X1,X2)) -> cons(X1,X2)
    32: activate(n__nil()) -> nil()
    33: activate(X) -> X
Number of strict rules: 33
Direct Order(PosReal,>,Poly) ... removes: 4 15 19 14 12 2
   U21(x1)	weight: x1
isNatList(x1)	weight: x1
   U11(x1)	weight: (/ 1 8) + x1
     s(x1)	weight: x1
   U42(x1)	weight: x1
activate(x1)	weight: x1
n__zeros()	weight: 0
isNatIList(x1)	weight: (/ 129113 4) + x1
 zeros()	weight: 0
n__nil()	weight: 0
  n__s(x1)	weight: x1
     0()	weight: 0
n__cons(x1,x2)	weight: 2 * x1 + 2 * x2
   nil()	weight: 0
   U62(x1,x2)	weight: (/ 1 4) + x1 + 2 * x2
  n__0()	weight: 0
n__length(x1)	weight: (/ 1 4) + 2 * x1
 isNat(x1)	weight: x1
   U52(x1)	weight: x1
   U61(x1,x2,x3)	weight: (/ 1 4) + x1 + 2 * x2 + x3
   U31(x1)	weight: (/ 258225 8) + x1
  cons(x1,x2)	weight: 2 * x1 + 2 * x2
    tt()	weight: 0
   U51(x1,x2)	weight: x1 + x2
length(x1)	weight: (/ 1 4) + 2 * x1
   U41(x1,x2)	weight: (/ 129113 4) + x1 + x2
Number of strict rules: 27
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #activate(n__length(X)) -> #length(X)
   #2: #isNat(n__s(V1)) -> #U21(isNat(activate(V1)))
   #3: #isNat(n__s(V1)) -> #isNat(activate(V1))
   #4: #isNat(n__s(V1)) -> #activate(V1)
   #5: #U61(tt(),L,N) -> #U62(isNat(activate(N)),activate(L))
   #6: #U61(tt(),L,N) -> #isNat(activate(N))
   #7: #U61(tt(),L,N) -> #activate(N)
   #8: #U61(tt(),L,N) -> #activate(L)
   #9: #activate(n__cons(X1,X2)) -> #cons(X1,X2)
   #10: #activate(n__s(X)) -> #s(X)
   #11: #length(cons(N,L)) -> #U61(isNatList(activate(L)),activate(L),N)
   #12: #length(cons(N,L)) -> #isNatList(activate(L))
   #13: #length(cons(N,L)) -> #activate(L)
   #14: #length(cons(N,L)) -> #activate(L)
   #15: #U51(tt(),V2) -> #U52(isNatList(activate(V2)))
   #16: #U51(tt(),V2) -> #isNatList(activate(V2))
   #17: #U51(tt(),V2) -> #activate(V2)
   #18: #U62(tt(),L) -> #s(length(activate(L)))
   #19: #U62(tt(),L) -> #length(activate(L))
   #20: #U62(tt(),L) -> #activate(L)
   #21: #U41(tt(),V2) -> #U42(isNatIList(activate(V2)))
   #22: #U41(tt(),V2) -> #isNatIList(activate(V2))
   #23: #U41(tt(),V2) -> #activate(V2)
   #24: #activate(n__0()) -> #0()
   #25: #activate(n__zeros()) -> #zeros()
   #26: #activate(n__nil()) -> #nil()
   #27: #isNatIList(n__cons(V1,V2)) -> #U41(isNat(activate(V1)),activate(V2))
   #28: #isNatIList(n__cons(V1,V2)) -> #isNat(activate(V1))
   #29: #isNatIList(n__cons(V1,V2)) -> #activate(V1)
   #30: #isNatIList(n__cons(V1,V2)) -> #activate(V2)
   #31: #zeros() -> #cons(0(),n__zeros())
   #32: #zeros() -> #0()
   #33: #isNatList(n__cons(V1,V2)) -> #U51(isNat(activate(V1)),activate(V2))
   #34: #isNatList(n__cons(V1,V2)) -> #isNat(activate(V1))
   #35: #isNatList(n__cons(V1,V2)) -> #activate(V1)
   #36: #isNatList(n__cons(V1,V2)) -> #activate(V2)
Number of SCCs: 2, DPs: 21, edges: 41
	SCC { #22 #27 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  failed.
