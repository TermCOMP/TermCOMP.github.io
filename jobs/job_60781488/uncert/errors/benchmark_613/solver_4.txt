Input TRS:
    1: double(x) -> permute(x,x,a())
    2: permute(x,y,a()) -> permute(isZero(x),x,b())
    3: permute(false(),x,b()) -> permute(ack(x,x),p(x),c())
    4: permute(true(),x,b()) -> 0()
    5: permute(y,x,c()) -> s(s(permute(x,y,a())))
    6: p(0()) -> 0()
    7: p(s(x)) -> x
    8: ack(0(),x) -> plus(x,s(0()))
    9: ack(s(x),0()) -> ack(x,s(0()))
    10: ack(s(x),s(y)) -> ack(x,ack(s(x),y))
    11: plus(0(),y) -> y
    12: plus(s(x),y) -> plus(x,s(y))
    13: plus(x,s(s(y))) -> s(plus(s(x),y))
    14: plus(x,s(0())) -> s(x)
    15: plus(x,0()) -> x
    16: isZero(0()) -> true()
    17: isZero(s(x)) -> false()
Number of strict rules: 17
Direct Order(PosReal,>,Poly) ... failed.
Freezing ack
1: double(x) -> permute(x,x,a())
2: permute(x,y,a()) -> permute(isZero(x),x,b())
3: permute(false(),x,b()) -> permute(ack(x,x),p(x),c())
4: permute(true(),x,b()) -> 0()
5: permute(y,x,c()) -> s(s(permute(x,y,a())))
6: p(0()) -> 0()
7: p(s(x)) -> x
8: ack❆1_0(x) -> plus(x,s(0()))
9: ack❆1_s(x,0()) -> ack(x,s(0()))
10: ack❆1_s(x,s(y)) -> ack(x,ack❆1_s(x,y))
11: plus(0(),y) -> y
12: plus(s(x),y) -> plus(x,s(y))
13: plus(x,s(s(y))) -> s(plus(s(x),y))
14: plus(x,s(0())) -> s(x)
15: plus(x,0()) -> x
16: isZero(0()) -> true()
17: isZero(s(x)) -> false()
18: ack(0(),_1) ->= ack❆1_0(_1)
19: ack(s(_1),_2) ->= ack❆1_s(_1,_2)
Number of strict rules: 17
Direct Order(PosReal,>,Poly) ... failed.
Dependency Pairs:
   #1: #permute(x,y,a()) -> #permute(isZero(x),x,b())
   #2: #permute(x,y,a()) -> #isZero(x)
   #3: #plus(x,s(s(y))) -> #plus(s(x),y)
   #4: #ack❆1_s(x,0()) -> #ack(x,s(0()))
   #5: #plus(s(x),y) -> #plus(x,s(y))
   #6: #ack❆1_s(x,s(y)) -> #ack(x,ack❆1_s(x,y))
   #7: #ack❆1_s(x,s(y)) -> #ack❆1_s(x,y)
   #8: #permute(y,x,c()) -> #permute(x,y,a())
   #9: #ack(s(_1),_2) ->? #ack❆1_s(_1,_2)
   #10: #permute(false(),x,b()) -> #permute(ack(x,x),p(x),c())
   #11: #permute(false(),x,b()) -> #ack(x,x)
   #12: #permute(false(),x,b()) -> #p(x)
   #13: #double(x) -> #permute(x,x,a())
   #14: #ack❆1_0(x) -> #plus(x,s(0()))
   #15: #ack(0(),_1) ->? #ack❆1_0(_1)
Number of SCCs: 3, DPs: 9, edges: 15
	SCC { #3 #5 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
     a()	weight: 0
     s(x1)	weight: (/ 1 4) + x1
#isZero(x1)	weight: 0
permute(x1,x2,x3)	weight: 0
     b()	weight: 0
   ack(x1,x2)	weight: 0
#plus(x1,x2)	weight: x1 + x2
 false()	weight: 0
     c()	weight: 0
#ack❆1_0(x1)	weight: 0
   #p(x1)	weight: 0
  true()	weight: 0
     p(x1)	weight: 0
     0()	weight: 0
#double(x1)	weight: 0
double(x1)	weight: 0
ack❆1_0(x1)	weight: 0
  plus(x1,x2)	weight: 0
 #ack(x1,x2)	weight: 0
ack❆1_s(x1,x2)	weight: 0
#ack❆1_s(x1,x2)	weight: 0
#permute(x1,x2,x3)	weight: 0
isZero(x1)	weight: 0
    Usable rules: { }
    Removed DPs: #3
Number of SCCs: 3, DPs: 8, edges: 12
	SCC { #5 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
     a()	weight: 0
     s(x1)	weight: (/ 1 2) + x1
#isZero(x1)	weight: 0
permute(x1,x2,x3)	weight: 0
     b()	weight: 0
   ack(x1,x2)	weight: 0
#plus(x1,x2)	weight: x1
 false()	weight: 0
     c()	weight: 0
#ack❆1_0(x1)	weight: 0
   #p(x1)	weight: 0
  true()	weight: 0
     p(x1)	weight: 0
     0()	weight: 0
#double(x1)	weight: 0
double(x1)	weight: 0
ack❆1_0(x1)	weight: 0
  plus(x1,x2)	weight: 0
 #ack(x1,x2)	weight: 0
ack❆1_s(x1,x2)	weight: 0
#ack❆1_s(x1,x2)	weight: 0
#permute(x1,x2,x3)	weight: 0
isZero(x1)	weight: 0
    Usable rules: { }
    Removed DPs: #5
Number of SCCs: 2, DPs: 7, edges: 11
	SCC { #1 #8 #10 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  failed.
