Input TRS:
    1: natsFrom(N) -> cons(N,n__natsFrom(n__s(N)))
    2: fst(pair(XS,YS)) -> XS
    3: snd(pair(XS,YS)) -> YS
    4: splitAt(0(),XS) -> pair(nil(),XS)
    5: splitAt(s(N),cons(X,XS)) -> u(splitAt(N,activate(XS)),N,X,activate(XS))
    6: u(pair(YS,ZS),N,X,XS) -> pair(cons(activate(X),YS),ZS)
    7: head(cons(N,XS)) -> N
    8: tail(cons(N,XS)) -> activate(XS)
    9: sel(N,XS) -> head(afterNth(N,XS))
    10: take(N,XS) -> fst(splitAt(N,XS))
    11: afterNth(N,XS) -> snd(splitAt(N,XS))
    12: natsFrom(X) -> n__natsFrom(X)
    13: s(X) -> n__s(X)
    14: activate(n__natsFrom(X)) -> natsFrom(activate(X))
    15: activate(n__s(X)) -> s(activate(X))
    16: activate(X) -> X
Number of strict rules: 16
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #u(pair(YS,ZS),N,X,XS) -> #activate(X)
   #2: #sel(N,XS) -> #head(afterNth(N,XS))
   #3: #sel(N,XS) -> #afterNth(N,XS)
   #4: #afterNth(N,XS) -> #snd(splitAt(N,XS))
   #5: #afterNth(N,XS) -> #splitAt(N,XS)
   #6: #activate(n__natsFrom(X)) -> #natsFrom(activate(X))
   #7: #activate(n__natsFrom(X)) -> #activate(X)
   #8: #take(N,XS) -> #fst(splitAt(N,XS))
   #9: #take(N,XS) -> #splitAt(N,XS)
   #10: #splitAt(s(N),cons(X,XS)) -> #u(splitAt(N,activate(XS)),N,X,activate(XS))
   #11: #splitAt(s(N),cons(X,XS)) -> #splitAt(N,activate(XS))
   #12: #splitAt(s(N),cons(X,XS)) -> #activate(XS)
   #13: #splitAt(s(N),cons(X,XS)) -> #activate(XS)
   #14: #tail(cons(N,XS)) -> #activate(XS)
   #15: #activate(n__s(X)) -> #s(activate(X))
   #16: #activate(n__s(X)) -> #activate(X)
Number of SCCs: 2, DPs: 3, edges: 5
	SCC { #7 #16 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
     s(x1)	weight: 0
#take(x1,x2)	weight: 0
     u(x1,x2,x3,x4)	weight: 0
activate(x1)	weight: 0
  take(x1,x2)	weight: 0
   #u(x1,x2,x3,x4)	weight: 0
  pair(x1,x2)	weight: 0
   fst(x1)	weight: 0
#activate(x1)	weight: x1
natsFrom(x1)	weight: 0
#head(x1)	weight: 0
splitAt(x1,x2)	weight: 0
 #fst(x1)	weight: 0
n__natsFrom(x1)	weight: (/ 1 2) + x1
  n__s(x1)	weight: (/ 1 2) + x1
  tail(x1)	weight: 0
     0()	weight: 0
 #sel(x1,x2)	weight: 0
   sel(x1,x2)	weight: 0
   #s(x1)	weight: 0
afterNth(x1,x2)	weight: 0
   nil()	weight: 0
#tail(x1)	weight: 0
#splitAt(x1,x2)	weight: 0
#afterNth(x1,x2)	weight: 0
  head(x1)	weight: 0
 #snd(x1)	weight: 0
  cons(x1,x2)	weight: 0
#natsFrom(x1)	weight: 0
   snd(x1)	weight: 0
    Usable rules: { }
    Removed DPs: #7 #16
Number of SCCs: 1, DPs: 1, edges: 1
	SCC { #11 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
     s(x1)	weight: (/ 1 8) + x1
#take(x1,x2)	weight: 0
     u(x1,x2,x3,x4)	weight: 0
activate(x1)	weight: (/ 1 8)
  take(x1,x2)	weight: 0
   #u(x1,x2,x3,x4)	weight: 0
  pair(x1,x2)	weight: 0
   fst(x1)	weight: 0
#activate(x1)	weight: 0
natsFrom(x1)	weight: (/ 1 4)
#head(x1)	weight: 0
splitAt(x1,x2)	weight: 0
 #fst(x1)	weight: 0
n__natsFrom(x1)	weight: (/ 3 8) + x1
  n__s(x1)	weight: (/ 1 4) + x1
  tail(x1)	weight: 0
     0()	weight: 0
 #sel(x1,x2)	weight: 0
   sel(x1,x2)	weight: 0
   #s(x1)	weight: 0
afterNth(x1,x2)	weight: 0
   nil()	weight: 0
#tail(x1)	weight: 0
#splitAt(x1,x2)	weight: x1
#afterNth(x1,x2)	weight: 0
  head(x1)	weight: 0
 #snd(x1)	weight: 0
  cons(x1,x2)	weight: (/ 1 8) + x2
#natsFrom(x1)	weight: 0
   snd(x1)	weight: 0
    Usable rules: { }
    Removed DPs: #11
Number of SCCs: 0, DPs: 0, edges: 0
