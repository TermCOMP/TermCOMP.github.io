Input TRS:
    1: notZero(pos(s(x))) -> true()
    2: notZero(neg(s(x))) -> true()
    3: notZero(neg(0())) -> false()
    4: notZero(pos(0())) -> false()
    5: greaterZero(pos(s(x))) -> true()
    6: greaterZero(pos(0())) -> false()
    7: greaterZero(neg(x)) -> false()
    8: and(false(),false()) -> false()
    9: and(false(),true()) -> false()
    10: and(true(),false()) -> false()
    11: and(true(),true()) -> true()
    12: minusT(0(),y) -> neg(y)
    13: minusT(x,0()) -> pos(x)
    14: minusT(s(x),s(y)) -> minusT(x,y)
    15: plusNat(0(),y) -> y
    16: plusNat(s(x),y) -> plusNat(x,s(y))
    17: negate(pos(x)) -> neg(x)
    18: negate(neg(x)) -> pos(x)
    19: minus(pos(x),pos(y)) -> minusT(x,y)
    20: minus(neg(x),neg(y)) -> negate(minusT(x,y))
    21: minus(pos(x),neg(y)) -> pos(plusNat(x,y))
    22: minus(neg(x),pos(y)) -> neg(plusNat(x,y))
    23: while(true(),i,y) -> while(and(notZero(y),greaterZero(i)),minus(i,y),y)
Number of strict rules: 23
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #while(true(),i,y) -> #while(and(notZero(y),greaterZero(i)),minus(i,y),y)
   #2: #while(true(),i,y) -> #and(notZero(y),greaterZero(i))
   #3: #while(true(),i,y) -> #notZero(y)
   #4: #while(true(),i,y) -> #greaterZero(i)
   #5: #while(true(),i,y) -> #minus(i,y)
   #6: #minusT(s(x),s(y)) -> #minusT(x,y)
   #7: #minus(neg(x),neg(y)) -> #negate(minusT(x,y))
   #8: #minus(neg(x),neg(y)) -> #minusT(x,y)
   #9: #minus(neg(x),pos(y)) -> #plusNat(x,y)
   #10: #minus(pos(x),pos(y)) -> #minusT(x,y)
   #11: #minus(pos(x),neg(y)) -> #plusNat(x,y)
   #12: #plusNat(s(x),y) -> #plusNat(x,s(y))
Number of SCCs: 3, DPs: 3, edges: 3
	SCC { #6 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#negate(x1)	weight: 0
     s(x1)	weight: (/ 1 2) + x1
negate(x1)	weight: 0
 minus(x1,x2)	weight: 0
minusT(x1,x2)	weight: 0
   and(x1,x2)	weight: 0
#greaterZero(x1)	weight: 0
 false()	weight: 0
#while(x1,x2,x3)	weight: 0
  true()	weight: 0
   pos(x1)	weight: 0
greaterZero(x1)	weight: 0
     0()	weight: 0
 while(x1,x2,x3)	weight: 0
plusNat(x1,x2)	weight: 0
notZero(x1)	weight: 0
#minusT(x1,x2)	weight: x2
   neg(x1)	weight: 0
#minus(x1,x2)	weight: 0
#plusNat(x1,x2)	weight: 0
 #and(x1,x2)	weight: 0
#notZero(x1)	weight: 0
    Usable rules: { }
    Removed DPs: #6
Number of SCCs: 2, DPs: 2, edges: 2
	SCC { #12 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#negate(x1)	weight: 0
     s(x1)	weight: (/ 1 2) + x1
negate(x1)	weight: 0
 minus(x1,x2)	weight: 0
minusT(x1,x2)	weight: 0
   and(x1,x2)	weight: 0
#greaterZero(x1)	weight: 0
 false()	weight: 0
#while(x1,x2,x3)	weight: 0
  true()	weight: 0
   pos(x1)	weight: 0
greaterZero(x1)	weight: 0
     0()	weight: 0
 while(x1,x2,x3)	weight: 0
plusNat(x1,x2)	weight: 0
notZero(x1)	weight: 0
#minusT(x1,x2)	weight: 0
   neg(x1)	weight: 0
#minus(x1,x2)	weight: 0
#plusNat(x1,x2)	weight: x1
 #and(x1,x2)	weight: 0
#notZero(x1)	weight: 0
    Usable rules: { }
    Removed DPs: #12
Number of SCCs: 1, DPs: 1, edges: 1
	SCC { #1 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  failed.
