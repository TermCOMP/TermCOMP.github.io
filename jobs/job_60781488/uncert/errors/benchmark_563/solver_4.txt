Input TRS:
    1: min(X,0()) -> X
    2: min(s(X),s(Y)) -> min(X,Y)
    3: quot(0(),s(Y)) -> 0()
    4: quot(s(X),s(Y)) -> s(quot(min(X,Y),s(Y)))
    5: log(s(0())) -> 0()
    6: log(s(s(X))) -> s(log(s(quot(X,s(s(0()))))))
Number of strict rules: 6
Direct Order(PosReal,>,Poly) ... failed.
Freezing log
1: min(X,0()) -> X
2: min(s(X),s(Y)) -> min(X,Y)
3: quot(0(),s(Y)) -> 0()
4: quot(s(X),s(Y)) -> s(quot(min(X,Y),s(Y)))
5: log❆1_s(0()) -> 0()
6: log❆1_s(s(X)) -> s(log❆1_s(quot(X,s(s(0())))))
7: log(s(_1)) ->= log❆1_s(_1)
Number of strict rules: 6
Direct Order(PosReal,>,Poly) ... failed.
Dependency Pairs:
   #1: #min(s(X),s(Y)) -> #min(X,Y)
   #2: #log❆1_s(s(X)) -> #log❆1_s(quot(X,s(s(0()))))
   #3: #log❆1_s(s(X)) -> #quot(X,s(s(0())))
   #4: #log(s(_1)) ->? #log❆1_s(_1)
   #5: #quot(s(X),s(Y)) -> #quot(min(X,Y),s(Y))
   #6: #quot(s(X),s(Y)) -> #min(X,Y)
Number of SCCs: 3, DPs: 3, edges: 3
	SCC { #1 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
     s(x1)	weight: (/ 1 2) + x1
 #min(x1,x2)	weight: x2
 #log(x1)	weight: 0
#log❆1_s(x1)	weight: 0
   log(x1)	weight: 0
     0()	weight: 0
  quot(x1,x2)	weight: 0
   min(x1,x2)	weight: 0
#quot(x1,x2)	weight: 0
log❆1_s(x1)	weight: 0
    Usable rules: { }
    Removed DPs: #1
Number of SCCs: 2, DPs: 2, edges: 2
	SCC { #2 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
     s(x1)	weight: (/ 1 4) + x1
 #min(x1,x2)	weight: 0
 #log(x1)	weight: 0
#log❆1_s(x1)	weight: x1
   log(x1)	weight: 0
     0()	weight: 0
  quot(x1,x2)	weight: (/ 1 8) + x1
   min(x1,x2)	weight: x1
#quot(x1,x2)	weight: 0
log❆1_s(x1)	weight: 0
    Usable rules: { 1..4 }
    Removed DPs: #2
Number of SCCs: 1, DPs: 1, edges: 1
	SCC { #5 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
     s(x1)	weight: (/ 1 2) + x1
 #min(x1,x2)	weight: 0
 #log(x1)	weight: 0
#log❆1_s(x1)	weight: x1
   log(x1)	weight: 0
     0()	weight: 0
  quot(x1,x2)	weight: (/ 1 4) + x1
   min(x1,x2)	weight: x1
#quot(x1,x2)	weight: x1
log❆1_s(x1)	weight: 0
    Usable rules: { 1 2 }
    Removed DPs: #5
Number of SCCs: 0, DPs: 0, edges: 0
