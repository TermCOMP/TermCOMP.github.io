Input TRS:
    1: fstsplit(0(),x) -> nil()
    2: fstsplit(s(n),nil()) -> nil()
    3: fstsplit(s(n),cons(h,t)) -> cons(h,fstsplit(n,t))
    4: sndsplit(0(),x) -> x
    5: sndsplit(s(n),nil()) -> nil()
    6: sndsplit(s(n),cons(h,t)) -> sndsplit(n,t)
    7: empty(nil()) -> true()
    8: empty(cons(h,t)) -> false()
    9: leq(0(),m) -> true()
    10: leq(s(n),0()) -> false()
    11: leq(s(n),s(m)) -> leq(n,m)
    12: length(nil()) -> 0()
    13: length(cons(h,t)) -> s(length(t))
    14: app(nil(),x) -> x
    15: app(cons(h,t),x) -> cons(h,app(t,x))
    16: map_f(pid,nil()) -> nil()
    17: map_f(pid,cons(h,t)) -> app(f(pid,h),map_f(pid,t))
    18: process(store,m) -> if1(store,m,leq(m,length(store)))
    19: if1(store,m,true()) -> if2(store,m,empty(fstsplit(m,store)))
    20: if1(store,m,false()) -> if3(store,m,empty(fstsplit(m,app(map_f(self(),nil()),store))))
    21: if2(store,m,false()) -> process(app(map_f(self(),nil()),sndsplit(m,store)),m)
    22: if3(store,m,false()) -> process(sndsplit(m,app(map_f(self(),nil()),store)),m)
Number of strict rules: 22
Direct Order(PosReal,>,Poly) ... failed.
Freezing app
1: fstsplit(0(),x) -> nil()
2: fstsplit(s(n),nil()) -> nil()
3: fstsplit(s(n),cons(h,t)) -> cons(h,fstsplit(n,t))
4: sndsplit(0(),x) -> x
5: sndsplit(s(n),nil()) -> nil()
6: sndsplit(s(n),cons(h,t)) -> sndsplit(n,t)
7: empty(nil()) -> true()
8: empty(cons(h,t)) -> false()
9: leq(0(),m) -> true()
10: leq(s(n),0()) -> false()
11: leq(s(n),s(m)) -> leq(n,m)
12: length(nil()) -> 0()
13: length(cons(h,t)) -> s(length(t))
14: app❆1_nil(x) -> x
15: app❆1_cons(h,t,x) -> cons(h,app(t,x))
16: map_f(pid,nil()) -> nil()
17: map_f(pid,cons(h,t)) -> app❆1_f(pid,h,map_f(pid,t))
18: process(store,m) -> if1(store,m,leq(m,length(store)))
19: if1(store,m,true()) -> if2(store,m,empty(fstsplit(m,store)))
20: if1(store,m,false()) -> if3(store,m,empty(fstsplit(m,app(map_f(self(),nil()),store))))
21: if2(store,m,false()) -> process(app(map_f(self(),nil()),sndsplit(m,store)),m)
22: if3(store,m,false()) -> process(sndsplit(m,app(map_f(self(),nil()),store)),m)
23: app(cons(_1,_2),_3) ->= app❆1_cons(_1,_2,_3)
24: app(nil(),_1) ->= app❆1_nil(_1)
25: app(f(_1,_2),_3) ->= app❆1_f(_1,_2,_3)
Number of strict rules: 22
Direct Order(PosReal,>,Poly) ... failed.
Dependency Pairs:
   #1: #sndsplit(s(n),cons(h,t)) -> #sndsplit(n,t)
   #2: #length(cons(h,t)) -> #length(t)
   #3: #leq(s(n),s(m)) -> #leq(n,m)
   #4: #app(nil(),_1) ->? #app❆1_nil(_1)
   #5: #app(cons(_1,_2),_3) ->? #app❆1_cons(_1,_2,_3)
   #6: #if1(store,m,false()) -> #if3(store,m,empty(fstsplit(m,app(map_f(self(),nil()),store))))
   #7: #if1(store,m,false()) -> #empty(fstsplit(m,app(map_f(self(),nil()),store)))
   #8: #if1(store,m,false()) -> #fstsplit(m,app(map_f(self(),nil()),store))
   #9: #if1(store,m,false()) -> #app(map_f(self(),nil()),store)
   #10: #if1(store,m,false()) -> #map_f(self(),nil())
   #11: #if3(store,m,false()) -> #process(sndsplit(m,app(map_f(self(),nil()),store)),m)
   #12: #if3(store,m,false()) -> #sndsplit(m,app(map_f(self(),nil()),store))
   #13: #if3(store,m,false()) -> #app(map_f(self(),nil()),store)
   #14: #if3(store,m,false()) -> #map_f(self(),nil())
   #15: #map_f(pid,cons(h,t)) -> #map_f(pid,t)
   #16: #if1(store,m,true()) -> #if2(store,m,empty(fstsplit(m,store)))
   #17: #if1(store,m,true()) -> #empty(fstsplit(m,store))
   #18: #if1(store,m,true()) -> #fstsplit(m,store)
   #19: #if2(store,m,false()) -> #process(app(map_f(self(),nil()),sndsplit(m,store)),m)
   #20: #if2(store,m,false()) -> #app(map_f(self(),nil()),sndsplit(m,store))
   #21: #if2(store,m,false()) -> #map_f(self(),nil())
   #22: #if2(store,m,false()) -> #sndsplit(m,store)
   #23: #fstsplit(s(n),cons(h,t)) -> #fstsplit(n,t)
   #24: #app❆1_cons(h,t,x) -> #app(t,x)
   #25: #process(store,m) -> #if1(store,m,leq(m,length(store)))
   #26: #process(store,m) -> #leq(m,length(store))
   #27: #process(store,m) -> #length(store)
Number of SCCs: 7, DPs: 12, edges: 13
	SCC { #2 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#empty(x1)	weight: 0
     s(x1)	weight: 0
#sndsplit(x1,x2)	weight: 0
#process(x1,x2)	weight: 0
app❆1_nil(x1)	weight: 0
#app❆1_cons(x1,x2,x3)	weight: 0
sndsplit(x1,x2)	weight: 0
   if1(x1,x2,x3)	weight: 0
 false()	weight: 0
   leq(x1,x2)	weight: 0
  true()	weight: 0
     f(x1,x2)	weight: 0
 #leq(x1,x2)	weight: 0
 #if1(x1,x2,x3)	weight: 0
   if2(x1,x2,x3)	weight: 0
#fstsplit(x1,x2)	weight: 0
 #if3(x1,x2,x3)	weight: 0
     0()	weight: 0
app❆1_f(x1,x2,x3)	weight: 0
#map_f(x1,x2)	weight: 0
#app❆1_nil(x1)	weight: 0
   nil()	weight: 0
process(x1,x2)	weight: 0
 #app(x1,x2)	weight: 0
fstsplit(x1,x2)	weight: 0
 map_f(x1,x2)	weight: 0
  self()	weight: 0
   if3(x1,x2,x3)	weight: 0
  cons(x1,x2)	weight: (/ 1 2) + x2
 empty(x1)	weight: 0
app❆1_cons(x1,x2,x3)	weight: 0
length(x1)	weight: 0
 #if2(x1,x2,x3)	weight: 0
#length(x1)	weight: x1
   app(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #2
Number of SCCs: 6, DPs: 11, edges: 12
	SCC { #3 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#empty(x1)	weight: 0
     s(x1)	weight: (/ 1 2) + x1
#sndsplit(x1,x2)	weight: 0
#process(x1,x2)	weight: 0
app❆1_nil(x1)	weight: 0
#app❆1_cons(x1,x2,x3)	weight: 0
sndsplit(x1,x2)	weight: 0
   if1(x1,x2,x3)	weight: 0
 false()	weight: 0
   leq(x1,x2)	weight: 0
  true()	weight: 0
     f(x1,x2)	weight: 0
 #leq(x1,x2)	weight: x2
 #if1(x1,x2,x3)	weight: 0
   if2(x1,x2,x3)	weight: 0
#fstsplit(x1,x2)	weight: 0
 #if3(x1,x2,x3)	weight: 0
     0()	weight: 0
app❆1_f(x1,x2,x3)	weight: 0
#map_f(x1,x2)	weight: 0
#app❆1_nil(x1)	weight: 0
   nil()	weight: 0
process(x1,x2)	weight: 0
 #app(x1,x2)	weight: 0
fstsplit(x1,x2)	weight: 0
 map_f(x1,x2)	weight: 0
  self()	weight: 0
   if3(x1,x2,x3)	weight: 0
  cons(x1,x2)	weight: (/ 1 2)
 empty(x1)	weight: 0
app❆1_cons(x1,x2,x3)	weight: 0
length(x1)	weight: 0
 #if2(x1,x2,x3)	weight: 0
#length(x1)	weight: 0
   app(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #3
Number of SCCs: 5, DPs: 10, edges: 11
	SCC { #15 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#empty(x1)	weight: 0
     s(x1)	weight: (/ 1 2)
#sndsplit(x1,x2)	weight: 0
#process(x1,x2)	weight: 0
app❆1_nil(x1)	weight: 0
#app❆1_cons(x1,x2,x3)	weight: 0
sndsplit(x1,x2)	weight: 0
   if1(x1,x2,x3)	weight: 0
 false()	weight: 0
   leq(x1,x2)	weight: 0
  true()	weight: 0
     f(x1,x2)	weight: 0
 #leq(x1,x2)	weight: 0
 #if1(x1,x2,x3)	weight: 0
   if2(x1,x2,x3)	weight: 0
#fstsplit(x1,x2)	weight: 0
 #if3(x1,x2,x3)	weight: 0
     0()	weight: 0
app❆1_f(x1,x2,x3)	weight: 0
#map_f(x1,x2)	weight: x2
#app❆1_nil(x1)	weight: 0
   nil()	weight: 0
process(x1,x2)	weight: 0
 #app(x1,x2)	weight: 0
fstsplit(x1,x2)	weight: 0
 map_f(x1,x2)	weight: 0
  self()	weight: 0
   if3(x1,x2,x3)	weight: 0
  cons(x1,x2)	weight: (/ 1 2) + x2
 empty(x1)	weight: 0
app❆1_cons(x1,x2,x3)	weight: 0
length(x1)	weight: 0
 #if2(x1,x2,x3)	weight: 0
#length(x1)	weight: 0
   app(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #15
Number of SCCs: 4, DPs: 9, edges: 10
	SCC { #1 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#empty(x1)	weight: 0
     s(x1)	weight: (/ 1 2) + x1
#sndsplit(x1,x2)	weight: x1
#process(x1,x2)	weight: 0
app❆1_nil(x1)	weight: 0
#app❆1_cons(x1,x2,x3)	weight: 0
sndsplit(x1,x2)	weight: 0
   if1(x1,x2,x3)	weight: 0
 false()	weight: 0
   leq(x1,x2)	weight: 0
  true()	weight: 0
     f(x1,x2)	weight: 0
 #leq(x1,x2)	weight: 0
 #if1(x1,x2,x3)	weight: 0
   if2(x1,x2,x3)	weight: 0
#fstsplit(x1,x2)	weight: 0
 #if3(x1,x2,x3)	weight: 0
     0()	weight: 0
app❆1_f(x1,x2,x3)	weight: 0
#map_f(x1,x2)	weight: 0
#app❆1_nil(x1)	weight: 0
   nil()	weight: 0
process(x1,x2)	weight: 0
 #app(x1,x2)	weight: 0
fstsplit(x1,x2)	weight: 0
 map_f(x1,x2)	weight: 0
  self()	weight: 0
   if3(x1,x2,x3)	weight: 0
  cons(x1,x2)	weight: (/ 1 2)
 empty(x1)	weight: 0
app❆1_cons(x1,x2,x3)	weight: 0
length(x1)	weight: 0
 #if2(x1,x2,x3)	weight: 0
#length(x1)	weight: 0
   app(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #1
Number of SCCs: 3, DPs: 8, edges: 9
	SCC { #23 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#empty(x1)	weight: 0
     s(x1)	weight: (/ 1 2)
#sndsplit(x1,x2)	weight: 0
#process(x1,x2)	weight: 0
app❆1_nil(x1)	weight: 0
#app❆1_cons(x1,x2,x3)	weight: 0
sndsplit(x1,x2)	weight: 0
   if1(x1,x2,x3)	weight: 0
 false()	weight: 0
   leq(x1,x2)	weight: 0
  true()	weight: 0
     f(x1,x2)	weight: 0
 #leq(x1,x2)	weight: 0
 #if1(x1,x2,x3)	weight: 0
   if2(x1,x2,x3)	weight: 0
#fstsplit(x1,x2)	weight: x2
 #if3(x1,x2,x3)	weight: 0
     0()	weight: 0
app❆1_f(x1,x2,x3)	weight: 0
#map_f(x1,x2)	weight: 0
#app❆1_nil(x1)	weight: 0
   nil()	weight: 0
process(x1,x2)	weight: 0
 #app(x1,x2)	weight: 0
fstsplit(x1,x2)	weight: 0
 map_f(x1,x2)	weight: 0
  self()	weight: 0
   if3(x1,x2,x3)	weight: 0
  cons(x1,x2)	weight: (/ 1 2) + x2
 empty(x1)	weight: 0
app❆1_cons(x1,x2,x3)	weight: 0
length(x1)	weight: 0
 #if2(x1,x2,x3)	weight: 0
#length(x1)	weight: 0
   app(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #23
Number of SCCs: 2, DPs: 7, edges: 8
	SCC { #5 #24 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#empty(x1)	weight: 0
     s(x1)	weight: (/ 1 4)
#sndsplit(x1,x2)	weight: 0
#process(x1,x2)	weight: 0
app❆1_nil(x1)	weight: 0
#app❆1_cons(x1,x2,x3)	weight: (/ 1 4) + x2
sndsplit(x1,x2)	weight: 0
   if1(x1,x2,x3)	weight: 0
 false()	weight: 0
   leq(x1,x2)	weight: 0
  true()	weight: 0
     f(x1,x2)	weight: 0
 #leq(x1,x2)	weight: 0
 #if1(x1,x2,x3)	weight: 0
   if2(x1,x2,x3)	weight: 0
#fstsplit(x1,x2)	weight: 0
 #if3(x1,x2,x3)	weight: 0
     0()	weight: 0
app❆1_f(x1,x2,x3)	weight: 0
#map_f(x1,x2)	weight: 0
#app❆1_nil(x1)	weight: 0
   nil()	weight: 0
process(x1,x2)	weight: 0
 #app(x1,x2)	weight: x1
fstsplit(x1,x2)	weight: 0
 map_f(x1,x2)	weight: 0
  self()	weight: 0
   if3(x1,x2,x3)	weight: 0
  cons(x1,x2)	weight: (/ 1 2) + x2
 empty(x1)	weight: 0
app❆1_cons(x1,x2,x3)	weight: 0
length(x1)	weight: 0
 #if2(x1,x2,x3)	weight: 0
#length(x1)	weight: 0
   app(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #5 #24
Number of SCCs: 1, DPs: 5, edges: 6
	SCC { #6 #11 #16 #19 #25 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  failed.
