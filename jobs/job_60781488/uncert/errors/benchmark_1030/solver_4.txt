Input TRS:
    1: active(from(X)) -> mark(cons(X,from(s(X))))
    2: active(sel(0(),cons(X,XS))) -> mark(X)
    3: active(sel(s(N),cons(X,XS))) -> mark(sel(N,XS))
    4: active(minus(X,0())) -> mark(0())
    5: active(minus(s(X),s(Y))) -> mark(minus(X,Y))
    6: active(quot(0(),s(Y))) -> mark(0())
    7: active(quot(s(X),s(Y))) -> mark(s(quot(minus(X,Y),s(Y))))
    8: active(zWquot(XS,nil())) -> mark(nil())
    9: active(zWquot(nil(),XS)) -> mark(nil())
    10: active(zWquot(cons(X,XS),cons(Y,YS))) -> mark(cons(quot(X,Y),zWquot(XS,YS)))
    11: mark(from(X)) -> active(from(mark(X)))
    12: mark(cons(X1,X2)) -> active(cons(mark(X1),X2))
    13: mark(s(X)) -> active(s(mark(X)))
    14: mark(sel(X1,X2)) -> active(sel(mark(X1),mark(X2)))
    15: mark(0()) -> active(0())
    16: mark(minus(X1,X2)) -> active(minus(mark(X1),mark(X2)))
    17: mark(quot(X1,X2)) -> active(quot(mark(X1),mark(X2)))
    18: mark(zWquot(X1,X2)) -> active(zWquot(mark(X1),mark(X2)))
    19: mark(nil()) -> active(nil())
    20: from(mark(X)) -> from(X)
    21: from(active(X)) -> from(X)
    22: cons(mark(X1),X2) -> cons(X1,X2)
    23: cons(X1,mark(X2)) -> cons(X1,X2)
    24: cons(active(X1),X2) -> cons(X1,X2)
    25: cons(X1,active(X2)) -> cons(X1,X2)
    26: s(mark(X)) -> s(X)
    27: s(active(X)) -> s(X)
    28: sel(mark(X1),X2) -> sel(X1,X2)
    29: sel(X1,mark(X2)) -> sel(X1,X2)
    30: sel(active(X1),X2) -> sel(X1,X2)
    31: sel(X1,active(X2)) -> sel(X1,X2)
    32: minus(mark(X1),X2) -> minus(X1,X2)
    33: minus(X1,mark(X2)) -> minus(X1,X2)
    34: minus(active(X1),X2) -> minus(X1,X2)
    35: minus(X1,active(X2)) -> minus(X1,X2)
    36: quot(mark(X1),X2) -> quot(X1,X2)
    37: quot(X1,mark(X2)) -> quot(X1,X2)
    38: quot(active(X1),X2) -> quot(X1,X2)
    39: quot(X1,active(X2)) -> quot(X1,X2)
    40: zWquot(mark(X1),X2) -> zWquot(X1,X2)
    41: zWquot(X1,mark(X2)) -> zWquot(X1,X2)
    42: zWquot(active(X1),X2) -> zWquot(X1,X2)
    43: zWquot(X1,active(X2)) -> zWquot(X1,X2)
Number of strict rules: 43
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #active(sel(0(),cons(X,XS))) -> #mark(X)
   #2: #zWquot(X1,active(X2)) -> #zWquot(X1,X2)
   #3: #sel(X1,mark(X2)) -> #sel(X1,X2)
   #4: #minus(X1,active(X2)) -> #minus(X1,X2)
   #5: #zWquot(active(X1),X2) -> #zWquot(X1,X2)
   #6: #zWquot(X1,mark(X2)) -> #zWquot(X1,X2)
   #7: #quot(X1,mark(X2)) -> #quot(X1,X2)
   #8: #quot(active(X1),X2) -> #quot(X1,X2)
   #9: #active(quot(0(),s(Y))) -> #mark(0())
   #10: #zWquot(mark(X1),X2) -> #zWquot(X1,X2)
   #11: #mark(s(X)) -> #active(s(mark(X)))
   #12: #mark(s(X)) -> #s(mark(X))
   #13: #mark(s(X)) -> #mark(X)
   #14: #active(zWquot(nil(),XS)) -> #mark(nil())
   #15: #mark(from(X)) -> #active(from(mark(X)))
   #16: #mark(from(X)) -> #from(mark(X))
   #17: #mark(from(X)) -> #mark(X)
   #18: #cons(active(X1),X2) -> #cons(X1,X2)
   #19: #cons(X1,mark(X2)) -> #cons(X1,X2)
   #20: #mark(cons(X1,X2)) -> #active(cons(mark(X1),X2))
   #21: #mark(cons(X1,X2)) -> #cons(mark(X1),X2)
   #22: #mark(cons(X1,X2)) -> #mark(X1)
   #23: #sel(X1,active(X2)) -> #sel(X1,X2)
   #24: #mark(sel(X1,X2)) -> #active(sel(mark(X1),mark(X2)))
   #25: #mark(sel(X1,X2)) -> #sel(mark(X1),mark(X2))
   #26: #mark(sel(X1,X2)) -> #mark(X1)
   #27: #mark(sel(X1,X2)) -> #mark(X2)
   #28: #sel(active(X1),X2) -> #sel(X1,X2)
   #29: #cons(X1,active(X2)) -> #cons(X1,X2)
   #30: #from(mark(X)) -> #from(X)
   #31: #active(quot(s(X),s(Y))) -> #mark(s(quot(minus(X,Y),s(Y))))
   #32: #active(quot(s(X),s(Y))) -> #s(quot(minus(X,Y),s(Y)))
   #33: #active(quot(s(X),s(Y))) -> #quot(minus(X,Y),s(Y))
   #34: #active(quot(s(X),s(Y))) -> #minus(X,Y)
   #35: #quot(X1,active(X2)) -> #quot(X1,X2)
   #36: #active(zWquot(cons(X,XS),cons(Y,YS))) -> #mark(cons(quot(X,Y),zWquot(XS,YS)))
   #37: #active(zWquot(cons(X,XS),cons(Y,YS))) -> #cons(quot(X,Y),zWquot(XS,YS))
   #38: #active(zWquot(cons(X,XS),cons(Y,YS))) -> #quot(X,Y)
   #39: #active(zWquot(cons(X,XS),cons(Y,YS))) -> #zWquot(XS,YS)
   #40: #minus(X1,mark(X2)) -> #minus(X1,X2)
   #41: #active(minus(s(X),s(Y))) -> #mark(minus(X,Y))
   #42: #active(minus(s(X),s(Y))) -> #minus(X,Y)
   #43: #sel(mark(X1),X2) -> #sel(X1,X2)
   #44: #cons(mark(X1),X2) -> #cons(X1,X2)
   #45: #minus(active(X1),X2) -> #minus(X1,X2)
   #46: #s(active(X)) -> #s(X)
   #47: #mark(quot(X1,X2)) -> #active(quot(mark(X1),mark(X2)))
   #48: #mark(quot(X1,X2)) -> #quot(mark(X1),mark(X2))
   #49: #mark(quot(X1,X2)) -> #mark(X1)
   #50: #mark(quot(X1,X2)) -> #mark(X2)
   #51: #minus(mark(X1),X2) -> #minus(X1,X2)
   #52: #mark(nil()) -> #active(nil())
   #53: #s(mark(X)) -> #s(X)
   #54: #quot(mark(X1),X2) -> #quot(X1,X2)
   #55: #from(active(X)) -> #from(X)
   #56: #mark(minus(X1,X2)) -> #active(minus(mark(X1),mark(X2)))
   #57: #mark(minus(X1,X2)) -> #minus(mark(X1),mark(X2))
   #58: #mark(minus(X1,X2)) -> #mark(X1)
   #59: #mark(minus(X1,X2)) -> #mark(X2)
   #60: #active(sel(s(N),cons(X,XS))) -> #mark(sel(N,XS))
   #61: #active(sel(s(N),cons(X,XS))) -> #sel(N,XS)
   #62: #active(from(X)) -> #mark(cons(X,from(s(X))))
   #63: #active(from(X)) -> #cons(X,from(s(X)))
   #64: #active(from(X)) -> #from(s(X))
   #65: #active(from(X)) -> #s(X)
   #66: #active(zWquot(XS,nil())) -> #mark(nil())
   #67: #mark(0()) -> #active(0())
   #68: #active(minus(X,0())) -> #mark(0())
   #69: #mark(zWquot(X1,X2)) -> #active(zWquot(mark(X1),mark(X2)))
   #70: #mark(zWquot(X1,X2)) -> #zWquot(mark(X1),mark(X2))
   #71: #mark(zWquot(X1,X2)) -> #mark(X1)
   #72: #mark(zWquot(X1,X2)) -> #mark(X2)
Number of SCCs: 8, DPs: 46, edges: 295
	SCC { #46 #53 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: 0
#zWquot(x1,x2)	weight: 0
 minus(x1,x2)	weight: 0
zWquot(x1,x2)	weight: 0
#mark(x1)	weight: 0
     0()	weight: 0
  quot(x1,x2)	weight: 0
 #sel(x1,x2)	weight: 0
  from(x1)	weight: 0
   sel(x1,x2)	weight: 0
   #s(x1)	weight: x1
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#minus(x1,x2)	weight: 0
#from(x1)	weight: 0
active(x1)	weight: (/ 1 2) + x1
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
#quot(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #46 #53
Number of SCCs: 7, DPs: 44, edges: 291
	SCC { #30 #55 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: 0
#zWquot(x1,x2)	weight: 0
 minus(x1,x2)	weight: 0
zWquot(x1,x2)	weight: 0
#mark(x1)	weight: 0
     0()	weight: 0
  quot(x1,x2)	weight: 0
 #sel(x1,x2)	weight: 0
  from(x1)	weight: 0
   sel(x1,x2)	weight: 0
   #s(x1)	weight: 0
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#minus(x1,x2)	weight: 0
#from(x1)	weight: x1
active(x1)	weight: (/ 1 2) + x1
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
#quot(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #30 #55
Number of SCCs: 6, DPs: 42, edges: 287
	SCC { #2 #5 #6 #10 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: 0
#zWquot(x1,x2)	weight: x1
 minus(x1,x2)	weight: 0
zWquot(x1,x2)	weight: 0
#mark(x1)	weight: 0
     0()	weight: 0
  quot(x1,x2)	weight: 0
 #sel(x1,x2)	weight: 0
  from(x1)	weight: 0
   sel(x1,x2)	weight: 0
   #s(x1)	weight: 0
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#minus(x1,x2)	weight: 0
#from(x1)	weight: 0
active(x1)	weight: (/ 1 2) + x1
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
#quot(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #5 #10
Number of SCCs: 6, DPs: 40, edges: 275
	SCC { #2 #6 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: 0
#zWquot(x1,x2)	weight: x2
 minus(x1,x2)	weight: 0
zWquot(x1,x2)	weight: 0
#mark(x1)	weight: 0
     0()	weight: 0
  quot(x1,x2)	weight: 0
 #sel(x1,x2)	weight: 0
  from(x1)	weight: 0
   sel(x1,x2)	weight: 0
   #s(x1)	weight: 0
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#minus(x1,x2)	weight: 0
#from(x1)	weight: 0
active(x1)	weight: (/ 1 2) + x1
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
#quot(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #2 #6
Number of SCCs: 5, DPs: 38, edges: 271
	SCC { #3 #23 #28 #43 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: 0
#zWquot(x1,x2)	weight: 0
 minus(x1,x2)	weight: 0
zWquot(x1,x2)	weight: 0
#mark(x1)	weight: 0
     0()	weight: 0
  quot(x1,x2)	weight: 0
 #sel(x1,x2)	weight: x2
  from(x1)	weight: 0
   sel(x1,x2)	weight: 0
   #s(x1)	weight: 0
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#minus(x1,x2)	weight: 0
#from(x1)	weight: 0
active(x1)	weight: (/ 1 2) + x1
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
#quot(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #3 #23
Number of SCCs: 6, DPs: 36, edges: 259
	SCC { #28 #43 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: 0
#zWquot(x1,x2)	weight: 0
 minus(x1,x2)	weight: 0
zWquot(x1,x2)	weight: 0
#mark(x1)	weight: 0
     0()	weight: 0
  quot(x1,x2)	weight: 0
 #sel(x1,x2)	weight: x1
  from(x1)	weight: 0
   sel(x1,x2)	weight: 0
   #s(x1)	weight: 0
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#minus(x1,x2)	weight: 0
#from(x1)	weight: 0
active(x1)	weight: (/ 1 2) + x1
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
#quot(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #28 #43
Number of SCCs: 5, DPs: 34, edges: 255
	SCC { #18 #19 #29 #44 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: x1
     s(x1)	weight: 0
#zWquot(x1,x2)	weight: 0
 minus(x1,x2)	weight: 0
zWquot(x1,x2)	weight: 0
#mark(x1)	weight: 0
     0()	weight: 0
  quot(x1,x2)	weight: 0
 #sel(x1,x2)	weight: 0
  from(x1)	weight: 0
   sel(x1,x2)	weight: 0
   #s(x1)	weight: 0
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#minus(x1,x2)	weight: 0
#from(x1)	weight: 0
active(x1)	weight: (/ 1 2) + x1
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
#quot(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #18 #44
Number of SCCs: 6, DPs: 32, edges: 243
	SCC { #19 #29 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: x2
     s(x1)	weight: 0
#zWquot(x1,x2)	weight: 0
 minus(x1,x2)	weight: 0
zWquot(x1,x2)	weight: 0
#mark(x1)	weight: 0
     0()	weight: 0
  quot(x1,x2)	weight: 0
 #sel(x1,x2)	weight: 0
  from(x1)	weight: 0
   sel(x1,x2)	weight: 0
   #s(x1)	weight: 0
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#minus(x1,x2)	weight: 0
#from(x1)	weight: 0
active(x1)	weight: (/ 1 2) + x1
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
#quot(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #19 #29
Number of SCCs: 5, DPs: 30, edges: 239
	SCC { #7 #8 #35 #54 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: 0
#zWquot(x1,x2)	weight: 0
 minus(x1,x2)	weight: 0
zWquot(x1,x2)	weight: 0
#mark(x1)	weight: 0
     0()	weight: 0
  quot(x1,x2)	weight: 0
 #sel(x1,x2)	weight: 0
  from(x1)	weight: 0
   sel(x1,x2)	weight: 0
   #s(x1)	weight: 0
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#minus(x1,x2)	weight: 0
#from(x1)	weight: 0
active(x1)	weight: (/ 1 2) + x1
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
#quot(x1,x2)	weight: x1
    Usable rules: { }
    Removed DPs: #8 #54
Number of SCCs: 6, DPs: 28, edges: 227
	SCC { #7 #35 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: 0
#zWquot(x1,x2)	weight: 0
 minus(x1,x2)	weight: 0
zWquot(x1,x2)	weight: 0
#mark(x1)	weight: 0
     0()	weight: 0
  quot(x1,x2)	weight: 0
 #sel(x1,x2)	weight: 0
  from(x1)	weight: 0
   sel(x1,x2)	weight: 0
   #s(x1)	weight: 0
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#minus(x1,x2)	weight: 0
#from(x1)	weight: 0
active(x1)	weight: (/ 1 2) + x1
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
#quot(x1,x2)	weight: x2
    Usable rules: { }
    Removed DPs: #7 #35
Number of SCCs: 5, DPs: 26, edges: 223
	SCC { #4 #40 #45 #51 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: 0
#zWquot(x1,x2)	weight: 0
 minus(x1,x2)	weight: 0
zWquot(x1,x2)	weight: 0
#mark(x1)	weight: 0
     0()	weight: 0
  quot(x1,x2)	weight: 0
 #sel(x1,x2)	weight: 0
  from(x1)	weight: 0
   sel(x1,x2)	weight: 0
   #s(x1)	weight: 0
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#minus(x1,x2)	weight: x1
#from(x1)	weight: 0
active(x1)	weight: (/ 1 2) + x1
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
#quot(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #45 #51
Number of SCCs: 6, DPs: 24, edges: 211
	SCC { #4 #40 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: 0
#zWquot(x1,x2)	weight: 0
 minus(x1,x2)	weight: 0
zWquot(x1,x2)	weight: 0
#mark(x1)	weight: 0
     0()	weight: 0
  quot(x1,x2)	weight: 0
 #sel(x1,x2)	weight: 0
  from(x1)	weight: 0
   sel(x1,x2)	weight: 0
   #s(x1)	weight: 0
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#minus(x1,x2)	weight: x2
#from(x1)	weight: 0
active(x1)	weight: (/ 1 2) + x1
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
#quot(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #4 #40
Number of SCCs: 5, DPs: 22, edges: 207
	SCC { #1 #13 #15 #17 #22 #24 #26 #27 #31 #36 #41 #47 #49 #50 #56 #58..60 #62 #69 #71 #72 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: x1
#zWquot(x1,x2)	weight: 0
 minus(x1,x2)	weight: max{(/ 3 8) + x2, x1}
zWquot(x1,x2)	weight: max{(/ 16731 2) + x2, (/ 66925 8) + x1}
#mark(x1)	weight: x1
     0()	weight: (/ 66925 8)
  quot(x1,x2)	weight: max{(/ 16731 2) + x2, (/ 66921 8) + x1}
 #sel(x1,x2)	weight: 0
  from(x1)	weight: (/ 3 8) + x1
   sel(x1,x2)	weight: max{(/ 1 8) + x2, (/ 1 4) + x1}
   #s(x1)	weight: 0
   nil()	weight: (/ 33463 4)
  mark(x1)	weight: x1
#minus(x1,x2)	weight: 0
#from(x1)	weight: 0
active(x1)	weight: x1
  cons(x1,x2)	weight: max{x2, (/ 1 4) + x1}
#active(x1)	weight: x1
#quot(x1,x2)	weight: 0
    Usable rules: { 1..43 }
    Removed DPs: #1 #17 #22 #26 #27 #49 #50 #59 #71 #72
Number of SCCs: 7, DPs: 8, edges: 15
	SCC { #24 #60 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... succeeded.
#cons(x1,x2)	weight: x2	status: [x2]	precedence above:
     s(x1)	weight: x1	status: [x1]	precedence above: minus 0
#zWquot(x1,x2)	weight: (/ 1 8) + x2 + x1	status: [x2,x1]	precedence above:
 minus(x1,x2)	weight: max{0, x1}	status: []	precedence above: 0
zWquot(x1,x2)	weight: (/ 1 4) + x1	status: []	precedence above: s minus 0 quot from nil mark cons
#mark(x1)	weight: (/ 1 4) + x1	status: [x1]	precedence above: sel #active
     0()	weight: 0	status: []	precedence above:
  quot(x1,x2)	weight: max{0, x1}	status: [x1]	precedence above: s minus 0
 #sel(x1,x2)	weight: x2	status: []	precedence above:
  from(x1)	weight: (/ 1 4) + x1	status: []	precedence above: s minus 0 quot mark cons
   sel(x1,x2)	weight: (/ 1 4) + x2 + x1	status: [x1]	precedence above:
   #s(x1)	weight: x1	status: []	precedence above:
   nil()	weight: 0	status: []	precedence above:
  mark(x1)	weight: x1	status: x1
#minus(x1,x2)	weight: (/ 1 8) + x2	status: [x2]	precedence above:
#from(x1)	weight: x1	status: []	precedence above:
active(x1)	weight: x1	status: x1
  cons(x1,x2)	weight: max{x2, (/ 1 8) + x1}	status: []	precedence above: s minus 0 quot from mark
#active(x1)	weight: (/ 1 4) + x1	status: [x1]	precedence above: #mark sel
#quot(x1,x2)	weight: (/ 1 8) + x2 + x1	status: [x2,x1]	precedence above:
    Usable rules: { 1..43 }
    Removed DPs: #60
Number of SCCs: 6, DPs: 6, edges: 13
	SCC { #13 #31 #41 #47 #56 #58 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: x1
#zWquot(x1,x2)	weight: 0
 minus(x1,x2)	weight: max{0, (/ 1 4) + x1}
zWquot(x1,x2)	weight: max{(/ 1 2) + x2, (/ 1 4) + x1}
#mark(x1)	weight: x1
     0()	weight: (/ 1 4)
  quot(x1,x2)	weight: max{0, (/ 1 4) + x2}
 #sel(x1,x2)	weight: 0
  from(x1)	weight: (/ 1 4) + x1
   sel(x1,x2)	weight: max{0, (/ 1 4) + x2}
   #s(x1)	weight: 0
   nil()	weight: (/ 1 4)
  mark(x1)	weight: x1
#minus(x1,x2)	weight: 0
#from(x1)	weight: 0
active(x1)	weight: x1
  cons(x1,x2)	weight: max{x2, x1}
#active(x1)	weight: x1
#quot(x1,x2)	weight: 0
    Usable rules: { 1..43 }
    Removed DPs: #58
Number of SCCs: 7, DPs: 5, edges: 6
	SCC { #41 #56 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: max{0, (/ 1 4) + x1}
#zWquot(x1,x2)	weight: 0
 minus(x1,x2)	weight: max{0, (- (/ 1 8)) + x1}
zWquot(x1,x2)	weight: max{0, (/ 11 16) + x1}
#mark(x1)	weight: max{0, (/ 1 4) + x1}
     0()	weight: 0
  quot(x1,x2)	weight: max{0, (/ 1 4) + x1}
 #sel(x1,x2)	weight: 0
  from(x1)	weight: max{0, (/ 3 16) + x1}
   sel(x1,x2)	weight: max{0, (- (/ 1 8)) + x2 + x1}
   #s(x1)	weight: 0
   nil()	weight: (/ 1 16)
  mark(x1)	weight: max{0, x1}
#minus(x1,x2)	weight: 0
#from(x1)	weight: 0
active(x1)	weight: max{0, x1}
  cons(x1,x2)	weight: max{0, (/ 3 16) + x1, (- (/ 1 4)) + x2}
#active(x1)	weight: max{0, (/ 3 16) + x1}
#quot(x1,x2)	weight: 0
    Usable rules: { 1..43 }
    Removed DPs: #41 #56
Number of SCCs: 6, DPs: 3, edges: 4
	SCC { #13 #31 #47 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: max{0, (/ 3 16) + x1}
#zWquot(x1,x2)	weight: 0
 minus(x1,x2)	weight: max{0, (- (/ 1 16)) + x1}
zWquot(x1,x2)	weight: max{0, (/ 9 16) + x1}
#mark(x1)	weight: max{0, (/ 1 16) + x1}
     0()	weight: 0
  quot(x1,x2)	weight: max{0, (/ 1 4) + x1}
 #sel(x1,x2)	weight: 0
  from(x1)	weight: max{0, (/ 1 8) + x1}
   sel(x1,x2)	weight: max{0, (- (/ 1 16)) + x2 + x1}
   #s(x1)	weight: 0
   nil()	weight: (/ 1 16)
  mark(x1)	weight: max{0, x1}
#minus(x1,x2)	weight: 0
#from(x1)	weight: 0
active(x1)	weight: max{0, x1}
  cons(x1,x2)	weight: max{0, (/ 1 8) + x1, (- (/ 3 16)) + x2}
#active(x1)	weight: max{0, (/ 1 16) + x1}
#quot(x1,x2)	weight: 0
    Usable rules: { 1..43 }
    Removed DPs: #13
Number of SCCs: 5, DPs: 0, edges: 0
