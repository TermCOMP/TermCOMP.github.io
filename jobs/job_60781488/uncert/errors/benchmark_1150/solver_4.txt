Input TRS:
    1: a__nats() -> a__adx(a__zeros())
    2: a__zeros() -> cons(0(),zeros())
    3: a__incr(cons(X,Y)) -> cons(s(X),incr(Y))
    4: a__adx(cons(X,Y)) -> a__incr(cons(X,adx(Y)))
    5: a__hd(cons(X,Y)) -> mark(X)
    6: a__tl(cons(X,Y)) -> mark(Y)
    7: mark(nats()) -> a__nats()
    8: mark(adx(X)) -> a__adx(mark(X))
    9: mark(zeros()) -> a__zeros()
    10: mark(incr(X)) -> a__incr(mark(X))
    11: mark(hd(X)) -> a__hd(mark(X))
    12: mark(tl(X)) -> a__tl(mark(X))
    13: mark(cons(X1,X2)) -> cons(X1,X2)
    14: mark(0()) -> 0()
    15: mark(s(X)) -> s(X)
    16: a__nats() -> nats()
    17: a__adx(X) -> adx(X)
    18: a__zeros() -> zeros()
    19: a__incr(X) -> incr(X)
    20: a__hd(X) -> hd(X)
    21: a__tl(X) -> tl(X)
Number of strict rules: 21
Direct Order(PosReal,>,Poly) ... removes: 15 5 7 14 9 13 6
  incr(x1)	weight: x1
    hd(x1)	weight: (/ 1 4) + x1
     s(x1)	weight: x1
a__incr(x1)	weight: x1
a__nats()	weight: 0
   adx(x1)	weight: x1
 zeros()	weight: 0
 a__hd(x1)	weight: (/ 1 4) + x1
     0()	weight: 0
    tl(x1)	weight: (/ 1 4) + x1
  mark(x1)	weight: (/ 1 8) + x1
a__adx(x1)	weight: x1
  nats()	weight: 0
  cons(x1,x2)	weight: x1 + x2
 a__tl(x1)	weight: (/ 1 4) + x1
a__zeros()	weight: 0
Number of strict rules: 14
Direct Order(PosReal,>,Poly) ... removes: 21 20 12 11
  incr(x1)	weight: x1
    hd(x1)	weight: (/ 1 4) + x1
     s(x1)	weight: x1
a__incr(x1)	weight: x1
a__nats()	weight: 0
   adx(x1)	weight: x1
 zeros()	weight: 0
 a__hd(x1)	weight: (/ 3 8) + x1
     0()	weight: 0
    tl(x1)	weight: (/ 1 4) + x1
  mark(x1)	weight: (/ 1 8) + 2 * x1
a__adx(x1)	weight: x1
  nats()	weight: 0
  cons(x1,x2)	weight: x1 + x2
 a__tl(x1)	weight: (/ 3 8) + x1
a__zeros()	weight: 0
Number of strict rules: 10
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #mark(incr(X)) -> #a__incr(mark(X))
   #2: #mark(incr(X)) -> #mark(X)
   #3: #a__nats() -> #a__adx(a__zeros())
   #4: #a__nats() -> #a__zeros()
   #5: #mark(adx(X)) -> #a__adx(mark(X))
   #6: #mark(adx(X)) -> #mark(X)
   #7: #a__adx(cons(X,Y)) -> #a__incr(cons(X,adx(Y)))
Number of SCCs: 1, DPs: 2, edges: 4
	SCC { #2 #6 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
  incr(x1)	weight: (/ 1 2) + x1
    hd(x1)	weight: 0
     s(x1)	weight: 0
a__incr(x1)	weight: 0
a__nats()	weight: 0
   adx(x1)	weight: (/ 1 2) + x1
 zeros()	weight: 0
 a__hd(x1)	weight: 0
#a__adx(x1)	weight: 0
#mark(x1)	weight: x1
     0()	weight: 0
#a__zeros()	weight: 0
    tl(x1)	weight: 0
#a__nats()	weight: 0
  mark(x1)	weight: 0
a__adx(x1)	weight: 0
  nats()	weight: 0
#a__incr(x1)	weight: 0
  cons(x1,x2)	weight: 0
 a__tl(x1)	weight: 0
a__zeros()	weight: 0
    Usable rules: { }
    Removed DPs: #2 #6
Number of SCCs: 0, DPs: 0, edges: 0
