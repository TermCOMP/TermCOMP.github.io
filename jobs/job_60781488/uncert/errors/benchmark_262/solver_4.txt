Input TRS:
    1: max(nil()) -> 0()
    2: max(cons(x,nil())) -> x
    3: max(cons(x,cons(y,xs))) -> if1(ge(x,y),x,y,xs)
    4: if1(true(),x,y,xs) -> max(cons(x,xs))
    5: if1(false(),x,y,xs) -> max(cons(y,xs))
    6: del(x,nil()) -> nil()
    7: del(x,cons(y,xs)) -> if2(eq(x,y),x,y,xs)
    8: if2(true(),x,y,xs) -> xs
    9: if2(false(),x,y,xs) -> cons(y,del(x,xs))
    10: eq(0(),0()) -> true()
    11: eq(0(),s(y)) -> false()
    12: eq(s(x),0()) -> false()
    13: eq(s(x),s(y)) -> eq(x,y)
    14: sort(nil()) -> nil()
    15: sort(cons(x,xs)) -> cons(max(cons(x,xs)),sort(h(del(max(cons(x,xs)),cons(x,xs)))))
    16: ge(0(),0()) -> true()
    17: ge(s(x),0()) -> true()
    18: ge(0(),s(x)) -> false()
    19: ge(s(x),s(y)) -> ge(x,y)
    20: h(nil()) -> nil()
    21: h(cons(x,xs)) -> cons(x,h(xs))
Number of strict rules: 21
Direct Order(PosReal,>,Poly) ... failed.
Freezing max
1: max❆1_nil() -> 0()
2: max❆1_cons(x,nil()) -> x
3: max❆1_cons(x,cons(y,xs)) -> if1(ge(x,y),x,y,xs)
4: if1(true(),x,y,xs) -> max❆1_cons(x,xs)
5: if1(false(),x,y,xs) -> max❆1_cons(y,xs)
6: del(x,nil()) -> nil()
7: del(x,cons(y,xs)) -> if2(eq(x,y),x,y,xs)
8: if2(true(),x,y,xs) -> xs
9: if2(false(),x,y,xs) -> cons(y,del(x,xs))
10: eq(0(),0()) -> true()
11: eq(0(),s(y)) -> false()
12: eq(s(x),0()) -> false()
13: eq(s(x),s(y)) -> eq(x,y)
14: sort(nil()) -> nil()
15: sort(cons(x,xs)) -> cons(max❆1_cons(x,xs),sort(h(del(max❆1_cons(x,xs),cons(x,xs)))))
16: ge(0(),0()) -> true()
17: ge(s(x),0()) -> true()
18: ge(0(),s(x)) -> false()
19: ge(s(x),s(y)) -> ge(x,y)
20: h(nil()) -> nil()
21: h(cons(x,xs)) -> cons(x,h(xs))
22: max(cons(_1,_2)) ->= max❆1_cons(_1,_2)
23: max(nil()) ->= max❆1_nil()
Number of strict rules: 21
Direct Order(PosReal,>,Poly) ... failed.
Dependency Pairs:
   #1: #eq(s(x),s(y)) -> #eq(x,y)
   #2: #if2(false(),x,y,xs) -> #del(x,xs)
   #3: #max(nil()) ->? #max❆1_nil()
   #4: #del(x,cons(y,xs)) -> #if2(eq(x,y),x,y,xs)
   #5: #del(x,cons(y,xs)) -> #eq(x,y)
   #6: #if1(false(),x,y,xs) -> #max❆1_cons(y,xs)
   #7: #max(cons(_1,_2)) ->? #max❆1_cons(_1,_2)
   #8: #ge(s(x),s(y)) -> #ge(x,y)
   #9: #h(cons(x,xs)) -> #h(xs)
   #10: #max❆1_cons(x,cons(y,xs)) -> #if1(ge(x,y),x,y,xs)
   #11: #max❆1_cons(x,cons(y,xs)) -> #ge(x,y)
   #12: #sort(cons(x,xs)) -> #max❆1_cons(x,xs)
   #13: #sort(cons(x,xs)) -> #sort(h(del(max❆1_cons(x,xs),cons(x,xs))))
   #14: #sort(cons(x,xs)) -> #h(del(max❆1_cons(x,xs),cons(x,xs)))
   #15: #sort(cons(x,xs)) -> #del(max❆1_cons(x,xs),cons(x,xs))
   #16: #sort(cons(x,xs)) -> #max❆1_cons(x,xs)
   #17: #if1(true(),x,y,xs) -> #max❆1_cons(x,xs)
Number of SCCs: 6, DPs: 9, edges: 10
	SCC { #9 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
     h(x1)	weight: 0
 #del(x1,x2)	weight: 0
     s(x1)	weight: 0
    eq(x1,x2)	weight: 0
   if1(x1,x2,x3,x4)	weight: 0
 false()	weight: 0
  #ge(x1,x2)	weight: 0
  true()	weight: 0
  #eq(x1,x2)	weight: 0
 #if1(x1,x2,x3,x4)	weight: 0
#sort(x1)	weight: 0
#max❆1_cons(x1,x2)	weight: 0
   if2(x1,x2,x3,x4)	weight: 0
max❆1_cons(x1,x2)	weight: 0
     0()	weight: 0
    ge(x1,x2)	weight: 0
   del(x1,x2)	weight: 0
   #h(x1)	weight: x1
   max(x1)	weight: 0
   nil()	weight: 0
 #max(x1)	weight: 0
  sort(x1)	weight: 0
  cons(x1,x2)	weight: (/ 1 2) + x2
max❆1_nil()	weight: 0
 #if2(x1,x2,x3,x4)	weight: 0
#max❆1_nil()	weight: 0
    Usable rules: { }
    Removed DPs: #9
Number of SCCs: 5, DPs: 8, edges: 9
	SCC { #1 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
     h(x1)	weight: 0
 #del(x1,x2)	weight: 0
     s(x1)	weight: (/ 1 2) + x1
    eq(x1,x2)	weight: 0
   if1(x1,x2,x3,x4)	weight: 0
 false()	weight: 0
  #ge(x1,x2)	weight: 0
  true()	weight: 0
  #eq(x1,x2)	weight: x2
 #if1(x1,x2,x3,x4)	weight: 0
#sort(x1)	weight: 0
#max❆1_cons(x1,x2)	weight: 0
   if2(x1,x2,x3,x4)	weight: 0
max❆1_cons(x1,x2)	weight: 0
     0()	weight: 0
    ge(x1,x2)	weight: 0
   del(x1,x2)	weight: 0
   #h(x1)	weight: 0
   max(x1)	weight: 0
   nil()	weight: 0
 #max(x1)	weight: 0
  sort(x1)	weight: 0
  cons(x1,x2)	weight: (/ 1 2)
max❆1_nil()	weight: 0
 #if2(x1,x2,x3,x4)	weight: 0
#max❆1_nil()	weight: 0
    Usable rules: { }
    Removed DPs: #1
Number of SCCs: 4, DPs: 7, edges: 8
	SCC { #8 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
     h(x1)	weight: 0
 #del(x1,x2)	weight: 0
     s(x1)	weight: (/ 1 2) + x1
    eq(x1,x2)	weight: 0
   if1(x1,x2,x3,x4)	weight: 0
 false()	weight: 0
  #ge(x1,x2)	weight: x2
  true()	weight: 0
  #eq(x1,x2)	weight: 0
 #if1(x1,x2,x3,x4)	weight: 0
#sort(x1)	weight: 0
#max❆1_cons(x1,x2)	weight: 0
   if2(x1,x2,x3,x4)	weight: 0
max❆1_cons(x1,x2)	weight: 0
     0()	weight: 0
    ge(x1,x2)	weight: 0
   del(x1,x2)	weight: 0
   #h(x1)	weight: 0
   max(x1)	weight: 0
   nil()	weight: 0
 #max(x1)	weight: 0
  sort(x1)	weight: 0
  cons(x1,x2)	weight: (/ 1 2)
max❆1_nil()	weight: 0
 #if2(x1,x2,x3,x4)	weight: 0
#max❆1_nil()	weight: 0
    Usable rules: { }
    Removed DPs: #8
Number of SCCs: 3, DPs: 6, edges: 7
	SCC { #13 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  failed.
