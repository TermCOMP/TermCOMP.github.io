Input TRS:
    1: app(nil(),YS) -> YS
    2: app(cons(X,XS),YS) -> cons(X,n__app(activate(XS),YS))
    3: from(X) -> cons(X,n__from(s(X)))
    4: zWadr(nil(),YS) -> nil()
    5: zWadr(XS,nil()) -> nil()
    6: zWadr(cons(X,XS),cons(Y,YS)) -> cons(app(Y,cons(X,n__nil())),n__zWadr(activate(XS),activate(YS)))
    7: prefix(L) -> cons(nil(),n__zWadr(L,prefix(L)))
    8: app(X1,X2) -> n__app(X1,X2)
    9: from(X) -> n__from(X)
    10: nil() -> n__nil()
    11: zWadr(X1,X2) -> n__zWadr(X1,X2)
    12: activate(n__app(X1,X2)) -> app(X1,X2)
    13: activate(n__from(X)) -> from(X)
    14: activate(n__nil()) -> nil()
    15: activate(n__zWadr(X1,X2)) -> zWadr(X1,X2)
    16: activate(X) -> X
Number of strict rules: 16
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #app(cons(X,XS),YS) -> #activate(XS)
   #2: #zWadr(cons(X,XS),cons(Y,YS)) -> #app(Y,cons(X,n__nil()))
   #3: #zWadr(cons(X,XS),cons(Y,YS)) -> #activate(XS)
   #4: #zWadr(cons(X,XS),cons(Y,YS)) -> #activate(YS)
   #5: #activate(n__from(X)) -> #from(X)
   #6: #activate(n__app(X1,X2)) -> #app(X1,X2)
   #7: #activate(n__nil()) -> #nil()
   #8: #prefix(L) -> #nil()
   #9: #prefix(L) -> #prefix(L)
   #10: #activate(n__zWadr(X1,X2)) -> #zWadr(X1,X2)
Number of SCCs: 2, DPs: 7, edges: 12
	SCC { #9 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  found.
  #prefix(L_{1})	-#9->
  #prefix(L_{1})	--->*
  #prefix(L_{1})
  Looping with: [ L_{1} := L_{1}; ]
