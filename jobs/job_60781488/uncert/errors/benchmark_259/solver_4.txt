Input TRS:
    1: last(nil()) -> 0()
    2: last(cons(x,nil())) -> x
    3: last(cons(x,cons(y,xs))) -> last(cons(y,xs))
    4: del(x,nil()) -> nil()
    5: del(x,cons(y,xs)) -> if(eq(x,y),x,y,xs)
    6: if(true(),x,y,xs) -> xs
    7: if(false(),x,y,xs) -> cons(y,del(x,xs))
    8: eq(0(),0()) -> true()
    9: eq(0(),s(y)) -> false()
    10: eq(s(x),0()) -> false()
    11: eq(s(x),s(y)) -> eq(x,y)
    12: reverse(nil()) -> nil()
    13: reverse(cons(x,xs)) -> cons(last(cons(x,xs)),reverse(del(last(cons(x,xs)),cons(x,xs))))
Number of strict rules: 13
Direct Order(PosReal,>,Poly) ... failed.
Freezing last
1: last❆1_nil() -> 0()
2: last❆1_cons(x,nil()) -> x
3: last❆1_cons(x,cons(y,xs)) -> last❆1_cons(y,xs)
4: del(x,nil()) -> nil()
5: del(x,cons(y,xs)) -> if(eq(x,y),x,y,xs)
6: if(true(),x,y,xs) -> xs
7: if(false(),x,y,xs) -> cons(y,del(x,xs))
8: eq(0(),0()) -> true()
9: eq(0(),s(y)) -> false()
10: eq(s(x),0()) -> false()
11: eq(s(x),s(y)) -> eq(x,y)
12: reverse(nil()) -> nil()
13: reverse(cons(x,xs)) -> cons(last❆1_cons(x,xs),reverse(del(last❆1_cons(x,xs),cons(x,xs))))
14: last(cons(_1,_2)) ->= last❆1_cons(_1,_2)
15: last(nil()) ->= last❆1_nil()
Number of strict rules: 13
Direct Order(PosReal,>,Poly) ... failed.
Dependency Pairs:
   #1: #reverse(cons(x,xs)) -> #last❆1_cons(x,xs)
   #2: #reverse(cons(x,xs)) -> #reverse(del(last❆1_cons(x,xs),cons(x,xs)))
   #3: #reverse(cons(x,xs)) -> #del(last❆1_cons(x,xs),cons(x,xs))
   #4: #reverse(cons(x,xs)) -> #last❆1_cons(x,xs)
   #5: #eq(s(x),s(y)) -> #eq(x,y)
   #6: #last(cons(_1,_2)) ->? #last❆1_cons(_1,_2)
   #7: #if(false(),x,y,xs) -> #del(x,xs)
   #8: #del(x,cons(y,xs)) -> #if(eq(x,y),x,y,xs)
   #9: #del(x,cons(y,xs)) -> #eq(x,y)
   #10: #last❆1_cons(x,cons(y,xs)) -> #last❆1_cons(y,xs)
   #11: #last(nil()) ->? #last❆1_nil()
Number of SCCs: 4, DPs: 5, edges: 5
	SCC { #10 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
 #del(x1,x2)	weight: 0
last❆1_nil()	weight: 0
     s(x1)	weight: 0
#reverse(x1)	weight: 0
#last❆1_nil()	weight: 0
    eq(x1,x2)	weight: 0
#last❆1_cons(x1,x2)	weight: x2
 false()	weight: 0
last❆1_cons(x1,x2)	weight: 0
reverse(x1)	weight: 0
  true()	weight: 0
#last(x1)	weight: 0
  #eq(x1,x2)	weight: 0
     0()	weight: 0
    if(x1,x2,x3,x4)	weight: 0
   del(x1,x2)	weight: 0
  last(x1)	weight: 0
   nil()	weight: 0
  cons(x1,x2)	weight: (/ 1 2) + x2
  #if(x1,x2,x3,x4)	weight: 0
    Usable rules: { }
    Removed DPs: #10
Number of SCCs: 3, DPs: 4, edges: 4
	SCC { #5 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
 #del(x1,x2)	weight: 0
last❆1_nil()	weight: 0
     s(x1)	weight: (/ 1 2) + x1
#reverse(x1)	weight: 0
#last❆1_nil()	weight: 0
    eq(x1,x2)	weight: 0
#last❆1_cons(x1,x2)	weight: 0
 false()	weight: 0
last❆1_cons(x1,x2)	weight: 0
reverse(x1)	weight: 0
  true()	weight: 0
#last(x1)	weight: 0
  #eq(x1,x2)	weight: x2
     0()	weight: 0
    if(x1,x2,x3,x4)	weight: 0
   del(x1,x2)	weight: 0
  last(x1)	weight: 0
   nil()	weight: 0
  cons(x1,x2)	weight: (/ 1 2)
  #if(x1,x2,x3,x4)	weight: 0
    Usable rules: { }
    Removed DPs: #5
Number of SCCs: 2, DPs: 3, edges: 3
	SCC { #2 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  failed.
