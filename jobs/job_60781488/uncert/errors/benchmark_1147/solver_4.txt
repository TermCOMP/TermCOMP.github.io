Input TRS:
    1: incr(nil()) -> nil()
    2: incr(cons(X,L)) -> cons(s(X),n__incr(activate(L)))
    3: adx(nil()) -> nil()
    4: adx(cons(X,L)) -> incr(cons(X,n__adx(activate(L))))
    5: nats() -> adx(zeros())
    6: zeros() -> cons(0(),n__zeros())
    7: head(cons(X,L)) -> X
    8: tail(cons(X,L)) -> activate(L)
    9: incr(X) -> n__incr(X)
    10: adx(X) -> n__adx(X)
    11: zeros() -> n__zeros()
    12: activate(n__incr(X)) -> incr(X)
    13: activate(n__adx(X)) -> adx(X)
    14: activate(n__zeros()) -> zeros()
    15: activate(X) -> X
Number of strict rules: 15
Direct Order(PosReal,>,Poly) ... removes: 8 7
  incr(x1)	weight: x1
     s(x1)	weight: x1
n__adx(x1)	weight: x1
activate(x1)	weight: x1
n__zeros()	weight: 0
   adx(x1)	weight: x1
 zeros()	weight: 0
  tail(x1)	weight: (/ 1 2) + x1
     0()	weight: 0
   nil()	weight: 0
  nats()	weight: 0
  head(x1)	weight: (/ 1 2) + x1
  cons(x1,x2)	weight: x1 + x2
n__incr(x1)	weight: x1
Number of strict rules: 13
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #incr(cons(X,L)) -> #activate(L)
   #2: #activate(n__adx(X)) -> #adx(X)
   #3: #activate(n__incr(X)) -> #incr(X)
   #4: #activate(n__zeros()) -> #zeros()
   #5: #nats() -> #adx(zeros())
   #6: #nats() -> #zeros()
   #7: #adx(cons(X,L)) -> #incr(cons(X,n__adx(activate(L))))
   #8: #adx(cons(X,L)) -> #activate(L)
Number of SCCs: 1, DPs: 5, edges: 8
	SCC { #1..3 #7 #8 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
 #adx(x1)	weight: (/ 1 2) + x1
  incr(x1)	weight: x1
#nats()	weight: 0
     s(x1)	weight: 0
n__adx(x1)	weight: (/ 1 2) + x1
activate(x1)	weight: x1
n__zeros()	weight: 0
#activate(x1)	weight: x1
   adx(x1)	weight: (/ 1 2) + x1
 zeros()	weight: 0
  tail(x1)	weight: 0
     0()	weight: 0
#zeros()	weight: 0
   nil()	weight: 0
#incr(x1)	weight: x1
  nats()	weight: 0
  head(x1)	weight: 0
  cons(x1,x2)	weight: x1 + x2
n__incr(x1)	weight: x1
    Usable rules: { 1..4 6 9..15 }
    Removed DPs: #8
Number of SCCs: 1, DPs: 4, edges: 5
	SCC { #1..3 #7 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
 #adx(x1)	weight: (/ 1 2)
  incr(x1)	weight: (/ 1 2)
#nats()	weight: 0
     s(x1)	weight: 0
n__adx(x1)	weight: (/ 3 8)
activate(x1)	weight: (/ 1 8)
n__zeros()	weight: 0
#activate(x1)	weight: (/ 1 8) + x1
   adx(x1)	weight: (/ 1 4) + x1
 zeros()	weight: 0
  tail(x1)	weight: 0
     0()	weight: 0
#zeros()	weight: 0
   nil()	weight: 0
#incr(x1)	weight: x1
  nats()	weight: 0
  head(x1)	weight: 0
  cons(x1,x2)	weight: (/ 1 8) + x2
n__incr(x1)	weight: (/ 5 8) + x1
    Usable rules: { }
    Removed DPs: #3
Number of SCCs: 1, DPs: 3, edges: 3
	SCC { #1 #2 #7 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  found.
  #adx(cons(X_{1},n__zeros()))	-#7->
  #incr(cons(X_{1},n__adx(activate(n__zeros()))))	--->*
  #incr(cons(X_{1},n__adx(activate(n__zeros()))))	-#1->
  #activate(n__adx(activate(n__zeros())))	--->*
  #activate(n__adx(activate(n__zeros())))	-#2->
  #adx(activate(n__zeros()))	--->*
  #adx(cons(0(),n__zeros()))
  Looping with: [ X_{1} := 0(); ]
