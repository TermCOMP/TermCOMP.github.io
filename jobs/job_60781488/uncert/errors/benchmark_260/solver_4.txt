Input TRS:
    1: double(0()) -> 0()
    2: double(s(x)) -> s(s(double(x)))
    3: del(x,nil()) -> nil()
    4: del(x,cons(y,xs)) -> if(eq(x,y),x,y,xs)
    5: if(true(),x,y,xs) -> xs
    6: if(false(),x,y,xs) -> cons(y,del(x,xs))
    7: eq(0(),0()) -> true()
    8: eq(0(),s(y)) -> false()
    9: eq(s(x),0()) -> false()
    10: eq(s(x),s(y)) -> eq(x,y)
    11: first(nil()) -> 0()
    12: first(cons(x,xs)) -> x
    13: doublelist(nil()) -> nil()
    14: doublelist(cons(x,xs)) -> cons(double(x),doublelist(del(first(cons(x,xs)),cons(x,xs))))
Number of strict rules: 14
Direct Order(PosReal,>,Poly) ... failed.
Freezing first
1: double(0()) -> 0()
2: double(s(x)) -> s(s(double(x)))
3: del(x,nil()) -> nil()
4: del(x,cons(y,xs)) -> if(eq(x,y),x,y,xs)
5: if(true(),x,y,xs) -> xs
6: if(false(),x,y,xs) -> cons(y,del(x,xs))
7: eq(0(),0()) -> true()
8: eq(0(),s(y)) -> false()
9: eq(s(x),0()) -> false()
10: eq(s(x),s(y)) -> eq(x,y)
11: first❆1_nil() -> 0()
12: first❆1_cons(x,xs) -> x
13: doublelist(nil()) -> nil()
14: doublelist(cons(x,xs)) -> cons(double(x),doublelist(del(first❆1_cons(x,xs),cons(x,xs))))
15: first(cons(_1,_2)) ->= first❆1_cons(_1,_2)
16: first(nil()) ->= first❆1_nil()
Number of strict rules: 14
Direct Order(PosReal,>,Poly) ... failed.
Dependency Pairs:
   #1: #double(s(x)) -> #double(x)
   #2: #if(false(),x,y,xs) -> #del(x,xs)
   #3: #doublelist(cons(x,xs)) -> #double(x)
   #4: #doublelist(cons(x,xs)) -> #doublelist(del(first❆1_cons(x,xs),cons(x,xs)))
   #5: #doublelist(cons(x,xs)) -> #del(first❆1_cons(x,xs),cons(x,xs))
   #6: #doublelist(cons(x,xs)) -> #first❆1_cons(x,xs)
   #7: #eq(s(x),s(y)) -> #eq(x,y)
   #8: #first(nil()) ->? #first❆1_nil()
   #9: #first(cons(_1,_2)) ->? #first❆1_cons(_1,_2)
   #10: #del(x,cons(y,xs)) -> #if(eq(x,y),x,y,xs)
   #11: #del(x,cons(y,xs)) -> #eq(x,y)
Number of SCCs: 4, DPs: 5, edges: 5
	SCC { #1 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
 #del(x1,x2)	weight: 0
     s(x1)	weight: (/ 1 2) + x1
    eq(x1,x2)	weight: 0
 false()	weight: 0
#doublelist(x1)	weight: 0
  true()	weight: 0
  #eq(x1,x2)	weight: 0
first❆1_cons(x1,x2)	weight: 0
#first❆1_nil()	weight: 0
     0()	weight: 0
    if(x1,x2,x3,x4)	weight: 0
#double(x1)	weight: x1
double(x1)	weight: 0
   del(x1,x2)	weight: 0
doublelist(x1)	weight: 0
#first(x1)	weight: 0
   nil()	weight: 0
 first(x1)	weight: 0
first❆1_nil()	weight: 0
  cons(x1,x2)	weight: 0
  #if(x1,x2,x3,x4)	weight: 0
#first❆1_cons(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #1
Number of SCCs: 3, DPs: 4, edges: 4
	SCC { #7 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
 #del(x1,x2)	weight: 0
     s(x1)	weight: (/ 1 2) + x1
    eq(x1,x2)	weight: 0
 false()	weight: 0
#doublelist(x1)	weight: 0
  true()	weight: 0
  #eq(x1,x2)	weight: x2
first❆1_cons(x1,x2)	weight: 0
#first❆1_nil()	weight: 0
     0()	weight: 0
    if(x1,x2,x3,x4)	weight: 0
#double(x1)	weight: 0
double(x1)	weight: 0
   del(x1,x2)	weight: 0
doublelist(x1)	weight: 0
#first(x1)	weight: 0
   nil()	weight: 0
 first(x1)	weight: 0
first❆1_nil()	weight: 0
  cons(x1,x2)	weight: 0
  #if(x1,x2,x3,x4)	weight: 0
#first❆1_cons(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #7
Number of SCCs: 2, DPs: 3, edges: 3
	SCC { #4 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  failed.
