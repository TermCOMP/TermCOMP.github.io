Input TRS:
    1: pairNs() -> cons(0(),n__incr(n__oddNs()))
    2: oddNs() -> incr(pairNs())
    3: incr(cons(X,XS)) -> cons(s(X),n__incr(activate(XS)))
    4: take(0(),XS) -> nil()
    5: take(s(N),cons(X,XS)) -> cons(X,n__take(N,activate(XS)))
    6: zip(nil(),XS) -> nil()
    7: zip(X,nil()) -> nil()
    8: zip(cons(X,XS),cons(Y,YS)) -> cons(pair(X,Y),n__zip(activate(XS),activate(YS)))
    9: tail(cons(X,XS)) -> activate(XS)
    10: repItems(nil()) -> nil()
    11: repItems(cons(X,XS)) -> cons(X,n__cons(X,n__repItems(activate(XS))))
    12: incr(X) -> n__incr(X)
    13: oddNs() -> n__oddNs()
    14: take(X1,X2) -> n__take(X1,X2)
    15: zip(X1,X2) -> n__zip(X1,X2)
    16: cons(X1,X2) -> n__cons(X1,X2)
    17: repItems(X) -> n__repItems(X)
    18: activate(n__incr(X)) -> incr(activate(X))
    19: activate(n__oddNs()) -> oddNs()
    20: activate(n__take(X1,X2)) -> take(activate(X1),activate(X2))
    21: activate(n__zip(X1,X2)) -> zip(activate(X1),activate(X2))
    22: activate(n__cons(X1,X2)) -> cons(activate(X1),X2)
    23: activate(n__repItems(X)) -> repItems(activate(X))
    24: activate(X) -> X
Number of strict rules: 24
Direct Order(PosReal,>,Poly) ... removes: 4 10 7 9 6
repItems(x1)	weight: (/ 1 8) + 2 * x1
  incr(x1)	weight: x1
     s(x1)	weight: x1
n__oddNs()	weight: 0
activate(x1)	weight: x1
  take(x1,x2)	weight: (/ 1 8) + x1 + x2
  pair(x1,x2)	weight: x1 + x2
  tail(x1)	weight: (/ 1 8) + x1
     0()	weight: 0
n__take(x1,x2)	weight: (/ 1 8) + x1 + x2
n__cons(x1,x2)	weight: x1 + x2
   nil()	weight: 0
n__zip(x1,x2)	weight: (/ 230969 8) + x1 + x2
pairNs()	weight: 0
 oddNs()	weight: 0
n__repItems(x1)	weight: (/ 1 8) + 2 * x1
  cons(x1,x2)	weight: x1 + x2
n__incr(x1)	weight: x1
   zip(x1,x2)	weight: (/ 230969 8) + x1 + x2
Number of strict rules: 19
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #oddNs() -> #incr(pairNs())
   #2: #oddNs() -> #pairNs()
   #3: #repItems(cons(X,XS)) -> #cons(X,n__cons(X,n__repItems(activate(XS))))
   #4: #repItems(cons(X,XS)) -> #activate(XS)
   #5: #activate(n__repItems(X)) -> #repItems(activate(X))
   #6: #activate(n__repItems(X)) -> #activate(X)
   #7: #activate(n__take(X1,X2)) -> #take(activate(X1),activate(X2))
   #8: #activate(n__take(X1,X2)) -> #activate(X1)
   #9: #activate(n__take(X1,X2)) -> #activate(X2)
   #10: #take(s(N),cons(X,XS)) -> #cons(X,n__take(N,activate(XS)))
   #11: #take(s(N),cons(X,XS)) -> #activate(XS)
   #12: #activate(n__cons(X1,X2)) -> #cons(activate(X1),X2)
   #13: #activate(n__cons(X1,X2)) -> #activate(X1)
   #14: #activate(n__oddNs()) -> #oddNs()
   #15: #activate(n__zip(X1,X2)) -> #zip(activate(X1),activate(X2))
   #16: #activate(n__zip(X1,X2)) -> #activate(X1)
   #17: #activate(n__zip(X1,X2)) -> #activate(X2)
   #18: #incr(cons(X,XS)) -> #cons(s(X),n__incr(activate(XS)))
   #19: #incr(cons(X,XS)) -> #activate(XS)
   #20: #pairNs() -> #cons(0(),n__incr(n__oddNs()))
   #21: #zip(cons(X,XS),cons(Y,YS)) -> #cons(pair(X,Y),n__zip(activate(XS),activate(YS)))
   #22: #zip(cons(X,XS),cons(Y,YS)) -> #activate(XS)
   #23: #zip(cons(X,XS),cons(Y,YS)) -> #activate(YS)
   #24: #activate(n__incr(X)) -> #incr(activate(X))
   #25: #activate(n__incr(X)) -> #activate(X)
Number of SCCs: 1, DPs: 18, edges: 151
	SCC { #1 #4..9 #11 #13..17 #19 #22..25 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... succeeded.
repItems(x1)	weight: (/ 1 4) + x1
  incr(x1)	weight: x1
#cons(x1,x2)	weight: 0
     s(x1)	weight: x1
n__oddNs()	weight: (/ 1 4)
#take(x1,x2)	weight: max{(/ 1 4) + x2, (/ 1 16) + x1}
activate(x1)	weight: x1
  take(x1,x2)	weight: max{(/ 3 16) + x2, (/ 1 16) + x1}
#pairNs()	weight: 0
  pair(x1,x2)	weight: max{(/ 3 16) + x2, (/ 1 8) + x1}
#activate(x1)	weight: (/ 1 8) + x1
 #zip(x1,x2)	weight: max{(/ 3 16) + x2, (/ 1 4) + x1}
  tail(x1)	weight: 0
     0()	weight: 0
n__take(x1,x2)	weight: max{(/ 3 16) + x2, (/ 1 16) + x1}
n__cons(x1,x2)	weight: max{x2, (/ 1 4) + x1}
   nil()	weight: 0
#incr(x1)	weight: (/ 1 8) + x1
n__zip(x1,x2)	weight: max{(/ 3 16) + x2, (/ 1 8) + x1}
pairNs()	weight: (/ 1 4)
#oddNs()	weight: (/ 3 8)
 oddNs()	weight: (/ 1 4)
n__repItems(x1)	weight: (/ 1 4) + x1
#repItems(x1)	weight: (/ 3 16) + x1
  cons(x1,x2)	weight: max{x2, (/ 1 4) + x1}
n__incr(x1)	weight: x1
   zip(x1,x2)	weight: max{(/ 3 16) + x2, (/ 1 8) + x1}
    Usable rules: { 1..3 5 8 11..24 }
    Removed DPs: #4..9 #11 #13 #16 #17 #22 #23
Number of SCCs: 1, DPs: 5, edges: 9
	SCC { #1 #14 #19 #24 #25 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  failed.
