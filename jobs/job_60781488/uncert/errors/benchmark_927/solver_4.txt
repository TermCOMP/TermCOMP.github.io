Input TRS:
    1: eq(n__0(),n__0()) -> true()
    2: eq(n__s(X),n__s(Y)) -> eq(activate(X),activate(Y))
    3: eq(X,Y) -> false()
    4: inf(X) -> cons(X,n__inf(s(X)))
    5: take(0(),X) -> nil()
    6: take(s(X),cons(Y,L)) -> cons(activate(Y),n__take(activate(X),activate(L)))
    7: length(nil()) -> 0()
    8: length(cons(X,L)) -> s(n__length(activate(L)))
    9: 0() -> n__0()
    10: s(X) -> n__s(X)
    11: inf(X) -> n__inf(X)
    12: take(X1,X2) -> n__take(X1,X2)
    13: length(X) -> n__length(X)
    14: activate(n__0()) -> 0()
    15: activate(n__s(X)) -> s(X)
    16: activate(n__inf(X)) -> inf(X)
    17: activate(n__take(X1,X2)) -> take(X1,X2)
    18: activate(n__length(X)) -> length(X)
    19: activate(X) -> X
Number of strict rules: 19
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #eq(n__s(X),n__s(Y)) -> #eq(activate(X),activate(Y))
   #2: #eq(n__s(X),n__s(Y)) -> #activate(X)
   #3: #eq(n__s(X),n__s(Y)) -> #activate(Y)
   #4: #take(s(X),cons(Y,L)) -> #activate(Y)
   #5: #take(s(X),cons(Y,L)) -> #activate(X)
   #6: #take(s(X),cons(Y,L)) -> #activate(L)
   #7: #activate(n__0()) -> #0()
   #8: #length(nil()) -> #0()
   #9: #activate(n__take(X1,X2)) -> #take(X1,X2)
   #10: #activate(n__inf(X)) -> #inf(X)
   #11: #length(cons(X,L)) -> #s(n__length(activate(L)))
   #12: #length(cons(X,L)) -> #activate(L)
   #13: #activate(n__s(X)) -> #s(X)
   #14: #inf(X) -> #s(X)
   #15: #activate(n__length(X)) -> #length(X)
Number of SCCs: 2, DPs: 7, edges: 13
	SCC { #1 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  failed.
