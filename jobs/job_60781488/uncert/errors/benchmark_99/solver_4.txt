Input TRS:
    1: ap(ap(f(),x),x) -> ap(ap(x,ap(f(),x)),ap(ap(cons(),x),nil()))
    2: ap(ap(ap(foldr(),g),h),nil()) -> h
    3: ap(ap(ap(foldr(),g),h),ap(ap(cons(),x),xs)) -> ap(ap(g,x),ap(ap(ap(foldr(),g),h),xs))
Number of strict rules: 3
Direct Order(PosReal,>,Poly) ... failed.
Freezing ap
1: ap❆2_f(x,x) -> ap(ap(x,ap❆1_f(x)),ap❆2_cons(x,nil()))
2: ap❆3_foldr(g,h,nil()) -> h
3: ap❆3_foldr(g,h,ap❆2_cons(x,xs)) -> ap(ap(g,x),ap❆3_foldr(g,h,xs))
4: ap(cons(),_1) ->= ap❆1_cons(_1)
5: ap(ap❆1_cons(_1),_2) ->= ap❆2_cons(_1,_2)
6: ap(foldr(),_1) ->= ap❆1_foldr(_1)
7: ap(ap❆1_foldr(_1),_2) ->= ap❆2_foldr(_1,_2)
8: ap(ap❆2_foldr(_1,_2),_3) ->= ap❆3_foldr(_1,_2,_3)
9: ap(f(),_1) ->= ap❆1_f(_1)
10: ap(ap❆1_f(_1),_2) ->= ap❆2_f(_1,_2)
Number of strict rules: 3
Direct Order(PosReal,>,Poly) ... failed.
Dependency Pairs:
   #1: #ap(ap❆1_f(_1),_2) ->? #ap❆2_f(_1,_2)
   #2: #ap❆3_foldr(g,h,ap❆2_cons(x,xs)) -> #ap(ap(g,x),ap❆3_foldr(g,h,xs))
   #3: #ap❆3_foldr(g,h,ap❆2_cons(x,xs)) -> #ap(g,x)
   #4: #ap❆3_foldr(g,h,ap❆2_cons(x,xs)) -> #ap❆3_foldr(g,h,xs)
   #5: #ap❆2_f(x,x) -> #ap(ap(x,ap❆1_f(x)),ap❆2_cons(x,nil()))
   #6: #ap❆2_f(x,x) -> #ap(x,ap❆1_f(x))
   #7: #ap(ap❆2_foldr(_1,_2),_3) ->? #ap❆3_foldr(_1,_2,_3)
Number of SCCs: 1, DPs: 7, edges: 16
	SCC { #1..7 }
Removing DPs: Order(PosReal,>,Sum)... Order(PosReal,>,Max)... QLPOpS... Order(PosReal,>,MaxSum)... QWPOpS(PosReal,>,MaxSum)... Order(PosReal,>,Sum-Sum; PosReal,≥,Sum-Sum)... Order(PosReal,>,Sum-Sum; NegReal,≥,Sum)... Order(PosReal,>,MaxSum-Sum; NegReal,≥,Sum)... failed.
Removing edges: failed.
Finding a loop...  failed.
