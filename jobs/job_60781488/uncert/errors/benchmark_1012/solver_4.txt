Input TRS:
    1: active(app(nil(),YS)) -> mark(YS)
    2: active(app(cons(X,XS),YS)) -> mark(cons(X,app(XS,YS)))
    3: active(from(X)) -> mark(cons(X,from(s(X))))
    4: active(zWadr(nil(),YS)) -> mark(nil())
    5: active(zWadr(XS,nil())) -> mark(nil())
    6: active(zWadr(cons(X,XS),cons(Y,YS))) -> mark(cons(app(Y,cons(X,nil())),zWadr(XS,YS)))
    7: active(prefix(L)) -> mark(cons(nil(),zWadr(L,prefix(L))))
    8: mark(app(X1,X2)) -> active(app(mark(X1),mark(X2)))
    9: mark(nil()) -> active(nil())
    10: mark(cons(X1,X2)) -> active(cons(mark(X1),X2))
    11: mark(from(X)) -> active(from(mark(X)))
    12: mark(s(X)) -> active(s(mark(X)))
    13: mark(zWadr(X1,X2)) -> active(zWadr(mark(X1),mark(X2)))
    14: mark(prefix(X)) -> active(prefix(mark(X)))
    15: app(mark(X1),X2) -> app(X1,X2)
    16: app(X1,mark(X2)) -> app(X1,X2)
    17: app(active(X1),X2) -> app(X1,X2)
    18: app(X1,active(X2)) -> app(X1,X2)
    19: cons(mark(X1),X2) -> cons(X1,X2)
    20: cons(X1,mark(X2)) -> cons(X1,X2)
    21: cons(active(X1),X2) -> cons(X1,X2)
    22: cons(X1,active(X2)) -> cons(X1,X2)
    23: from(mark(X)) -> from(X)
    24: from(active(X)) -> from(X)
    25: s(mark(X)) -> s(X)
    26: s(active(X)) -> s(X)
    27: zWadr(mark(X1),X2) -> zWadr(X1,X2)
    28: zWadr(X1,mark(X2)) -> zWadr(X1,X2)
    29: zWadr(active(X1),X2) -> zWadr(X1,X2)
    30: zWadr(X1,active(X2)) -> zWadr(X1,X2)
    31: prefix(mark(X)) -> prefix(X)
    32: prefix(active(X)) -> prefix(X)
Number of strict rules: 32
Direct Order(PosReal,>,Poly) ... failed.
Freezing ... failed.
Dependency Pairs:
   #1: #active(app(cons(X,XS),YS)) -> #mark(cons(X,app(XS,YS)))
   #2: #active(app(cons(X,XS),YS)) -> #cons(X,app(XS,YS))
   #3: #active(app(cons(X,XS),YS)) -> #app(XS,YS)
   #4: #zWadr(active(X1),X2) -> #zWadr(X1,X2)
   #5: #active(zWadr(cons(X,XS),cons(Y,YS))) -> #mark(cons(app(Y,cons(X,nil())),zWadr(XS,YS)))
   #6: #active(zWadr(cons(X,XS),cons(Y,YS))) -> #cons(app(Y,cons(X,nil())),zWadr(XS,YS))
   #7: #active(zWadr(cons(X,XS),cons(Y,YS))) -> #app(Y,cons(X,nil()))
   #8: #active(zWadr(cons(X,XS),cons(Y,YS))) -> #cons(X,nil())
   #9: #active(zWadr(cons(X,XS),cons(Y,YS))) -> #zWadr(XS,YS)
   #10: #mark(zWadr(X1,X2)) -> #active(zWadr(mark(X1),mark(X2)))
   #11: #mark(zWadr(X1,X2)) -> #zWadr(mark(X1),mark(X2))
   #12: #mark(zWadr(X1,X2)) -> #mark(X1)
   #13: #mark(zWadr(X1,X2)) -> #mark(X2)
   #14: #mark(nil()) -> #active(nil())
   #15: #mark(from(X)) -> #active(from(mark(X)))
   #16: #mark(from(X)) -> #from(mark(X))
   #17: #mark(from(X)) -> #mark(X)
   #18: #from(active(X)) -> #from(X)
   #19: #from(mark(X)) -> #from(X)
   #20: #mark(s(X)) -> #active(s(mark(X)))
   #21: #mark(s(X)) -> #s(mark(X))
   #22: #mark(s(X)) -> #mark(X)
   #23: #prefix(mark(X)) -> #prefix(X)
   #24: #mark(prefix(X)) -> #active(prefix(mark(X)))
   #25: #mark(prefix(X)) -> #prefix(mark(X))
   #26: #mark(prefix(X)) -> #mark(X)
   #27: #zWadr(X1,active(X2)) -> #zWadr(X1,X2)
   #28: #s(mark(X)) -> #s(X)
   #29: #cons(X1,mark(X2)) -> #cons(X1,X2)
   #30: #active(prefix(L)) -> #mark(cons(nil(),zWadr(L,prefix(L))))
   #31: #active(prefix(L)) -> #cons(nil(),zWadr(L,prefix(L)))
   #32: #active(prefix(L)) -> #zWadr(L,prefix(L))
   #33: #mark(cons(X1,X2)) -> #active(cons(mark(X1),X2))
   #34: #mark(cons(X1,X2)) -> #cons(mark(X1),X2)
   #35: #mark(cons(X1,X2)) -> #mark(X1)
   #36: #active(zWadr(XS,nil())) -> #mark(nil())
   #37: #zWadr(X1,mark(X2)) -> #zWadr(X1,X2)
   #38: #cons(X1,active(X2)) -> #cons(X1,X2)
   #39: #zWadr(mark(X1),X2) -> #zWadr(X1,X2)
   #40: #app(active(X1),X2) -> #app(X1,X2)
   #41: #prefix(active(X)) -> #prefix(X)
   #42: #cons(mark(X1),X2) -> #cons(X1,X2)
   #43: #s(active(X)) -> #s(X)
   #44: #cons(active(X1),X2) -> #cons(X1,X2)
   #45: #app(X1,mark(X2)) -> #app(X1,X2)
   #46: #active(from(X)) -> #mark(cons(X,from(s(X))))
   #47: #active(from(X)) -> #cons(X,from(s(X)))
   #48: #active(from(X)) -> #from(s(X))
   #49: #active(from(X)) -> #s(X)
   #50: #active(app(nil(),YS)) -> #mark(YS)
   #51: #mark(app(X1,X2)) -> #active(app(mark(X1),mark(X2)))
   #52: #mark(app(X1,X2)) -> #app(mark(X1),mark(X2))
   #53: #mark(app(X1,X2)) -> #mark(X1)
   #54: #mark(app(X1,X2)) -> #mark(X2)
   #55: #app(mark(X1),X2) -> #app(X1,X2)
   #56: #active(zWadr(nil(),YS)) -> #mark(nil())
   #57: #app(X1,active(X2)) -> #app(X1,X2)
Number of SCCs: 7, DPs: 35, edges: 177
	SCC { #28 #43 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: 0
prefix(x1)	weight: 0
#zWadr(x1,x2)	weight: 0
 zWadr(x1,x2)	weight: 0
#mark(x1)	weight: 0
  from(x1)	weight: 0
   #s(x1)	weight: x1
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#prefix(x1)	weight: 0
 #app(x1,x2)	weight: 0
#from(x1)	weight: 0
active(x1)	weight: (/ 1 2) + x1
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
   app(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #28 #43
Number of SCCs: 6, DPs: 33, edges: 173
	SCC { #23 #41 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: 0
prefix(x1)	weight: 0
#zWadr(x1,x2)	weight: 0
 zWadr(x1,x2)	weight: 0
#mark(x1)	weight: 0
  from(x1)	weight: 0
   #s(x1)	weight: 0
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#prefix(x1)	weight: x1
 #app(x1,x2)	weight: 0
#from(x1)	weight: 0
active(x1)	weight: (/ 1 2) + x1
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
   app(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #23 #41
Number of SCCs: 5, DPs: 31, edges: 169
	SCC { #18 #19 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: 0
prefix(x1)	weight: 0
#zWadr(x1,x2)	weight: 0
 zWadr(x1,x2)	weight: 0
#mark(x1)	weight: 0
  from(x1)	weight: 0
   #s(x1)	weight: 0
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#prefix(x1)	weight: 0
 #app(x1,x2)	weight: 0
#from(x1)	weight: x1
active(x1)	weight: (/ 1 2) + x1
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
   app(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #18 #19
Number of SCCs: 4, DPs: 29, edges: 165
	SCC { #29 #38 #42 #44 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: x1
     s(x1)	weight: 0
prefix(x1)	weight: 0
#zWadr(x1,x2)	weight: 0
 zWadr(x1,x2)	weight: 0
#mark(x1)	weight: 0
  from(x1)	weight: 0
   #s(x1)	weight: 0
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#prefix(x1)	weight: 0
 #app(x1,x2)	weight: 0
#from(x1)	weight: 0
active(x1)	weight: (/ 1 2) + x1
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
   app(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #42 #44
Number of SCCs: 4, DPs: 27, edges: 153
	SCC { #29 #38 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: x2
     s(x1)	weight: 0
prefix(x1)	weight: 0
#zWadr(x1,x2)	weight: 0
 zWadr(x1,x2)	weight: 0
#mark(x1)	weight: 0
  from(x1)	weight: 0
   #s(x1)	weight: 0
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#prefix(x1)	weight: 0
 #app(x1,x2)	weight: 0
#from(x1)	weight: 0
active(x1)	weight: (/ 1 2) + x1
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
   app(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #29 #38
Number of SCCs: 3, DPs: 25, edges: 149
	SCC { #40 #45 #55 #57 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: 0
prefix(x1)	weight: 0
#zWadr(x1,x2)	weight: 0
 zWadr(x1,x2)	weight: 0
#mark(x1)	weight: 0
  from(x1)	weight: 0
   #s(x1)	weight: 0
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#prefix(x1)	weight: 0
 #app(x1,x2)	weight: x2
#from(x1)	weight: 0
active(x1)	weight: (/ 1 2) + x1
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
   app(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #45 #57
Number of SCCs: 4, DPs: 23, edges: 137
	SCC { #40 #55 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: 0
prefix(x1)	weight: 0
#zWadr(x1,x2)	weight: 0
 zWadr(x1,x2)	weight: 0
#mark(x1)	weight: 0
  from(x1)	weight: 0
   #s(x1)	weight: 0
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#prefix(x1)	weight: 0
 #app(x1,x2)	weight: x1
#from(x1)	weight: 0
active(x1)	weight: (/ 1 2) + x1
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
   app(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #40 #55
Number of SCCs: 3, DPs: 21, edges: 133
	SCC { #4 #27 #37 #39 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: 0
prefix(x1)	weight: 0
#zWadr(x1,x2)	weight: x2
 zWadr(x1,x2)	weight: 0
#mark(x1)	weight: 0
  from(x1)	weight: 0
   #s(x1)	weight: 0
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#prefix(x1)	weight: 0
 #app(x1,x2)	weight: 0
#from(x1)	weight: 0
active(x1)	weight: (/ 1 2) + x1
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
   app(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #27 #37
Number of SCCs: 4, DPs: 19, edges: 121
	SCC { #4 #39 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: 0
prefix(x1)	weight: 0
#zWadr(x1,x2)	weight: x1
 zWadr(x1,x2)	weight: 0
#mark(x1)	weight: 0
  from(x1)	weight: 0
   #s(x1)	weight: 0
   nil()	weight: 0
  mark(x1)	weight: (/ 1 2) + x1
#prefix(x1)	weight: 0
 #app(x1,x2)	weight: 0
#from(x1)	weight: 0
active(x1)	weight: (/ 1 2) + x1
  cons(x1,x2)	weight: 0
#active(x1)	weight: 0
   app(x1,x2)	weight: 0
    Usable rules: { }
    Removed DPs: #4 #39
Number of SCCs: 3, DPs: 17, edges: 117
	SCC { #1 #5 #10 #12 #13 #15 #17 #22 #24 #26 #30 #35 #46 #50 #51 #53 #54 }
Removing DPs: Order(PosReal,>,Sum)... succeeded.
#cons(x1,x2)	weight: 0
     s(x1)	weight: (/ 1 8) + x1
prefix(x1)	weight: (/ 241635 8) + x1
#zWadr(x1,x2)	weight: 0
 zWadr(x1,x2)	weight: (/ 1 2) + x1 + x2
#mark(x1)	weight: (/ 1 8) + x1
  from(x1)	weight: (/ 241635 8) + x1
   #s(x1)	weight: 0
   nil()	weight: 0
  mark(x1)	weight: x1
#prefix(x1)	weight: 0
 #app(x1,x2)	weight: 0
#from(x1)	weight: 0
active(x1)	weight: x1
  cons(x1,x2)	weight: (/ 241633 8) + x1
#active(x1)	weight: x1
   app(x1,x2)	weight: (/ 1 4) + x1 + x2
    Usable rules: { 1..32 }
    Removed DPs: #1 #5 #10 #12 #13 #15 #17 #22 #24 #26 #30 #35 #46 #50 #51 #53 #54
Number of SCCs: 3, DPs: 0, edges: 0
