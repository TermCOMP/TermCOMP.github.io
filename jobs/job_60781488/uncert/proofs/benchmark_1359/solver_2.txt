YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/xFJOw.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) QTRSRRRProof [EQUIVALENT, 94 ms]
(2) QTRS
(3) QTRSRRRProof [EQUIVALENT, 0 ms]
(4) QTRS
(5) RisEmptyProof [EQUIVALENT, 0 ms]
(6) YES


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   U11(tt, V1, V2) -> U12(isNat(activate(V1)), activate(V2))
   U12(tt, V2) -> U13(isNat(activate(V2)))
   U13(tt) -> tt
   U21(tt, V1) -> U22(isNat(activate(V1)))
   U22(tt) -> tt
   U31(tt, N) -> activate(N)
   U41(tt, M, N) -> s(plus(activate(N), activate(M)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__plus(V1, V2)) -> U11(and(isNatKind(activate(V1)), n__isNatKind(activate(V2))), activate(V1), activate(V2))
   isNat(n__s(V1)) -> U21(isNatKind(activate(V1)), activate(V1))
   isNatKind(n__0) -> tt
   isNatKind(n__plus(V1, V2)) -> and(isNatKind(activate(V1)), n__isNatKind(activate(V2)))
   isNatKind(n__s(V1)) -> isNatKind(activate(V1))
   plus(N, 0) -> U31(and(isNat(N), n__isNatKind(N)), N)
   plus(N, s(M)) -> U41(and(and(isNat(M), n__isNatKind(M)), n__and(n__isNat(N), n__isNatKind(N))), M, N)
   0 -> n__0
   plus(X1, X2) -> n__plus(X1, X2)
   isNatKind(X) -> n__isNatKind(X)
   s(X) -> n__s(X)
   and(X1, X2) -> n__and(X1, X2)
   isNat(X) -> n__isNat(X)
   activate(n__0) -> 0
   activate(n__plus(X1, X2)) -> plus(activate(X1), activate(X2))
   activate(n__isNatKind(X)) -> isNatKind(X)
   activate(n__s(X)) -> s(activate(X))
   activate(n__and(X1, X2)) -> and(activate(X1), X2)
   activate(n__isNat(X)) -> isNat(X)
   activate(X) -> X

Q is empty.

----------------------------------------

(1) QTRSRRRProof (EQUIVALENT)
Used ordering:
U11/3(YES,YES,YES)
tt/0)
U12/2(YES,YES)
isNat/1(YES)
activate/1)YES(
U13/1)YES(
U21/2(YES,YES)
U22/1(YES)
U31/2(YES,YES)
U41/3(YES,YES,YES)
s/1(YES)
plus/2(YES,YES)
and/2(YES,YES)
n__0/0)
n__plus/2(YES,YES)
isNatKind/1(YES)
n__isNatKind/1(YES)
n__s/1(YES)
0/0)
n__and/2(YES,YES)
n__isNat/1(YES)

Quasi precedence:
[U41_3, plus_2, n__plus_2] > U11_3 > [U12_2, isNat_1, U21_2, n__isNat_1] > tt > U22_1
[U41_3, plus_2, n__plus_2] > U31_2
[U41_3, plus_2, n__plus_2] > [s_1, and_2, isNatKind_1, n__isNatKind_1, n__s_1, n__and_2] > [U12_2, isNat_1, U21_2, n__isNat_1] > tt > U22_1
[n__0, 0]


Status:
U11_3: multiset status
tt: multiset status
U12_2: [2,1]
isNat_1: [1]
U21_2: [2,1]
U22_1: [1]
U31_2: multiset status
U41_3: [3,2,1]
s_1: multiset status
plus_2: [1,2]
and_2: multiset status
n__0: multiset status
n__plus_2: [1,2]
isNatKind_1: multiset status
n__isNatKind_1: multiset status
n__s_1: multiset status
0: multiset status
n__and_2: multiset status
n__isNat_1: [1]

With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   U11(tt, V1, V2) -> U12(isNat(activate(V1)), activate(V2))
   U12(tt, V2) -> U13(isNat(activate(V2)))
   U21(tt, V1) -> U22(isNat(activate(V1)))
   U22(tt) -> tt
   U31(tt, N) -> activate(N)
   U41(tt, M, N) -> s(plus(activate(N), activate(M)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__plus(V1, V2)) -> U11(and(isNatKind(activate(V1)), n__isNatKind(activate(V2))), activate(V1), activate(V2))
   isNat(n__s(V1)) -> U21(isNatKind(activate(V1)), activate(V1))
   isNatKind(n__0) -> tt
   isNatKind(n__plus(V1, V2)) -> and(isNatKind(activate(V1)), n__isNatKind(activate(V2)))
   isNatKind(n__s(V1)) -> isNatKind(activate(V1))
   plus(N, 0) -> U31(and(isNat(N), n__isNatKind(N)), N)
   plus(N, s(M)) -> U41(and(and(isNat(M), n__isNatKind(M)), n__and(n__isNat(N), n__isNatKind(N))), M, N)




----------------------------------------

(2)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   U13(tt) -> tt
   0 -> n__0
   plus(X1, X2) -> n__plus(X1, X2)
   isNatKind(X) -> n__isNatKind(X)
   s(X) -> n__s(X)
   and(X1, X2) -> n__and(X1, X2)
   isNat(X) -> n__isNat(X)
   activate(n__0) -> 0
   activate(n__plus(X1, X2)) -> plus(activate(X1), activate(X2))
   activate(n__isNatKind(X)) -> isNatKind(X)
   activate(n__s(X)) -> s(activate(X))
   activate(n__and(X1, X2)) -> and(activate(X1), X2)
   activate(n__isNat(X)) -> isNat(X)
   activate(X) -> X

Q is empty.

----------------------------------------

(3) QTRSRRRProof (EQUIVALENT)
Used ordering:
Knuth-Bendix order [KBO] with precedence:activate_1 > plus_2 > 0 > s_1 > isNat_1 > and_2 > n__and_2 > n__plus_2 > n__s_1 > isNatKind_1 > U13_1 > n__isNatKind_1 > n__isNat_1 > n__0 > tt

and weight map:

   tt=1
   0=1
   n__0=1
   U13_1=1
   isNatKind_1=1
   n__isNatKind_1=1
   s_1=1
   n__s_1=1
   isNat_1=1
   n__isNat_1=1
   activate_1=0
   plus_2=0
   n__plus_2=0
   and_2=0
   n__and_2=0

The variable weight is 1With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   U13(tt) -> tt
   0 -> n__0
   plus(X1, X2) -> n__plus(X1, X2)
   isNatKind(X) -> n__isNatKind(X)
   s(X) -> n__s(X)
   and(X1, X2) -> n__and(X1, X2)
   isNat(X) -> n__isNat(X)
   activate(n__0) -> 0
   activate(n__plus(X1, X2)) -> plus(activate(X1), activate(X2))
   activate(n__isNatKind(X)) -> isNatKind(X)
   activate(n__s(X)) -> s(activate(X))
   activate(n__and(X1, X2)) -> and(activate(X1), X2)
   activate(n__isNat(X)) -> isNat(X)
   activate(X) -> X




----------------------------------------

(4)
Obligation:
Q restricted rewrite system:
R is empty.
Q is empty.

----------------------------------------

(5) RisEmptyProof (EQUIVALENT)
The TRS R is empty. Hence, termination is trivially proven.
----------------------------------------

(6)
YES
