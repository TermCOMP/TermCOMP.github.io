YES

Problem 1: 

(VAR vu95NonEmpty x y z)
(RULES
bsort(u46(x,y)) -> last(u46(bubble(u46(x,y)),bsort(butlast(bubble(u46(x,y))))))
bsort(nil) -> nil
bubble(u46(x,u46(y,z))) -> if(u60u61(x,y),u46(y,bubble(u46(x,z))),u46(x,bubble(u46(y,z))))
bubble(u46(x,nil)) -> u46(x,nil)
bubble(nil) -> nil
butlast(u46(x,u46(y,z))) -> u46(x,butlast(u46(y,z)))
butlast(u46(x,nil)) -> nil
butlast(nil) -> nil
last(u46(x,u46(y,z))) -> last(u46(y,z))
last(u46(x,nil)) -> x
last(nil) -> num0
)


Problem 1: 

Innermost Equivalent Processor:
-> Rules:
 bsort(u46(x,y)) -> last(u46(bubble(u46(x,y)),bsort(butlast(bubble(u46(x,y))))))
 bsort(nil) -> nil
 bubble(u46(x,u46(y,z))) -> if(u60u61(x,y),u46(y,bubble(u46(x,z))),u46(x,bubble(u46(y,z))))
 bubble(u46(x,nil)) -> u46(x,nil)
 bubble(nil) -> nil
 butlast(u46(x,u46(y,z))) -> u46(x,butlast(u46(y,z)))
 butlast(u46(x,nil)) -> nil
 butlast(nil) -> nil
 last(u46(x,u46(y,z))) -> last(u46(y,z))
 last(u46(x,nil)) -> x
 last(nil) -> num0
-> The term rewriting system is non-overlaping or locally confluent overlay system. Therefore, innermost termination implies termination.
 

Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 BSORT(u46(x,y)) -> BSORT(butlast(bubble(u46(x,y))))
 BSORT(u46(x,y)) -> BUBBLE(u46(x,y))
 BSORT(u46(x,y)) -> BUTLAST(bubble(u46(x,y)))
 BSORT(u46(x,y)) -> LAST(u46(bubble(u46(x,y)),bsort(butlast(bubble(u46(x,y))))))
 BUBBLE(u46(x,u46(y,z))) -> BUBBLE(u46(x,z))
 BUBBLE(u46(x,u46(y,z))) -> BUBBLE(u46(y,z))
 BUTLAST(u46(x,u46(y,z))) -> BUTLAST(u46(y,z))
 LAST(u46(x,u46(y,z))) -> LAST(u46(y,z))
-> Rules:
 bsort(u46(x,y)) -> last(u46(bubble(u46(x,y)),bsort(butlast(bubble(u46(x,y))))))
 bsort(nil) -> nil
 bubble(u46(x,u46(y,z))) -> if(u60u61(x,y),u46(y,bubble(u46(x,z))),u46(x,bubble(u46(y,z))))
 bubble(u46(x,nil)) -> u46(x,nil)
 bubble(nil) -> nil
 butlast(u46(x,u46(y,z))) -> u46(x,butlast(u46(y,z)))
 butlast(u46(x,nil)) -> nil
 butlast(nil) -> nil
 last(u46(x,u46(y,z))) -> last(u46(y,z))
 last(u46(x,nil)) -> x
 last(nil) -> num0

Problem 1: 

SCC Processor:
-> Pairs:
 BSORT(u46(x,y)) -> BSORT(butlast(bubble(u46(x,y))))
 BSORT(u46(x,y)) -> BUBBLE(u46(x,y))
 BSORT(u46(x,y)) -> BUTLAST(bubble(u46(x,y)))
 BSORT(u46(x,y)) -> LAST(u46(bubble(u46(x,y)),bsort(butlast(bubble(u46(x,y))))))
 BUBBLE(u46(x,u46(y,z))) -> BUBBLE(u46(x,z))
 BUBBLE(u46(x,u46(y,z))) -> BUBBLE(u46(y,z))
 BUTLAST(u46(x,u46(y,z))) -> BUTLAST(u46(y,z))
 LAST(u46(x,u46(y,z))) -> LAST(u46(y,z))
-> Rules:
 bsort(u46(x,y)) -> last(u46(bubble(u46(x,y)),bsort(butlast(bubble(u46(x,y))))))
 bsort(nil) -> nil
 bubble(u46(x,u46(y,z))) -> if(u60u61(x,y),u46(y,bubble(u46(x,z))),u46(x,bubble(u46(y,z))))
 bubble(u46(x,nil)) -> u46(x,nil)
 bubble(nil) -> nil
 butlast(u46(x,u46(y,z))) -> u46(x,butlast(u46(y,z)))
 butlast(u46(x,nil)) -> nil
 butlast(nil) -> nil
 last(u46(x,u46(y,z))) -> last(u46(y,z))
 last(u46(x,nil)) -> x
 last(nil) -> num0
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 LAST(u46(x,u46(y,z))) -> LAST(u46(y,z))
->->-> Rules:
 bsort(u46(x,y)) -> last(u46(bubble(u46(x,y)),bsort(butlast(bubble(u46(x,y))))))
 bsort(nil) -> nil
 bubble(u46(x,u46(y,z))) -> if(u60u61(x,y),u46(y,bubble(u46(x,z))),u46(x,bubble(u46(y,z))))
 bubble(u46(x,nil)) -> u46(x,nil)
 bubble(nil) -> nil
 butlast(u46(x,u46(y,z))) -> u46(x,butlast(u46(y,z)))
 butlast(u46(x,nil)) -> nil
 butlast(nil) -> nil
 last(u46(x,u46(y,z))) -> last(u46(y,z))
 last(u46(x,nil)) -> x
 last(nil) -> num0
->->Cycle:
->->-> Pairs:
 BUTLAST(u46(x,u46(y,z))) -> BUTLAST(u46(y,z))
->->-> Rules:
 bsort(u46(x,y)) -> last(u46(bubble(u46(x,y)),bsort(butlast(bubble(u46(x,y))))))
 bsort(nil) -> nil
 bubble(u46(x,u46(y,z))) -> if(u60u61(x,y),u46(y,bubble(u46(x,z))),u46(x,bubble(u46(y,z))))
 bubble(u46(x,nil)) -> u46(x,nil)
 bubble(nil) -> nil
 butlast(u46(x,u46(y,z))) -> u46(x,butlast(u46(y,z)))
 butlast(u46(x,nil)) -> nil
 butlast(nil) -> nil
 last(u46(x,u46(y,z))) -> last(u46(y,z))
 last(u46(x,nil)) -> x
 last(nil) -> num0
->->Cycle:
->->-> Pairs:
 BUBBLE(u46(x,u46(y,z))) -> BUBBLE(u46(x,z))
 BUBBLE(u46(x,u46(y,z))) -> BUBBLE(u46(y,z))
->->-> Rules:
 bsort(u46(x,y)) -> last(u46(bubble(u46(x,y)),bsort(butlast(bubble(u46(x,y))))))
 bsort(nil) -> nil
 bubble(u46(x,u46(y,z))) -> if(u60u61(x,y),u46(y,bubble(u46(x,z))),u46(x,bubble(u46(y,z))))
 bubble(u46(x,nil)) -> u46(x,nil)
 bubble(nil) -> nil
 butlast(u46(x,u46(y,z))) -> u46(x,butlast(u46(y,z)))
 butlast(u46(x,nil)) -> nil
 butlast(nil) -> nil
 last(u46(x,u46(y,z))) -> last(u46(y,z))
 last(u46(x,nil)) -> x
 last(nil) -> num0
->->Cycle:
->->-> Pairs:
 BSORT(u46(x,y)) -> BSORT(butlast(bubble(u46(x,y))))
->->-> Rules:
 bsort(u46(x,y)) -> last(u46(bubble(u46(x,y)),bsort(butlast(bubble(u46(x,y))))))
 bsort(nil) -> nil
 bubble(u46(x,u46(y,z))) -> if(u60u61(x,y),u46(y,bubble(u46(x,z))),u46(x,bubble(u46(y,z))))
 bubble(u46(x,nil)) -> u46(x,nil)
 bubble(nil) -> nil
 butlast(u46(x,u46(y,z))) -> u46(x,butlast(u46(y,z)))
 butlast(u46(x,nil)) -> nil
 butlast(nil) -> nil
 last(u46(x,u46(y,z))) -> last(u46(y,z))
 last(u46(x,nil)) -> x
 last(nil) -> num0


The problem is decomposed in 4 subproblems.

Problem 1.1: 

Subterm Processor:
-> Pairs:
 LAST(u46(x,u46(y,z))) -> LAST(u46(y,z))
-> Rules:
 bsort(u46(x,y)) -> last(u46(bubble(u46(x,y)),bsort(butlast(bubble(u46(x,y))))))
 bsort(nil) -> nil
 bubble(u46(x,u46(y,z))) -> if(u60u61(x,y),u46(y,bubble(u46(x,z))),u46(x,bubble(u46(y,z))))
 bubble(u46(x,nil)) -> u46(x,nil)
 bubble(nil) -> nil
 butlast(u46(x,u46(y,z))) -> u46(x,butlast(u46(y,z)))
 butlast(u46(x,nil)) -> nil
 butlast(nil) -> nil
 last(u46(x,u46(y,z))) -> last(u46(y,z))
 last(u46(x,nil)) -> x
 last(nil) -> num0
->Projection:
 pi(LAST) = 1

Problem 1.1: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 bsort(u46(x,y)) -> last(u46(bubble(u46(x,y)),bsort(butlast(bubble(u46(x,y))))))
 bsort(nil) -> nil
 bubble(u46(x,u46(y,z))) -> if(u60u61(x,y),u46(y,bubble(u46(x,z))),u46(x,bubble(u46(y,z))))
 bubble(u46(x,nil)) -> u46(x,nil)
 bubble(nil) -> nil
 butlast(u46(x,u46(y,z))) -> u46(x,butlast(u46(y,z)))
 butlast(u46(x,nil)) -> nil
 butlast(nil) -> nil
 last(u46(x,u46(y,z))) -> last(u46(y,z))
 last(u46(x,nil)) -> x
 last(nil) -> num0
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2: 

Subterm Processor:
-> Pairs:
 BUTLAST(u46(x,u46(y,z))) -> BUTLAST(u46(y,z))
-> Rules:
 bsort(u46(x,y)) -> last(u46(bubble(u46(x,y)),bsort(butlast(bubble(u46(x,y))))))
 bsort(nil) -> nil
 bubble(u46(x,u46(y,z))) -> if(u60u61(x,y),u46(y,bubble(u46(x,z))),u46(x,bubble(u46(y,z))))
 bubble(u46(x,nil)) -> u46(x,nil)
 bubble(nil) -> nil
 butlast(u46(x,u46(y,z))) -> u46(x,butlast(u46(y,z)))
 butlast(u46(x,nil)) -> nil
 butlast(nil) -> nil
 last(u46(x,u46(y,z))) -> last(u46(y,z))
 last(u46(x,nil)) -> x
 last(nil) -> num0
->Projection:
 pi(BUTLAST) = 1

Problem 1.2: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 bsort(u46(x,y)) -> last(u46(bubble(u46(x,y)),bsort(butlast(bubble(u46(x,y))))))
 bsort(nil) -> nil
 bubble(u46(x,u46(y,z))) -> if(u60u61(x,y),u46(y,bubble(u46(x,z))),u46(x,bubble(u46(y,z))))
 bubble(u46(x,nil)) -> u46(x,nil)
 bubble(nil) -> nil
 butlast(u46(x,u46(y,z))) -> u46(x,butlast(u46(y,z)))
 butlast(u46(x,nil)) -> nil
 butlast(nil) -> nil
 last(u46(x,u46(y,z))) -> last(u46(y,z))
 last(u46(x,nil)) -> x
 last(nil) -> num0
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.3: 

Reduction Pairs Processor:
-> Pairs:
 BUBBLE(u46(x,u46(y,z))) -> BUBBLE(u46(x,z))
 BUBBLE(u46(x,u46(y,z))) -> BUBBLE(u46(y,z))
-> Rules:
 bsort(u46(x,y)) -> last(u46(bubble(u46(x,y)),bsort(butlast(bubble(u46(x,y))))))
 bsort(nil) -> nil
 bubble(u46(x,u46(y,z))) -> if(u60u61(x,y),u46(y,bubble(u46(x,z))),u46(x,bubble(u46(y,z))))
 bubble(u46(x,nil)) -> u46(x,nil)
 bubble(nil) -> nil
 butlast(u46(x,u46(y,z))) -> u46(x,butlast(u46(y,z)))
 butlast(u46(x,nil)) -> nil
 butlast(nil) -> nil
 last(u46(x,u46(y,z))) -> last(u46(y,z))
 last(u46(x,nil)) -> x
 last(nil) -> num0
-> Usable rules:
 Empty
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[bsort](X) = 0
[bubble](X) = 0
[butlast](X) = 0
[last](X) = 0
[u46](X1,X2) = 2.X1 + 2.X2 + 2
[num0] = 0
[u60u61](X1,X2) = 0
[fSNonEmpty] = 0
[if](X1,X2,X3) = 0
[nil] = 0
[BSORT](X) = 0
[BUBBLE](X) = 2.X
[BUTLAST](X) = 0
[LAST](X) = 0

Problem 1.3: 

SCC Processor:
-> Pairs:
 BUBBLE(u46(x,u46(y,z))) -> BUBBLE(u46(y,z))
-> Rules:
 bsort(u46(x,y)) -> last(u46(bubble(u46(x,y)),bsort(butlast(bubble(u46(x,y))))))
 bsort(nil) -> nil
 bubble(u46(x,u46(y,z))) -> if(u60u61(x,y),u46(y,bubble(u46(x,z))),u46(x,bubble(u46(y,z))))
 bubble(u46(x,nil)) -> u46(x,nil)
 bubble(nil) -> nil
 butlast(u46(x,u46(y,z))) -> u46(x,butlast(u46(y,z)))
 butlast(u46(x,nil)) -> nil
 butlast(nil) -> nil
 last(u46(x,u46(y,z))) -> last(u46(y,z))
 last(u46(x,nil)) -> x
 last(nil) -> num0
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 BUBBLE(u46(x,u46(y,z))) -> BUBBLE(u46(y,z))
->->-> Rules:
 bsort(u46(x,y)) -> last(u46(bubble(u46(x,y)),bsort(butlast(bubble(u46(x,y))))))
 bsort(nil) -> nil
 bubble(u46(x,u46(y,z))) -> if(u60u61(x,y),u46(y,bubble(u46(x,z))),u46(x,bubble(u46(y,z))))
 bubble(u46(x,nil)) -> u46(x,nil)
 bubble(nil) -> nil
 butlast(u46(x,u46(y,z))) -> u46(x,butlast(u46(y,z)))
 butlast(u46(x,nil)) -> nil
 butlast(nil) -> nil
 last(u46(x,u46(y,z))) -> last(u46(y,z))
 last(u46(x,nil)) -> x
 last(nil) -> num0

Problem 1.3: 

Subterm Processor:
-> Pairs:
 BUBBLE(u46(x,u46(y,z))) -> BUBBLE(u46(y,z))
-> Rules:
 bsort(u46(x,y)) -> last(u46(bubble(u46(x,y)),bsort(butlast(bubble(u46(x,y))))))
 bsort(nil) -> nil
 bubble(u46(x,u46(y,z))) -> if(u60u61(x,y),u46(y,bubble(u46(x,z))),u46(x,bubble(u46(y,z))))
 bubble(u46(x,nil)) -> u46(x,nil)
 bubble(nil) -> nil
 butlast(u46(x,u46(y,z))) -> u46(x,butlast(u46(y,z)))
 butlast(u46(x,nil)) -> nil
 butlast(nil) -> nil
 last(u46(x,u46(y,z))) -> last(u46(y,z))
 last(u46(x,nil)) -> x
 last(nil) -> num0
->Projection:
 pi(BUBBLE) = 1

Problem 1.3: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 bsort(u46(x,y)) -> last(u46(bubble(u46(x,y)),bsort(butlast(bubble(u46(x,y))))))
 bsort(nil) -> nil
 bubble(u46(x,u46(y,z))) -> if(u60u61(x,y),u46(y,bubble(u46(x,z))),u46(x,bubble(u46(y,z))))
 bubble(u46(x,nil)) -> u46(x,nil)
 bubble(nil) -> nil
 butlast(u46(x,u46(y,z))) -> u46(x,butlast(u46(y,z)))
 butlast(u46(x,nil)) -> nil
 butlast(nil) -> nil
 last(u46(x,u46(y,z))) -> last(u46(y,z))
 last(u46(x,nil)) -> x
 last(nil) -> num0
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.4: 

Reduction Pairs Processor:
-> Pairs:
 BSORT(u46(x,y)) -> BSORT(butlast(bubble(u46(x,y))))
-> Rules:
 bsort(u46(x,y)) -> last(u46(bubble(u46(x,y)),bsort(butlast(bubble(u46(x,y))))))
 bsort(nil) -> nil
 bubble(u46(x,u46(y,z))) -> if(u60u61(x,y),u46(y,bubble(u46(x,z))),u46(x,bubble(u46(y,z))))
 bubble(u46(x,nil)) -> u46(x,nil)
 bubble(nil) -> nil
 butlast(u46(x,u46(y,z))) -> u46(x,butlast(u46(y,z)))
 butlast(u46(x,nil)) -> nil
 butlast(nil) -> nil
 last(u46(x,u46(y,z))) -> last(u46(y,z))
 last(u46(x,nil)) -> x
 last(nil) -> num0
-> Usable rules:
 bubble(u46(x,u46(y,z))) -> if(u60u61(x,y),u46(y,bubble(u46(x,z))),u46(x,bubble(u46(y,z))))
 bubble(u46(x,nil)) -> u46(x,nil)
 bubble(nil) -> nil
 butlast(u46(x,u46(y,z))) -> u46(x,butlast(u46(y,z)))
 butlast(u46(x,nil)) -> nil
 butlast(nil) -> nil
->Interpretation type:
 Simple mixed
->Coefficients:
 All rationals
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[bsort](X) = 0
[bubble](X) = 1/2
[butlast](X) = 1/2.X.X + 1/2.X
[last](X) = 0
[u46](X1,X2) = 1/2.X1.X2 + 2.X2 + 1/2
[num0] = 0
[u60u61](X1,X2) = 1/2.X1.X2 + 2.X1
[fSNonEmpty] = 0
[if](X1,X2,X3) = 0
[nil] = 0
[BSORT](X) = 1/2.X
[BUBBLE](X) = 0
[BUTLAST](X) = 0
[LAST](X) = 0

Problem 1.4: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 bsort(u46(x,y)) -> last(u46(bubble(u46(x,y)),bsort(butlast(bubble(u46(x,y))))))
 bsort(nil) -> nil
 bubble(u46(x,u46(y,z))) -> if(u60u61(x,y),u46(y,bubble(u46(x,z))),u46(x,bubble(u46(y,z))))
 bubble(u46(x,nil)) -> u46(x,nil)
 bubble(nil) -> nil
 butlast(u46(x,u46(y,z))) -> u46(x,butlast(u46(y,z)))
 butlast(u46(x,nil)) -> nil
 butlast(nil) -> nil
 last(u46(x,u46(y,z))) -> last(u46(y,z))
 last(u46(x,nil)) -> x
 last(nil) -> num0
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
