YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/POFFU.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) QTRSRRRProof [EQUIVALENT, 22 ms]
(2) QTRS
(3) QTRSRRRProof [EQUIVALENT, 1 ms]
(4) QTRS
(5) RisEmptyProof [EQUIVALENT, 0 ms]
(6) YES


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   natsFrom(N) -> cons(N, n__natsFrom(n__s(N)))
   fst(pair(XS, YS)) -> XS
   snd(pair(XS, YS)) -> YS
   splitAt(0, XS) -> pair(nil, XS)
   splitAt(s(N), cons(X, XS)) -> u(splitAt(N, activate(XS)), N, X, activate(XS))
   u(pair(YS, ZS), N, X, XS) -> pair(cons(activate(X), YS), ZS)
   head(cons(N, XS)) -> N
   tail(cons(N, XS)) -> activate(XS)
   sel(N, XS) -> head(afterNth(N, XS))
   take(N, XS) -> fst(splitAt(N, XS))
   afterNth(N, XS) -> snd(splitAt(N, XS))
   natsFrom(X) -> n__natsFrom(X)
   s(X) -> n__s(X)
   activate(n__natsFrom(X)) -> natsFrom(activate(X))
   activate(n__s(X)) -> s(activate(X))
   activate(X) -> X

Q is empty.

----------------------------------------

(1) QTRSRRRProof (EQUIVALENT)
Used ordering:
natsFrom/1(YES)
cons/2(YES,YES)
n__natsFrom/1(YES)
n__s/1(YES)
fst/1)YES(
pair/2(YES,YES)
snd/1)YES(
splitAt/2(YES,YES)
0/0)
nil/0)
s/1(YES)
u/4(YES,YES,YES,YES)
activate/1(YES)
head/1)YES(
tail/1(YES)
sel/2(YES,YES)
afterNth/2(YES,YES)
take/2(YES,YES)

Quasi precedence:
[splitAt_2, sel_2, afterNth_2, take_2] > nil > [cons_2, n__s_1]
[splitAt_2, sel_2, afterNth_2, take_2] > [u_4, activate_1, tail_1] > natsFrom_1 > n__natsFrom_1 > [cons_2, n__s_1]
[splitAt_2, sel_2, afterNth_2, take_2] > [u_4, activate_1, tail_1] > pair_2 > [cons_2, n__s_1]
[splitAt_2, sel_2, afterNth_2, take_2] > [u_4, activate_1, tail_1] > s_1 > [cons_2, n__s_1]
0 > pair_2 > [cons_2, n__s_1]


Status:
natsFrom_1: multiset status
cons_2: multiset status
n__natsFrom_1: multiset status
n__s_1: multiset status
pair_2: multiset status
splitAt_2: [1,2]
0: multiset status
nil: multiset status
s_1: multiset status
u_4: multiset status
activate_1: multiset status
tail_1: multiset status
sel_2: [1,2]
afterNth_2: [1,2]
take_2: [1,2]

With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   natsFrom(N) -> cons(N, n__natsFrom(n__s(N)))
   fst(pair(XS, YS)) -> XS
   snd(pair(XS, YS)) -> YS
   splitAt(0, XS) -> pair(nil, XS)
   splitAt(s(N), cons(X, XS)) -> u(splitAt(N, activate(XS)), N, X, activate(XS))
   u(pair(YS, ZS), N, X, XS) -> pair(cons(activate(X), YS), ZS)
   head(cons(N, XS)) -> N
   tail(cons(N, XS)) -> activate(XS)
   natsFrom(X) -> n__natsFrom(X)
   s(X) -> n__s(X)
   activate(n__natsFrom(X)) -> natsFrom(activate(X))
   activate(n__s(X)) -> s(activate(X))
   activate(X) -> X




----------------------------------------

(2)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   sel(N, XS) -> head(afterNth(N, XS))
   take(N, XS) -> fst(splitAt(N, XS))
   afterNth(N, XS) -> snd(splitAt(N, XS))

Q is empty.

----------------------------------------

(3) QTRSRRRProof (EQUIVALENT)
Used ordering:
Knuth-Bendix order [KBO] with precedence:afterNth_2 > snd_1 > splitAt_2 > take_2 > fst_1 > sel_2 > head_1

and weight map:

   head_1=1
   fst_1=1
   snd_1=1
   sel_2=2
   afterNth_2=1
   take_2=1
   splitAt_2=0

The variable weight is 1With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   sel(N, XS) -> head(afterNth(N, XS))
   take(N, XS) -> fst(splitAt(N, XS))
   afterNth(N, XS) -> snd(splitAt(N, XS))




----------------------------------------

(4)
Obligation:
Q restricted rewrite system:
R is empty.
Q is empty.

----------------------------------------

(5) RisEmptyProof (EQUIVALENT)
The TRS R is empty. Hence, termination is trivially proven.
----------------------------------------

(6)
YES
