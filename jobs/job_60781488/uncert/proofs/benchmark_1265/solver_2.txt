YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/CLxYw.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) QTRSRRRProof [EQUIVALENT, 123 ms]
(2) QTRS
(3) QTRSRRRProof [EQUIVALENT, 0 ms]
(4) QTRS
(5) RisEmptyProof [EQUIVALENT, 0 ms]
(6) YES


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   U11(tt, V1, V2) -> U12(isNat(activate(V1)), activate(V2))
   U12(tt, V2) -> U13(isNat(activate(V2)))
   U13(tt) -> tt
   U21(tt, V1) -> U22(isNat(activate(V1)))
   U22(tt) -> tt
   U31(tt, V1, V2) -> U32(isNat(activate(V1)), activate(V2))
   U32(tt, V2) -> U33(isNat(activate(V2)))
   U33(tt) -> tt
   U41(tt, N) -> activate(N)
   U51(tt, M, N) -> s(plus(activate(N), activate(M)))
   U61(tt) -> 0
   U71(tt, M, N) -> plus(x(activate(N), activate(M)), activate(N))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__plus(V1, V2)) -> U11(and(isNatKind(activate(V1)), n__isNatKind(activate(V2))), activate(V1), activate(V2))
   isNat(n__s(V1)) -> U21(isNatKind(activate(V1)), activate(V1))
   isNat(n__x(V1, V2)) -> U31(and(isNatKind(activate(V1)), n__isNatKind(activate(V2))), activate(V1), activate(V2))
   isNatKind(n__0) -> tt
   isNatKind(n__plus(V1, V2)) -> and(isNatKind(activate(V1)), n__isNatKind(activate(V2)))
   isNatKind(n__s(V1)) -> isNatKind(activate(V1))
   isNatKind(n__x(V1, V2)) -> and(isNatKind(activate(V1)), n__isNatKind(activate(V2)))
   plus(N, 0) -> U41(and(isNat(N), n__isNatKind(N)), N)
   plus(N, s(M)) -> U51(and(and(isNat(M), n__isNatKind(M)), n__and(isNat(N), n__isNatKind(N))), M, N)
   x(N, 0) -> U61(and(isNat(N), n__isNatKind(N)))
   x(N, s(M)) -> U71(and(and(isNat(M), n__isNatKind(M)), n__and(isNat(N), n__isNatKind(N))), M, N)
   0 -> n__0
   plus(X1, X2) -> n__plus(X1, X2)
   isNatKind(X) -> n__isNatKind(X)
   s(X) -> n__s(X)
   x(X1, X2) -> n__x(X1, X2)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__0) -> 0
   activate(n__plus(X1, X2)) -> plus(X1, X2)
   activate(n__isNatKind(X)) -> isNatKind(X)
   activate(n__s(X)) -> s(X)
   activate(n__x(X1, X2)) -> x(X1, X2)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.

----------------------------------------

(1) QTRSRRRProof (EQUIVALENT)
Used ordering:
U11/3(YES,YES,YES)
tt/0)
U12/2(YES,YES)
isNat/1)YES(
activate/1)YES(
U13/1)YES(
U21/2(YES,YES)
U22/1(YES)
U31/3(YES,YES,YES)
U32/2(YES,YES)
U33/1)YES(
U41/2(YES,YES)
U51/3(YES,YES,YES)
s/1(YES)
plus/2(YES,YES)
U61/1(YES)
0/0)
U71/3(YES,YES,YES)
x/2(YES,YES)
and/2(YES,YES)
n__0/0)
n__plus/2(YES,YES)
isNatKind/1)YES(
n__isNatKind/1)YES(
n__s/1(YES)
n__x/2(YES,YES)
n__and/2(YES,YES)

Quasi precedence:
[U71_3, x_2, n__x_2] > U31_3 > U32_2 > U22_1
[U71_3, x_2, n__x_2] > [U51_3, plus_2, n__plus_2] > U11_3 > U12_2 > U22_1
[U71_3, x_2, n__x_2] > [U51_3, plus_2, n__plus_2] > U41_2 > U22_1
[U71_3, x_2, n__x_2] > [U51_3, plus_2, n__plus_2] > [s_1, and_2, n__s_1, n__and_2] > U21_2 > U22_1
[U71_3, x_2, n__x_2] > U61_1 > [0, n__0] > tt > U22_1
[U71_3, x_2, n__x_2] > U61_1 > [0, n__0] > U41_2 > U22_1


Status:
U11_3: multiset status
tt: multiset status
U12_2: [1,2]
U21_2: multiset status
U22_1: [1]
U31_3: multiset status
U32_2: [1,2]
U41_2: multiset status
U51_3: [3,2,1]
s_1: multiset status
plus_2: [1,2]
U61_1: [1]
0: multiset status
U71_3: [2,3,1]
x_2: [2,1]
and_2: multiset status
n__0: multiset status
n__plus_2: [1,2]
n__s_1: multiset status
n__x_2: [2,1]
n__and_2: multiset status

With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   U11(tt, V1, V2) -> U12(isNat(activate(V1)), activate(V2))
   U12(tt, V2) -> U13(isNat(activate(V2)))
   U21(tt, V1) -> U22(isNat(activate(V1)))
   U22(tt) -> tt
   U31(tt, V1, V2) -> U32(isNat(activate(V1)), activate(V2))
   U32(tt, V2) -> U33(isNat(activate(V2)))
   U41(tt, N) -> activate(N)
   U51(tt, M, N) -> s(plus(activate(N), activate(M)))
   U61(tt) -> 0
   U71(tt, M, N) -> plus(x(activate(N), activate(M)), activate(N))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__plus(V1, V2)) -> U11(and(isNatKind(activate(V1)), n__isNatKind(activate(V2))), activate(V1), activate(V2))
   isNat(n__s(V1)) -> U21(isNatKind(activate(V1)), activate(V1))
   isNat(n__x(V1, V2)) -> U31(and(isNatKind(activate(V1)), n__isNatKind(activate(V2))), activate(V1), activate(V2))
   isNatKind(n__0) -> tt
   isNatKind(n__plus(V1, V2)) -> and(isNatKind(activate(V1)), n__isNatKind(activate(V2)))
   isNatKind(n__s(V1)) -> isNatKind(activate(V1))
   isNatKind(n__x(V1, V2)) -> and(isNatKind(activate(V1)), n__isNatKind(activate(V2)))
   plus(N, 0) -> U41(and(isNat(N), n__isNatKind(N)), N)
   plus(N, s(M)) -> U51(and(and(isNat(M), n__isNatKind(M)), n__and(isNat(N), n__isNatKind(N))), M, N)
   x(N, 0) -> U61(and(isNat(N), n__isNatKind(N)))
   x(N, s(M)) -> U71(and(and(isNat(M), n__isNatKind(M)), n__and(isNat(N), n__isNatKind(N))), M, N)




----------------------------------------

(2)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   U13(tt) -> tt
   U33(tt) -> tt
   0 -> n__0
   plus(X1, X2) -> n__plus(X1, X2)
   isNatKind(X) -> n__isNatKind(X)
   s(X) -> n__s(X)
   x(X1, X2) -> n__x(X1, X2)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__0) -> 0
   activate(n__plus(X1, X2)) -> plus(X1, X2)
   activate(n__isNatKind(X)) -> isNatKind(X)
   activate(n__s(X)) -> s(X)
   activate(n__x(X1, X2)) -> x(X1, X2)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.

----------------------------------------

(3) QTRSRRRProof (EQUIVALENT)
Used ordering:
Knuth-Bendix order [KBO] with precedence:U13_1 > and_2 > n__and_2 > x_2 > n__isNatKind_1 > n__plus_2 > n__0 > U33_1 > activate_1 > n__x_2 > n__s_1 > s_1 > isNatKind_1 > 0 > tt > plus_2

and weight map:

   tt=1
   0=3
   n__0=1
   U13_1=0
   U33_1=1
   isNatKind_1=3
   n__isNatKind_1=1
   s_1=3
   n__s_1=1
   activate_1=2
   plus_2=2
   n__plus_2=0
   x_2=1
   n__x_2=0
   and_2=0
   n__and_2=0

The variable weight is 1With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   U13(tt) -> tt
   U33(tt) -> tt
   0 -> n__0
   plus(X1, X2) -> n__plus(X1, X2)
   isNatKind(X) -> n__isNatKind(X)
   s(X) -> n__s(X)
   x(X1, X2) -> n__x(X1, X2)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__0) -> 0
   activate(n__plus(X1, X2)) -> plus(X1, X2)
   activate(n__isNatKind(X)) -> isNatKind(X)
   activate(n__s(X)) -> s(X)
   activate(n__x(X1, X2)) -> x(X1, X2)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X




----------------------------------------

(4)
Obligation:
Q restricted rewrite system:
R is empty.
Q is empty.

----------------------------------------

(5) RisEmptyProof (EQUIVALENT)
The TRS R is empty. Hence, termination is trivially proven.
----------------------------------------

(6)
YES
