YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/eUfxr.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) Overlay + Local Confluence [EQUIVALENT, 0 ms]
(2) QTRS
(3) DependencyPairsProof [EQUIVALENT, 7 ms]
(4) QDP
(5) DependencyGraphProof [EQUIVALENT, 0 ms]
(6) QDP
(7) QDPQMonotonicMRRProof [EQUIVALENT, 18 ms]
(8) QDP
(9) DependencyGraphProof [EQUIVALENT, 0 ms]
(10) QDP
(11) QDPOrderProof [EQUIVALENT, 16 ms]
(12) QDP
(13) PisEmptyProof [EQUIVALENT, 0 ms]
(14) YES


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   din(der(plus(X, Y))) -> u21(din(der(X)), X, Y)
   u21(dout(DX), X, Y) -> u22(din(der(Y)), X, Y, DX)
   u22(dout(DY), X, Y, DX) -> dout(plus(DX, DY))
   din(der(times(X, Y))) -> u31(din(der(X)), X, Y)
   u31(dout(DX), X, Y) -> u32(din(der(Y)), X, Y, DX)
   u32(dout(DY), X, Y, DX) -> dout(plus(times(X, DY), times(Y, DX)))
   din(der(der(X))) -> u41(din(der(X)), X)
   u41(dout(DX), X) -> u42(din(der(DX)), X, DX)
   u42(dout(DDX), X, DX) -> dout(DDX)

Q is empty.

----------------------------------------

(1) Overlay + Local Confluence (EQUIVALENT)
The TRS is overlay and locally confluent. By [NOC] we can switch to innermost.
----------------------------------------

(2)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   din(der(plus(X, Y))) -> u21(din(der(X)), X, Y)
   u21(dout(DX), X, Y) -> u22(din(der(Y)), X, Y, DX)
   u22(dout(DY), X, Y, DX) -> dout(plus(DX, DY))
   din(der(times(X, Y))) -> u31(din(der(X)), X, Y)
   u31(dout(DX), X, Y) -> u32(din(der(Y)), X, Y, DX)
   u32(dout(DY), X, Y, DX) -> dout(plus(times(X, DY), times(Y, DX)))
   din(der(der(X))) -> u41(din(der(X)), X)
   u41(dout(DX), X) -> u42(din(der(DX)), X, DX)
   u42(dout(DDX), X, DX) -> dout(DDX)

The set Q consists of the following terms:

   din(der(plus(x0, x1)))
   u21(dout(x0), x1, x2)
   u22(dout(x0), x1, x2, x3)
   din(der(times(x0, x1)))
   u31(dout(x0), x1, x2)
   u32(dout(x0), x1, x2, x3)
   din(der(der(x0)))
   u41(dout(x0), x1)
   u42(dout(x0), x1, x2)


----------------------------------------

(3) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(4)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   DIN(der(plus(X, Y))) -> U21(din(der(X)), X, Y)
   DIN(der(plus(X, Y))) -> DIN(der(X))
   U21(dout(DX), X, Y) -> U22(din(der(Y)), X, Y, DX)
   U21(dout(DX), X, Y) -> DIN(der(Y))
   DIN(der(times(X, Y))) -> U31(din(der(X)), X, Y)
   DIN(der(times(X, Y))) -> DIN(der(X))
   U31(dout(DX), X, Y) -> U32(din(der(Y)), X, Y, DX)
   U31(dout(DX), X, Y) -> DIN(der(Y))
   DIN(der(der(X))) -> U41(din(der(X)), X)
   DIN(der(der(X))) -> DIN(der(X))
   U41(dout(DX), X) -> U42(din(der(DX)), X, DX)
   U41(dout(DX), X) -> DIN(der(DX))

The TRS R consists of the following rules:

   din(der(plus(X, Y))) -> u21(din(der(X)), X, Y)
   u21(dout(DX), X, Y) -> u22(din(der(Y)), X, Y, DX)
   u22(dout(DY), X, Y, DX) -> dout(plus(DX, DY))
   din(der(times(X, Y))) -> u31(din(der(X)), X, Y)
   u31(dout(DX), X, Y) -> u32(din(der(Y)), X, Y, DX)
   u32(dout(DY), X, Y, DX) -> dout(plus(times(X, DY), times(Y, DX)))
   din(der(der(X))) -> u41(din(der(X)), X)
   u41(dout(DX), X) -> u42(din(der(DX)), X, DX)
   u42(dout(DDX), X, DX) -> dout(DDX)

The set Q consists of the following terms:

   din(der(plus(x0, x1)))
   u21(dout(x0), x1, x2)
   u22(dout(x0), x1, x2, x3)
   din(der(times(x0, x1)))
   u31(dout(x0), x1, x2)
   u32(dout(x0), x1, x2, x3)
   din(der(der(x0)))
   u41(dout(x0), x1)
   u42(dout(x0), x1, x2)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(5) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 3 less nodes.
----------------------------------------

(6)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U21(dout(DX), X, Y) -> DIN(der(Y))
   DIN(der(plus(X, Y))) -> U21(din(der(X)), X, Y)
   DIN(der(plus(X, Y))) -> DIN(der(X))
   DIN(der(times(X, Y))) -> U31(din(der(X)), X, Y)
   U31(dout(DX), X, Y) -> DIN(der(Y))
   DIN(der(times(X, Y))) -> DIN(der(X))
   DIN(der(der(X))) -> U41(din(der(X)), X)
   U41(dout(DX), X) -> DIN(der(DX))
   DIN(der(der(X))) -> DIN(der(X))

The TRS R consists of the following rules:

   din(der(plus(X, Y))) -> u21(din(der(X)), X, Y)
   u21(dout(DX), X, Y) -> u22(din(der(Y)), X, Y, DX)
   u22(dout(DY), X, Y, DX) -> dout(plus(DX, DY))
   din(der(times(X, Y))) -> u31(din(der(X)), X, Y)
   u31(dout(DX), X, Y) -> u32(din(der(Y)), X, Y, DX)
   u32(dout(DY), X, Y, DX) -> dout(plus(times(X, DY), times(Y, DX)))
   din(der(der(X))) -> u41(din(der(X)), X)
   u41(dout(DX), X) -> u42(din(der(DX)), X, DX)
   u42(dout(DDX), X, DX) -> dout(DDX)

The set Q consists of the following terms:

   din(der(plus(x0, x1)))
   u21(dout(x0), x1, x2)
   u22(dout(x0), x1, x2, x3)
   din(der(times(x0, x1)))
   u31(dout(x0), x1, x2)
   u32(dout(x0), x1, x2, x3)
   din(der(der(x0)))
   u41(dout(x0), x1)
   u42(dout(x0), x1, x2)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(7) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   U21(dout(DX), X, Y) -> DIN(der(Y))
   U41(dout(DX), X) -> DIN(der(DX))


Used ordering: Polynomial interpretation [POLO]:

   POL(DIN(x_1)) = 0
   POL(U21(x_1, x_2, x_3)) = 2*x_1
   POL(U31(x_1, x_2, x_3)) = 0
   POL(U41(x_1, x_2)) = 2*x_1
   POL(der(x_1)) = 0
   POL(din(x_1)) = 0
   POL(dout(x_1)) = 1
   POL(plus(x_1, x_2)) = 0
   POL(times(x_1, x_2)) = 0
   POL(u21(x_1, x_2, x_3)) = 0
   POL(u22(x_1, x_2, x_3, x_4)) = 2*x_1
   POL(u31(x_1, x_2, x_3)) = 0
   POL(u32(x_1, x_2, x_3, x_4)) = 2*x_1
   POL(u41(x_1, x_2)) = x_1
   POL(u42(x_1, x_2, x_3)) = 2*x_1


----------------------------------------

(8)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   DIN(der(plus(X, Y))) -> U21(din(der(X)), X, Y)
   DIN(der(plus(X, Y))) -> DIN(der(X))
   DIN(der(times(X, Y))) -> U31(din(der(X)), X, Y)
   U31(dout(DX), X, Y) -> DIN(der(Y))
   DIN(der(times(X, Y))) -> DIN(der(X))
   DIN(der(der(X))) -> U41(din(der(X)), X)
   DIN(der(der(X))) -> DIN(der(X))

The TRS R consists of the following rules:

   din(der(plus(X, Y))) -> u21(din(der(X)), X, Y)
   u21(dout(DX), X, Y) -> u22(din(der(Y)), X, Y, DX)
   u22(dout(DY), X, Y, DX) -> dout(plus(DX, DY))
   din(der(times(X, Y))) -> u31(din(der(X)), X, Y)
   u31(dout(DX), X, Y) -> u32(din(der(Y)), X, Y, DX)
   u32(dout(DY), X, Y, DX) -> dout(plus(times(X, DY), times(Y, DX)))
   din(der(der(X))) -> u41(din(der(X)), X)
   u41(dout(DX), X) -> u42(din(der(DX)), X, DX)
   u42(dout(DDX), X, DX) -> dout(DDX)

The set Q consists of the following terms:

   din(der(plus(x0, x1)))
   u21(dout(x0), x1, x2)
   u22(dout(x0), x1, x2, x3)
   din(der(times(x0, x1)))
   u31(dout(x0), x1, x2)
   u32(dout(x0), x1, x2, x3)
   din(der(der(x0)))
   u41(dout(x0), x1)
   u42(dout(x0), x1, x2)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(9) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 2 less nodes.
----------------------------------------

(10)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   DIN(der(times(X, Y))) -> U31(din(der(X)), X, Y)
   U31(dout(DX), X, Y) -> DIN(der(Y))
   DIN(der(plus(X, Y))) -> DIN(der(X))
   DIN(der(times(X, Y))) -> DIN(der(X))
   DIN(der(der(X))) -> DIN(der(X))

The TRS R consists of the following rules:

   din(der(plus(X, Y))) -> u21(din(der(X)), X, Y)
   u21(dout(DX), X, Y) -> u22(din(der(Y)), X, Y, DX)
   u22(dout(DY), X, Y, DX) -> dout(plus(DX, DY))
   din(der(times(X, Y))) -> u31(din(der(X)), X, Y)
   u31(dout(DX), X, Y) -> u32(din(der(Y)), X, Y, DX)
   u32(dout(DY), X, Y, DX) -> dout(plus(times(X, DY), times(Y, DX)))
   din(der(der(X))) -> u41(din(der(X)), X)
   u41(dout(DX), X) -> u42(din(der(DX)), X, DX)
   u42(dout(DDX), X, DX) -> dout(DDX)

The set Q consists of the following terms:

   din(der(plus(x0, x1)))
   u21(dout(x0), x1, x2)
   u22(dout(x0), x1, x2, x3)
   din(der(times(x0, x1)))
   u31(dout(x0), x1, x2)
   u32(dout(x0), x1, x2, x3)
   din(der(der(x0)))
   u41(dout(x0), x1)
   u42(dout(x0), x1, x2)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(11) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   DIN(der(times(X, Y))) -> U31(din(der(X)), X, Y)
   U31(dout(DX), X, Y) -> DIN(der(Y))
   DIN(der(plus(X, Y))) -> DIN(der(X))
   DIN(der(times(X, Y))) -> DIN(der(X))
   DIN(der(der(X))) -> DIN(der(X))
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( U31_3(x_1, ..., x_3) ) = 2x_2 + x_3 + 2
POL( din_1(x_1) ) = max{0, -2}
POL( der_1(x_1) ) = x_1 + 1
POL( plus_2(x_1, x_2) ) = 2x_1 + 1
POL( u21_3(x_1, ..., x_3) ) = max{0, 2x_2 + 2x_3 - 2}
POL( times_2(x_1, x_2) ) = 2x_1 + 2x_2 + 2
POL( u31_3(x_1, ..., x_3) ) = max{0, x_3 - 2}
POL( u41_2(x_1, x_2) ) = max{0, 2x_2 - 2}
POL( dout_1(x_1) ) = max{0, -2}
POL( u42_3(x_1, ..., x_3) ) = max{0, x_1 + x_2 - 2}
POL( u22_4(x_1, ..., x_4) ) = x_4 + 2
POL( u32_4(x_1, ..., x_4) ) = max{0, 2x_4 - 2}
POL( DIN_1(x_1) ) = x_1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:
none


----------------------------------------

(12)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   din(der(plus(X, Y))) -> u21(din(der(X)), X, Y)
   u21(dout(DX), X, Y) -> u22(din(der(Y)), X, Y, DX)
   u22(dout(DY), X, Y, DX) -> dout(plus(DX, DY))
   din(der(times(X, Y))) -> u31(din(der(X)), X, Y)
   u31(dout(DX), X, Y) -> u32(din(der(Y)), X, Y, DX)
   u32(dout(DY), X, Y, DX) -> dout(plus(times(X, DY), times(Y, DX)))
   din(der(der(X))) -> u41(din(der(X)), X)
   u41(dout(DX), X) -> u42(din(der(DX)), X, DX)
   u42(dout(DDX), X, DX) -> dout(DDX)

The set Q consists of the following terms:

   din(der(plus(x0, x1)))
   u21(dout(x0), x1, x2)
   u22(dout(x0), x1, x2, x3)
   din(der(times(x0, x1)))
   u31(dout(x0), x1, x2)
   u32(dout(x0), x1, x2, x3)
   din(der(der(x0)))
   u41(dout(x0), x1)
   u42(dout(x0), x1, x2)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(13) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(14)
YES
