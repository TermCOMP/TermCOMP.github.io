YES

Problem 1: 

(VAR vu95NonEmpty B B1 B2 CS1 CS2 Client Client1 Client2 E E1 E2 E3 F0 F1 F2 Field Fields H1 H2 Head List Lock Locks MCRLFree0 MCRLFree1 N1 N2 Name NewF Pending Pendings Pid Record Resource Resources S1 S2 T1 T2 Tail)
(RULES
and(F,B) -> F
and(T,B) -> B
and(B,F) -> F
and(B,T) -> B
append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
case0(Client,Lock,MCRLFree0) -> Lock
case1(Client,Resources,Lock,ffalse) -> Lock
case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
case4(Client,Lock,MCRLFree1) -> ffalse
case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
case8(Tail,Head,E,ftrue) -> Tail
case9(Tail,Head,E,ffalse) -> member(E,Tail)
case9(Tail,Head,E,ftrue) -> ftrue
delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
delete(E,nil) -> nil
element(int(s(num0)),tuple(T1,T2)) -> T1
element(int(s(num0)),tuplenil(T1)) -> T1
element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
eq(F,F) -> T
eq(F,T) -> F
eq(T,F) -> F
eq(T,T) -> T
eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
eqc(calls(E1,S1,CS1),nocalls) -> F
eqc(nocalls,calls(E2,S2,CS2)) -> F
eqc(nocalls,nocalls) -> T
eqs(empty,empty) -> T
eqs(empty,stack(E2,S2)) -> F
eqs(stack(E1,S1),empty) -> F
eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
eqt(a,a) -> T
eqt(a,cons(H2,T2)) -> F
eqt(a,excl) -> F
eqt(a,ffalse) -> F
eqt(a,int(N2)) -> F
eqt(a,lock) -> F
eqt(a,locker) -> F
eqt(a,mcrlrecord) -> F
eqt(a,nil) -> F
eqt(a,ok) -> F
eqt(a,pending) -> F
eqt(a,pid(N2)) -> F
eqt(a,release) -> F
eqt(a,request) -> F
eqt(a,resource) -> F
eqt(a,tag) -> F
eqt(a,ftrue) -> F
eqt(a,tuple(H2,T2)) -> F
eqt(a,tuplenil(H2)) -> F
eqt(a,undefined) -> F
eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
eqt(cons(H1,T1),int(N2)) -> F
eqt(cons(H1,T1),pid(N2)) -> F
eqt(cons(H1,T1),resource) -> F
eqt(cons(H1,T1),tag) -> F
eqt(cons(H1,T1),ftrue) -> F
eqt(cons(H1,T1),tuple(H2,T2)) -> F
eqt(cons(H1,T1),tuplenil(H2)) -> F
eqt(cons(H1,T1),undefined) -> F
eqt(excl,eqt(ffalse,int(N2))) -> F
eqt(excl,a) -> F
eqt(excl,excl) -> T
eqt(excl,ffalse) -> F
eqt(excl,lock) -> F
eqt(excl,locker) -> F
eqt(excl,mcrlrecord) -> F
eqt(excl,nil) -> F
eqt(excl,ok) -> F
eqt(excl,pending) -> F
eqt(excl,pid(N2)) -> F
eqt(excl,release) -> F
eqt(excl,request) -> F
eqt(excl,resource) -> F
eqt(excl,tag) -> F
eqt(excl,ftrue) -> F
eqt(excl,undefined) -> F
eqt(ffalse,cons(H2,T2)) -> F
eqt(ffalse,tuple(H2,T2)) -> F
eqt(ffalse,tuplenil(H2)) -> F
eqt(int(N1),a) -> F
eqt(int(N1),excl) -> F
eqt(int(N1),ffalse) -> F
eqt(int(N1),lock) -> F
eqt(int(N1),locker) -> F
eqt(int(N1),mcrlrecord) -> F
eqt(int(N1),nil) -> F
eqt(int(N1),ok) -> F
eqt(int(N1),pending) -> F
eqt(int(N1),release) -> F
eqt(int(N1),request) -> F
eqt(int(N1),resource) -> F
eqt(int(N1),tag) -> F
eqt(int(N1),ftrue) -> F
eqt(int(N1),undefined) -> F
eqt(lock,a) -> F
eqt(lock,cons(H2,T2)) -> F
eqt(lock,excl) -> F
eqt(lock,ffalse) -> F
eqt(lock,int(N2)) -> F
eqt(lock,lock) -> T
eqt(lock,locker) -> F
eqt(lock,mcrlrecord) -> F
eqt(lock,nil) -> F
eqt(lock,ok) -> F
eqt(lock,pending) -> F
eqt(lock,pid(N2)) -> F
eqt(lock,release) -> F
eqt(lock,request) -> F
eqt(lock,resource) -> F
eqt(lock,tag) -> F
eqt(lock,ftrue) -> F
eqt(lock,tuple(H2,T2)) -> F
eqt(lock,tuplenil(H2)) -> F
eqt(lock,undefined) -> F
eqt(locker,a) -> F
eqt(locker,cons(H2,T2)) -> F
eqt(locker,excl) -> F
eqt(locker,ffalse) -> F
eqt(locker,int(N2)) -> F
eqt(locker,lock) -> F
eqt(locker,locker) -> T
eqt(locker,mcrlrecord) -> F
eqt(locker,nil) -> F
eqt(locker,ok) -> F
eqt(locker,pending) -> F
eqt(locker,pid(N2)) -> F
eqt(locker,release) -> F
eqt(locker,request) -> F
eqt(locker,resource) -> F
eqt(locker,tag) -> F
eqt(locker,ftrue) -> F
eqt(locker,tuple(H2,T2)) -> F
eqt(locker,tuplenil(H2)) -> F
eqt(locker,undefined) -> F
eqt(mcrlrecord,a) -> F
eqt(mcrlrecord,excl) -> F
eqt(mcrlrecord,ffalse) -> F
eqt(mcrlrecord,lock) -> F
eqt(mcrlrecord,locker) -> F
eqt(mcrlrecord,mcrlrecord) -> T
eqt(mcrlrecord,nil) -> F
eqt(mcrlrecord,ok) -> F
eqt(mcrlrecord,pending) -> F
eqt(mcrlrecord,release) -> F
eqt(mcrlrecord,request) -> F
eqt(mcrlrecord,resource) -> F
eqt(nil,cons(H2,T2)) -> F
eqt(nil,int(N2)) -> F
eqt(nil,pid(N2)) -> F
eqt(nil,tuple(H2,T2)) -> F
eqt(nil,tuplenil(H2)) -> F
eqt(nil,undefined) -> F
eqt(ok,cons(H2,T2)) -> F
eqt(ok,int(N2)) -> F
eqt(ok,pid(N2)) -> F
eqt(ok,resource) -> F
eqt(ok,tag) -> F
eqt(ok,ftrue) -> F
eqt(ok,tuple(H2,T2)) -> F
eqt(ok,tuplenil(H2)) -> F
eqt(ok,undefined) -> F
eqt(pending,a) -> F
eqt(pending,cons(H2,T2)) -> F
eqt(pending,excl) -> F
eqt(pending,ffalse) -> F
eqt(pending,int(N2)) -> F
eqt(pending,lock) -> F
eqt(pending,locker) -> F
eqt(pending,mcrlrecord) -> F
eqt(pending,nil) -> F
eqt(pending,ok) -> F
eqt(pending,pending) -> T
eqt(pending,pid(N2)) -> F
eqt(pending,release) -> F
eqt(pending,request) -> F
eqt(pending,resource) -> F
eqt(pending,tag) -> F
eqt(pending,ftrue) -> F
eqt(pending,tuple(H2,T2)) -> F
eqt(pending,tuplenil(H2)) -> F
eqt(pending,undefined) -> F
eqt(pid(N1),a) -> F
eqt(pid(N1),cons(H2,T2)) -> F
eqt(pid(N1),excl) -> F
eqt(pid(N1),ffalse) -> F
eqt(pid(N1),int(N2)) -> F
eqt(pid(N1),lock) -> F
eqt(pid(N1),locker) -> F
eqt(pid(N1),mcrlrecord) -> F
eqt(pid(N1),nil) -> F
eqt(pid(N1),ok) -> F
eqt(pid(N1),pending) -> F
eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
eqt(pid(N1),release) -> F
eqt(pid(N1),request) -> F
eqt(pid(N1),resource) -> F
eqt(pid(N1),tag) -> F
eqt(pid(N1),ftrue) -> F
eqt(pid(N1),tuple(H2,T2)) -> F
eqt(pid(N1),tuplenil(H2)) -> F
eqt(pid(N1),undefined) -> F
eqt(release,a) -> F
eqt(release,excl) -> F
eqt(release,ffalse) -> F
eqt(release,lock) -> F
eqt(release,locker) -> F
eqt(release,mcrlrecord) -> F
eqt(release,nil) -> F
eqt(release,ok) -> F
eqt(request,cons(H2,T2)) -> F
eqt(request,int(N2)) -> F
eqt(request,mcrlrecord) -> F
eqt(request,ok) -> F
eqt(request,pending) -> F
eqt(request,pid(N2)) -> F
eqt(request,release) -> F
eqt(request,request) -> T
eqt(request,resource) -> F
eqt(request,tag) -> F
eqt(request,ftrue) -> F
eqt(request,tuple(H2,T2)) -> F
eqt(request,tuplenil(H2)) -> F
eqt(request,undefined) -> F
eqt(resource,a) -> F
eqt(resource,cons(H2,T2)) -> F
eqt(resource,excl) -> F
eqt(resource,ffalse) -> F
eqt(resource,int(N2)) -> F
eqt(resource,lock) -> F
eqt(resource,locker) -> F
eqt(resource,mcrlrecord) -> F
eqt(resource,nil) -> F
eqt(resource,ok) -> F
eqt(resource,pending) -> F
eqt(resource,pid(N2)) -> F
eqt(resource,release) -> F
eqt(resource,request) -> F
eqt(resource,resource) -> T
eqt(resource,tag) -> F
eqt(resource,ftrue) -> F
eqt(resource,tuple(H2,T2)) -> F
eqt(resource,tuplenil(H2)) -> F
eqt(resource,undefined) -> F
eqt(tag,a) -> F
eqt(tag,cons(H2,T2)) -> F
eqt(tag,excl) -> F
eqt(tag,ffalse) -> F
eqt(tag,int(N2)) -> F
eqt(tag,lock) -> F
eqt(tag,locker) -> F
eqt(tag,mcrlrecord) -> F
eqt(tag,nil) -> F
eqt(tag,ok) -> F
eqt(tag,pending) -> F
eqt(tag,pid(N2)) -> F
eqt(tag,release) -> F
eqt(tag,request) -> F
eqt(tag,resource) -> F
eqt(tag,tag) -> T
eqt(tag,ftrue) -> F
eqt(tag,tuple(H2,T2)) -> F
eqt(tag,tuplenil(H2)) -> F
eqt(tag,undefined) -> F
eqt(ftrue,a) -> F
eqt(ftrue,cons(H2,T2)) -> F
eqt(ftrue,excl) -> F
eqt(ftrue,ffalse) -> F
eqt(ftrue,int(N2)) -> F
eqt(ftrue,lock) -> F
eqt(ftrue,locker) -> F
eqt(ftrue,mcrlrecord) -> F
eqt(ftrue,nil) -> F
eqt(ftrue,ok) -> F
eqt(ftrue,pending) -> F
eqt(ftrue,pid(N2)) -> F
eqt(ftrue,release) -> F
eqt(ftrue,request) -> F
eqt(ftrue,resource) -> F
eqt(ftrue,tag) -> F
eqt(ftrue,ftrue) -> T
eqt(ftrue,tuple(H2,T2)) -> F
eqt(ftrue,tuplenil(H2)) -> F
eqt(ftrue,undefined) -> F
eqt(tuple(H1,T1),a) -> F
eqt(tuple(H1,T1),cons(H2,T2)) -> F
eqt(tuple(H1,T1),excl) -> F
eqt(tuple(H1,T1),ffalse) -> F
eqt(tuple(H1,T1),int(N2)) -> F
eqt(tuple(H1,T1),lock) -> F
eqt(tuple(H1,T1),locker) -> F
eqt(tuple(H1,T1),mcrlrecord) -> F
eqt(tuple(H1,T1),nil) -> F
eqt(tuple(H1,T1),ok) -> F
eqt(tuple(H1,T1),pending) -> F
eqt(tuple(H1,T1),pid(N2)) -> F
eqt(tuple(H1,T1),release) -> F
eqt(tuple(H1,T1),request) -> F
eqt(tuple(H1,T1),resource) -> F
eqt(tuple(H1,T1),tag) -> F
eqt(tuple(H1,T1),ftrue) -> F
eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
eqt(tuple(H1,T1),tuplenil(H2)) -> F
eqt(tuple(H1,T1),undefined) -> F
eqt(tuplenil(H1),a) -> F
eqt(tuplenil(H1),cons(H2,T2)) -> F
eqt(tuplenil(H1),excl) -> F
eqt(tuplenil(H1),ffalse) -> F
eqt(tuplenil(H1),int(N2)) -> F
eqt(tuplenil(H1),lock) -> F
eqt(tuplenil(H1),locker) -> F
eqt(tuplenil(H1),mcrlrecord) -> F
eqt(tuplenil(H1),nil) -> F
eqt(tuplenil(H1),ok) -> F
eqt(tuplenil(H1),pending) -> F
eqt(tuplenil(H1),pid(N2)) -> F
eqt(tuplenil(H1),release) -> F
eqt(tuplenil(H1),request) -> F
eqt(tuplenil(H1),resource) -> F
eqt(tuplenil(H1),tag) -> F
eqt(tuplenil(H1),ftrue) -> F
eqt(tuplenil(H1),tuple(H2,T2)) -> F
eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
eqt(tuplenil(H1),undefined) -> F
eqt(undefined,a) -> F
eqt(undefined,nil) -> F
eqt(undefined,tuplenil(H2)) -> F
genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
if(F,B1,B2) -> B2
if(T,B1,B2) -> B1
imp(F,B) -> T
imp(T,B) -> B
istops(E1,empty) -> F
istops(E1,stack(E2,S1)) -> eqt(E1,E2)
locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
locker2u95adduniq(nil,List) -> List
locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
locker2u95checku95available(Resource,nil) -> ffalse
locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
locker2u95checku95availables(nil,Locks) -> ftrue
locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
locker2u95mapu95promoteu95pending(nil,Pending) -> nil
locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
locker2u95obtainables(nil,Client) -> ftrue
locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
member(E,nil) -> ffalse
not(F) -> T
not(T) -> F
or(F,F) -> F
or(F,T) -> T
or(T,F) -> T
or(T,T) -> T
pops(stack(E1,S1)) -> S1
push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
pushs(E1,S1) -> stack(E1,S1)
recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
recordu95updates(Record,Name,nil) -> Record
subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
subtract(List,nil) -> List
tops(stack(E1,S1)) -> E1
)


Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 APPEND(cons(Head,Tail),List) -> APPEND(Tail,List)
 CASE0(Client,Lock,cons(Client,Pendings)) -> RECORDU95UPDATES(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 CASE1(Client,Resources,Lock,ftrue) -> RECORDU95UPDATES(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 CASE5(Client,Locks,Lock,ffalse) -> LOCKER2U95OBTAINABLES(Locks,Client)
 CASE5(Client,Locks,Lock,ftrue) -> LOCKER2U95OBTAINABLES(Locks,Client)
 CASE6(Locks,Lock,Resource,ffalse) -> LOCKER2U95CHECKU95AVAILABLE(Resource,Locks)
 CASE8(Tail,Head,E,ffalse) -> DELETE(E,Tail)
 CASE9(Tail,Head,E,ffalse) -> MEMBER(E,Tail)
 ELEMENT(int(s(s(N1))),tuple(T1,T2)) -> ELEMENT(int(s(N1)),T2)
 EQC(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> AND(eqs(S1,S2),eqc(CS1,CS2))
 EQC(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> AND(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 EQC(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> EQC(CS1,CS2)
 EQC(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> EQS(S1,S2)
 EQC(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> EQT(E1,E2)
 EQS(stack(E1,S1),stack(E2,S2)) -> AND(eqt(E1,E2),eqs(S1,S2))
 EQS(stack(E1,S1),stack(E2,S2)) -> EQS(S1,S2)
 EQS(stack(E1,S1),stack(E2,S2)) -> EQT(E1,E2)
 EQT(cons(H1,T1),cons(H2,T2)) -> AND(eqt(H1,H2),eqt(T1,T2))
 EQT(cons(H1,T1),cons(H2,T2)) -> EQT(H1,H2)
 EQT(cons(H1,T1),cons(H2,T2)) -> EQT(T1,T2)
 EQT(pid(N1),pid(N2)) -> EQT(N1,N2)
 EQT(tuple(H1,T1),tuple(H2,T2)) -> AND(eqt(H1,H2),eqt(T1,T2))
 EQT(tuple(H1,T1),tuple(H2,T2)) -> EQT(H1,H2)
 EQT(tuple(H1,T1),tuple(H2,T2)) -> EQT(T1,T2)
 EQT(tuplenil(H1),tuplenil(H2)) -> EQT(H1,H2)
 ISTOPS(E1,stack(E2,S1)) -> EQT(E1,E2)
 LOCKER2U95ADDU95PENDING(Lock,Resources,Client) -> CASE1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 LOCKER2U95ADDU95PENDING(Lock,Resources,Client) -> MEMBER(recordu95extract(Lock,lock,resource),Resources)
 LOCKER2U95ADDU95PENDING(Lock,Resources,Client) -> RECORDU95EXTRACT(Lock,lock,resource)
 LOCKER2U95CHECKU95AVAILABLE(Resource,cons(Lock,Locks)) -> CASE6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 LOCKER2U95CHECKU95AVAILABLE(Resource,cons(Lock,Locks)) -> RECORDU95EXTRACT(Lock,lock,resource)
 LOCKER2U95CHECKU95AVAILABLES(cons(Resource,Resources),Locks) -> LOCKER2U95CHECKU95AVAILABLE(Resource,Locks)
 LOCKER2U95CHECKU95AVAILABLES(cons(Resource,Resources),Locks) -> LOCKER2U95CHECKU95AVAILABLES(Resources,Locks)
 LOCKER2U95MAPU95CLAIMU95LOCK(cons(Lock,Locks),Resources,Client) -> LOCKER2U95MAPU95CLAIMU95LOCK(Locks,Resources,Client)
 LOCKER2U95MAPU95PROMOTEU95PENDING(cons(Lock,Locks),Pending) -> LOCKER2U95MAPU95PROMOTEU95PENDING(Locks,Pending)
 LOCKER2U95MAPU95PROMOTEU95PENDING(cons(Lock,Locks),Pending) -> LOCKER2U95PROMOTEU95PENDING(Lock,Pending)
 LOCKER2U95PROMOTEU95PENDING(Lock,Client) -> CASE0(Client,Lock,recordu95extract(Lock,lock,pending))
 LOCKER2U95RELEASEU95LOCK(Lock,Client) -> CASE2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 LOCKER2U95RELEASEU95LOCK(Lock,Client) -> GENU95MODTAGEQ(Client,recordu95extract(Lock,lock,excl))
 LOCKER2U95REMOVEU95PENDING(Lock,Client) -> RECORDU95UPDATES(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 LOCKER2U95REMOVEU95PENDING(Lock,Client) -> SUBTRACT(recordu95extract(Lock,lock,pending),cons(Client,nil))
 PUSH(E1,E2,calls(E3,S1,CS1)) -> EQT(E1,E3)
 PUSH(E1,E2,calls(E3,S1,CS1)) -> PUSH1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 PUSH1(E1,E2,E3,S1,CS1,T) -> PUSHS(E2,S1)
 RECORDU95UPDATES(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> RECORDU95UPDATE(Record,Name,Field,NewF)
 RECORDU95UPDATES(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> RECORDU95UPDATES(recordu95update(Record,Name,Field,NewF),Name,Fields)
 SUBTRACT(List,cons(Head,Tail)) -> DELETE(Head,List)
 SUBTRACT(List,cons(Head,Tail)) -> SUBTRACT(delete(Head,List),Tail)
-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1

Problem 1: 

SCC Processor:
-> Pairs:
 APPEND(cons(Head,Tail),List) -> APPEND(Tail,List)
 CASE0(Client,Lock,cons(Client,Pendings)) -> RECORDU95UPDATES(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 CASE1(Client,Resources,Lock,ftrue) -> RECORDU95UPDATES(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 CASE5(Client,Locks,Lock,ffalse) -> LOCKER2U95OBTAINABLES(Locks,Client)
 CASE5(Client,Locks,Lock,ftrue) -> LOCKER2U95OBTAINABLES(Locks,Client)
 CASE6(Locks,Lock,Resource,ffalse) -> LOCKER2U95CHECKU95AVAILABLE(Resource,Locks)
 CASE8(Tail,Head,E,ffalse) -> DELETE(E,Tail)
 CASE9(Tail,Head,E,ffalse) -> MEMBER(E,Tail)
 ELEMENT(int(s(s(N1))),tuple(T1,T2)) -> ELEMENT(int(s(N1)),T2)
 EQC(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> AND(eqs(S1,S2),eqc(CS1,CS2))
 EQC(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> AND(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 EQC(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> EQC(CS1,CS2)
 EQC(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> EQS(S1,S2)
 EQC(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> EQT(E1,E2)
 EQS(stack(E1,S1),stack(E2,S2)) -> AND(eqt(E1,E2),eqs(S1,S2))
 EQS(stack(E1,S1),stack(E2,S2)) -> EQS(S1,S2)
 EQS(stack(E1,S1),stack(E2,S2)) -> EQT(E1,E2)
 EQT(cons(H1,T1),cons(H2,T2)) -> AND(eqt(H1,H2),eqt(T1,T2))
 EQT(cons(H1,T1),cons(H2,T2)) -> EQT(H1,H2)
 EQT(cons(H1,T1),cons(H2,T2)) -> EQT(T1,T2)
 EQT(pid(N1),pid(N2)) -> EQT(N1,N2)
 EQT(tuple(H1,T1),tuple(H2,T2)) -> AND(eqt(H1,H2),eqt(T1,T2))
 EQT(tuple(H1,T1),tuple(H2,T2)) -> EQT(H1,H2)
 EQT(tuple(H1,T1),tuple(H2,T2)) -> EQT(T1,T2)
 EQT(tuplenil(H1),tuplenil(H2)) -> EQT(H1,H2)
 ISTOPS(E1,stack(E2,S1)) -> EQT(E1,E2)
 LOCKER2U95ADDU95PENDING(Lock,Resources,Client) -> CASE1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 LOCKER2U95ADDU95PENDING(Lock,Resources,Client) -> MEMBER(recordu95extract(Lock,lock,resource),Resources)
 LOCKER2U95ADDU95PENDING(Lock,Resources,Client) -> RECORDU95EXTRACT(Lock,lock,resource)
 LOCKER2U95CHECKU95AVAILABLE(Resource,cons(Lock,Locks)) -> CASE6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 LOCKER2U95CHECKU95AVAILABLE(Resource,cons(Lock,Locks)) -> RECORDU95EXTRACT(Lock,lock,resource)
 LOCKER2U95CHECKU95AVAILABLES(cons(Resource,Resources),Locks) -> LOCKER2U95CHECKU95AVAILABLE(Resource,Locks)
 LOCKER2U95CHECKU95AVAILABLES(cons(Resource,Resources),Locks) -> LOCKER2U95CHECKU95AVAILABLES(Resources,Locks)
 LOCKER2U95MAPU95CLAIMU95LOCK(cons(Lock,Locks),Resources,Client) -> LOCKER2U95MAPU95CLAIMU95LOCK(Locks,Resources,Client)
 LOCKER2U95MAPU95PROMOTEU95PENDING(cons(Lock,Locks),Pending) -> LOCKER2U95MAPU95PROMOTEU95PENDING(Locks,Pending)
 LOCKER2U95MAPU95PROMOTEU95PENDING(cons(Lock,Locks),Pending) -> LOCKER2U95PROMOTEU95PENDING(Lock,Pending)
 LOCKER2U95PROMOTEU95PENDING(Lock,Client) -> CASE0(Client,Lock,recordu95extract(Lock,lock,pending))
 LOCKER2U95RELEASEU95LOCK(Lock,Client) -> CASE2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 LOCKER2U95RELEASEU95LOCK(Lock,Client) -> GENU95MODTAGEQ(Client,recordu95extract(Lock,lock,excl))
 LOCKER2U95REMOVEU95PENDING(Lock,Client) -> RECORDU95UPDATES(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 LOCKER2U95REMOVEU95PENDING(Lock,Client) -> SUBTRACT(recordu95extract(Lock,lock,pending),cons(Client,nil))
 PUSH(E1,E2,calls(E3,S1,CS1)) -> EQT(E1,E3)
 PUSH(E1,E2,calls(E3,S1,CS1)) -> PUSH1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 PUSH1(E1,E2,E3,S1,CS1,T) -> PUSHS(E2,S1)
 RECORDU95UPDATES(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> RECORDU95UPDATE(Record,Name,Field,NewF)
 RECORDU95UPDATES(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> RECORDU95UPDATES(recordu95update(Record,Name,Field,NewF),Name,Fields)
 SUBTRACT(List,cons(Head,Tail)) -> DELETE(Head,List)
 SUBTRACT(List,cons(Head,Tail)) -> SUBTRACT(delete(Head,List),Tail)
-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 SUBTRACT(List,cons(Head,Tail)) -> SUBTRACT(delete(Head,List),Tail)
->->-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->->Cycle:
->->-> Pairs:
 RECORDU95UPDATES(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> RECORDU95UPDATES(recordu95update(Record,Name,Field,NewF),Name,Fields)
->->-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->->Cycle:
->->-> Pairs:
 LOCKER2U95MAPU95PROMOTEU95PENDING(cons(Lock,Locks),Pending) -> LOCKER2U95MAPU95PROMOTEU95PENDING(Locks,Pending)
->->-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->->Cycle:
->->-> Pairs:
 LOCKER2U95MAPU95CLAIMU95LOCK(cons(Lock,Locks),Resources,Client) -> LOCKER2U95MAPU95CLAIMU95LOCK(Locks,Resources,Client)
->->-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->->Cycle:
->->-> Pairs:
 LOCKER2U95CHECKU95AVAILABLES(cons(Resource,Resources),Locks) -> LOCKER2U95CHECKU95AVAILABLES(Resources,Locks)
->->-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->->Cycle:
->->-> Pairs:
 EQT(cons(H1,T1),cons(H2,T2)) -> EQT(H1,H2)
 EQT(cons(H1,T1),cons(H2,T2)) -> EQT(T1,T2)
 EQT(pid(N1),pid(N2)) -> EQT(N1,N2)
 EQT(tuple(H1,T1),tuple(H2,T2)) -> EQT(H1,H2)
 EQT(tuple(H1,T1),tuple(H2,T2)) -> EQT(T1,T2)
 EQT(tuplenil(H1),tuplenil(H2)) -> EQT(H1,H2)
->->-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->->Cycle:
->->-> Pairs:
 EQS(stack(E1,S1),stack(E2,S2)) -> EQS(S1,S2)
->->-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->->Cycle:
->->-> Pairs:
 EQC(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> EQC(CS1,CS2)
->->-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->->Cycle:
->->-> Pairs:
 ELEMENT(int(s(s(N1))),tuple(T1,T2)) -> ELEMENT(int(s(N1)),T2)
->->-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->->Cycle:
->->-> Pairs:
 APPEND(cons(Head,Tail),List) -> APPEND(Tail,List)
->->-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1


The problem is decomposed in 10 subproblems.

Problem 1.1: 

Subterm Processor:
-> Pairs:
 SUBTRACT(List,cons(Head,Tail)) -> SUBTRACT(delete(Head,List),Tail)
-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->Projection:
 pi(SUBTRACT) = 2

Problem 1.1: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2: 

Subterm Processor:
-> Pairs:
 RECORDU95UPDATES(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> RECORDU95UPDATES(recordu95update(Record,Name,Field,NewF),Name,Fields)
-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->Projection:
 pi(RECORDU95UPDATES) = 3

Problem 1.2: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.3: 

Subterm Processor:
-> Pairs:
 LOCKER2U95MAPU95PROMOTEU95PENDING(cons(Lock,Locks),Pending) -> LOCKER2U95MAPU95PROMOTEU95PENDING(Locks,Pending)
-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->Projection:
 pi(LOCKER2U95MAPU95PROMOTEU95PENDING) = 1

Problem 1.3: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.4: 

Subterm Processor:
-> Pairs:
 LOCKER2U95MAPU95CLAIMU95LOCK(cons(Lock,Locks),Resources,Client) -> LOCKER2U95MAPU95CLAIMU95LOCK(Locks,Resources,Client)
-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->Projection:
 pi(LOCKER2U95MAPU95CLAIMU95LOCK) = 1

Problem 1.4: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.5: 

Subterm Processor:
-> Pairs:
 LOCKER2U95CHECKU95AVAILABLES(cons(Resource,Resources),Locks) -> LOCKER2U95CHECKU95AVAILABLES(Resources,Locks)
-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->Projection:
 pi(LOCKER2U95CHECKU95AVAILABLES) = 1

Problem 1.5: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.6: 

Subterm Processor:
-> Pairs:
 EQT(cons(H1,T1),cons(H2,T2)) -> EQT(H1,H2)
 EQT(cons(H1,T1),cons(H2,T2)) -> EQT(T1,T2)
 EQT(pid(N1),pid(N2)) -> EQT(N1,N2)
 EQT(tuple(H1,T1),tuple(H2,T2)) -> EQT(H1,H2)
 EQT(tuple(H1,T1),tuple(H2,T2)) -> EQT(T1,T2)
 EQT(tuplenil(H1),tuplenil(H2)) -> EQT(H1,H2)
-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->Projection:
 pi(EQT) = 1

Problem 1.6: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.7: 

Subterm Processor:
-> Pairs:
 EQS(stack(E1,S1),stack(E2,S2)) -> EQS(S1,S2)
-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->Projection:
 pi(EQS) = 1

Problem 1.7: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.8: 

Subterm Processor:
-> Pairs:
 EQC(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> EQC(CS1,CS2)
-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->Projection:
 pi(EQC) = 1

Problem 1.8: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.9: 

Subterm Processor:
-> Pairs:
 ELEMENT(int(s(s(N1))),tuple(T1,T2)) -> ELEMENT(int(s(N1)),T2)
-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->Projection:
 pi(ELEMENT) = 2

Problem 1.9: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.10: 

Subterm Processor:
-> Pairs:
 APPEND(cons(Head,Tail),List) -> APPEND(Tail,List)
-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->Projection:
 pi(APPEND) = 1

Problem 1.10: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 and(F,B) -> F
 and(T,B) -> B
 and(B,F) -> F
 and(B,T) -> B
 append(cons(Head,Tail),List) -> cons(Head,append(Tail,List))
 case0(Client,Lock,cons(Client,Pendings)) -> recordu95updates(Lock,lock,cons(tuple(excl,tuplenil(Client)),cons(tuple(pending,tuplenil(Pendings)),nil)))
 case0(Client,Lock,MCRLFree0) -> Lock
 case1(Client,Resources,Lock,ffalse) -> Lock
 case1(Client,Resources,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(append(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 case2(Client,Lock,ftrue) -> recordu95updates(Lock,lock,cons(tuple(excllock,excl),nil))
 case4(Client,Lock,MCRLFree1) -> ffalse
 case5(Client,Locks,Lock,ffalse) -> locker2u95obtainables(Locks,Client)
 case5(Client,Locks,Lock,ftrue) -> andt(locker2u95obtainable(Lock,Client),locker2u95obtainables(Locks,Client))
 case6(Locks,Lock,Resource,ffalse) -> locker2u95checku95available(Resource,Locks)
 case6(Locks,Lock,Resource,ftrue) -> andt(equal(recordu95extract(Lock,lock,excl),nil),equal(recordu95extract(Lock,lock,pending),nil))
 case8(Tail,Head,E,ffalse) -> cons(Head,delete(E,Tail))
 case8(Tail,Head,E,ftrue) -> Tail
 case9(Tail,Head,E,ffalse) -> member(E,Tail)
 case9(Tail,Head,E,ftrue) -> ftrue
 delete(E,cons(Head,Tail)) -> case8(Tail,Head,E,equal(E,Head))
 delete(E,nil) -> nil
 element(int(s(num0)),tuple(T1,T2)) -> T1
 element(int(s(num0)),tuplenil(T1)) -> T1
 element(int(s(s(N1))),tuple(T1,T2)) -> element(int(s(N1)),T2)
 eq(F,F) -> T
 eq(F,T) -> F
 eq(T,F) -> F
 eq(T,T) -> T
 eqc(calls(E1,S1,CS1),calls(E2,S2,CS2)) -> and(eqt(E1,E2),and(eqs(S1,S2),eqc(CS1,CS2)))
 eqc(calls(E1,S1,CS1),nocalls) -> F
 eqc(nocalls,calls(E2,S2,CS2)) -> F
 eqc(nocalls,nocalls) -> T
 eqs(empty,empty) -> T
 eqs(empty,stack(E2,S2)) -> F
 eqs(stack(E1,S1),empty) -> F
 eqs(stack(E1,S1),stack(E2,S2)) -> and(eqt(E1,E2),eqs(S1,S2))
 eqt(a,a) -> T
 eqt(a,cons(H2,T2)) -> F
 eqt(a,excl) -> F
 eqt(a,ffalse) -> F
 eqt(a,int(N2)) -> F
 eqt(a,lock) -> F
 eqt(a,locker) -> F
 eqt(a,mcrlrecord) -> F
 eqt(a,nil) -> F
 eqt(a,ok) -> F
 eqt(a,pending) -> F
 eqt(a,pid(N2)) -> F
 eqt(a,release) -> F
 eqt(a,request) -> F
 eqt(a,resource) -> F
 eqt(a,tag) -> F
 eqt(a,ftrue) -> F
 eqt(a,tuple(H2,T2)) -> F
 eqt(a,tuplenil(H2)) -> F
 eqt(a,undefined) -> F
 eqt(cons(H1,T1),cons(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(cons(H1,T1),int(N2)) -> F
 eqt(cons(H1,T1),pid(N2)) -> F
 eqt(cons(H1,T1),resource) -> F
 eqt(cons(H1,T1),tag) -> F
 eqt(cons(H1,T1),ftrue) -> F
 eqt(cons(H1,T1),tuple(H2,T2)) -> F
 eqt(cons(H1,T1),tuplenil(H2)) -> F
 eqt(cons(H1,T1),undefined) -> F
 eqt(excl,eqt(ffalse,int(N2))) -> F
 eqt(excl,a) -> F
 eqt(excl,excl) -> T
 eqt(excl,ffalse) -> F
 eqt(excl,lock) -> F
 eqt(excl,locker) -> F
 eqt(excl,mcrlrecord) -> F
 eqt(excl,nil) -> F
 eqt(excl,ok) -> F
 eqt(excl,pending) -> F
 eqt(excl,pid(N2)) -> F
 eqt(excl,release) -> F
 eqt(excl,request) -> F
 eqt(excl,resource) -> F
 eqt(excl,tag) -> F
 eqt(excl,ftrue) -> F
 eqt(excl,undefined) -> F
 eqt(ffalse,cons(H2,T2)) -> F
 eqt(ffalse,tuple(H2,T2)) -> F
 eqt(ffalse,tuplenil(H2)) -> F
 eqt(int(N1),a) -> F
 eqt(int(N1),excl) -> F
 eqt(int(N1),ffalse) -> F
 eqt(int(N1),lock) -> F
 eqt(int(N1),locker) -> F
 eqt(int(N1),mcrlrecord) -> F
 eqt(int(N1),nil) -> F
 eqt(int(N1),ok) -> F
 eqt(int(N1),pending) -> F
 eqt(int(N1),release) -> F
 eqt(int(N1),request) -> F
 eqt(int(N1),resource) -> F
 eqt(int(N1),tag) -> F
 eqt(int(N1),ftrue) -> F
 eqt(int(N1),undefined) -> F
 eqt(lock,a) -> F
 eqt(lock,cons(H2,T2)) -> F
 eqt(lock,excl) -> F
 eqt(lock,ffalse) -> F
 eqt(lock,int(N2)) -> F
 eqt(lock,lock) -> T
 eqt(lock,locker) -> F
 eqt(lock,mcrlrecord) -> F
 eqt(lock,nil) -> F
 eqt(lock,ok) -> F
 eqt(lock,pending) -> F
 eqt(lock,pid(N2)) -> F
 eqt(lock,release) -> F
 eqt(lock,request) -> F
 eqt(lock,resource) -> F
 eqt(lock,tag) -> F
 eqt(lock,ftrue) -> F
 eqt(lock,tuple(H2,T2)) -> F
 eqt(lock,tuplenil(H2)) -> F
 eqt(lock,undefined) -> F
 eqt(locker,a) -> F
 eqt(locker,cons(H2,T2)) -> F
 eqt(locker,excl) -> F
 eqt(locker,ffalse) -> F
 eqt(locker,int(N2)) -> F
 eqt(locker,lock) -> F
 eqt(locker,locker) -> T
 eqt(locker,mcrlrecord) -> F
 eqt(locker,nil) -> F
 eqt(locker,ok) -> F
 eqt(locker,pending) -> F
 eqt(locker,pid(N2)) -> F
 eqt(locker,release) -> F
 eqt(locker,request) -> F
 eqt(locker,resource) -> F
 eqt(locker,tag) -> F
 eqt(locker,ftrue) -> F
 eqt(locker,tuple(H2,T2)) -> F
 eqt(locker,tuplenil(H2)) -> F
 eqt(locker,undefined) -> F
 eqt(mcrlrecord,a) -> F
 eqt(mcrlrecord,excl) -> F
 eqt(mcrlrecord,ffalse) -> F
 eqt(mcrlrecord,lock) -> F
 eqt(mcrlrecord,locker) -> F
 eqt(mcrlrecord,mcrlrecord) -> T
 eqt(mcrlrecord,nil) -> F
 eqt(mcrlrecord,ok) -> F
 eqt(mcrlrecord,pending) -> F
 eqt(mcrlrecord,release) -> F
 eqt(mcrlrecord,request) -> F
 eqt(mcrlrecord,resource) -> F
 eqt(nil,cons(H2,T2)) -> F
 eqt(nil,int(N2)) -> F
 eqt(nil,pid(N2)) -> F
 eqt(nil,tuple(H2,T2)) -> F
 eqt(nil,tuplenil(H2)) -> F
 eqt(nil,undefined) -> F
 eqt(ok,cons(H2,T2)) -> F
 eqt(ok,int(N2)) -> F
 eqt(ok,pid(N2)) -> F
 eqt(ok,resource) -> F
 eqt(ok,tag) -> F
 eqt(ok,ftrue) -> F
 eqt(ok,tuple(H2,T2)) -> F
 eqt(ok,tuplenil(H2)) -> F
 eqt(ok,undefined) -> F
 eqt(pending,a) -> F
 eqt(pending,cons(H2,T2)) -> F
 eqt(pending,excl) -> F
 eqt(pending,ffalse) -> F
 eqt(pending,int(N2)) -> F
 eqt(pending,lock) -> F
 eqt(pending,locker) -> F
 eqt(pending,mcrlrecord) -> F
 eqt(pending,nil) -> F
 eqt(pending,ok) -> F
 eqt(pending,pending) -> T
 eqt(pending,pid(N2)) -> F
 eqt(pending,release) -> F
 eqt(pending,request) -> F
 eqt(pending,resource) -> F
 eqt(pending,tag) -> F
 eqt(pending,ftrue) -> F
 eqt(pending,tuple(H2,T2)) -> F
 eqt(pending,tuplenil(H2)) -> F
 eqt(pending,undefined) -> F
 eqt(pid(N1),a) -> F
 eqt(pid(N1),cons(H2,T2)) -> F
 eqt(pid(N1),excl) -> F
 eqt(pid(N1),ffalse) -> F
 eqt(pid(N1),int(N2)) -> F
 eqt(pid(N1),lock) -> F
 eqt(pid(N1),locker) -> F
 eqt(pid(N1),mcrlrecord) -> F
 eqt(pid(N1),nil) -> F
 eqt(pid(N1),ok) -> F
 eqt(pid(N1),pending) -> F
 eqt(pid(N1),pid(N2)) -> eqt(N1,N2)
 eqt(pid(N1),release) -> F
 eqt(pid(N1),request) -> F
 eqt(pid(N1),resource) -> F
 eqt(pid(N1),tag) -> F
 eqt(pid(N1),ftrue) -> F
 eqt(pid(N1),tuple(H2,T2)) -> F
 eqt(pid(N1),tuplenil(H2)) -> F
 eqt(pid(N1),undefined) -> F
 eqt(release,a) -> F
 eqt(release,excl) -> F
 eqt(release,ffalse) -> F
 eqt(release,lock) -> F
 eqt(release,locker) -> F
 eqt(release,mcrlrecord) -> F
 eqt(release,nil) -> F
 eqt(release,ok) -> F
 eqt(request,cons(H2,T2)) -> F
 eqt(request,int(N2)) -> F
 eqt(request,mcrlrecord) -> F
 eqt(request,ok) -> F
 eqt(request,pending) -> F
 eqt(request,pid(N2)) -> F
 eqt(request,release) -> F
 eqt(request,request) -> T
 eqt(request,resource) -> F
 eqt(request,tag) -> F
 eqt(request,ftrue) -> F
 eqt(request,tuple(H2,T2)) -> F
 eqt(request,tuplenil(H2)) -> F
 eqt(request,undefined) -> F
 eqt(resource,a) -> F
 eqt(resource,cons(H2,T2)) -> F
 eqt(resource,excl) -> F
 eqt(resource,ffalse) -> F
 eqt(resource,int(N2)) -> F
 eqt(resource,lock) -> F
 eqt(resource,locker) -> F
 eqt(resource,mcrlrecord) -> F
 eqt(resource,nil) -> F
 eqt(resource,ok) -> F
 eqt(resource,pending) -> F
 eqt(resource,pid(N2)) -> F
 eqt(resource,release) -> F
 eqt(resource,request) -> F
 eqt(resource,resource) -> T
 eqt(resource,tag) -> F
 eqt(resource,ftrue) -> F
 eqt(resource,tuple(H2,T2)) -> F
 eqt(resource,tuplenil(H2)) -> F
 eqt(resource,undefined) -> F
 eqt(tag,a) -> F
 eqt(tag,cons(H2,T2)) -> F
 eqt(tag,excl) -> F
 eqt(tag,ffalse) -> F
 eqt(tag,int(N2)) -> F
 eqt(tag,lock) -> F
 eqt(tag,locker) -> F
 eqt(tag,mcrlrecord) -> F
 eqt(tag,nil) -> F
 eqt(tag,ok) -> F
 eqt(tag,pending) -> F
 eqt(tag,pid(N2)) -> F
 eqt(tag,release) -> F
 eqt(tag,request) -> F
 eqt(tag,resource) -> F
 eqt(tag,tag) -> T
 eqt(tag,ftrue) -> F
 eqt(tag,tuple(H2,T2)) -> F
 eqt(tag,tuplenil(H2)) -> F
 eqt(tag,undefined) -> F
 eqt(ftrue,a) -> F
 eqt(ftrue,cons(H2,T2)) -> F
 eqt(ftrue,excl) -> F
 eqt(ftrue,ffalse) -> F
 eqt(ftrue,int(N2)) -> F
 eqt(ftrue,lock) -> F
 eqt(ftrue,locker) -> F
 eqt(ftrue,mcrlrecord) -> F
 eqt(ftrue,nil) -> F
 eqt(ftrue,ok) -> F
 eqt(ftrue,pending) -> F
 eqt(ftrue,pid(N2)) -> F
 eqt(ftrue,release) -> F
 eqt(ftrue,request) -> F
 eqt(ftrue,resource) -> F
 eqt(ftrue,tag) -> F
 eqt(ftrue,ftrue) -> T
 eqt(ftrue,tuple(H2,T2)) -> F
 eqt(ftrue,tuplenil(H2)) -> F
 eqt(ftrue,undefined) -> F
 eqt(tuple(H1,T1),a) -> F
 eqt(tuple(H1,T1),cons(H2,T2)) -> F
 eqt(tuple(H1,T1),excl) -> F
 eqt(tuple(H1,T1),ffalse) -> F
 eqt(tuple(H1,T1),int(N2)) -> F
 eqt(tuple(H1,T1),lock) -> F
 eqt(tuple(H1,T1),locker) -> F
 eqt(tuple(H1,T1),mcrlrecord) -> F
 eqt(tuple(H1,T1),nil) -> F
 eqt(tuple(H1,T1),ok) -> F
 eqt(tuple(H1,T1),pending) -> F
 eqt(tuple(H1,T1),pid(N2)) -> F
 eqt(tuple(H1,T1),release) -> F
 eqt(tuple(H1,T1),request) -> F
 eqt(tuple(H1,T1),resource) -> F
 eqt(tuple(H1,T1),tag) -> F
 eqt(tuple(H1,T1),ftrue) -> F
 eqt(tuple(H1,T1),tuple(H2,T2)) -> and(eqt(H1,H2),eqt(T1,T2))
 eqt(tuple(H1,T1),tuplenil(H2)) -> F
 eqt(tuple(H1,T1),undefined) -> F
 eqt(tuplenil(H1),a) -> F
 eqt(tuplenil(H1),cons(H2,T2)) -> F
 eqt(tuplenil(H1),excl) -> F
 eqt(tuplenil(H1),ffalse) -> F
 eqt(tuplenil(H1),int(N2)) -> F
 eqt(tuplenil(H1),lock) -> F
 eqt(tuplenil(H1),locker) -> F
 eqt(tuplenil(H1),mcrlrecord) -> F
 eqt(tuplenil(H1),nil) -> F
 eqt(tuplenil(H1),ok) -> F
 eqt(tuplenil(H1),pending) -> F
 eqt(tuplenil(H1),pid(N2)) -> F
 eqt(tuplenil(H1),release) -> F
 eqt(tuplenil(H1),request) -> F
 eqt(tuplenil(H1),resource) -> F
 eqt(tuplenil(H1),tag) -> F
 eqt(tuplenil(H1),ftrue) -> F
 eqt(tuplenil(H1),tuple(H2,T2)) -> F
 eqt(tuplenil(H1),tuplenil(H2)) -> eqt(H1,H2)
 eqt(tuplenil(H1),undefined) -> F
 eqt(undefined,a) -> F
 eqt(undefined,nil) -> F
 eqt(undefined,tuplenil(H2)) -> F
 genu95modtageq(Client1,Client2) -> equal(Client1,Client2)
 genu95tag(Pid) -> tuple(Pid,tuplenil(tag))
 if(F,B1,B2) -> B2
 if(T,B1,B2) -> B1
 imp(F,B) -> T
 imp(T,B) -> B
 istops(E1,empty) -> F
 istops(E1,stack(E2,S1)) -> eqt(E1,E2)
 locker2u95addu95pending(Lock,Resources,Client) -> case1(Client,Resources,Lock,member(recordu95extract(Lock,lock,resource),Resources))
 locker2u95adduniq(nil,List) -> List
 locker2u95checku95available(Resource,cons(Lock,Locks)) -> case6(Locks,Lock,Resource,equal(Resource,recordu95extract(Lock,lock,resource)))
 locker2u95checku95available(Resource,nil) -> ffalse
 locker2u95checku95availables(cons(Resource,Resources),Locks) -> andt(locker2u95checku95available(Resource,Locks),locker2u95checku95availables(Resources,Locks))
 locker2u95checku95availables(nil,Locks) -> ftrue
 locker2u95mapu95addu95pending(nil,Resources,Client) -> nil
 locker2u95mapu95claimu95lock(cons(Lock,Locks),Resources,Client) -> cons(locker2u95claimu95lock(Lock,Resources,Client),locker2u95mapu95claimu95lock(Locks,Resources,Client))
 locker2u95mapu95claimu95lock(nil,Resources,Client) -> nil
 locker2u95mapu95promoteu95pending(cons(Lock,Locks),Pending) -> cons(locker2u95promoteu95pending(Lock,Pending),locker2u95mapu95promoteu95pending(Locks,Pending))
 locker2u95mapu95promoteu95pending(nil,Pending) -> nil
 locker2u95obtainables(cons(Lock,Locks),Client) -> case5(Client,Locks,Lock,member(Client,recordu95extract(Lock,lock,pending)))
 locker2u95obtainables(nil,Client) -> ftrue
 locker2u95promoteu95pending(Lock,Client) -> case0(Client,Lock,recordu95extract(Lock,lock,pending))
 locker2u95releaseu95lock(Lock,Client) -> case2(Client,Lock,genu95modtageq(Client,recordu95extract(Lock,lock,excl)))
 locker2u95removeu95pending(Lock,Client) -> recordu95updates(Lock,lock,cons(tuple(pending,tuplenil(subtract(recordu95extract(Lock,lock,pending),cons(Client,nil)))),nil))
 member(E,cons(Head,Tail)) -> case9(Tail,Head,E,equal(E,Head))
 member(E,nil) -> ffalse
 not(F) -> T
 not(T) -> F
 or(F,F) -> F
 or(F,T) -> T
 or(T,F) -> T
 or(T,T) -> T
 pops(stack(E1,S1)) -> S1
 push(E1,E2,calls(E3,S1,CS1)) -> push1(E1,E2,E3,S1,CS1,eqt(E1,E3))
 push(E1,E2,nocalls) -> calls(E1,stack(E2,empty),nocalls)
 push1(E1,E2,E3,S1,CS1,T) -> calls(E3,pushs(E2,S1),CS1)
 pushs(E1,S1) -> stack(E1,S1)
 recordu95extract(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,resource) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2)))))
 recordu95new(lock) -> tuple(mcrlrecord,tuple(lock,tuple(undefined,tuple(nil,tuplenil(nil)))))
 recordu95update(tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(F2))))),lock,pending,NewF) -> tuple(mcrlrecord,tuple(lock,tuple(F0,tuple(F1,tuplenil(NewF)))))
 recordu95updates(Record,Name,cons(tuple(Field,tuplenil(NewF)),Fields)) -> recordu95updates(recordu95update(Record,Name,Field,NewF),Name,Fields)
 recordu95updates(Record,Name,nil) -> Record
 subtract(List,cons(Head,Tail)) -> subtract(delete(Head,List),Tail)
 subtract(List,nil) -> List
 tops(stack(E1,S1)) -> E1
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
