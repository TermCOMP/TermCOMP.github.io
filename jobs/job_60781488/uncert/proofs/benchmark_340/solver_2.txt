YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/zvuX3.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) QTRSRRRProof [EQUIVALENT, 635 ms]
(2) QTRS
(3) QTRSRRRProof [EQUIVALENT, 0 ms]
(4) QTRS
(5) RisEmptyProof [EQUIVALENT, 0 ms]
(6) YES


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   or(T, T) -> T
   or(F, T) -> T
   or(T, F) -> T
   or(F, F) -> F
   and(T, B) -> B
   and(B, T) -> B
   and(F, B) -> F
   and(B, F) -> F
   imp(T, B) -> B
   imp(F, B) -> T
   not(T) -> F
   not(F) -> T
   if(T, B1, B2) -> B1
   if(F, B1, B2) -> B2
   eq(T, T) -> T
   eq(F, F) -> T
   eq(T, F) -> F
   eq(F, T) -> F
   eqt(nil, undefined) -> F
   eqt(nil, pid(N2)) -> F
   eqt(nil, int(N2)) -> F
   eqt(nil, cons(H2, T2)) -> F
   eqt(nil, tuple(H2, T2)) -> F
   eqt(nil, tuplenil(H2)) -> F
   eqt(a, nil) -> F
   eqt(a, a) -> T
   eqt(a, excl) -> F
   eqt(a, false) -> F
   eqt(a, lock) -> F
   eqt(a, locker) -> F
   eqt(a, mcrlrecord) -> F
   eqt(a, ok) -> F
   eqt(a, pending) -> F
   eqt(a, release) -> F
   eqt(a, request) -> F
   eqt(a, resource) -> F
   eqt(a, tag) -> F
   eqt(a, true) -> F
   eqt(a, undefined) -> F
   eqt(a, pid(N2)) -> F
   eqt(a, int(N2)) -> F
   eqt(a, cons(H2, T2)) -> F
   eqt(a, tuple(H2, T2)) -> F
   eqt(a, tuplenil(H2)) -> F
   eqt(excl, nil) -> F
   eqt(excl, a) -> F
   eqt(excl, excl) -> T
   eqt(excl, false) -> F
   eqt(excl, lock) -> F
   eqt(excl, locker) -> F
   eqt(excl, mcrlrecord) -> F
   eqt(excl, ok) -> F
   eqt(excl, pending) -> F
   eqt(excl, release) -> F
   eqt(excl, request) -> F
   eqt(excl, resource) -> F
   eqt(excl, tag) -> F
   eqt(excl, true) -> F
   eqt(excl, undefined) -> F
   eqt(excl, pid(N2)) -> F
   eqt(excl, eqt(false, int(N2))) -> F
   eqt(false, cons(H2, T2)) -> F
   eqt(false, tuple(H2, T2)) -> F
   eqt(false, tuplenil(H2)) -> F
   eqt(lock, nil) -> F
   eqt(lock, a) -> F
   eqt(lock, excl) -> F
   eqt(lock, false) -> F
   eqt(lock, lock) -> T
   eqt(lock, locker) -> F
   eqt(lock, mcrlrecord) -> F
   eqt(lock, ok) -> F
   eqt(lock, pending) -> F
   eqt(lock, release) -> F
   eqt(lock, request) -> F
   eqt(lock, resource) -> F
   eqt(lock, tag) -> F
   eqt(lock, true) -> F
   eqt(lock, undefined) -> F
   eqt(lock, pid(N2)) -> F
   eqt(lock, int(N2)) -> F
   eqt(lock, cons(H2, T2)) -> F
   eqt(lock, tuple(H2, T2)) -> F
   eqt(lock, tuplenil(H2)) -> F
   eqt(locker, nil) -> F
   eqt(locker, a) -> F
   eqt(locker, excl) -> F
   eqt(locker, false) -> F
   eqt(locker, lock) -> F
   eqt(locker, locker) -> T
   eqt(locker, mcrlrecord) -> F
   eqt(locker, ok) -> F
   eqt(locker, pending) -> F
   eqt(locker, release) -> F
   eqt(locker, request) -> F
   eqt(locker, resource) -> F
   eqt(locker, tag) -> F
   eqt(locker, true) -> F
   eqt(locker, undefined) -> F
   eqt(locker, pid(N2)) -> F
   eqt(locker, int(N2)) -> F
   eqt(locker, cons(H2, T2)) -> F
   eqt(locker, tuple(H2, T2)) -> F
   eqt(locker, tuplenil(H2)) -> F
   eqt(mcrlrecord, nil) -> F
   eqt(mcrlrecord, a) -> F
   eqt(mcrlrecord, excl) -> F
   eqt(mcrlrecord, false) -> F
   eqt(mcrlrecord, lock) -> F
   eqt(mcrlrecord, locker) -> F
   eqt(mcrlrecord, mcrlrecord) -> T
   eqt(mcrlrecord, ok) -> F
   eqt(mcrlrecord, pending) -> F
   eqt(mcrlrecord, release) -> F
   eqt(mcrlrecord, request) -> F
   eqt(mcrlrecord, resource) -> F
   eqt(ok, resource) -> F
   eqt(ok, tag) -> F
   eqt(ok, true) -> F
   eqt(ok, undefined) -> F
   eqt(ok, pid(N2)) -> F
   eqt(ok, int(N2)) -> F
   eqt(ok, cons(H2, T2)) -> F
   eqt(ok, tuple(H2, T2)) -> F
   eqt(ok, tuplenil(H2)) -> F
   eqt(pending, nil) -> F
   eqt(pending, a) -> F
   eqt(pending, excl) -> F
   eqt(pending, false) -> F
   eqt(pending, lock) -> F
   eqt(pending, locker) -> F
   eqt(pending, mcrlrecord) -> F
   eqt(pending, ok) -> F
   eqt(pending, pending) -> T
   eqt(pending, release) -> F
   eqt(pending, request) -> F
   eqt(pending, resource) -> F
   eqt(pending, tag) -> F
   eqt(pending, true) -> F
   eqt(pending, undefined) -> F
   eqt(pending, pid(N2)) -> F
   eqt(pending, int(N2)) -> F
   eqt(pending, cons(H2, T2)) -> F
   eqt(pending, tuple(H2, T2)) -> F
   eqt(pending, tuplenil(H2)) -> F
   eqt(release, nil) -> F
   eqt(release, a) -> F
   eqt(release, excl) -> F
   eqt(release, false) -> F
   eqt(release, lock) -> F
   eqt(release, locker) -> F
   eqt(release, mcrlrecord) -> F
   eqt(release, ok) -> F
   eqt(request, mcrlrecord) -> F
   eqt(request, ok) -> F
   eqt(request, pending) -> F
   eqt(request, release) -> F
   eqt(request, request) -> T
   eqt(request, resource) -> F
   eqt(request, tag) -> F
   eqt(request, true) -> F
   eqt(request, undefined) -> F
   eqt(request, pid(N2)) -> F
   eqt(request, int(N2)) -> F
   eqt(request, cons(H2, T2)) -> F
   eqt(request, tuple(H2, T2)) -> F
   eqt(request, tuplenil(H2)) -> F
   eqt(resource, nil) -> F
   eqt(resource, a) -> F
   eqt(resource, excl) -> F
   eqt(resource, false) -> F
   eqt(resource, lock) -> F
   eqt(resource, locker) -> F
   eqt(resource, mcrlrecord) -> F
   eqt(resource, ok) -> F
   eqt(resource, pending) -> F
   eqt(resource, release) -> F
   eqt(resource, request) -> F
   eqt(resource, resource) -> T
   eqt(resource, tag) -> F
   eqt(resource, true) -> F
   eqt(resource, undefined) -> F
   eqt(resource, pid(N2)) -> F
   eqt(resource, int(N2)) -> F
   eqt(resource, cons(H2, T2)) -> F
   eqt(resource, tuple(H2, T2)) -> F
   eqt(resource, tuplenil(H2)) -> F
   eqt(tag, nil) -> F
   eqt(tag, a) -> F
   eqt(tag, excl) -> F
   eqt(tag, false) -> F
   eqt(tag, lock) -> F
   eqt(tag, locker) -> F
   eqt(tag, mcrlrecord) -> F
   eqt(tag, ok) -> F
   eqt(tag, pending) -> F
   eqt(tag, release) -> F
   eqt(tag, request) -> F
   eqt(tag, resource) -> F
   eqt(tag, tag) -> T
   eqt(tag, true) -> F
   eqt(tag, undefined) -> F
   eqt(tag, pid(N2)) -> F
   eqt(tag, int(N2)) -> F
   eqt(tag, cons(H2, T2)) -> F
   eqt(tag, tuple(H2, T2)) -> F
   eqt(tag, tuplenil(H2)) -> F
   eqt(true, nil) -> F
   eqt(true, a) -> F
   eqt(true, excl) -> F
   eqt(true, false) -> F
   eqt(true, lock) -> F
   eqt(true, locker) -> F
   eqt(true, mcrlrecord) -> F
   eqt(true, ok) -> F
   eqt(true, pending) -> F
   eqt(true, release) -> F
   eqt(true, request) -> F
   eqt(true, resource) -> F
   eqt(true, tag) -> F
   eqt(true, true) -> T
   eqt(true, undefined) -> F
   eqt(true, pid(N2)) -> F
   eqt(true, int(N2)) -> F
   eqt(true, cons(H2, T2)) -> F
   eqt(true, tuple(H2, T2)) -> F
   eqt(true, tuplenil(H2)) -> F
   eqt(undefined, nil) -> F
   eqt(undefined, a) -> F
   eqt(undefined, tuplenil(H2)) -> F
   eqt(pid(N1), nil) -> F
   eqt(pid(N1), a) -> F
   eqt(pid(N1), excl) -> F
   eqt(pid(N1), false) -> F
   eqt(pid(N1), lock) -> F
   eqt(pid(N1), locker) -> F
   eqt(pid(N1), mcrlrecord) -> F
   eqt(pid(N1), ok) -> F
   eqt(pid(N1), pending) -> F
   eqt(pid(N1), release) -> F
   eqt(pid(N1), request) -> F
   eqt(pid(N1), resource) -> F
   eqt(pid(N1), tag) -> F
   eqt(pid(N1), true) -> F
   eqt(pid(N1), undefined) -> F
   eqt(pid(N1), pid(N2)) -> eqt(N1, N2)
   eqt(pid(N1), int(N2)) -> F
   eqt(pid(N1), cons(H2, T2)) -> F
   eqt(pid(N1), tuple(H2, T2)) -> F
   eqt(pid(N1), tuplenil(H2)) -> F
   eqt(int(N1), nil) -> F
   eqt(int(N1), a) -> F
   eqt(int(N1), excl) -> F
   eqt(int(N1), false) -> F
   eqt(int(N1), lock) -> F
   eqt(int(N1), locker) -> F
   eqt(int(N1), mcrlrecord) -> F
   eqt(int(N1), ok) -> F
   eqt(int(N1), pending) -> F
   eqt(int(N1), release) -> F
   eqt(int(N1), request) -> F
   eqt(int(N1), resource) -> F
   eqt(int(N1), tag) -> F
   eqt(int(N1), true) -> F
   eqt(int(N1), undefined) -> F
   eqt(cons(H1, T1), resource) -> F
   eqt(cons(H1, T1), tag) -> F
   eqt(cons(H1, T1), true) -> F
   eqt(cons(H1, T1), undefined) -> F
   eqt(cons(H1, T1), pid(N2)) -> F
   eqt(cons(H1, T1), int(N2)) -> F
   eqt(cons(H1, T1), cons(H2, T2)) -> and(eqt(H1, H2), eqt(T1, T2))
   eqt(cons(H1, T1), tuple(H2, T2)) -> F
   eqt(cons(H1, T1), tuplenil(H2)) -> F
   eqt(tuple(H1, T1), nil) -> F
   eqt(tuple(H1, T1), a) -> F
   eqt(tuple(H1, T1), excl) -> F
   eqt(tuple(H1, T1), false) -> F
   eqt(tuple(H1, T1), lock) -> F
   eqt(tuple(H1, T1), locker) -> F
   eqt(tuple(H1, T1), mcrlrecord) -> F
   eqt(tuple(H1, T1), ok) -> F
   eqt(tuple(H1, T1), pending) -> F
   eqt(tuple(H1, T1), release) -> F
   eqt(tuple(H1, T1), request) -> F
   eqt(tuple(H1, T1), resource) -> F
   eqt(tuple(H1, T1), tag) -> F
   eqt(tuple(H1, T1), true) -> F
   eqt(tuple(H1, T1), undefined) -> F
   eqt(tuple(H1, T1), pid(N2)) -> F
   eqt(tuple(H1, T1), int(N2)) -> F
   eqt(tuple(H1, T1), cons(H2, T2)) -> F
   eqt(tuple(H1, T1), tuple(H2, T2)) -> and(eqt(H1, H2), eqt(T1, T2))
   eqt(tuple(H1, T1), tuplenil(H2)) -> F
   eqt(tuplenil(H1), nil) -> F
   eqt(tuplenil(H1), a) -> F
   eqt(tuplenil(H1), excl) -> F
   eqt(tuplenil(H1), false) -> F
   eqt(tuplenil(H1), lock) -> F
   eqt(tuplenil(H1), locker) -> F
   eqt(tuplenil(H1), mcrlrecord) -> F
   eqt(tuplenil(H1), ok) -> F
   eqt(tuplenil(H1), pending) -> F
   eqt(tuplenil(H1), release) -> F
   eqt(tuplenil(H1), request) -> F
   eqt(tuplenil(H1), resource) -> F
   eqt(tuplenil(H1), tag) -> F
   eqt(tuplenil(H1), true) -> F
   eqt(tuplenil(H1), undefined) -> F
   eqt(tuplenil(H1), pid(N2)) -> F
   eqt(tuplenil(H1), int(N2)) -> F
   eqt(tuplenil(H1), cons(H2, T2)) -> F
   eqt(tuplenil(H1), tuple(H2, T2)) -> F
   eqt(tuplenil(H1), tuplenil(H2)) -> eqt(H1, H2)
   element(int(s(0)), tuplenil(T1)) -> T1
   element(int(s(0)), tuple(T1, T2)) -> T1
   element(int(s(s(N1))), tuple(T1, T2)) -> element(int(s(N1)), T2)
   record_new(lock) -> tuple(mcrlrecord, tuple(lock, tuple(undefined, tuple(nil, tuplenil(nil)))))
   record_extract(tuple(mcrlrecord, tuple(lock, tuple(F0, tuple(F1, tuplenil(F2))))), lock, resource) -> tuple(mcrlrecord, tuple(lock, tuple(F0, tuple(F1, tuplenil(F2)))))
   record_update(tuple(mcrlrecord, tuple(lock, tuple(F0, tuple(F1, tuplenil(F2))))), lock, pending, NewF) -> tuple(mcrlrecord, tuple(lock, tuple(F0, tuple(F1, tuplenil(NewF)))))
   record_updates(Record, Name, nil) -> Record
   record_updates(Record, Name, cons(tuple(Field, tuplenil(NewF)), Fields)) -> record_updates(record_update(Record, Name, Field, NewF), Name, Fields)
   locker2_map_promote_pending(nil, Pending) -> nil
   locker2_map_promote_pending(cons(Lock, Locks), Pending) -> cons(locker2_promote_pending(Lock, Pending), locker2_map_promote_pending(Locks, Pending))
   locker2_map_claim_lock(nil, Resources, Client) -> nil
   locker2_map_claim_lock(cons(Lock, Locks), Resources, Client) -> cons(locker2_claim_lock(Lock, Resources, Client), locker2_map_claim_lock(Locks, Resources, Client))
   locker2_map_add_pending(nil, Resources, Client) -> nil
   locker2_promote_pending(Lock, Client) -> case0(Client, Lock, record_extract(Lock, lock, pending))
   case0(Client, Lock, cons(Client, Pendings)) -> record_updates(Lock, lock, cons(tuple(excl, tuplenil(Client)), cons(tuple(pending, tuplenil(Pendings)), nil)))
   case0(Client, Lock, MCRLFree0) -> Lock
   locker2_remove_pending(Lock, Client) -> record_updates(Lock, lock, cons(tuple(pending, tuplenil(subtract(record_extract(Lock, lock, pending), cons(Client, nil)))), nil))
   locker2_add_pending(Lock, Resources, Client) -> case1(Client, Resources, Lock, member(record_extract(Lock, lock, resource), Resources))
   case1(Client, Resources, Lock, true) -> record_updates(Lock, lock, cons(tuple(pending, tuplenil(append(record_extract(Lock, lock, pending), cons(Client, nil)))), nil))
   case1(Client, Resources, Lock, false) -> Lock
   locker2_release_lock(Lock, Client) -> case2(Client, Lock, gen_modtageq(Client, record_extract(Lock, lock, excl)))
   case2(Client, Lock, true) -> record_updates(Lock, lock, cons(tuple(excllock, excl), nil))
   case4(Client, Lock, MCRLFree1) -> false
   locker2_obtainables(nil, Client) -> true
   locker2_obtainables(cons(Lock, Locks), Client) -> case5(Client, Locks, Lock, member(Client, record_extract(Lock, lock, pending)))
   case5(Client, Locks, Lock, true) -> andt(locker2_obtainable(Lock, Client), locker2_obtainables(Locks, Client))
   case5(Client, Locks, Lock, false) -> locker2_obtainables(Locks, Client)
   locker2_check_available(Resource, nil) -> false
   locker2_check_available(Resource, cons(Lock, Locks)) -> case6(Locks, Lock, Resource, equal(Resource, record_extract(Lock, lock, resource)))
   case6(Locks, Lock, Resource, true) -> andt(equal(record_extract(Lock, lock, excl), nil), equal(record_extract(Lock, lock, pending), nil))
   case6(Locks, Lock, Resource, false) -> locker2_check_available(Resource, Locks)
   locker2_check_availables(nil, Locks) -> true
   locker2_check_availables(cons(Resource, Resources), Locks) -> andt(locker2_check_available(Resource, Locks), locker2_check_availables(Resources, Locks))
   locker2_adduniq(nil, List) -> List
   append(cons(Head, Tail), List) -> cons(Head, append(Tail, List))
   subtract(List, nil) -> List
   subtract(List, cons(Head, Tail)) -> subtract(delete(Head, List), Tail)
   delete(E, nil) -> nil
   delete(E, cons(Head, Tail)) -> case8(Tail, Head, E, equal(E, Head))
   case8(Tail, Head, E, true) -> Tail
   case8(Tail, Head, E, false) -> cons(Head, delete(E, Tail))
   gen_tag(Pid) -> tuple(Pid, tuplenil(tag))
   gen_modtageq(Client1, Client2) -> equal(Client1, Client2)
   member(E, nil) -> false
   member(E, cons(Head, Tail)) -> case9(Tail, Head, E, equal(E, Head))
   case9(Tail, Head, E, true) -> true
   case9(Tail, Head, E, false) -> member(E, Tail)
   eqs(empty, empty) -> T
   eqs(empty, stack(E2, S2)) -> F
   eqs(stack(E1, S1), empty) -> F
   eqs(stack(E1, S1), stack(E2, S2)) -> and(eqt(E1, E2), eqs(S1, S2))
   pushs(E1, S1) -> stack(E1, S1)
   pops(stack(E1, S1)) -> S1
   tops(stack(E1, S1)) -> E1
   istops(E1, empty) -> F
   istops(E1, stack(E2, S1)) -> eqt(E1, E2)
   eqc(nocalls, nocalls) -> T
   eqc(nocalls, calls(E2, S2, CS2)) -> F
   eqc(calls(E1, S1, CS1), nocalls) -> F
   eqc(calls(E1, S1, CS1), calls(E2, S2, CS2)) -> and(eqt(E1, E2), and(eqs(S1, S2), eqc(CS1, CS2)))
   push(E1, E2, nocalls) -> calls(E1, stack(E2, empty), nocalls)
   push(E1, E2, calls(E3, S1, CS1)) -> push1(E1, E2, E3, S1, CS1, eqt(E1, E3))
   push1(E1, E2, E3, S1, CS1, T) -> calls(E3, pushs(E2, S1), CS1)

Q is empty.

----------------------------------------

(1) QTRSRRRProof (EQUIVALENT)
Used ordering:
or/2(YES,YES)
T/0)
F/0)
and/2(YES,YES)
imp/2(YES,YES)
not/1(YES)
if/3(YES,YES,YES)
eq/2(YES,YES)
eqt/2(YES,YES)
nil/0)
undefined/0)
pid/1)YES(
int/1)YES(
cons/2(YES,YES)
tuple/2(YES,YES)
tuplenil/1)YES(
a/0)
excl/0)
false/0)
lock/0)
locker/0)
mcrlrecord/0)
ok/0)
pending/0)
release/0)
request/0)
resource/0)
tag/0)
true/0)
element/2(YES,YES)
s/1)YES(
0/0)
record_new/1(YES)
record_extract/3(YES,YES,YES)
record_update/4(YES,YES,YES,YES)
record_updates/3(YES,YES,YES)
locker2_map_promote_pending/2(YES,YES)
locker2_promote_pending/2(YES,YES)
locker2_map_claim_lock/3(YES,YES,YES)
locker2_claim_lock/3(YES,YES,YES)
locker2_map_add_pending/3(YES,YES,YES)
case0/3(YES,YES,YES)
locker2_remove_pending/2(YES,YES)
subtract/2(YES,YES)
locker2_add_pending/3(YES,YES,YES)
case1/4(YES,YES,YES,YES)
member/2(YES,YES)
append/2(YES,YES)
locker2_release_lock/2(YES,YES)
case2/3(YES,YES,YES)
gen_modtageq/2(YES,YES)
excllock/0)
case4/3(YES,YES,YES)
locker2_obtainables/2(YES,YES)
case5/4(YES,YES,YES,YES)
andt/2(YES,YES)
locker2_obtainable/2(YES,YES)
locker2_check_available/2(YES,YES)
case6/4(YES,YES,YES,YES)
equal/2(YES,YES)
locker2_check_availables/2(YES,YES)
locker2_adduniq/2(YES,YES)
delete/2(YES,YES)
case8/4(YES,YES,YES,YES)
gen_tag/1(YES)
case9/4(YES,YES,YES,YES)
eqs/2(YES,YES)
empty/0)
stack/2(YES,YES)
pushs/2(YES,YES)
pops/1)YES(
tops/1)YES(
istops/2(YES,YES)
eqc/2(YES,YES)
nocalls/0)
calls/3(YES,YES,YES)
push/3(YES,YES,YES)
push1/6(YES,YES,YES,YES,YES,YES)

Quasi precedence:
imp_2 > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > record_updates_3 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
imp_2 > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > andt_2
imp_2 > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > calls_3 > and_2 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
eq_2 > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > record_updates_3 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
eq_2 > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > andt_2
eq_2 > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > calls_3 > and_2 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
[undefined, mcrlrecord, record_new_1] > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > record_updates_3 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
[undefined, mcrlrecord, record_new_1] > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > andt_2
[undefined, mcrlrecord, record_new_1] > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > calls_3 > and_2 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
a > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > record_updates_3 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
a > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > andt_2
a > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > calls_3 > and_2 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
locker > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > record_updates_3 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
locker > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > andt_2
locker > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > calls_3 > and_2 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
ok > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
[true, locker2_obtainables_2, case5_4, locker2_check_available_2, case6_4, locker2_check_availables_2] > excl > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > record_updates_3 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
[true, locker2_obtainables_2, case5_4, locker2_check_available_2, case6_4, locker2_check_availables_2] > excl > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > andt_2
[true, locker2_obtainables_2, case5_4, locker2_check_available_2, case6_4, locker2_check_availables_2] > excl > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > calls_3 > and_2 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
[true, locker2_obtainables_2, case5_4, locker2_check_available_2, case6_4, locker2_check_availables_2] > record_extract_3 > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > record_updates_3 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
[true, locker2_obtainables_2, case5_4, locker2_check_available_2, case6_4, locker2_check_availables_2] > record_extract_3 > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > andt_2
[true, locker2_obtainables_2, case5_4, locker2_check_available_2, case6_4, locker2_check_availables_2] > record_extract_3 > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > calls_3 > and_2 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
[true, locker2_obtainables_2, case5_4, locker2_check_available_2, case6_4, locker2_check_availables_2] > append_2 > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > record_updates_3 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
[true, locker2_obtainables_2, case5_4, locker2_check_available_2, case6_4, locker2_check_availables_2] > append_2 > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > andt_2
[true, locker2_obtainables_2, case5_4, locker2_check_available_2, case6_4, locker2_check_availables_2] > append_2 > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > calls_3 > and_2 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
[true, locker2_obtainables_2, case5_4, locker2_check_available_2, case6_4, locker2_check_availables_2] > excllock
[true, locker2_obtainables_2, case5_4, locker2_check_available_2, case6_4, locker2_check_availables_2] > locker2_obtainable_2
locker2_map_promote_pending_2 > locker2_promote_pending_2 > record_extract_3 > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > record_updates_3 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
locker2_map_promote_pending_2 > locker2_promote_pending_2 > record_extract_3 > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > andt_2
locker2_map_promote_pending_2 > locker2_promote_pending_2 > record_extract_3 > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > calls_3 > and_2 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
locker2_map_promote_pending_2 > locker2_promote_pending_2 > case0_3 > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > record_updates_3 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
locker2_map_promote_pending_2 > locker2_promote_pending_2 > case0_3 > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > andt_2
locker2_map_promote_pending_2 > locker2_promote_pending_2 > case0_3 > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > calls_3 > and_2 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
locker2_map_promote_pending_2 > locker2_promote_pending_2 > case0_3 > excl > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > record_updates_3 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
locker2_map_promote_pending_2 > locker2_promote_pending_2 > case0_3 > excl > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > andt_2
locker2_map_promote_pending_2 > locker2_promote_pending_2 > case0_3 > excl > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > calls_3 > and_2 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
[locker2_map_claim_lock_3, locker2_claim_lock_3] > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > record_updates_3 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
[locker2_map_claim_lock_3, locker2_claim_lock_3] > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > andt_2
[locker2_map_claim_lock_3, locker2_claim_lock_3] > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > calls_3 > and_2 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
locker2_remove_pending_2 > record_extract_3 > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > record_updates_3 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
locker2_remove_pending_2 > record_extract_3 > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > andt_2
locker2_remove_pending_2 > record_extract_3 > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > calls_3 > and_2 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
locker2_add_pending_3 > case1_4 > record_extract_3 > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > record_updates_3 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
locker2_add_pending_3 > case1_4 > record_extract_3 > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > andt_2
locker2_add_pending_3 > case1_4 > record_extract_3 > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > calls_3 > and_2 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
locker2_add_pending_3 > case1_4 > append_2 > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > record_updates_3 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
locker2_add_pending_3 > case1_4 > append_2 > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > andt_2
locker2_add_pending_3 > case1_4 > append_2 > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > calls_3 > and_2 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
locker2_release_lock_2 > excl > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > record_updates_3 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
locker2_release_lock_2 > excl > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > andt_2
locker2_release_lock_2 > excl > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > calls_3 > and_2 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
locker2_release_lock_2 > record_extract_3 > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > record_updates_3 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
locker2_release_lock_2 > record_extract_3 > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > andt_2
locker2_release_lock_2 > record_extract_3 > [nil, lock, pending, resource, subtract_2, delete_2, case8_4] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > calls_3 > and_2 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
locker2_release_lock_2 > case2_3 > record_updates_3 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
locker2_release_lock_2 > gen_modtageq_2 > equal_2
case4_3 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
gen_tag_1 > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > record_updates_3 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
gen_tag_1 > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > andt_2
gen_tag_1 > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > calls_3 > and_2 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
push_3 > empty > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > record_updates_3 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
push_3 > empty > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > andt_2
push_3 > empty > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > calls_3 > and_2 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
push_3 > nocalls > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
push_3 > push1_6 > [stack_2, pushs_2] > [eqs_2, eqc_2] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > record_updates_3 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2
push_3 > push1_6 > [stack_2, pushs_2] > [eqs_2, eqc_2] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > andt_2
push_3 > push1_6 > [stack_2, pushs_2] > [eqs_2, eqc_2] > [T, not_1, eqt_2, cons_2, request, tag, istops_2] > calls_3 > and_2 > [F, tuple_2, false, release, record_update_4, member_2, case9_4] > equal_2


Status:
or_2: [2,1]
T: multiset status
F: multiset status
and_2: multiset status
imp_2: [2,1]
not_1: [1]
if_3: multiset status
eq_2: [2,1]
eqt_2: multiset status
nil: multiset status
undefined: multiset status
cons_2: multiset status
tuple_2: [1,2]
a: multiset status
excl: multiset status
false: multiset status
lock: multiset status
locker: multiset status
mcrlrecord: multiset status
ok: multiset status
pending: multiset status
release: multiset status
request: multiset status
resource: multiset status
tag: multiset status
true: multiset status
element_2: [1,2]
0: multiset status
record_new_1: [1]
record_extract_3: [2,1,3]
record_update_4: [1,2,4,3]
record_updates_3: [3,1,2]
locker2_map_promote_pending_2: multiset status
locker2_promote_pending_2: multiset status
locker2_map_claim_lock_3: multiset status
locker2_claim_lock_3: multiset status
locker2_map_add_pending_3: multiset status
case0_3: multiset status
locker2_remove_pending_2: [1,2]
subtract_2: [2,1]
locker2_add_pending_3: multiset status
case1_4: multiset status
member_2: [2,1]
append_2: multiset status
locker2_release_lock_2: multiset status
case2_3: [1,3,2]
gen_modtageq_2: multiset status
excllock: multiset status
case4_3: [3,2,1]
locker2_obtainables_2: [1,2]
case5_4: [2,1,4,3]
andt_2: multiset status
locker2_obtainable_2: [2,1]
locker2_check_available_2: [1,2]
case6_4: [3,1,2,4]
equal_2: [1,2]
locker2_check_availables_2: [1,2]
locker2_adduniq_2: multiset status
delete_2: [1,2]
case8_4: [3,1,4,2]
gen_tag_1: multiset status
case9_4: [1,3,2,4]
eqs_2: multiset status
empty: multiset status
stack_2: multiset status
pushs_2: multiset status
istops_2: multiset status
eqc_2: multiset status
nocalls: multiset status
calls_3: [2,1,3]
push_3: multiset status
push1_6: multiset status

With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   or(T, T) -> T
   or(F, T) -> T
   or(T, F) -> T
   or(F, F) -> F
   and(T, B) -> B
   and(B, T) -> B
   and(F, B) -> F
   and(B, F) -> F
   imp(T, B) -> B
   imp(F, B) -> T
   not(T) -> F
   not(F) -> T
   if(T, B1, B2) -> B1
   if(F, B1, B2) -> B2
   eq(T, T) -> T
   eq(F, F) -> T
   eq(T, F) -> F
   eq(F, T) -> F
   eqt(nil, undefined) -> F
   eqt(nil, pid(N2)) -> F
   eqt(nil, int(N2)) -> F
   eqt(nil, cons(H2, T2)) -> F
   eqt(nil, tuple(H2, T2)) -> F
   eqt(nil, tuplenil(H2)) -> F
   eqt(a, nil) -> F
   eqt(a, a) -> T
   eqt(a, excl) -> F
   eqt(a, false) -> F
   eqt(a, lock) -> F
   eqt(a, locker) -> F
   eqt(a, mcrlrecord) -> F
   eqt(a, ok) -> F
   eqt(a, pending) -> F
   eqt(a, release) -> F
   eqt(a, request) -> F
   eqt(a, resource) -> F
   eqt(a, tag) -> F
   eqt(a, true) -> F
   eqt(a, undefined) -> F
   eqt(a, pid(N2)) -> F
   eqt(a, int(N2)) -> F
   eqt(a, cons(H2, T2)) -> F
   eqt(a, tuple(H2, T2)) -> F
   eqt(a, tuplenil(H2)) -> F
   eqt(excl, nil) -> F
   eqt(excl, a) -> F
   eqt(excl, excl) -> T
   eqt(excl, false) -> F
   eqt(excl, lock) -> F
   eqt(excl, locker) -> F
   eqt(excl, mcrlrecord) -> F
   eqt(excl, ok) -> F
   eqt(excl, pending) -> F
   eqt(excl, release) -> F
   eqt(excl, request) -> F
   eqt(excl, resource) -> F
   eqt(excl, tag) -> F
   eqt(excl, true) -> F
   eqt(excl, undefined) -> F
   eqt(excl, pid(N2)) -> F
   eqt(excl, eqt(false, int(N2))) -> F
   eqt(false, cons(H2, T2)) -> F
   eqt(false, tuple(H2, T2)) -> F
   eqt(false, tuplenil(H2)) -> F
   eqt(lock, nil) -> F
   eqt(lock, a) -> F
   eqt(lock, excl) -> F
   eqt(lock, false) -> F
   eqt(lock, lock) -> T
   eqt(lock, locker) -> F
   eqt(lock, mcrlrecord) -> F
   eqt(lock, ok) -> F
   eqt(lock, pending) -> F
   eqt(lock, release) -> F
   eqt(lock, request) -> F
   eqt(lock, resource) -> F
   eqt(lock, tag) -> F
   eqt(lock, true) -> F
   eqt(lock, undefined) -> F
   eqt(lock, pid(N2)) -> F
   eqt(lock, int(N2)) -> F
   eqt(lock, cons(H2, T2)) -> F
   eqt(lock, tuple(H2, T2)) -> F
   eqt(lock, tuplenil(H2)) -> F
   eqt(locker, nil) -> F
   eqt(locker, a) -> F
   eqt(locker, excl) -> F
   eqt(locker, false) -> F
   eqt(locker, lock) -> F
   eqt(locker, locker) -> T
   eqt(locker, mcrlrecord) -> F
   eqt(locker, ok) -> F
   eqt(locker, pending) -> F
   eqt(locker, release) -> F
   eqt(locker, request) -> F
   eqt(locker, resource) -> F
   eqt(locker, tag) -> F
   eqt(locker, true) -> F
   eqt(locker, undefined) -> F
   eqt(locker, pid(N2)) -> F
   eqt(locker, int(N2)) -> F
   eqt(locker, cons(H2, T2)) -> F
   eqt(locker, tuple(H2, T2)) -> F
   eqt(locker, tuplenil(H2)) -> F
   eqt(mcrlrecord, nil) -> F
   eqt(mcrlrecord, a) -> F
   eqt(mcrlrecord, excl) -> F
   eqt(mcrlrecord, false) -> F
   eqt(mcrlrecord, lock) -> F
   eqt(mcrlrecord, locker) -> F
   eqt(mcrlrecord, mcrlrecord) -> T
   eqt(mcrlrecord, ok) -> F
   eqt(mcrlrecord, pending) -> F
   eqt(mcrlrecord, release) -> F
   eqt(mcrlrecord, request) -> F
   eqt(mcrlrecord, resource) -> F
   eqt(ok, resource) -> F
   eqt(ok, tag) -> F
   eqt(ok, true) -> F
   eqt(ok, undefined) -> F
   eqt(ok, pid(N2)) -> F
   eqt(ok, int(N2)) -> F
   eqt(ok, cons(H2, T2)) -> F
   eqt(ok, tuple(H2, T2)) -> F
   eqt(ok, tuplenil(H2)) -> F
   eqt(pending, nil) -> F
   eqt(pending, a) -> F
   eqt(pending, excl) -> F
   eqt(pending, false) -> F
   eqt(pending, lock) -> F
   eqt(pending, locker) -> F
   eqt(pending, mcrlrecord) -> F
   eqt(pending, ok) -> F
   eqt(pending, pending) -> T
   eqt(pending, release) -> F
   eqt(pending, request) -> F
   eqt(pending, resource) -> F
   eqt(pending, tag) -> F
   eqt(pending, true) -> F
   eqt(pending, undefined) -> F
   eqt(pending, pid(N2)) -> F
   eqt(pending, int(N2)) -> F
   eqt(pending, cons(H2, T2)) -> F
   eqt(pending, tuple(H2, T2)) -> F
   eqt(pending, tuplenil(H2)) -> F
   eqt(release, nil) -> F
   eqt(release, a) -> F
   eqt(release, excl) -> F
   eqt(release, false) -> F
   eqt(release, lock) -> F
   eqt(release, locker) -> F
   eqt(release, mcrlrecord) -> F
   eqt(release, ok) -> F
   eqt(request, mcrlrecord) -> F
   eqt(request, ok) -> F
   eqt(request, pending) -> F
   eqt(request, release) -> F
   eqt(request, request) -> T
   eqt(request, resource) -> F
   eqt(request, tag) -> F
   eqt(request, true) -> F
   eqt(request, undefined) -> F
   eqt(request, pid(N2)) -> F
   eqt(request, int(N2)) -> F
   eqt(request, cons(H2, T2)) -> F
   eqt(request, tuple(H2, T2)) -> F
   eqt(request, tuplenil(H2)) -> F
   eqt(resource, nil) -> F
   eqt(resource, a) -> F
   eqt(resource, excl) -> F
   eqt(resource, false) -> F
   eqt(resource, lock) -> F
   eqt(resource, locker) -> F
   eqt(resource, mcrlrecord) -> F
   eqt(resource, ok) -> F
   eqt(resource, pending) -> F
   eqt(resource, release) -> F
   eqt(resource, request) -> F
   eqt(resource, resource) -> T
   eqt(resource, tag) -> F
   eqt(resource, true) -> F
   eqt(resource, undefined) -> F
   eqt(resource, pid(N2)) -> F
   eqt(resource, int(N2)) -> F
   eqt(resource, cons(H2, T2)) -> F
   eqt(resource, tuple(H2, T2)) -> F
   eqt(resource, tuplenil(H2)) -> F
   eqt(tag, nil) -> F
   eqt(tag, a) -> F
   eqt(tag, excl) -> F
   eqt(tag, false) -> F
   eqt(tag, lock) -> F
   eqt(tag, locker) -> F
   eqt(tag, mcrlrecord) -> F
   eqt(tag, ok) -> F
   eqt(tag, pending) -> F
   eqt(tag, release) -> F
   eqt(tag, request) -> F
   eqt(tag, resource) -> F
   eqt(tag, tag) -> T
   eqt(tag, true) -> F
   eqt(tag, undefined) -> F
   eqt(tag, pid(N2)) -> F
   eqt(tag, int(N2)) -> F
   eqt(tag, cons(H2, T2)) -> F
   eqt(tag, tuple(H2, T2)) -> F
   eqt(tag, tuplenil(H2)) -> F
   eqt(true, nil) -> F
   eqt(true, a) -> F
   eqt(true, excl) -> F
   eqt(true, false) -> F
   eqt(true, lock) -> F
   eqt(true, locker) -> F
   eqt(true, mcrlrecord) -> F
   eqt(true, ok) -> F
   eqt(true, pending) -> F
   eqt(true, release) -> F
   eqt(true, request) -> F
   eqt(true, resource) -> F
   eqt(true, tag) -> F
   eqt(true, true) -> T
   eqt(true, undefined) -> F
   eqt(true, pid(N2)) -> F
   eqt(true, int(N2)) -> F
   eqt(true, cons(H2, T2)) -> F
   eqt(true, tuple(H2, T2)) -> F
   eqt(true, tuplenil(H2)) -> F
   eqt(undefined, nil) -> F
   eqt(undefined, a) -> F
   eqt(undefined, tuplenil(H2)) -> F
   eqt(pid(N1), nil) -> F
   eqt(pid(N1), a) -> F
   eqt(pid(N1), excl) -> F
   eqt(pid(N1), false) -> F
   eqt(pid(N1), lock) -> F
   eqt(pid(N1), locker) -> F
   eqt(pid(N1), mcrlrecord) -> F
   eqt(pid(N1), ok) -> F
   eqt(pid(N1), pending) -> F
   eqt(pid(N1), release) -> F
   eqt(pid(N1), request) -> F
   eqt(pid(N1), resource) -> F
   eqt(pid(N1), tag) -> F
   eqt(pid(N1), true) -> F
   eqt(pid(N1), undefined) -> F
   eqt(pid(N1), int(N2)) -> F
   eqt(pid(N1), cons(H2, T2)) -> F
   eqt(pid(N1), tuple(H2, T2)) -> F
   eqt(pid(N1), tuplenil(H2)) -> F
   eqt(int(N1), nil) -> F
   eqt(int(N1), a) -> F
   eqt(int(N1), excl) -> F
   eqt(int(N1), false) -> F
   eqt(int(N1), lock) -> F
   eqt(int(N1), locker) -> F
   eqt(int(N1), mcrlrecord) -> F
   eqt(int(N1), ok) -> F
   eqt(int(N1), pending) -> F
   eqt(int(N1), release) -> F
   eqt(int(N1), request) -> F
   eqt(int(N1), resource) -> F
   eqt(int(N1), tag) -> F
   eqt(int(N1), true) -> F
   eqt(int(N1), undefined) -> F
   eqt(cons(H1, T1), resource) -> F
   eqt(cons(H1, T1), tag) -> F
   eqt(cons(H1, T1), true) -> F
   eqt(cons(H1, T1), undefined) -> F
   eqt(cons(H1, T1), pid(N2)) -> F
   eqt(cons(H1, T1), int(N2)) -> F
   eqt(cons(H1, T1), cons(H2, T2)) -> and(eqt(H1, H2), eqt(T1, T2))
   eqt(cons(H1, T1), tuple(H2, T2)) -> F
   eqt(cons(H1, T1), tuplenil(H2)) -> F
   eqt(tuple(H1, T1), nil) -> F
   eqt(tuple(H1, T1), a) -> F
   eqt(tuple(H1, T1), excl) -> F
   eqt(tuple(H1, T1), false) -> F
   eqt(tuple(H1, T1), lock) -> F
   eqt(tuple(H1, T1), locker) -> F
   eqt(tuple(H1, T1), mcrlrecord) -> F
   eqt(tuple(H1, T1), ok) -> F
   eqt(tuple(H1, T1), pending) -> F
   eqt(tuple(H1, T1), release) -> F
   eqt(tuple(H1, T1), request) -> F
   eqt(tuple(H1, T1), resource) -> F
   eqt(tuple(H1, T1), tag) -> F
   eqt(tuple(H1, T1), true) -> F
   eqt(tuple(H1, T1), undefined) -> F
   eqt(tuple(H1, T1), pid(N2)) -> F
   eqt(tuple(H1, T1), int(N2)) -> F
   eqt(tuple(H1, T1), cons(H2, T2)) -> F
   eqt(tuple(H1, T1), tuple(H2, T2)) -> and(eqt(H1, H2), eqt(T1, T2))
   eqt(tuple(H1, T1), tuplenil(H2)) -> F
   eqt(tuplenil(H1), nil) -> F
   eqt(tuplenil(H1), a) -> F
   eqt(tuplenil(H1), excl) -> F
   eqt(tuplenil(H1), false) -> F
   eqt(tuplenil(H1), lock) -> F
   eqt(tuplenil(H1), locker) -> F
   eqt(tuplenil(H1), mcrlrecord) -> F
   eqt(tuplenil(H1), ok) -> F
   eqt(tuplenil(H1), pending) -> F
   eqt(tuplenil(H1), release) -> F
   eqt(tuplenil(H1), request) -> F
   eqt(tuplenil(H1), resource) -> F
   eqt(tuplenil(H1), tag) -> F
   eqt(tuplenil(H1), true) -> F
   eqt(tuplenil(H1), undefined) -> F
   eqt(tuplenil(H1), pid(N2)) -> F
   eqt(tuplenil(H1), int(N2)) -> F
   eqt(tuplenil(H1), cons(H2, T2)) -> F
   eqt(tuplenil(H1), tuple(H2, T2)) -> F
   element(int(s(0)), tuplenil(T1)) -> T1
   element(int(s(0)), tuple(T1, T2)) -> T1
   element(int(s(s(N1))), tuple(T1, T2)) -> element(int(s(N1)), T2)
   record_new(lock) -> tuple(mcrlrecord, tuple(lock, tuple(undefined, tuple(nil, tuplenil(nil)))))
   record_extract(tuple(mcrlrecord, tuple(lock, tuple(F0, tuple(F1, tuplenil(F2))))), lock, resource) -> tuple(mcrlrecord, tuple(lock, tuple(F0, tuple(F1, tuplenil(F2)))))
   record_update(tuple(mcrlrecord, tuple(lock, tuple(F0, tuple(F1, tuplenil(F2))))), lock, pending, NewF) -> tuple(mcrlrecord, tuple(lock, tuple(F0, tuple(F1, tuplenil(NewF)))))
   record_updates(Record, Name, nil) -> Record
   record_updates(Record, Name, cons(tuple(Field, tuplenil(NewF)), Fields)) -> record_updates(record_update(Record, Name, Field, NewF), Name, Fields)
   locker2_map_promote_pending(nil, Pending) -> nil
   locker2_map_promote_pending(cons(Lock, Locks), Pending) -> cons(locker2_promote_pending(Lock, Pending), locker2_map_promote_pending(Locks, Pending))
   locker2_map_claim_lock(nil, Resources, Client) -> nil
   locker2_map_claim_lock(cons(Lock, Locks), Resources, Client) -> cons(locker2_claim_lock(Lock, Resources, Client), locker2_map_claim_lock(Locks, Resources, Client))
   locker2_map_add_pending(nil, Resources, Client) -> nil
   locker2_promote_pending(Lock, Client) -> case0(Client, Lock, record_extract(Lock, lock, pending))
   case0(Client, Lock, cons(Client, Pendings)) -> record_updates(Lock, lock, cons(tuple(excl, tuplenil(Client)), cons(tuple(pending, tuplenil(Pendings)), nil)))
   case0(Client, Lock, MCRLFree0) -> Lock
   locker2_remove_pending(Lock, Client) -> record_updates(Lock, lock, cons(tuple(pending, tuplenil(subtract(record_extract(Lock, lock, pending), cons(Client, nil)))), nil))
   locker2_add_pending(Lock, Resources, Client) -> case1(Client, Resources, Lock, member(record_extract(Lock, lock, resource), Resources))
   case1(Client, Resources, Lock, true) -> record_updates(Lock, lock, cons(tuple(pending, tuplenil(append(record_extract(Lock, lock, pending), cons(Client, nil)))), nil))
   case1(Client, Resources, Lock, false) -> Lock
   locker2_release_lock(Lock, Client) -> case2(Client, Lock, gen_modtageq(Client, record_extract(Lock, lock, excl)))
   case2(Client, Lock, true) -> record_updates(Lock, lock, cons(tuple(excllock, excl), nil))
   case4(Client, Lock, MCRLFree1) -> false
   locker2_obtainables(nil, Client) -> true
   locker2_obtainables(cons(Lock, Locks), Client) -> case5(Client, Locks, Lock, member(Client, record_extract(Lock, lock, pending)))
   case5(Client, Locks, Lock, true) -> andt(locker2_obtainable(Lock, Client), locker2_obtainables(Locks, Client))
   case5(Client, Locks, Lock, false) -> locker2_obtainables(Locks, Client)
   locker2_check_available(Resource, nil) -> false
   locker2_check_available(Resource, cons(Lock, Locks)) -> case6(Locks, Lock, Resource, equal(Resource, record_extract(Lock, lock, resource)))
   case6(Locks, Lock, Resource, true) -> andt(equal(record_extract(Lock, lock, excl), nil), equal(record_extract(Lock, lock, pending), nil))
   case6(Locks, Lock, Resource, false) -> locker2_check_available(Resource, Locks)
   locker2_check_availables(nil, Locks) -> true
   locker2_check_availables(cons(Resource, Resources), Locks) -> andt(locker2_check_available(Resource, Locks), locker2_check_availables(Resources, Locks))
   locker2_adduniq(nil, List) -> List
   append(cons(Head, Tail), List) -> cons(Head, append(Tail, List))
   subtract(List, nil) -> List
   subtract(List, cons(Head, Tail)) -> subtract(delete(Head, List), Tail)
   delete(E, nil) -> nil
   delete(E, cons(Head, Tail)) -> case8(Tail, Head, E, equal(E, Head))
   case8(Tail, Head, E, true) -> Tail
   case8(Tail, Head, E, false) -> cons(Head, delete(E, Tail))
   gen_tag(Pid) -> tuple(Pid, tuplenil(tag))
   gen_modtageq(Client1, Client2) -> equal(Client1, Client2)
   member(E, nil) -> false
   member(E, cons(Head, Tail)) -> case9(Tail, Head, E, equal(E, Head))
   case9(Tail, Head, E, true) -> true
   case9(Tail, Head, E, false) -> member(E, Tail)
   eqs(empty, empty) -> T
   eqs(empty, stack(E2, S2)) -> F
   eqs(stack(E1, S1), empty) -> F
   eqs(stack(E1, S1), stack(E2, S2)) -> and(eqt(E1, E2), eqs(S1, S2))
   pops(stack(E1, S1)) -> S1
   tops(stack(E1, S1)) -> E1
   istops(E1, empty) -> F
   istops(E1, stack(E2, S1)) -> eqt(E1, E2)
   eqc(nocalls, nocalls) -> T
   eqc(nocalls, calls(E2, S2, CS2)) -> F
   eqc(calls(E1, S1, CS1), nocalls) -> F
   eqc(calls(E1, S1, CS1), calls(E2, S2, CS2)) -> and(eqt(E1, E2), and(eqs(S1, S2), eqc(CS1, CS2)))
   push(E1, E2, nocalls) -> calls(E1, stack(E2, empty), nocalls)
   push(E1, E2, calls(E3, S1, CS1)) -> push1(E1, E2, E3, S1, CS1, eqt(E1, E3))
   push1(E1, E2, E3, S1, CS1, T) -> calls(E3, pushs(E2, S1), CS1)




----------------------------------------

(2)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   eqt(pid(N1), pid(N2)) -> eqt(N1, N2)
   eqt(tuplenil(H1), tuplenil(H2)) -> eqt(H1, H2)
   pushs(E1, S1) -> stack(E1, S1)

Q is empty.

----------------------------------------

(3) QTRSRRRProof (EQUIVALENT)
Used ordering:
Knuth-Bendix order [KBO] with precedence:tuplenil_1 > pushs_2 > stack_2 > pid_1 > eqt_2

and weight map:

   pid_1=1
   tuplenil_1=0
   pushs_2=0
   stack_2=0
   eqt_2=0

The variable weight is 1With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   eqt(pid(N1), pid(N2)) -> eqt(N1, N2)
   eqt(tuplenil(H1), tuplenil(H2)) -> eqt(H1, H2)
   pushs(E1, S1) -> stack(E1, S1)




----------------------------------------

(4)
Obligation:
Q restricted rewrite system:
R is empty.
Q is empty.

----------------------------------------

(5) RisEmptyProof (EQUIVALENT)
The TRS R is empty. Hence, termination is trivially proven.
----------------------------------------

(6)
YES
