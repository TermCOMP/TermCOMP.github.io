NO

Problem 1: 

(VAR vu95NonEmpty X Y Z)
(RULES
fcons(X,Z) -> cons(X,Z)
first(num0,Z) -> nil
first(s(X),cons(Y,Z)) -> cons(Y,first(X,Z))
first1(num0,Z) -> nil1
first1(s(X),cons(Y,Z)) -> cons1(quote(Y),first1(X,Z))
from(X) -> cons(X,from(s(X)))
quote(sel(X,Z)) -> sel1(X,Z)
quote(num0) -> num01
quote(s(X)) -> s1(quote(X))
quote1(first(X,Z)) -> first1(X,Z)
quote1(cons(X,Z)) -> cons1(quote(X),quote1(Z))
quote1(nil) -> nil1
sel(num0,cons(X,Z)) -> X
sel(s(X),cons(Y,Z)) -> sel(X,Z)
sel1(num0,cons(X,Z)) -> quote(X)
sel1(s(X),cons(Y,Z)) -> sel1(X,Z)
unquote(num01) -> num0
unquote(s1(X)) -> s(unquote(X))
unquote1(cons1(X,Z)) -> fcons(unquote(X),unquote1(Z))
unquote1(nil1) -> nil
)


Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 FIRST(s(X),cons(Y,Z)) -> FIRST(X,Z)
 FIRST1(s(X),cons(Y,Z)) -> FIRST1(X,Z)
 FIRST1(s(X),cons(Y,Z)) -> QUOTE(Y)
 FROM(X) -> FROM(s(X))
 QUOTE(sel(X,Z)) -> SEL1(X,Z)
 QUOTE(s(X)) -> QUOTE(X)
 QUOTE1(first(X,Z)) -> FIRST1(X,Z)
 QUOTE1(cons(X,Z)) -> QUOTE(X)
 QUOTE1(cons(X,Z)) -> QUOTE1(Z)
 SEL(s(X),cons(Y,Z)) -> SEL(X,Z)
 SEL1(num0,cons(X,Z)) -> QUOTE(X)
 SEL1(s(X),cons(Y,Z)) -> SEL1(X,Z)
 UNQUOTE(s1(X)) -> UNQUOTE(X)
 UNQUOTE1(cons1(X,Z)) -> FCONS(unquote(X),unquote1(Z))
 UNQUOTE1(cons1(X,Z)) -> UNQUOTE(X)
 UNQUOTE1(cons1(X,Z)) -> UNQUOTE1(Z)
-> Rules:
 fcons(X,Z) -> cons(X,Z)
 first(num0,Z) -> nil
 first(s(X),cons(Y,Z)) -> cons(Y,first(X,Z))
 first1(num0,Z) -> nil1
 first1(s(X),cons(Y,Z)) -> cons1(quote(Y),first1(X,Z))
 from(X) -> cons(X,from(s(X)))
 quote(sel(X,Z)) -> sel1(X,Z)
 quote(num0) -> num01
 quote(s(X)) -> s1(quote(X))
 quote1(first(X,Z)) -> first1(X,Z)
 quote1(cons(X,Z)) -> cons1(quote(X),quote1(Z))
 quote1(nil) -> nil1
 sel(num0,cons(X,Z)) -> X
 sel(s(X),cons(Y,Z)) -> sel(X,Z)
 sel1(num0,cons(X,Z)) -> quote(X)
 sel1(s(X),cons(Y,Z)) -> sel1(X,Z)
 unquote(num01) -> num0
 unquote(s1(X)) -> s(unquote(X))
 unquote1(cons1(X,Z)) -> fcons(unquote(X),unquote1(Z))
 unquote1(nil1) -> nil

Problem 1: 

Infiniteness Processor:
-> Pairs:
 FIRST(s(X),cons(Y,Z)) -> FIRST(X,Z)
 FIRST1(s(X),cons(Y,Z)) -> FIRST1(X,Z)
 FIRST1(s(X),cons(Y,Z)) -> QUOTE(Y)
 FROM(X) -> FROM(s(X))
 QUOTE(sel(X,Z)) -> SEL1(X,Z)
 QUOTE(s(X)) -> QUOTE(X)
 QUOTE1(first(X,Z)) -> FIRST1(X,Z)
 QUOTE1(cons(X,Z)) -> QUOTE(X)
 QUOTE1(cons(X,Z)) -> QUOTE1(Z)
 SEL(s(X),cons(Y,Z)) -> SEL(X,Z)
 SEL1(num0,cons(X,Z)) -> QUOTE(X)
 SEL1(s(X),cons(Y,Z)) -> SEL1(X,Z)
 UNQUOTE(s1(X)) -> UNQUOTE(X)
 UNQUOTE1(cons1(X,Z)) -> FCONS(unquote(X),unquote1(Z))
 UNQUOTE1(cons1(X,Z)) -> UNQUOTE(X)
 UNQUOTE1(cons1(X,Z)) -> UNQUOTE1(Z)
-> Rules:
 fcons(X,Z) -> cons(X,Z)
 first(num0,Z) -> nil
 first(s(X),cons(Y,Z)) -> cons(Y,first(X,Z))
 first1(num0,Z) -> nil1
 first1(s(X),cons(Y,Z)) -> cons1(quote(Y),first1(X,Z))
 from(X) -> cons(X,from(s(X)))
 quote(sel(X,Z)) -> sel1(X,Z)
 quote(num0) -> num01
 quote(s(X)) -> s1(quote(X))
 quote1(first(X,Z)) -> first1(X,Z)
 quote1(cons(X,Z)) -> cons1(quote(X),quote1(Z))
 quote1(nil) -> nil1
 sel(num0,cons(X,Z)) -> X
 sel(s(X),cons(Y,Z)) -> sel(X,Z)
 sel1(num0,cons(X,Z)) -> quote(X)
 sel1(s(X),cons(Y,Z)) -> sel1(X,Z)
 unquote(num01) -> num0
 unquote(s1(X)) -> s(unquote(X))
 unquote1(cons1(X,Z)) -> fcons(unquote(X),unquote1(Z))
 unquote1(nil1) -> nil
-> Pairs in cycle:
 FROM(X) -> FROM(s(X))

The problem is infinite.
