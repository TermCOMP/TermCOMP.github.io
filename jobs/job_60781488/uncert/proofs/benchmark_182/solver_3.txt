YES

Problem 1: 

(VAR vu95NonEmpty m n x y)
(RULES
app(add(n,x),y) -> add(n,app(x,y))
app(nil,y) -> y
head(add(n,x)) -> n
high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
high(n,nil) -> nil
ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
ifu95high(ftrue,n,add(m,x)) -> high(n,x)
ifu95low(ffalse,n,add(m,x)) -> low(n,x)
ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
ifu95qs(ffalse,x,n,y) -> app(quicksort(x),add(n,quicksort(y)))
ifu95qs(ftrue,x,n,y) -> nil
isempty(add(n,x)) -> ffalse
isempty(nil) -> ftrue
le(num0,y) -> ftrue
le(s(x),num0) -> ffalse
le(s(x),s(y)) -> le(x,y)
low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
low(n,nil) -> nil
quicksort(x) -> ifu95qs(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
tail(add(n,x)) -> x
)


Problem 1: 

Innermost Equivalent Processor:
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 ifu95qs(ffalse,x,n,y) -> app(quicksort(x),add(n,quicksort(y)))
 ifu95qs(ftrue,x,n,y) -> nil
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 quicksort(x) -> ifu95qs(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 tail(add(n,x)) -> x
-> The term rewriting system is non-overlaping or locally confluent overlay system. Therefore, innermost termination implies termination.
 

Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 APP(add(n,x),y) -> APP(x,y)
 HIGH(n,add(m,x)) -> IFU95HIGH(le(m,n),n,add(m,x))
 HIGH(n,add(m,x)) -> LE(m,n)
 IFU95HIGH(ffalse,n,add(m,x)) -> HIGH(n,x)
 IFU95HIGH(ftrue,n,add(m,x)) -> HIGH(n,x)
 IFU95LOW(ffalse,n,add(m,x)) -> LOW(n,x)
 IFU95LOW(ftrue,n,add(m,x)) -> LOW(n,x)
 IFU95QS(ffalse,x,n,y) -> APP(quicksort(x),add(n,quicksort(y)))
 IFU95QS(ffalse,x,n,y) -> QUICKSORT(x)
 IFU95QS(ffalse,x,n,y) -> QUICKSORT(y)
 LE(s(x),s(y)) -> LE(x,y)
 LOW(n,add(m,x)) -> IFU95LOW(le(m,n),n,add(m,x))
 LOW(n,add(m,x)) -> LE(m,n)
 QUICKSORT(x) -> HEAD(x)
 QUICKSORT(x) -> HIGH(head(x),tail(x))
 QUICKSORT(x) -> IFU95QS(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 QUICKSORT(x) -> ISEMPTY(x)
 QUICKSORT(x) -> LOW(head(x),tail(x))
 QUICKSORT(x) -> TAIL(x)
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 ifu95qs(ffalse,x,n,y) -> app(quicksort(x),add(n,quicksort(y)))
 ifu95qs(ftrue,x,n,y) -> nil
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 quicksort(x) -> ifu95qs(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 tail(add(n,x)) -> x

Problem 1: 

SCC Processor:
-> Pairs:
 APP(add(n,x),y) -> APP(x,y)
 HIGH(n,add(m,x)) -> IFU95HIGH(le(m,n),n,add(m,x))
 HIGH(n,add(m,x)) -> LE(m,n)
 IFU95HIGH(ffalse,n,add(m,x)) -> HIGH(n,x)
 IFU95HIGH(ftrue,n,add(m,x)) -> HIGH(n,x)
 IFU95LOW(ffalse,n,add(m,x)) -> LOW(n,x)
 IFU95LOW(ftrue,n,add(m,x)) -> LOW(n,x)
 IFU95QS(ffalse,x,n,y) -> APP(quicksort(x),add(n,quicksort(y)))
 IFU95QS(ffalse,x,n,y) -> QUICKSORT(x)
 IFU95QS(ffalse,x,n,y) -> QUICKSORT(y)
 LE(s(x),s(y)) -> LE(x,y)
 LOW(n,add(m,x)) -> IFU95LOW(le(m,n),n,add(m,x))
 LOW(n,add(m,x)) -> LE(m,n)
 QUICKSORT(x) -> HEAD(x)
 QUICKSORT(x) -> HIGH(head(x),tail(x))
 QUICKSORT(x) -> IFU95QS(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 QUICKSORT(x) -> ISEMPTY(x)
 QUICKSORT(x) -> LOW(head(x),tail(x))
 QUICKSORT(x) -> TAIL(x)
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 ifu95qs(ffalse,x,n,y) -> app(quicksort(x),add(n,quicksort(y)))
 ifu95qs(ftrue,x,n,y) -> nil
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 quicksort(x) -> ifu95qs(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 tail(add(n,x)) -> x
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 LE(s(x),s(y)) -> LE(x,y)
->->-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 ifu95qs(ffalse,x,n,y) -> app(quicksort(x),add(n,quicksort(y)))
 ifu95qs(ftrue,x,n,y) -> nil
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 quicksort(x) -> ifu95qs(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 tail(add(n,x)) -> x
->->Cycle:
->->-> Pairs:
 IFU95LOW(ffalse,n,add(m,x)) -> LOW(n,x)
 IFU95LOW(ftrue,n,add(m,x)) -> LOW(n,x)
 LOW(n,add(m,x)) -> IFU95LOW(le(m,n),n,add(m,x))
->->-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 ifu95qs(ffalse,x,n,y) -> app(quicksort(x),add(n,quicksort(y)))
 ifu95qs(ftrue,x,n,y) -> nil
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 quicksort(x) -> ifu95qs(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 tail(add(n,x)) -> x
->->Cycle:
->->-> Pairs:
 HIGH(n,add(m,x)) -> IFU95HIGH(le(m,n),n,add(m,x))
 IFU95HIGH(ffalse,n,add(m,x)) -> HIGH(n,x)
 IFU95HIGH(ftrue,n,add(m,x)) -> HIGH(n,x)
->->-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 ifu95qs(ffalse,x,n,y) -> app(quicksort(x),add(n,quicksort(y)))
 ifu95qs(ftrue,x,n,y) -> nil
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 quicksort(x) -> ifu95qs(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 tail(add(n,x)) -> x
->->Cycle:
->->-> Pairs:
 APP(add(n,x),y) -> APP(x,y)
->->-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 ifu95qs(ffalse,x,n,y) -> app(quicksort(x),add(n,quicksort(y)))
 ifu95qs(ftrue,x,n,y) -> nil
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 quicksort(x) -> ifu95qs(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 tail(add(n,x)) -> x
->->Cycle:
->->-> Pairs:
 IFU95QS(ffalse,x,n,y) -> QUICKSORT(x)
 IFU95QS(ffalse,x,n,y) -> QUICKSORT(y)
 QUICKSORT(x) -> IFU95QS(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
->->-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 ifu95qs(ffalse,x,n,y) -> app(quicksort(x),add(n,quicksort(y)))
 ifu95qs(ftrue,x,n,y) -> nil
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 quicksort(x) -> ifu95qs(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 tail(add(n,x)) -> x


The problem is decomposed in 5 subproblems.

Problem 1.1: 

Subterm Processor:
-> Pairs:
 LE(s(x),s(y)) -> LE(x,y)
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 ifu95qs(ffalse,x,n,y) -> app(quicksort(x),add(n,quicksort(y)))
 ifu95qs(ftrue,x,n,y) -> nil
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 quicksort(x) -> ifu95qs(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 tail(add(n,x)) -> x
->Projection:
 pi(LE) = 1

Problem 1.1: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 ifu95qs(ffalse,x,n,y) -> app(quicksort(x),add(n,quicksort(y)))
 ifu95qs(ftrue,x,n,y) -> nil
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 quicksort(x) -> ifu95qs(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 tail(add(n,x)) -> x
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2: 

Subterm Processor:
-> Pairs:
 IFU95LOW(ffalse,n,add(m,x)) -> LOW(n,x)
 IFU95LOW(ftrue,n,add(m,x)) -> LOW(n,x)
 LOW(n,add(m,x)) -> IFU95LOW(le(m,n),n,add(m,x))
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 ifu95qs(ffalse,x,n,y) -> app(quicksort(x),add(n,quicksort(y)))
 ifu95qs(ftrue,x,n,y) -> nil
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 quicksort(x) -> ifu95qs(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 tail(add(n,x)) -> x
->Projection:
 pi(IFU95LOW) = 3
 pi(LOW) = 2

Problem 1.2: 

SCC Processor:
-> Pairs:
 LOW(n,add(m,x)) -> IFU95LOW(le(m,n),n,add(m,x))
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 ifu95qs(ffalse,x,n,y) -> app(quicksort(x),add(n,quicksort(y)))
 ifu95qs(ftrue,x,n,y) -> nil
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 quicksort(x) -> ifu95qs(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 tail(add(n,x)) -> x
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.3: 

Subterm Processor:
-> Pairs:
 HIGH(n,add(m,x)) -> IFU95HIGH(le(m,n),n,add(m,x))
 IFU95HIGH(ffalse,n,add(m,x)) -> HIGH(n,x)
 IFU95HIGH(ftrue,n,add(m,x)) -> HIGH(n,x)
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 ifu95qs(ffalse,x,n,y) -> app(quicksort(x),add(n,quicksort(y)))
 ifu95qs(ftrue,x,n,y) -> nil
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 quicksort(x) -> ifu95qs(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 tail(add(n,x)) -> x
->Projection:
 pi(HIGH) = 2
 pi(IFU95HIGH) = 3

Problem 1.3: 

SCC Processor:
-> Pairs:
 HIGH(n,add(m,x)) -> IFU95HIGH(le(m,n),n,add(m,x))
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 ifu95qs(ffalse,x,n,y) -> app(quicksort(x),add(n,quicksort(y)))
 ifu95qs(ftrue,x,n,y) -> nil
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 quicksort(x) -> ifu95qs(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 tail(add(n,x)) -> x
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.4: 

Subterm Processor:
-> Pairs:
 APP(add(n,x),y) -> APP(x,y)
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 ifu95qs(ffalse,x,n,y) -> app(quicksort(x),add(n,quicksort(y)))
 ifu95qs(ftrue,x,n,y) -> nil
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 quicksort(x) -> ifu95qs(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 tail(add(n,x)) -> x
->Projection:
 pi(APP) = 1

Problem 1.4: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 ifu95qs(ffalse,x,n,y) -> app(quicksort(x),add(n,quicksort(y)))
 ifu95qs(ftrue,x,n,y) -> nil
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 quicksort(x) -> ifu95qs(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 tail(add(n,x)) -> x
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.5: 

Reduction Pairs Processor:
-> Pairs:
 IFU95QS(ffalse,x,n,y) -> QUICKSORT(x)
 IFU95QS(ffalse,x,n,y) -> QUICKSORT(y)
 QUICKSORT(x) -> IFU95QS(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 ifu95qs(ffalse,x,n,y) -> app(quicksort(x),add(n,quicksort(y)))
 ifu95qs(ftrue,x,n,y) -> nil
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 quicksort(x) -> ifu95qs(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 tail(add(n,x)) -> x
-> Usable rules:
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 tail(add(n,x)) -> x
->Interpretation type:
 Linear
->Coefficients:
 All rationals
->Dimension:
 1
->Bound:
 4
->Interpretation:
 
[app](X1,X2) = 0
[head](X) = 3.X
[high](X1,X2) = 4/3.X2
[ifu95high](X1,X2,X3) = 4/3.X3
[ifu95low](X1,X2,X3) = X3
[ifu95qs](X1,X2,X3,X4) = 0
[isempty](X) = 1/4.X
[le](X1,X2) = 1/2
[low](X1,X2) = X2
[quicksort](X) = 0
[tail](X) = 1/4.X
[num0] = 0
[add](X1,X2) = 3.X1 + 4.X2 + 4
[fSNonEmpty] = 0
[ffalse] = 1/2
[nil] = 3
[s](X) = 3.X + 3/4
[ftrue] = 0
[APP](X1,X2) = 0
[HEAD](X) = 0
[HIGH](X1,X2) = 0
[IFU95HIGH](X1,X2,X3) = 0
[IFU95LOW](X1,X2,X3) = 0
[IFU95QS](X1,X2,X3,X4) = 1/3.X1 + 1/3.X2 + 1/4.X4 + 1/3
[ISEMPTY](X) = 0
[LE](X1,X2) = 0
[LOW](X1,X2) = 0
[QUICKSORT](X) = 1/4.X + 1/3
[TAIL](X) = 0

Problem 1.5: 

SCC Processor:
-> Pairs:
 IFU95QS(ffalse,x,n,y) -> QUICKSORT(y)
 QUICKSORT(x) -> IFU95QS(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 ifu95qs(ffalse,x,n,y) -> app(quicksort(x),add(n,quicksort(y)))
 ifu95qs(ftrue,x,n,y) -> nil
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 quicksort(x) -> ifu95qs(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 tail(add(n,x)) -> x
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 IFU95QS(ffalse,x,n,y) -> QUICKSORT(y)
 QUICKSORT(x) -> IFU95QS(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
->->-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 ifu95qs(ffalse,x,n,y) -> app(quicksort(x),add(n,quicksort(y)))
 ifu95qs(ftrue,x,n,y) -> nil
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 quicksort(x) -> ifu95qs(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 tail(add(n,x)) -> x

Problem 1.5: 

Reduction Pairs Processor:
-> Pairs:
 IFU95QS(ffalse,x,n,y) -> QUICKSORT(y)
 QUICKSORT(x) -> IFU95QS(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 ifu95qs(ffalse,x,n,y) -> app(quicksort(x),add(n,quicksort(y)))
 ifu95qs(ftrue,x,n,y) -> nil
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 quicksort(x) -> ifu95qs(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 tail(add(n,x)) -> x
-> Usable rules:
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 tail(add(n,x)) -> x
->Interpretation type:
 Linear
->Coefficients:
 All rationals
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[app](X1,X2) = 0
[head](X) = X
[high](X1,X2) = X2
[ifu95high](X1,X2,X3) = X3
[ifu95low](X1,X2,X3) = 2.X3 + 2
[ifu95qs](X1,X2,X3,X4) = 0
[isempty](X) = 1/2.X
[le](X1,X2) = 2.X2
[low](X1,X2) = 2.X2 + 2
[quicksort](X) = 0
[tail](X) = 1/2.X
[num0] = 1/2
[add](X1,X2) = X1 + 2.X2 + 2
[fSNonEmpty] = 0
[ffalse] = 1/2
[nil] = 0
[s](X) = X
[ftrue] = 0
[APP](X1,X2) = 0
[HEAD](X) = 0
[HIGH](X1,X2) = 0
[IFU95HIGH](X1,X2,X3) = 0
[IFU95LOW](X1,X2,X3) = 0
[IFU95QS](X1,X2,X3,X4) = 2.X1 + 2.X4 + 2
[ISEMPTY](X) = 0
[LE](X1,X2) = 0
[LOW](X1,X2) = 0
[QUICKSORT](X) = 2.X + 2
[TAIL](X) = 0

Problem 1.5: 

SCC Processor:
-> Pairs:
 QUICKSORT(x) -> IFU95QS(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 head(add(n,x)) -> n
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 ifu95qs(ffalse,x,n,y) -> app(quicksort(x),add(n,quicksort(y)))
 ifu95qs(ftrue,x,n,y) -> nil
 isempty(add(n,x)) -> ffalse
 isempty(nil) -> ftrue
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 quicksort(x) -> ifu95qs(isempty(x),low(head(x),tail(x)),head(x),high(head(x),tail(x)))
 tail(add(n,x)) -> x
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
