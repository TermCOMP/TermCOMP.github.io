NO

Problem 1: 

(VAR vu95NonEmpty f n x xs)
(RULES
app(app(map,f),app(app(cons,x),xs)) -> app(app(cons,app(f,x)),app(app(map,f),xs))
app(app(map,f),nil) -> nil
app(app(f,num0),n) -> app(app(hd,app(app(map,f),app(app(cons,num0),nil))),n)
)


Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 APP(app(map,f),app(app(cons,x),xs)) -> APP(app(cons,app(f,x)),app(app(map,f),xs))
 APP(app(map,f),app(app(cons,x),xs)) -> APP(app(map,f),xs)
 APP(app(map,f),app(app(cons,x),xs)) -> APP(cons,app(f,x))
 APP(app(map,f),app(app(cons,x),xs)) -> APP(f,x)
 APP(app(f,num0),n) -> APP(app(cons,num0),nil)
 APP(app(f,num0),n) -> APP(app(hd,app(app(map,f),app(app(cons,num0),nil))),n)
 APP(app(f,num0),n) -> APP(app(map,f),app(app(cons,num0),nil))
 APP(app(f,num0),n) -> APP(hd,app(app(map,f),app(app(cons,num0),nil)))
-> Rules:
 app(app(map,f),app(app(cons,x),xs)) -> app(app(cons,app(f,x)),app(app(map,f),xs))
 app(app(map,f),nil) -> nil
 app(app(f,num0),n) -> app(app(hd,app(app(map,f),app(app(cons,num0),nil))),n)

Problem 1: 

Infiniteness Processor:
-> Pairs:
 APP(app(map,f),app(app(cons,x),xs)) -> APP(app(cons,app(f,x)),app(app(map,f),xs))
 APP(app(map,f),app(app(cons,x),xs)) -> APP(app(map,f),xs)
 APP(app(map,f),app(app(cons,x),xs)) -> APP(cons,app(f,x))
 APP(app(map,f),app(app(cons,x),xs)) -> APP(f,x)
 APP(app(f,num0),n) -> APP(app(cons,num0),nil)
 APP(app(f,num0),n) -> APP(app(hd,app(app(map,f),app(app(cons,num0),nil))),n)
 APP(app(f,num0),n) -> APP(app(map,f),app(app(cons,num0),nil))
 APP(app(f,num0),n) -> APP(hd,app(app(map,f),app(app(cons,num0),nil)))
-> Rules:
 app(app(map,f),app(app(cons,x),xs)) -> app(app(cons,app(f,x)),app(app(map,f),xs))
 app(app(map,f),nil) -> nil
 app(app(f,num0),n) -> app(app(hd,app(app(map,f),app(app(cons,num0),nil))),n)
-> Pairs in cycle:
 APP(app(f,num0),n) -> APP(app(cons,num0),nil)

The problem is infinite.
