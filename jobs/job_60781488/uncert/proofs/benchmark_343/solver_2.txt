YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/XGRWD.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) DependencyPairsProof [EQUIVALENT, 0 ms]
(2) QDP
(3) DependencyGraphProof [EQUIVALENT, 0 ms]
(4) AND
    (5) QDP
        (6) UsableRulesProof [EQUIVALENT, 0 ms]
        (7) QDP
        (8) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (9) YES
    (10) QDP
        (11) UsableRulesProof [EQUIVALENT, 0 ms]
        (12) QDP
        (13) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (14) YES
    (15) QDP
        (16) UsableRulesProof [EQUIVALENT, 0 ms]
        (17) QDP
        (18) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (19) YES
    (20) QDP
        (21) UsableRulesProof [EQUIVALENT, 0 ms]
        (22) QDP
        (23) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (24) YES
    (25) QDP
        (26) UsableRulesProof [EQUIVALENT, 0 ms]
        (27) QDP
        (28) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (29) YES
    (30) QDP
        (31) UsableRulesProof [EQUIVALENT, 0 ms]
        (32) QDP
        (33) MRRProof [EQUIVALENT, 1 ms]
        (34) QDP
        (35) PisEmptyProof [EQUIVALENT, 0 ms]
        (36) YES
    (37) QDP
        (38) UsableRulesProof [EQUIVALENT, 0 ms]
        (39) QDP
        (40) MRRProof [EQUIVALENT, 6 ms]
        (41) QDP
        (42) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (43) YES
    (44) QDP
        (45) UsableRulesProof [EQUIVALENT, 0 ms]
        (46) QDP
        (47) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (48) YES
    (49) QDP
        (50) UsableRulesProof [EQUIVALENT, 0 ms]
        (51) QDP
        (52) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (53) YES


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   0(#) -> #
   +(x, #) -> x
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(1(x), 0(y)) -> 1(+(x, y))
   +(1(x), 1(y)) -> 0(+(+(x, y), 1(#)))
   +(x, +(y, z)) -> +(+(x, y), z)
   -(x, #) -> x
   -(#, x) -> #
   -(0(x), 0(y)) -> 0(-(x, y))
   -(0(x), 1(y)) -> 1(-(-(x, y), 1(#)))
   -(1(x), 0(y)) -> 1(-(x, y))
   -(1(x), 1(y)) -> 0(-(x, y))
   not(false) -> true
   not(true) -> false
   and(x, true) -> x
   and(x, false) -> false
   if(true, x, y) -> x
   if(false, x, y) -> y
   ge(0(x), 0(y)) -> ge(x, y)
   ge(0(x), 1(y)) -> not(ge(y, x))
   ge(1(x), 0(y)) -> ge(x, y)
   ge(1(x), 1(y)) -> ge(x, y)
   ge(x, #) -> true
   ge(#, 1(x)) -> false
   ge(#, 0(x)) -> ge(#, x)
   val(l(x)) -> x
   val(n(x, y, z)) -> x
   min(l(x)) -> x
   min(n(x, y, z)) -> min(y)
   max(l(x)) -> x
   max(n(x, y, z)) -> max(z)
   bs(l(x)) -> true
   bs(n(x, y, z)) -> and(and(ge(x, max(y)), ge(min(z), x)), and(bs(y), bs(z)))
   size(l(x)) -> 1(#)
   size(n(x, y, z)) -> +(+(size(x), size(y)), 1(#))
   wb(l(x)) -> true
   wb(n(x, y, z)) -> and(if(ge(size(y), size(z)), ge(1(#), -(size(y), size(z))), ge(1(#), -(size(z), size(y)))), and(wb(y), wb(z)))

Q is empty.

----------------------------------------

(1) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(2)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   +^1(0(x), 0(y)) -> 0^1(+(x, y))
   +^1(0(x), 0(y)) -> +^1(x, y)
   +^1(0(x), 1(y)) -> +^1(x, y)
   +^1(1(x), 0(y)) -> +^1(x, y)
   +^1(1(x), 1(y)) -> 0^1(+(+(x, y), 1(#)))
   +^1(1(x), 1(y)) -> +^1(+(x, y), 1(#))
   +^1(1(x), 1(y)) -> +^1(x, y)
   +^1(x, +(y, z)) -> +^1(+(x, y), z)
   +^1(x, +(y, z)) -> +^1(x, y)
   -^1(0(x), 0(y)) -> 0^1(-(x, y))
   -^1(0(x), 0(y)) -> -^1(x, y)
   -^1(0(x), 1(y)) -> -^1(-(x, y), 1(#))
   -^1(0(x), 1(y)) -> -^1(x, y)
   -^1(1(x), 0(y)) -> -^1(x, y)
   -^1(1(x), 1(y)) -> 0^1(-(x, y))
   -^1(1(x), 1(y)) -> -^1(x, y)
   GE(0(x), 0(y)) -> GE(x, y)
   GE(0(x), 1(y)) -> NOT(ge(y, x))
   GE(0(x), 1(y)) -> GE(y, x)
   GE(1(x), 0(y)) -> GE(x, y)
   GE(1(x), 1(y)) -> GE(x, y)
   GE(#, 0(x)) -> GE(#, x)
   MIN(n(x, y, z)) -> MIN(y)
   MAX(n(x, y, z)) -> MAX(z)
   BS(n(x, y, z)) -> AND(and(ge(x, max(y)), ge(min(z), x)), and(bs(y), bs(z)))
   BS(n(x, y, z)) -> AND(ge(x, max(y)), ge(min(z), x))
   BS(n(x, y, z)) -> GE(x, max(y))
   BS(n(x, y, z)) -> MAX(y)
   BS(n(x, y, z)) -> GE(min(z), x)
   BS(n(x, y, z)) -> MIN(z)
   BS(n(x, y, z)) -> AND(bs(y), bs(z))
   BS(n(x, y, z)) -> BS(y)
   BS(n(x, y, z)) -> BS(z)
   SIZE(n(x, y, z)) -> +^1(+(size(x), size(y)), 1(#))
   SIZE(n(x, y, z)) -> +^1(size(x), size(y))
   SIZE(n(x, y, z)) -> SIZE(x)
   SIZE(n(x, y, z)) -> SIZE(y)
   WB(n(x, y, z)) -> AND(if(ge(size(y), size(z)), ge(1(#), -(size(y), size(z))), ge(1(#), -(size(z), size(y)))), and(wb(y), wb(z)))
   WB(n(x, y, z)) -> IF(ge(size(y), size(z)), ge(1(#), -(size(y), size(z))), ge(1(#), -(size(z), size(y))))
   WB(n(x, y, z)) -> GE(size(y), size(z))
   WB(n(x, y, z)) -> SIZE(y)
   WB(n(x, y, z)) -> SIZE(z)
   WB(n(x, y, z)) -> GE(1(#), -(size(y), size(z)))
   WB(n(x, y, z)) -> -^1(size(y), size(z))
   WB(n(x, y, z)) -> GE(1(#), -(size(z), size(y)))
   WB(n(x, y, z)) -> -^1(size(z), size(y))
   WB(n(x, y, z)) -> AND(wb(y), wb(z))
   WB(n(x, y, z)) -> WB(y)
   WB(n(x, y, z)) -> WB(z)

The TRS R consists of the following rules:

   0(#) -> #
   +(x, #) -> x
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(1(x), 0(y)) -> 1(+(x, y))
   +(1(x), 1(y)) -> 0(+(+(x, y), 1(#)))
   +(x, +(y, z)) -> +(+(x, y), z)
   -(x, #) -> x
   -(#, x) -> #
   -(0(x), 0(y)) -> 0(-(x, y))
   -(0(x), 1(y)) -> 1(-(-(x, y), 1(#)))
   -(1(x), 0(y)) -> 1(-(x, y))
   -(1(x), 1(y)) -> 0(-(x, y))
   not(false) -> true
   not(true) -> false
   and(x, true) -> x
   and(x, false) -> false
   if(true, x, y) -> x
   if(false, x, y) -> y
   ge(0(x), 0(y)) -> ge(x, y)
   ge(0(x), 1(y)) -> not(ge(y, x))
   ge(1(x), 0(y)) -> ge(x, y)
   ge(1(x), 1(y)) -> ge(x, y)
   ge(x, #) -> true
   ge(#, 1(x)) -> false
   ge(#, 0(x)) -> ge(#, x)
   val(l(x)) -> x
   val(n(x, y, z)) -> x
   min(l(x)) -> x
   min(n(x, y, z)) -> min(y)
   max(l(x)) -> x
   max(n(x, y, z)) -> max(z)
   bs(l(x)) -> true
   bs(n(x, y, z)) -> and(and(ge(x, max(y)), ge(min(z), x)), and(bs(y), bs(z)))
   size(l(x)) -> 1(#)
   size(n(x, y, z)) -> +(+(size(x), size(y)), 1(#))
   wb(l(x)) -> true
   wb(n(x, y, z)) -> and(if(ge(size(y), size(z)), ge(1(#), -(size(y), size(z))), ge(1(#), -(size(z), size(y)))), and(wb(y), wb(z)))

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(3) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 9 SCCs with 24 less nodes.
----------------------------------------

(4)
Complex Obligation (AND)

----------------------------------------

(5)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MAX(n(x, y, z)) -> MAX(z)

The TRS R consists of the following rules:

   0(#) -> #
   +(x, #) -> x
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(1(x), 0(y)) -> 1(+(x, y))
   +(1(x), 1(y)) -> 0(+(+(x, y), 1(#)))
   +(x, +(y, z)) -> +(+(x, y), z)
   -(x, #) -> x
   -(#, x) -> #
   -(0(x), 0(y)) -> 0(-(x, y))
   -(0(x), 1(y)) -> 1(-(-(x, y), 1(#)))
   -(1(x), 0(y)) -> 1(-(x, y))
   -(1(x), 1(y)) -> 0(-(x, y))
   not(false) -> true
   not(true) -> false
   and(x, true) -> x
   and(x, false) -> false
   if(true, x, y) -> x
   if(false, x, y) -> y
   ge(0(x), 0(y)) -> ge(x, y)
   ge(0(x), 1(y)) -> not(ge(y, x))
   ge(1(x), 0(y)) -> ge(x, y)
   ge(1(x), 1(y)) -> ge(x, y)
   ge(x, #) -> true
   ge(#, 1(x)) -> false
   ge(#, 0(x)) -> ge(#, x)
   val(l(x)) -> x
   val(n(x, y, z)) -> x
   min(l(x)) -> x
   min(n(x, y, z)) -> min(y)
   max(l(x)) -> x
   max(n(x, y, z)) -> max(z)
   bs(l(x)) -> true
   bs(n(x, y, z)) -> and(and(ge(x, max(y)), ge(min(z), x)), and(bs(y), bs(z)))
   size(l(x)) -> 1(#)
   size(n(x, y, z)) -> +(+(size(x), size(y)), 1(#))
   wb(l(x)) -> true
   wb(n(x, y, z)) -> and(if(ge(size(y), size(z)), ge(1(#), -(size(y), size(z))), ge(1(#), -(size(z), size(y)))), and(wb(y), wb(z)))

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(6) UsableRulesProof (EQUIVALENT)
We can use the usable rules and reduction pair processor [LPAR04] with the Ce-compatible extension of the polynomial order that maps every function symbol to the sum of its arguments. Then, we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(7)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MAX(n(x, y, z)) -> MAX(z)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(8) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*MAX(n(x, y, z)) -> MAX(z)
The graph contains the following edges 1 > 1


----------------------------------------

(9)
YES

----------------------------------------

(10)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MIN(n(x, y, z)) -> MIN(y)

The TRS R consists of the following rules:

   0(#) -> #
   +(x, #) -> x
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(1(x), 0(y)) -> 1(+(x, y))
   +(1(x), 1(y)) -> 0(+(+(x, y), 1(#)))
   +(x, +(y, z)) -> +(+(x, y), z)
   -(x, #) -> x
   -(#, x) -> #
   -(0(x), 0(y)) -> 0(-(x, y))
   -(0(x), 1(y)) -> 1(-(-(x, y), 1(#)))
   -(1(x), 0(y)) -> 1(-(x, y))
   -(1(x), 1(y)) -> 0(-(x, y))
   not(false) -> true
   not(true) -> false
   and(x, true) -> x
   and(x, false) -> false
   if(true, x, y) -> x
   if(false, x, y) -> y
   ge(0(x), 0(y)) -> ge(x, y)
   ge(0(x), 1(y)) -> not(ge(y, x))
   ge(1(x), 0(y)) -> ge(x, y)
   ge(1(x), 1(y)) -> ge(x, y)
   ge(x, #) -> true
   ge(#, 1(x)) -> false
   ge(#, 0(x)) -> ge(#, x)
   val(l(x)) -> x
   val(n(x, y, z)) -> x
   min(l(x)) -> x
   min(n(x, y, z)) -> min(y)
   max(l(x)) -> x
   max(n(x, y, z)) -> max(z)
   bs(l(x)) -> true
   bs(n(x, y, z)) -> and(and(ge(x, max(y)), ge(min(z), x)), and(bs(y), bs(z)))
   size(l(x)) -> 1(#)
   size(n(x, y, z)) -> +(+(size(x), size(y)), 1(#))
   wb(l(x)) -> true
   wb(n(x, y, z)) -> and(if(ge(size(y), size(z)), ge(1(#), -(size(y), size(z))), ge(1(#), -(size(z), size(y)))), and(wb(y), wb(z)))

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(11) UsableRulesProof (EQUIVALENT)
We can use the usable rules and reduction pair processor [LPAR04] with the Ce-compatible extension of the polynomial order that maps every function symbol to the sum of its arguments. Then, we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(12)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MIN(n(x, y, z)) -> MIN(y)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(13) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*MIN(n(x, y, z)) -> MIN(y)
The graph contains the following edges 1 > 1


----------------------------------------

(14)
YES

----------------------------------------

(15)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   GE(#, 0(x)) -> GE(#, x)

The TRS R consists of the following rules:

   0(#) -> #
   +(x, #) -> x
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(1(x), 0(y)) -> 1(+(x, y))
   +(1(x), 1(y)) -> 0(+(+(x, y), 1(#)))
   +(x, +(y, z)) -> +(+(x, y), z)
   -(x, #) -> x
   -(#, x) -> #
   -(0(x), 0(y)) -> 0(-(x, y))
   -(0(x), 1(y)) -> 1(-(-(x, y), 1(#)))
   -(1(x), 0(y)) -> 1(-(x, y))
   -(1(x), 1(y)) -> 0(-(x, y))
   not(false) -> true
   not(true) -> false
   and(x, true) -> x
   and(x, false) -> false
   if(true, x, y) -> x
   if(false, x, y) -> y
   ge(0(x), 0(y)) -> ge(x, y)
   ge(0(x), 1(y)) -> not(ge(y, x))
   ge(1(x), 0(y)) -> ge(x, y)
   ge(1(x), 1(y)) -> ge(x, y)
   ge(x, #) -> true
   ge(#, 1(x)) -> false
   ge(#, 0(x)) -> ge(#, x)
   val(l(x)) -> x
   val(n(x, y, z)) -> x
   min(l(x)) -> x
   min(n(x, y, z)) -> min(y)
   max(l(x)) -> x
   max(n(x, y, z)) -> max(z)
   bs(l(x)) -> true
   bs(n(x, y, z)) -> and(and(ge(x, max(y)), ge(min(z), x)), and(bs(y), bs(z)))
   size(l(x)) -> 1(#)
   size(n(x, y, z)) -> +(+(size(x), size(y)), 1(#))
   wb(l(x)) -> true
   wb(n(x, y, z)) -> and(if(ge(size(y), size(z)), ge(1(#), -(size(y), size(z))), ge(1(#), -(size(z), size(y)))), and(wb(y), wb(z)))

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(16) UsableRulesProof (EQUIVALENT)
We can use the usable rules and reduction pair processor [LPAR04] with the Ce-compatible extension of the polynomial order that maps every function symbol to the sum of its arguments. Then, we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(17)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   GE(#, 0(x)) -> GE(#, x)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(18) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*GE(#, 0(x)) -> GE(#, x)
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(19)
YES

----------------------------------------

(20)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   GE(0(x), 1(y)) -> GE(y, x)
   GE(0(x), 0(y)) -> GE(x, y)
   GE(1(x), 0(y)) -> GE(x, y)
   GE(1(x), 1(y)) -> GE(x, y)

The TRS R consists of the following rules:

   0(#) -> #
   +(x, #) -> x
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(1(x), 0(y)) -> 1(+(x, y))
   +(1(x), 1(y)) -> 0(+(+(x, y), 1(#)))
   +(x, +(y, z)) -> +(+(x, y), z)
   -(x, #) -> x
   -(#, x) -> #
   -(0(x), 0(y)) -> 0(-(x, y))
   -(0(x), 1(y)) -> 1(-(-(x, y), 1(#)))
   -(1(x), 0(y)) -> 1(-(x, y))
   -(1(x), 1(y)) -> 0(-(x, y))
   not(false) -> true
   not(true) -> false
   and(x, true) -> x
   and(x, false) -> false
   if(true, x, y) -> x
   if(false, x, y) -> y
   ge(0(x), 0(y)) -> ge(x, y)
   ge(0(x), 1(y)) -> not(ge(y, x))
   ge(1(x), 0(y)) -> ge(x, y)
   ge(1(x), 1(y)) -> ge(x, y)
   ge(x, #) -> true
   ge(#, 1(x)) -> false
   ge(#, 0(x)) -> ge(#, x)
   val(l(x)) -> x
   val(n(x, y, z)) -> x
   min(l(x)) -> x
   min(n(x, y, z)) -> min(y)
   max(l(x)) -> x
   max(n(x, y, z)) -> max(z)
   bs(l(x)) -> true
   bs(n(x, y, z)) -> and(and(ge(x, max(y)), ge(min(z), x)), and(bs(y), bs(z)))
   size(l(x)) -> 1(#)
   size(n(x, y, z)) -> +(+(size(x), size(y)), 1(#))
   wb(l(x)) -> true
   wb(n(x, y, z)) -> and(if(ge(size(y), size(z)), ge(1(#), -(size(y), size(z))), ge(1(#), -(size(z), size(y)))), and(wb(y), wb(z)))

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(21) UsableRulesProof (EQUIVALENT)
We can use the usable rules and reduction pair processor [LPAR04] with the Ce-compatible extension of the polynomial order that maps every function symbol to the sum of its arguments. Then, we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(22)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   GE(0(x), 1(y)) -> GE(y, x)
   GE(0(x), 0(y)) -> GE(x, y)
   GE(1(x), 0(y)) -> GE(x, y)
   GE(1(x), 1(y)) -> GE(x, y)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(23) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*GE(0(x), 1(y)) -> GE(y, x)
The graph contains the following edges 2 > 1, 1 > 2


*GE(0(x), 0(y)) -> GE(x, y)
The graph contains the following edges 1 > 1, 2 > 2


*GE(1(x), 0(y)) -> GE(x, y)
The graph contains the following edges 1 > 1, 2 > 2


*GE(1(x), 1(y)) -> GE(x, y)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(24)
YES

----------------------------------------

(25)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   BS(n(x, y, z)) -> BS(z)
   BS(n(x, y, z)) -> BS(y)

The TRS R consists of the following rules:

   0(#) -> #
   +(x, #) -> x
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(1(x), 0(y)) -> 1(+(x, y))
   +(1(x), 1(y)) -> 0(+(+(x, y), 1(#)))
   +(x, +(y, z)) -> +(+(x, y), z)
   -(x, #) -> x
   -(#, x) -> #
   -(0(x), 0(y)) -> 0(-(x, y))
   -(0(x), 1(y)) -> 1(-(-(x, y), 1(#)))
   -(1(x), 0(y)) -> 1(-(x, y))
   -(1(x), 1(y)) -> 0(-(x, y))
   not(false) -> true
   not(true) -> false
   and(x, true) -> x
   and(x, false) -> false
   if(true, x, y) -> x
   if(false, x, y) -> y
   ge(0(x), 0(y)) -> ge(x, y)
   ge(0(x), 1(y)) -> not(ge(y, x))
   ge(1(x), 0(y)) -> ge(x, y)
   ge(1(x), 1(y)) -> ge(x, y)
   ge(x, #) -> true
   ge(#, 1(x)) -> false
   ge(#, 0(x)) -> ge(#, x)
   val(l(x)) -> x
   val(n(x, y, z)) -> x
   min(l(x)) -> x
   min(n(x, y, z)) -> min(y)
   max(l(x)) -> x
   max(n(x, y, z)) -> max(z)
   bs(l(x)) -> true
   bs(n(x, y, z)) -> and(and(ge(x, max(y)), ge(min(z), x)), and(bs(y), bs(z)))
   size(l(x)) -> 1(#)
   size(n(x, y, z)) -> +(+(size(x), size(y)), 1(#))
   wb(l(x)) -> true
   wb(n(x, y, z)) -> and(if(ge(size(y), size(z)), ge(1(#), -(size(y), size(z))), ge(1(#), -(size(z), size(y)))), and(wb(y), wb(z)))

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(26) UsableRulesProof (EQUIVALENT)
We can use the usable rules and reduction pair processor [LPAR04] with the Ce-compatible extension of the polynomial order that maps every function symbol to the sum of its arguments. Then, we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(27)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   BS(n(x, y, z)) -> BS(z)
   BS(n(x, y, z)) -> BS(y)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(28) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*BS(n(x, y, z)) -> BS(z)
The graph contains the following edges 1 > 1


*BS(n(x, y, z)) -> BS(y)
The graph contains the following edges 1 > 1


----------------------------------------

(29)
YES

----------------------------------------

(30)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   -^1(0(x), 1(y)) -> -^1(-(x, y), 1(#))
   -^1(0(x), 1(y)) -> -^1(x, y)
   -^1(0(x), 0(y)) -> -^1(x, y)
   -^1(1(x), 0(y)) -> -^1(x, y)
   -^1(1(x), 1(y)) -> -^1(x, y)

The TRS R consists of the following rules:

   0(#) -> #
   +(x, #) -> x
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(1(x), 0(y)) -> 1(+(x, y))
   +(1(x), 1(y)) -> 0(+(+(x, y), 1(#)))
   +(x, +(y, z)) -> +(+(x, y), z)
   -(x, #) -> x
   -(#, x) -> #
   -(0(x), 0(y)) -> 0(-(x, y))
   -(0(x), 1(y)) -> 1(-(-(x, y), 1(#)))
   -(1(x), 0(y)) -> 1(-(x, y))
   -(1(x), 1(y)) -> 0(-(x, y))
   not(false) -> true
   not(true) -> false
   and(x, true) -> x
   and(x, false) -> false
   if(true, x, y) -> x
   if(false, x, y) -> y
   ge(0(x), 0(y)) -> ge(x, y)
   ge(0(x), 1(y)) -> not(ge(y, x))
   ge(1(x), 0(y)) -> ge(x, y)
   ge(1(x), 1(y)) -> ge(x, y)
   ge(x, #) -> true
   ge(#, 1(x)) -> false
   ge(#, 0(x)) -> ge(#, x)
   val(l(x)) -> x
   val(n(x, y, z)) -> x
   min(l(x)) -> x
   min(n(x, y, z)) -> min(y)
   max(l(x)) -> x
   max(n(x, y, z)) -> max(z)
   bs(l(x)) -> true
   bs(n(x, y, z)) -> and(and(ge(x, max(y)), ge(min(z), x)), and(bs(y), bs(z)))
   size(l(x)) -> 1(#)
   size(n(x, y, z)) -> +(+(size(x), size(y)), 1(#))
   wb(l(x)) -> true
   wb(n(x, y, z)) -> and(if(ge(size(y), size(z)), ge(1(#), -(size(y), size(z))), ge(1(#), -(size(z), size(y)))), and(wb(y), wb(z)))

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(31) UsableRulesProof (EQUIVALENT)
We can use the usable rules and reduction pair processor [LPAR04] with the Ce-compatible extension of the polynomial order that maps every function symbol to the sum of its arguments. Then, we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(32)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   -^1(0(x), 1(y)) -> -^1(-(x, y), 1(#))
   -^1(0(x), 1(y)) -> -^1(x, y)
   -^1(0(x), 0(y)) -> -^1(x, y)
   -^1(1(x), 0(y)) -> -^1(x, y)
   -^1(1(x), 1(y)) -> -^1(x, y)

The TRS R consists of the following rules:

   -(x, #) -> x
   -(#, x) -> #
   -(0(x), 0(y)) -> 0(-(x, y))
   -(0(x), 1(y)) -> 1(-(-(x, y), 1(#)))
   -(1(x), 0(y)) -> 1(-(x, y))
   -(1(x), 1(y)) -> 0(-(x, y))
   0(#) -> #

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(33) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   -^1(0(x), 1(y)) -> -^1(-(x, y), 1(#))
   -^1(0(x), 1(y)) -> -^1(x, y)
   -^1(0(x), 0(y)) -> -^1(x, y)
   -^1(1(x), 0(y)) -> -^1(x, y)
   -^1(1(x), 1(y)) -> -^1(x, y)

Strictly oriented rules of the TRS R:

   -(x, #) -> x
   -(#, x) -> #
   -(0(x), 0(y)) -> 0(-(x, y))
   -(0(x), 1(y)) -> 1(-(-(x, y), 1(#)))
   -(1(x), 0(y)) -> 1(-(x, y))
   -(1(x), 1(y)) -> 0(-(x, y))
   0(#) -> #

Used ordering: Knuth-Bendix order [KBO] with precedence:-_2 > -^1_2 > 0_1 > 1_1 > #

and weight map:

   #=2
   0_1=5
   1_1=3
   -_2=0
   -^1_2=0

The variable weight is 1

----------------------------------------

(34)
Obligation:
Q DP problem:
P is empty.
R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(35) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(36)
YES

----------------------------------------

(37)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   +^1(0(x), 1(y)) -> +^1(x, y)
   +^1(0(x), 0(y)) -> +^1(x, y)
   +^1(1(x), 0(y)) -> +^1(x, y)
   +^1(1(x), 1(y)) -> +^1(+(x, y), 1(#))
   +^1(1(x), 1(y)) -> +^1(x, y)
   +^1(x, +(y, z)) -> +^1(+(x, y), z)
   +^1(x, +(y, z)) -> +^1(x, y)

The TRS R consists of the following rules:

   0(#) -> #
   +(x, #) -> x
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(1(x), 0(y)) -> 1(+(x, y))
   +(1(x), 1(y)) -> 0(+(+(x, y), 1(#)))
   +(x, +(y, z)) -> +(+(x, y), z)
   -(x, #) -> x
   -(#, x) -> #
   -(0(x), 0(y)) -> 0(-(x, y))
   -(0(x), 1(y)) -> 1(-(-(x, y), 1(#)))
   -(1(x), 0(y)) -> 1(-(x, y))
   -(1(x), 1(y)) -> 0(-(x, y))
   not(false) -> true
   not(true) -> false
   and(x, true) -> x
   and(x, false) -> false
   if(true, x, y) -> x
   if(false, x, y) -> y
   ge(0(x), 0(y)) -> ge(x, y)
   ge(0(x), 1(y)) -> not(ge(y, x))
   ge(1(x), 0(y)) -> ge(x, y)
   ge(1(x), 1(y)) -> ge(x, y)
   ge(x, #) -> true
   ge(#, 1(x)) -> false
   ge(#, 0(x)) -> ge(#, x)
   val(l(x)) -> x
   val(n(x, y, z)) -> x
   min(l(x)) -> x
   min(n(x, y, z)) -> min(y)
   max(l(x)) -> x
   max(n(x, y, z)) -> max(z)
   bs(l(x)) -> true
   bs(n(x, y, z)) -> and(and(ge(x, max(y)), ge(min(z), x)), and(bs(y), bs(z)))
   size(l(x)) -> 1(#)
   size(n(x, y, z)) -> +(+(size(x), size(y)), 1(#))
   wb(l(x)) -> true
   wb(n(x, y, z)) -> and(if(ge(size(y), size(z)), ge(1(#), -(size(y), size(z))), ge(1(#), -(size(z), size(y)))), and(wb(y), wb(z)))

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(38) UsableRulesProof (EQUIVALENT)
We can use the usable rules and reduction pair processor [LPAR04] with the Ce-compatible extension of the polynomial order that maps every function symbol to the sum of its arguments. Then, we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(39)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   +^1(0(x), 1(y)) -> +^1(x, y)
   +^1(0(x), 0(y)) -> +^1(x, y)
   +^1(1(x), 0(y)) -> +^1(x, y)
   +^1(1(x), 1(y)) -> +^1(+(x, y), 1(#))
   +^1(1(x), 1(y)) -> +^1(x, y)
   +^1(x, +(y, z)) -> +^1(+(x, y), z)
   +^1(x, +(y, z)) -> +^1(x, y)

The TRS R consists of the following rules:

   +(x, #) -> x
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(1(x), 0(y)) -> 1(+(x, y))
   +(1(x), 1(y)) -> 0(+(+(x, y), 1(#)))
   +(x, +(y, z)) -> +(+(x, y), z)
   0(#) -> #

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(40) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   +^1(0(x), 1(y)) -> +^1(x, y)
   +^1(1(x), 0(y)) -> +^1(x, y)
   +^1(1(x), 1(y)) -> +^1(+(x, y), 1(#))
   +^1(1(x), 1(y)) -> +^1(x, y)


Used ordering: Polynomial interpretation [POLO]:

   POL(#) = 0
   POL(+(x_1, x_2)) = x_1 + x_2
   POL(+^1(x_1, x_2)) = x_1 + 2*x_2
   POL(0(x_1)) = 2*x_1
   POL(1(x_1)) = 1 + 2*x_1


----------------------------------------

(41)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   +^1(0(x), 0(y)) -> +^1(x, y)
   +^1(x, +(y, z)) -> +^1(+(x, y), z)
   +^1(x, +(y, z)) -> +^1(x, y)

The TRS R consists of the following rules:

   +(x, #) -> x
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(1(x), 0(y)) -> 1(+(x, y))
   +(1(x), 1(y)) -> 0(+(+(x, y), 1(#)))
   +(x, +(y, z)) -> +(+(x, y), z)
   0(#) -> #

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(42) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*+^1(0(x), 0(y)) -> +^1(x, y)
The graph contains the following edges 1 > 1, 2 > 2


*+^1(x, +(y, z)) -> +^1(+(x, y), z)
The graph contains the following edges 2 > 2


*+^1(x, +(y, z)) -> +^1(x, y)
The graph contains the following edges 1 >= 1, 2 > 2


----------------------------------------

(43)
YES

----------------------------------------

(44)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   SIZE(n(x, y, z)) -> SIZE(y)
   SIZE(n(x, y, z)) -> SIZE(x)

The TRS R consists of the following rules:

   0(#) -> #
   +(x, #) -> x
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(1(x), 0(y)) -> 1(+(x, y))
   +(1(x), 1(y)) -> 0(+(+(x, y), 1(#)))
   +(x, +(y, z)) -> +(+(x, y), z)
   -(x, #) -> x
   -(#, x) -> #
   -(0(x), 0(y)) -> 0(-(x, y))
   -(0(x), 1(y)) -> 1(-(-(x, y), 1(#)))
   -(1(x), 0(y)) -> 1(-(x, y))
   -(1(x), 1(y)) -> 0(-(x, y))
   not(false) -> true
   not(true) -> false
   and(x, true) -> x
   and(x, false) -> false
   if(true, x, y) -> x
   if(false, x, y) -> y
   ge(0(x), 0(y)) -> ge(x, y)
   ge(0(x), 1(y)) -> not(ge(y, x))
   ge(1(x), 0(y)) -> ge(x, y)
   ge(1(x), 1(y)) -> ge(x, y)
   ge(x, #) -> true
   ge(#, 1(x)) -> false
   ge(#, 0(x)) -> ge(#, x)
   val(l(x)) -> x
   val(n(x, y, z)) -> x
   min(l(x)) -> x
   min(n(x, y, z)) -> min(y)
   max(l(x)) -> x
   max(n(x, y, z)) -> max(z)
   bs(l(x)) -> true
   bs(n(x, y, z)) -> and(and(ge(x, max(y)), ge(min(z), x)), and(bs(y), bs(z)))
   size(l(x)) -> 1(#)
   size(n(x, y, z)) -> +(+(size(x), size(y)), 1(#))
   wb(l(x)) -> true
   wb(n(x, y, z)) -> and(if(ge(size(y), size(z)), ge(1(#), -(size(y), size(z))), ge(1(#), -(size(z), size(y)))), and(wb(y), wb(z)))

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(45) UsableRulesProof (EQUIVALENT)
We can use the usable rules and reduction pair processor [LPAR04] with the Ce-compatible extension of the polynomial order that maps every function symbol to the sum of its arguments. Then, we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(46)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   SIZE(n(x, y, z)) -> SIZE(y)
   SIZE(n(x, y, z)) -> SIZE(x)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(47) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*SIZE(n(x, y, z)) -> SIZE(y)
The graph contains the following edges 1 > 1


*SIZE(n(x, y, z)) -> SIZE(x)
The graph contains the following edges 1 > 1


----------------------------------------

(48)
YES

----------------------------------------

(49)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   WB(n(x, y, z)) -> WB(z)
   WB(n(x, y, z)) -> WB(y)

The TRS R consists of the following rules:

   0(#) -> #
   +(x, #) -> x
   +(#, x) -> x
   +(0(x), 0(y)) -> 0(+(x, y))
   +(0(x), 1(y)) -> 1(+(x, y))
   +(1(x), 0(y)) -> 1(+(x, y))
   +(1(x), 1(y)) -> 0(+(+(x, y), 1(#)))
   +(x, +(y, z)) -> +(+(x, y), z)
   -(x, #) -> x
   -(#, x) -> #
   -(0(x), 0(y)) -> 0(-(x, y))
   -(0(x), 1(y)) -> 1(-(-(x, y), 1(#)))
   -(1(x), 0(y)) -> 1(-(x, y))
   -(1(x), 1(y)) -> 0(-(x, y))
   not(false) -> true
   not(true) -> false
   and(x, true) -> x
   and(x, false) -> false
   if(true, x, y) -> x
   if(false, x, y) -> y
   ge(0(x), 0(y)) -> ge(x, y)
   ge(0(x), 1(y)) -> not(ge(y, x))
   ge(1(x), 0(y)) -> ge(x, y)
   ge(1(x), 1(y)) -> ge(x, y)
   ge(x, #) -> true
   ge(#, 1(x)) -> false
   ge(#, 0(x)) -> ge(#, x)
   val(l(x)) -> x
   val(n(x, y, z)) -> x
   min(l(x)) -> x
   min(n(x, y, z)) -> min(y)
   max(l(x)) -> x
   max(n(x, y, z)) -> max(z)
   bs(l(x)) -> true
   bs(n(x, y, z)) -> and(and(ge(x, max(y)), ge(min(z), x)), and(bs(y), bs(z)))
   size(l(x)) -> 1(#)
   size(n(x, y, z)) -> +(+(size(x), size(y)), 1(#))
   wb(l(x)) -> true
   wb(n(x, y, z)) -> and(if(ge(size(y), size(z)), ge(1(#), -(size(y), size(z))), ge(1(#), -(size(z), size(y)))), and(wb(y), wb(z)))

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(50) UsableRulesProof (EQUIVALENT)
We can use the usable rules and reduction pair processor [LPAR04] with the Ce-compatible extension of the polynomial order that maps every function symbol to the sum of its arguments. Then, we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(51)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   WB(n(x, y, z)) -> WB(z)
   WB(n(x, y, z)) -> WB(y)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(52) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*WB(n(x, y, z)) -> WB(z)
The graph contains the following edges 1 > 1


*WB(n(x, y, z)) -> WB(y)
The graph contains the following edges 1 > 1


----------------------------------------

(53)
YES
