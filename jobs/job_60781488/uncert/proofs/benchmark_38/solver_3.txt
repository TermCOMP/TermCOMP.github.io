YES

Problem 1: 

(VAR vu95NonEmpty m n x y)
(RULES
app(add(n,x),y) -> add(n,app(x,y))
app(nil,y) -> y
high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
high(n,nil) -> nil
ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
ifu95high(ftrue,n,add(m,x)) -> high(n,x)
ifu95low(ffalse,n,add(m,x)) -> low(n,x)
ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
le(num0,y) -> ftrue
le(s(x),num0) -> ffalse
le(s(x),s(y)) -> le(x,y)
low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
low(n,nil) -> nil
minus(s(x),s(y)) -> minus(x,y)
minus(x,num0) -> x
quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
quicksort(nil) -> nil
quot(num0,s(y)) -> num0
quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
)


Problem 1: 

Innermost Equivalent Processor:
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
-> The term rewriting system is non-overlaping or locally confluent overlay system. Therefore, innermost termination implies termination.
 

Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 APP(add(n,x),y) -> APP(x,y)
 HIGH(n,add(m,x)) -> IFU95HIGH(le(m,n),n,add(m,x))
 HIGH(n,add(m,x)) -> LE(m,n)
 IFU95HIGH(ffalse,n,add(m,x)) -> HIGH(n,x)
 IFU95HIGH(ftrue,n,add(m,x)) -> HIGH(n,x)
 IFU95LOW(ffalse,n,add(m,x)) -> LOW(n,x)
 IFU95LOW(ftrue,n,add(m,x)) -> LOW(n,x)
 LE(s(x),s(y)) -> LE(x,y)
 LOW(n,add(m,x)) -> IFU95LOW(le(m,n),n,add(m,x))
 LOW(n,add(m,x)) -> LE(m,n)
 MINUS(s(x),s(y)) -> MINUS(x,y)
 QUICKSORT(add(n,x)) -> APP(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 QUICKSORT(add(n,x)) -> HIGH(n,x)
 QUICKSORT(add(n,x)) -> LOW(n,x)
 QUICKSORT(add(n,x)) -> QUICKSORT(high(n,x))
 QUICKSORT(add(n,x)) -> QUICKSORT(low(n,x))
 QUOT(s(x),s(y)) -> MINUS(x,y)
 QUOT(s(x),s(y)) -> QUOT(minus(x,y),s(y))
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))

Problem 1: 

SCC Processor:
-> Pairs:
 APP(add(n,x),y) -> APP(x,y)
 HIGH(n,add(m,x)) -> IFU95HIGH(le(m,n),n,add(m,x))
 HIGH(n,add(m,x)) -> LE(m,n)
 IFU95HIGH(ffalse,n,add(m,x)) -> HIGH(n,x)
 IFU95HIGH(ftrue,n,add(m,x)) -> HIGH(n,x)
 IFU95LOW(ffalse,n,add(m,x)) -> LOW(n,x)
 IFU95LOW(ftrue,n,add(m,x)) -> LOW(n,x)
 LE(s(x),s(y)) -> LE(x,y)
 LOW(n,add(m,x)) -> IFU95LOW(le(m,n),n,add(m,x))
 LOW(n,add(m,x)) -> LE(m,n)
 MINUS(s(x),s(y)) -> MINUS(x,y)
 QUICKSORT(add(n,x)) -> APP(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 QUICKSORT(add(n,x)) -> HIGH(n,x)
 QUICKSORT(add(n,x)) -> LOW(n,x)
 QUICKSORT(add(n,x)) -> QUICKSORT(high(n,x))
 QUICKSORT(add(n,x)) -> QUICKSORT(low(n,x))
 QUOT(s(x),s(y)) -> MINUS(x,y)
 QUOT(s(x),s(y)) -> QUOT(minus(x,y),s(y))
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 MINUS(s(x),s(y)) -> MINUS(x,y)
->->-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
->->Cycle:
->->-> Pairs:
 QUOT(s(x),s(y)) -> QUOT(minus(x,y),s(y))
->->-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
->->Cycle:
->->-> Pairs:
 LE(s(x),s(y)) -> LE(x,y)
->->-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
->->Cycle:
->->-> Pairs:
 IFU95LOW(ffalse,n,add(m,x)) -> LOW(n,x)
 IFU95LOW(ftrue,n,add(m,x)) -> LOW(n,x)
 LOW(n,add(m,x)) -> IFU95LOW(le(m,n),n,add(m,x))
->->-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
->->Cycle:
->->-> Pairs:
 HIGH(n,add(m,x)) -> IFU95HIGH(le(m,n),n,add(m,x))
 IFU95HIGH(ffalse,n,add(m,x)) -> HIGH(n,x)
 IFU95HIGH(ftrue,n,add(m,x)) -> HIGH(n,x)
->->-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
->->Cycle:
->->-> Pairs:
 APP(add(n,x),y) -> APP(x,y)
->->-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
->->Cycle:
->->-> Pairs:
 QUICKSORT(add(n,x)) -> QUICKSORT(high(n,x))
 QUICKSORT(add(n,x)) -> QUICKSORT(low(n,x))
->->-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))


The problem is decomposed in 7 subproblems.

Problem 1.1: 

Subterm Processor:
-> Pairs:
 MINUS(s(x),s(y)) -> MINUS(x,y)
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
->Projection:
 pi(MINUS) = 1

Problem 1.1: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2: 

Reduction Pairs Processor:
-> Pairs:
 QUOT(s(x),s(y)) -> QUOT(minus(x,y),s(y))
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
-> Usable rules:
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[app](X1,X2) = 0
[high](X1,X2) = 0
[ifu95high](X1,X2,X3) = 0
[ifu95low](X1,X2,X3) = 0
[le](X1,X2) = 0
[low](X1,X2) = 0
[minus](X1,X2) = 2.X1
[quicksort](X) = 0
[quot](X1,X2) = 0
[num0] = 0
[add](X1,X2) = 0
[fSNonEmpty] = 0
[ffalse] = 0
[nil] = 0
[s](X) = 2.X + 2
[ftrue] = 0
[APP](X1,X2) = 0
[HIGH](X1,X2) = 0
[IFU95HIGH](X1,X2,X3) = 0
[IFU95LOW](X1,X2,X3) = 0
[LE](X1,X2) = 0
[LOW](X1,X2) = 0
[MINUS](X1,X2) = 0
[QUICKSORT](X) = 0
[QUOT](X1,X2) = 2.X1

Problem 1.2: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.3: 

Subterm Processor:
-> Pairs:
 LE(s(x),s(y)) -> LE(x,y)
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
->Projection:
 pi(LE) = 1

Problem 1.3: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.4: 

Subterm Processor:
-> Pairs:
 IFU95LOW(ffalse,n,add(m,x)) -> LOW(n,x)
 IFU95LOW(ftrue,n,add(m,x)) -> LOW(n,x)
 LOW(n,add(m,x)) -> IFU95LOW(le(m,n),n,add(m,x))
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
->Projection:
 pi(IFU95LOW) = 3
 pi(LOW) = 2

Problem 1.4: 

SCC Processor:
-> Pairs:
 LOW(n,add(m,x)) -> IFU95LOW(le(m,n),n,add(m,x))
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.5: 

Subterm Processor:
-> Pairs:
 HIGH(n,add(m,x)) -> IFU95HIGH(le(m,n),n,add(m,x))
 IFU95HIGH(ffalse,n,add(m,x)) -> HIGH(n,x)
 IFU95HIGH(ftrue,n,add(m,x)) -> HIGH(n,x)
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
->Projection:
 pi(HIGH) = 2
 pi(IFU95HIGH) = 3

Problem 1.5: 

SCC Processor:
-> Pairs:
 HIGH(n,add(m,x)) -> IFU95HIGH(le(m,n),n,add(m,x))
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.6: 

Subterm Processor:
-> Pairs:
 APP(add(n,x),y) -> APP(x,y)
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
->Projection:
 pi(APP) = 1

Problem 1.6: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.7: 

Reduction Pairs Processor:
-> Pairs:
 QUICKSORT(add(n,x)) -> QUICKSORT(high(n,x))
 QUICKSORT(add(n,x)) -> QUICKSORT(low(n,x))
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
-> Usable rules:
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[app](X1,X2) = 0
[high](X1,X2) = 2.X2 + 1
[ifu95high](X1,X2,X3) = 2.X3 + 1
[ifu95low](X1,X2,X3) = 2.X3 + 1
[le](X1,X2) = X1 + 2.X2 + 2
[low](X1,X2) = 2.X2 + 1
[minus](X1,X2) = 0
[quicksort](X) = 0
[quot](X1,X2) = 0
[num0] = 2
[add](X1,X2) = 2.X1 + 2.X2 + 2
[fSNonEmpty] = 0
[ffalse] = 2
[nil] = 2
[s](X) = 2.X + 1
[ftrue] = 2
[APP](X1,X2) = 0
[HIGH](X1,X2) = 0
[IFU95HIGH](X1,X2,X3) = 0
[IFU95LOW](X1,X2,X3) = 0
[LE](X1,X2) = 0
[LOW](X1,X2) = 0
[MINUS](X1,X2) = 0
[QUICKSORT](X) = 2.X
[QUOT](X1,X2) = 0

Problem 1.7: 

SCC Processor:
-> Pairs:
 QUICKSORT(add(n,x)) -> QUICKSORT(low(n,x))
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 QUICKSORT(add(n,x)) -> QUICKSORT(low(n,x))
->->-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))

Problem 1.7: 

Reduction Pairs Processor:
-> Pairs:
 QUICKSORT(add(n,x)) -> QUICKSORT(low(n,x))
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
-> Usable rules:
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[app](X1,X2) = 0
[high](X1,X2) = 0
[ifu95high](X1,X2,X3) = 0
[ifu95low](X1,X2,X3) = X1 + 2.X3
[le](X1,X2) = 1
[low](X1,X2) = 2.X2 + 1
[minus](X1,X2) = 0
[quicksort](X) = 0
[quot](X1,X2) = 0
[num0] = 0
[add](X1,X2) = X1 + 2.X2 + 2
[fSNonEmpty] = 0
[ffalse] = 1
[nil] = 2
[s](X) = X + 2
[ftrue] = 1
[APP](X1,X2) = 0
[HIGH](X1,X2) = 0
[IFU95HIGH](X1,X2,X3) = 0
[IFU95LOW](X1,X2,X3) = 0
[LE](X1,X2) = 0
[LOW](X1,X2) = 0
[MINUS](X1,X2) = 0
[QUICKSORT](X) = 2.X
[QUOT](X1,X2) = 0

Problem 1.7: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 app(add(n,x),y) -> add(n,app(x,y))
 app(nil,y) -> y
 high(n,add(m,x)) -> ifu95high(le(m,n),n,add(m,x))
 high(n,nil) -> nil
 ifu95high(ffalse,n,add(m,x)) -> add(m,high(n,x))
 ifu95high(ftrue,n,add(m,x)) -> high(n,x)
 ifu95low(ffalse,n,add(m,x)) -> low(n,x)
 ifu95low(ftrue,n,add(m,x)) -> add(m,low(n,x))
 le(num0,y) -> ftrue
 le(s(x),num0) -> ffalse
 le(s(x),s(y)) -> le(x,y)
 low(n,add(m,x)) -> ifu95low(le(m,n),n,add(m,x))
 low(n,nil) -> nil
 minus(s(x),s(y)) -> minus(x,y)
 minus(x,num0) -> x
 quicksort(add(n,x)) -> app(quicksort(low(n,x)),add(n,quicksort(high(n,x))))
 quicksort(nil) -> nil
 quot(num0,s(y)) -> num0
 quot(s(x),s(y)) -> s(quot(minus(x,y),s(y)))
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
