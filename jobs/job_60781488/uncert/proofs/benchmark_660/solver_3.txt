YES

Problem 1: 

(VAR vu95NonEmpty N X X1 X2 Y Z)
(RULES
a(nf(X1,X2)) -> f(a(X1),a(X2))
a(ns(X)) -> s(a(X))
a(nt(X)) -> t(a(X))
a(X) -> X
d(s(X)) -> s(s(d(X)))
d(num0) -> num0
f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
f(num0,X) -> nil
f(X1,X2) -> nf(X1,X2)
p(s(X),s(Y)) -> s(s(p(X,Y)))
p(num0,X) -> X
p(X,num0) -> X
q(s(X)) -> s(p(q(X),d(X)))
q(num0) -> num0
s(X) -> ns(X)
t(N) -> cs(r(q(N)),nt(ns(N)))
t(X) -> nt(X)
)


Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 A(nf(X1,X2)) -> A(X1)
 A(nf(X1,X2)) -> A(X2)
 A(nf(X1,X2)) -> F(a(X1),a(X2))
 A(ns(X)) -> A(X)
 A(ns(X)) -> S(a(X))
 A(nt(X)) -> A(X)
 A(nt(X)) -> T(a(X))
 D(s(X)) -> D(X)
 D(s(X)) -> S(d(X))
 D(s(X)) -> S(s(d(X)))
 F(s(X),cs(Y,Z)) -> A(Z)
 P(s(X),s(Y)) -> P(X,Y)
 P(s(X),s(Y)) -> S(p(X,Y))
 P(s(X),s(Y)) -> S(s(p(X,Y)))
 Q(s(X)) -> D(X)
 Q(s(X)) -> P(q(X),d(X))
 Q(s(X)) -> Q(X)
 Q(s(X)) -> S(p(q(X),d(X)))
 T(N) -> Q(N)
-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)

Problem 1: 

SCC Processor:
-> Pairs:
 A(nf(X1,X2)) -> A(X1)
 A(nf(X1,X2)) -> A(X2)
 A(nf(X1,X2)) -> F(a(X1),a(X2))
 A(ns(X)) -> A(X)
 A(ns(X)) -> S(a(X))
 A(nt(X)) -> A(X)
 A(nt(X)) -> T(a(X))
 D(s(X)) -> D(X)
 D(s(X)) -> S(d(X))
 D(s(X)) -> S(s(d(X)))
 F(s(X),cs(Y,Z)) -> A(Z)
 P(s(X),s(Y)) -> P(X,Y)
 P(s(X),s(Y)) -> S(p(X,Y))
 P(s(X),s(Y)) -> S(s(p(X,Y)))
 Q(s(X)) -> D(X)
 Q(s(X)) -> P(q(X),d(X))
 Q(s(X)) -> Q(X)
 Q(s(X)) -> S(p(q(X),d(X)))
 T(N) -> Q(N)
-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 P(s(X),s(Y)) -> P(X,Y)
->->-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)
->->Cycle:
->->-> Pairs:
 D(s(X)) -> D(X)
->->-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)
->->Cycle:
->->-> Pairs:
 Q(s(X)) -> Q(X)
->->-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)
->->Cycle:
->->-> Pairs:
 A(nf(X1,X2)) -> A(X1)
 A(nf(X1,X2)) -> A(X2)
 A(nf(X1,X2)) -> F(a(X1),a(X2))
 A(ns(X)) -> A(X)
 A(nt(X)) -> A(X)
 F(s(X),cs(Y,Z)) -> A(Z)
->->-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)


The problem is decomposed in 4 subproblems.

Problem 1.1: 

Subterm Processor:
-> Pairs:
 P(s(X),s(Y)) -> P(X,Y)
-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)
->Projection:
 pi(P) = 1

Problem 1.1: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2: 

Subterm Processor:
-> Pairs:
 D(s(X)) -> D(X)
-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)
->Projection:
 pi(D) = 1

Problem 1.2: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.3: 

Subterm Processor:
-> Pairs:
 Q(s(X)) -> Q(X)
-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)
->Projection:
 pi(Q) = 1

Problem 1.3: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.4: 

Reduction Pair Processor:
-> Pairs:
 A(nf(X1,X2)) -> A(X1)
 A(nf(X1,X2)) -> A(X2)
 A(nf(X1,X2)) -> F(a(X1),a(X2))
 A(ns(X)) -> A(X)
 A(nt(X)) -> A(X)
 F(s(X),cs(Y,Z)) -> A(Z)
-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)
-> Usable rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[a](X) = X
[d](X) = 0
[f](X1,X2) = 2.X1 + 2.X2 + 2
[p](X1,X2) = 2.X1 + X2
[q](X) = 0
[s](X) = X
[t](X) = 2.X
[num0] = 0
[cs](X1,X2) = X2
[fSNonEmpty] = 0
[nf](X1,X2) = 2.X1 + 2.X2 + 2
[nil] = 2
[ns](X) = X
[nt](X) = 2.X
[r](X) = 2.X + 2
[A](X) = X
[D](X) = 0
[F](X1,X2) = X1 + X2
[P](X1,X2) = 0
[Q](X) = 0
[S](X) = 0
[T](X) = 0

Problem 1.4: 

SCC Processor:
-> Pairs:
 A(nf(X1,X2)) -> A(X2)
 A(nf(X1,X2)) -> F(a(X1),a(X2))
 A(ns(X)) -> A(X)
 A(nt(X)) -> A(X)
 F(s(X),cs(Y,Z)) -> A(Z)
-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 A(nf(X1,X2)) -> A(X2)
 A(nf(X1,X2)) -> F(a(X1),a(X2))
 A(ns(X)) -> A(X)
 A(nt(X)) -> A(X)
 F(s(X),cs(Y,Z)) -> A(Z)
->->-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)

Problem 1.4: 

Reduction Pair Processor:
-> Pairs:
 A(nf(X1,X2)) -> A(X2)
 A(nf(X1,X2)) -> F(a(X1),a(X2))
 A(ns(X)) -> A(X)
 A(nt(X)) -> A(X)
 F(s(X),cs(Y,Z)) -> A(Z)
-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)
-> Usable rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[a](X) = X
[d](X) = 0
[f](X1,X2) = 2.X2 + 2
[p](X1,X2) = 2.X1 + 2.X2
[q](X) = 0
[s](X) = X
[t](X) = 2.X + 2
[num0] = 0
[cs](X1,X2) = 2.X1 + X2
[fSNonEmpty] = 0
[nf](X1,X2) = 2.X2 + 2
[nil] = 2
[ns](X) = X
[nt](X) = 2.X + 2
[r](X) = 0
[A](X) = 2.X + 1
[D](X) = 0
[F](X1,X2) = 2.X2 + 2
[P](X1,X2) = 0
[Q](X) = 0
[S](X) = 0
[T](X) = 0

Problem 1.4: 

SCC Processor:
-> Pairs:
 A(nf(X1,X2)) -> F(a(X1),a(X2))
 A(ns(X)) -> A(X)
 A(nt(X)) -> A(X)
 F(s(X),cs(Y,Z)) -> A(Z)
-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 A(nf(X1,X2)) -> F(a(X1),a(X2))
 A(ns(X)) -> A(X)
 A(nt(X)) -> A(X)
 F(s(X),cs(Y,Z)) -> A(Z)
->->-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)

Problem 1.4: 

Reduction Pair Processor:
-> Pairs:
 A(nf(X1,X2)) -> F(a(X1),a(X2))
 A(ns(X)) -> A(X)
 A(nt(X)) -> A(X)
 F(s(X),cs(Y,Z)) -> A(Z)
-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)
-> Usable rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[a](X) = X
[d](X) = 0
[f](X1,X2) = 2.X1 + 2.X2 + 2
[p](X1,X2) = X1 + 2.X2
[q](X) = X + 2
[s](X) = X
[t](X) = 2.X + 2
[num0] = 0
[cs](X1,X2) = X2
[fSNonEmpty] = 0
[nf](X1,X2) = 2.X1 + 2.X2 + 2
[nil] = 1
[ns](X) = X
[nt](X) = 2.X + 2
[r](X) = 2
[A](X) = 2.X + 2
[D](X) = 0
[F](X1,X2) = 2.X2 + 2
[P](X1,X2) = 0
[Q](X) = 0
[S](X) = 0
[T](X) = 0

Problem 1.4: 

SCC Processor:
-> Pairs:
 A(ns(X)) -> A(X)
 A(nt(X)) -> A(X)
 F(s(X),cs(Y,Z)) -> A(Z)
-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 A(ns(X)) -> A(X)
 A(nt(X)) -> A(X)
->->-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)

Problem 1.4: 

Subterm Processor:
-> Pairs:
 A(ns(X)) -> A(X)
 A(nt(X)) -> A(X)
-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)
->Projection:
 pi(A) = 1

Problem 1.4: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 a(nf(X1,X2)) -> f(a(X1),a(X2))
 a(ns(X)) -> s(a(X))
 a(nt(X)) -> t(a(X))
 a(X) -> X
 d(s(X)) -> s(s(d(X)))
 d(num0) -> num0
 f(s(X),cs(Y,Z)) -> cs(Y,nf(X,a(Z)))
 f(num0,X) -> nil
 f(X1,X2) -> nf(X1,X2)
 p(s(X),s(Y)) -> s(s(p(X,Y)))
 p(num0,X) -> X
 p(X,num0) -> X
 q(s(X)) -> s(p(q(X),d(X)))
 q(num0) -> num0
 s(X) -> ns(X)
 t(N) -> cs(r(q(N)),nt(ns(N)))
 t(X) -> nt(X)
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
