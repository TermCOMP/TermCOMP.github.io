YES

Problem 1: 

(VAR vu95NonEmpty L M N X Y)
(RULES
app(cons(N,L),Y) -> cons(N,app(L,Y))
app(nil,Y) -> Y
high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
high(N,nil) -> nil
ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
iflow(ffalse,N,cons(M,L)) -> low(N,L)
iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
le(num0,Y) -> ftrue
le(s(X),num0) -> ffalse
le(s(X),s(Y)) -> le(X,Y)
low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
low(N,nil) -> nil
quicksort(cons(N,L)) -> app(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
quicksort(nil) -> nil
)


Problem 1: 

Innermost Equivalent Processor:
-> Rules:
 app(cons(N,L),Y) -> cons(N,app(L,Y))
 app(nil,Y) -> Y
 high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
 high(N,nil) -> nil
 ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
 ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
 quicksort(cons(N,L)) -> app(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 quicksort(nil) -> nil
-> The term rewriting system is non-overlaping or locally confluent overlay system. Therefore, innermost termination implies termination.
 

Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 APP(cons(N,L),Y) -> APP(L,Y)
 HIGH(N,cons(M,L)) -> IFHIGH(le(M,N),N,cons(M,L))
 HIGH(N,cons(M,L)) -> LE(M,N)
 IFHIGH(ffalse,N,cons(M,L)) -> HIGH(N,L)
 IFHIGH(ftrue,N,cons(M,L)) -> HIGH(N,L)
 IFLOW(ffalse,N,cons(M,L)) -> LOW(N,L)
 IFLOW(ftrue,N,cons(M,L)) -> LOW(N,L)
 LE(s(X),s(Y)) -> LE(X,Y)
 LOW(N,cons(M,L)) -> IFLOW(le(M,N),N,cons(M,L))
 LOW(N,cons(M,L)) -> LE(M,N)
 QUICKSORT(cons(N,L)) -> APP(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 QUICKSORT(cons(N,L)) -> HIGH(N,L)
 QUICKSORT(cons(N,L)) -> LOW(N,L)
 QUICKSORT(cons(N,L)) -> QUICKSORT(high(N,L))
 QUICKSORT(cons(N,L)) -> QUICKSORT(low(N,L))
-> Rules:
 app(cons(N,L),Y) -> cons(N,app(L,Y))
 app(nil,Y) -> Y
 high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
 high(N,nil) -> nil
 ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
 ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
 quicksort(cons(N,L)) -> app(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 quicksort(nil) -> nil

Problem 1: 

SCC Processor:
-> Pairs:
 APP(cons(N,L),Y) -> APP(L,Y)
 HIGH(N,cons(M,L)) -> IFHIGH(le(M,N),N,cons(M,L))
 HIGH(N,cons(M,L)) -> LE(M,N)
 IFHIGH(ffalse,N,cons(M,L)) -> HIGH(N,L)
 IFHIGH(ftrue,N,cons(M,L)) -> HIGH(N,L)
 IFLOW(ffalse,N,cons(M,L)) -> LOW(N,L)
 IFLOW(ftrue,N,cons(M,L)) -> LOW(N,L)
 LE(s(X),s(Y)) -> LE(X,Y)
 LOW(N,cons(M,L)) -> IFLOW(le(M,N),N,cons(M,L))
 LOW(N,cons(M,L)) -> LE(M,N)
 QUICKSORT(cons(N,L)) -> APP(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 QUICKSORT(cons(N,L)) -> HIGH(N,L)
 QUICKSORT(cons(N,L)) -> LOW(N,L)
 QUICKSORT(cons(N,L)) -> QUICKSORT(high(N,L))
 QUICKSORT(cons(N,L)) -> QUICKSORT(low(N,L))
-> Rules:
 app(cons(N,L),Y) -> cons(N,app(L,Y))
 app(nil,Y) -> Y
 high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
 high(N,nil) -> nil
 ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
 ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
 quicksort(cons(N,L)) -> app(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 quicksort(nil) -> nil
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 LE(s(X),s(Y)) -> LE(X,Y)
->->-> Rules:
 app(cons(N,L),Y) -> cons(N,app(L,Y))
 app(nil,Y) -> Y
 high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
 high(N,nil) -> nil
 ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
 ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
 quicksort(cons(N,L)) -> app(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 quicksort(nil) -> nil
->->Cycle:
->->-> Pairs:
 IFLOW(ffalse,N,cons(M,L)) -> LOW(N,L)
 IFLOW(ftrue,N,cons(M,L)) -> LOW(N,L)
 LOW(N,cons(M,L)) -> IFLOW(le(M,N),N,cons(M,L))
->->-> Rules:
 app(cons(N,L),Y) -> cons(N,app(L,Y))
 app(nil,Y) -> Y
 high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
 high(N,nil) -> nil
 ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
 ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
 quicksort(cons(N,L)) -> app(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 quicksort(nil) -> nil
->->Cycle:
->->-> Pairs:
 HIGH(N,cons(M,L)) -> IFHIGH(le(M,N),N,cons(M,L))
 IFHIGH(ffalse,N,cons(M,L)) -> HIGH(N,L)
 IFHIGH(ftrue,N,cons(M,L)) -> HIGH(N,L)
->->-> Rules:
 app(cons(N,L),Y) -> cons(N,app(L,Y))
 app(nil,Y) -> Y
 high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
 high(N,nil) -> nil
 ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
 ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
 quicksort(cons(N,L)) -> app(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 quicksort(nil) -> nil
->->Cycle:
->->-> Pairs:
 APP(cons(N,L),Y) -> APP(L,Y)
->->-> Rules:
 app(cons(N,L),Y) -> cons(N,app(L,Y))
 app(nil,Y) -> Y
 high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
 high(N,nil) -> nil
 ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
 ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
 quicksort(cons(N,L)) -> app(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 quicksort(nil) -> nil
->->Cycle:
->->-> Pairs:
 QUICKSORT(cons(N,L)) -> QUICKSORT(high(N,L))
 QUICKSORT(cons(N,L)) -> QUICKSORT(low(N,L))
->->-> Rules:
 app(cons(N,L),Y) -> cons(N,app(L,Y))
 app(nil,Y) -> Y
 high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
 high(N,nil) -> nil
 ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
 ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
 quicksort(cons(N,L)) -> app(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 quicksort(nil) -> nil


The problem is decomposed in 5 subproblems.

Problem 1.1: 

Subterm Processor:
-> Pairs:
 LE(s(X),s(Y)) -> LE(X,Y)
-> Rules:
 app(cons(N,L),Y) -> cons(N,app(L,Y))
 app(nil,Y) -> Y
 high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
 high(N,nil) -> nil
 ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
 ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
 quicksort(cons(N,L)) -> app(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 quicksort(nil) -> nil
->Projection:
 pi(LE) = 1

Problem 1.1: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 app(cons(N,L),Y) -> cons(N,app(L,Y))
 app(nil,Y) -> Y
 high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
 high(N,nil) -> nil
 ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
 ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
 quicksort(cons(N,L)) -> app(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 quicksort(nil) -> nil
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2: 

Subterm Processor:
-> Pairs:
 IFLOW(ffalse,N,cons(M,L)) -> LOW(N,L)
 IFLOW(ftrue,N,cons(M,L)) -> LOW(N,L)
 LOW(N,cons(M,L)) -> IFLOW(le(M,N),N,cons(M,L))
-> Rules:
 app(cons(N,L),Y) -> cons(N,app(L,Y))
 app(nil,Y) -> Y
 high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
 high(N,nil) -> nil
 ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
 ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
 quicksort(cons(N,L)) -> app(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 quicksort(nil) -> nil
->Projection:
 pi(IFLOW) = 3
 pi(LOW) = 2

Problem 1.2: 

SCC Processor:
-> Pairs:
 LOW(N,cons(M,L)) -> IFLOW(le(M,N),N,cons(M,L))
-> Rules:
 app(cons(N,L),Y) -> cons(N,app(L,Y))
 app(nil,Y) -> Y
 high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
 high(N,nil) -> nil
 ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
 ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
 quicksort(cons(N,L)) -> app(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 quicksort(nil) -> nil
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.3: 

Subterm Processor:
-> Pairs:
 HIGH(N,cons(M,L)) -> IFHIGH(le(M,N),N,cons(M,L))
 IFHIGH(ffalse,N,cons(M,L)) -> HIGH(N,L)
 IFHIGH(ftrue,N,cons(M,L)) -> HIGH(N,L)
-> Rules:
 app(cons(N,L),Y) -> cons(N,app(L,Y))
 app(nil,Y) -> Y
 high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
 high(N,nil) -> nil
 ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
 ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
 quicksort(cons(N,L)) -> app(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 quicksort(nil) -> nil
->Projection:
 pi(HIGH) = 2
 pi(IFHIGH) = 3

Problem 1.3: 

SCC Processor:
-> Pairs:
 HIGH(N,cons(M,L)) -> IFHIGH(le(M,N),N,cons(M,L))
-> Rules:
 app(cons(N,L),Y) -> cons(N,app(L,Y))
 app(nil,Y) -> Y
 high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
 high(N,nil) -> nil
 ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
 ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
 quicksort(cons(N,L)) -> app(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 quicksort(nil) -> nil
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.4: 

Subterm Processor:
-> Pairs:
 APP(cons(N,L),Y) -> APP(L,Y)
-> Rules:
 app(cons(N,L),Y) -> cons(N,app(L,Y))
 app(nil,Y) -> Y
 high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
 high(N,nil) -> nil
 ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
 ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
 quicksort(cons(N,L)) -> app(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 quicksort(nil) -> nil
->Projection:
 pi(APP) = 1

Problem 1.4: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 app(cons(N,L),Y) -> cons(N,app(L,Y))
 app(nil,Y) -> Y
 high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
 high(N,nil) -> nil
 ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
 ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
 quicksort(cons(N,L)) -> app(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 quicksort(nil) -> nil
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.5: 

Reduction Pairs Processor:
-> Pairs:
 QUICKSORT(cons(N,L)) -> QUICKSORT(high(N,L))
 QUICKSORT(cons(N,L)) -> QUICKSORT(low(N,L))
-> Rules:
 app(cons(N,L),Y) -> cons(N,app(L,Y))
 app(nil,Y) -> Y
 high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
 high(N,nil) -> nil
 ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
 ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
 quicksort(cons(N,L)) -> app(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 quicksort(nil) -> nil
-> Usable rules:
 high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
 high(N,nil) -> nil
 ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
 ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[app](X1,X2) = 0
[high](X1,X2) = 2.X2 + 1
[ifhigh](X1,X2,X3) = 2.X3
[iflow](X1,X2,X3) = 2.X3 + 1
[le](X1,X2) = X1 + 2.X2 + 2
[low](X1,X2) = 2.X2 + 1
[quicksort](X) = 0
[num0] = 2
[cons](X1,X2) = 2.X1 + 2.X2 + 2
[fSNonEmpty] = 0
[ffalse] = 2
[nil] = 2
[s](X) = 2.X + 2
[ftrue] = 2
[APP](X1,X2) = 0
[HIGH](X1,X2) = 0
[IFHIGH](X1,X2,X3) = 0
[IFLOW](X1,X2,X3) = 0
[LE](X1,X2) = 0
[LOW](X1,X2) = 0
[QUICKSORT](X) = 2.X

Problem 1.5: 

SCC Processor:
-> Pairs:
 QUICKSORT(cons(N,L)) -> QUICKSORT(low(N,L))
-> Rules:
 app(cons(N,L),Y) -> cons(N,app(L,Y))
 app(nil,Y) -> Y
 high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
 high(N,nil) -> nil
 ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
 ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
 quicksort(cons(N,L)) -> app(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 quicksort(nil) -> nil
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 QUICKSORT(cons(N,L)) -> QUICKSORT(low(N,L))
->->-> Rules:
 app(cons(N,L),Y) -> cons(N,app(L,Y))
 app(nil,Y) -> Y
 high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
 high(N,nil) -> nil
 ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
 ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
 quicksort(cons(N,L)) -> app(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 quicksort(nil) -> nil

Problem 1.5: 

Reduction Pairs Processor:
-> Pairs:
 QUICKSORT(cons(N,L)) -> QUICKSORT(low(N,L))
-> Rules:
 app(cons(N,L),Y) -> cons(N,app(L,Y))
 app(nil,Y) -> Y
 high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
 high(N,nil) -> nil
 ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
 ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
 quicksort(cons(N,L)) -> app(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 quicksort(nil) -> nil
-> Usable rules:
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[app](X1,X2) = 0
[high](X1,X2) = 0
[ifhigh](X1,X2,X3) = 0
[iflow](X1,X2,X3) = 2.X3 + 1
[le](X1,X2) = 2.X1 + 2.X2 + 2
[low](X1,X2) = 2.X2 + 1
[quicksort](X) = 0
[num0] = 1
[cons](X1,X2) = 2.X1 + 2.X2 + 2
[fSNonEmpty] = 0
[ffalse] = 0
[nil] = 2
[s](X) = 2.X
[ftrue] = 0
[APP](X1,X2) = 0
[HIGH](X1,X2) = 0
[IFHIGH](X1,X2,X3) = 0
[IFLOW](X1,X2,X3) = 0
[LE](X1,X2) = 0
[LOW](X1,X2) = 0
[QUICKSORT](X) = 2.X

Problem 1.5: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 app(cons(N,L),Y) -> cons(N,app(L,Y))
 app(nil,Y) -> Y
 high(N,cons(M,L)) -> ifhigh(le(M,N),N,cons(M,L))
 high(N,nil) -> nil
 ifhigh(ffalse,N,cons(M,L)) -> cons(M,high(N,L))
 ifhigh(ftrue,N,cons(M,L)) -> high(N,L)
 iflow(ffalse,N,cons(M,L)) -> low(N,L)
 iflow(ftrue,N,cons(M,L)) -> cons(M,low(N,L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 low(N,cons(M,L)) -> iflow(le(M,N),N,cons(M,L))
 low(N,nil) -> nil
 quicksort(cons(N,L)) -> app(quicksort(low(N,L)),cons(N,quicksort(high(N,L))))
 quicksort(nil) -> nil
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
