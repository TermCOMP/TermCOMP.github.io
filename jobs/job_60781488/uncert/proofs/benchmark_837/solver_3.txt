NO

Problem 1: 

(VAR vu95NonEmpty X Y Z)
(RULES
dbl(num0) -> num0
dbl(s(X)) -> s(s(dbl(X)))
dbl1(num0) -> num01
dbl1(s(X)) -> s1(s1(dbl1(X)))
dbls(cons(X,Y)) -> cons(dbl(X),dbls(Y))
dbls(nil) -> nil
from(X) -> cons(X,from(s(X)))
indx(cons(X,Y),Z) -> cons(sel(X,Z),indx(Y,Z))
indx(nil,X) -> nil
quote(dbl(X)) -> dbl1(X)
quote(sel(X,Y)) -> sel1(X,Y)
quote(num0) -> num01
quote(s(X)) -> s1(quote(X))
sel(num0,cons(X,Y)) -> X
sel(s(X),cons(Y,Z)) -> sel(X,Z)
sel1(num0,cons(X,Y)) -> X
sel1(s(X),cons(Y,Z)) -> sel1(X,Z)
)


Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 DBL(s(X)) -> DBL(X)
 DBL1(s(X)) -> DBL1(X)
 DBLS(cons(X,Y)) -> DBL(X)
 DBLS(cons(X,Y)) -> DBLS(Y)
 FROM(X) -> FROM(s(X))
 INDX(cons(X,Y),Z) -> INDX(Y,Z)
 INDX(cons(X,Y),Z) -> SEL(X,Z)
 QUOTE(dbl(X)) -> DBL1(X)
 QUOTE(sel(X,Y)) -> SEL1(X,Y)
 QUOTE(s(X)) -> QUOTE(X)
 SEL(s(X),cons(Y,Z)) -> SEL(X,Z)
 SEL1(s(X),cons(Y,Z)) -> SEL1(X,Z)
-> Rules:
 dbl(num0) -> num0
 dbl(s(X)) -> s(s(dbl(X)))
 dbl1(num0) -> num01
 dbl1(s(X)) -> s1(s1(dbl1(X)))
 dbls(cons(X,Y)) -> cons(dbl(X),dbls(Y))
 dbls(nil) -> nil
 from(X) -> cons(X,from(s(X)))
 indx(cons(X,Y),Z) -> cons(sel(X,Z),indx(Y,Z))
 indx(nil,X) -> nil
 quote(dbl(X)) -> dbl1(X)
 quote(sel(X,Y)) -> sel1(X,Y)
 quote(num0) -> num01
 quote(s(X)) -> s1(quote(X))
 sel(num0,cons(X,Y)) -> X
 sel(s(X),cons(Y,Z)) -> sel(X,Z)
 sel1(num0,cons(X,Y)) -> X
 sel1(s(X),cons(Y,Z)) -> sel1(X,Z)

Problem 1: 

Infiniteness Processor:
-> Pairs:
 DBL(s(X)) -> DBL(X)
 DBL1(s(X)) -> DBL1(X)
 DBLS(cons(X,Y)) -> DBL(X)
 DBLS(cons(X,Y)) -> DBLS(Y)
 FROM(X) -> FROM(s(X))
 INDX(cons(X,Y),Z) -> INDX(Y,Z)
 INDX(cons(X,Y),Z) -> SEL(X,Z)
 QUOTE(dbl(X)) -> DBL1(X)
 QUOTE(sel(X,Y)) -> SEL1(X,Y)
 QUOTE(s(X)) -> QUOTE(X)
 SEL(s(X),cons(Y,Z)) -> SEL(X,Z)
 SEL1(s(X),cons(Y,Z)) -> SEL1(X,Z)
-> Rules:
 dbl(num0) -> num0
 dbl(s(X)) -> s(s(dbl(X)))
 dbl1(num0) -> num01
 dbl1(s(X)) -> s1(s1(dbl1(X)))
 dbls(cons(X,Y)) -> cons(dbl(X),dbls(Y))
 dbls(nil) -> nil
 from(X) -> cons(X,from(s(X)))
 indx(cons(X,Y),Z) -> cons(sel(X,Z),indx(Y,Z))
 indx(nil,X) -> nil
 quote(dbl(X)) -> dbl1(X)
 quote(sel(X,Y)) -> sel1(X,Y)
 quote(num0) -> num01
 quote(s(X)) -> s1(quote(X))
 sel(num0,cons(X,Y)) -> X
 sel(s(X),cons(Y,Z)) -> sel(X,Z)
 sel1(num0,cons(X,Y)) -> X
 sel1(s(X),cons(Y,Z)) -> sel1(X,Z)
-> Pairs in cycle:
 FROM(X) -> FROM(s(X))

The problem is infinite.
