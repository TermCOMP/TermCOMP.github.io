YES

Problem 1: 

(VAR vu95NonEmpty M N X Y Z)
(RULES
append(add(N,X),Y) -> add(N,append(X,Y))
append(nil,Y) -> Y
fu951(pair(X,Z),N,M,Y) -> fu952(lt(N,M),N,M,Y,X,Z)
fu952(ffalse,N,M,Y,X,Z) -> pair(add(M,X),Z)
fu952(ftrue,N,M,Y,X,Z) -> pair(X,add(M,Z))
fu953(pair(Y,Z),N,X) -> append(qsort(Y),add(X,qsort(Z)))
lt(num0,s(X)) -> ftrue
lt(s(X),num0) -> ffalse
lt(s(X),s(Y)) -> lt(X,Y)
qsort(add(N,X)) -> fu953(split(N,X),N,X)
qsort(nil) -> nil
split(N,add(M,Y)) -> fu951(split(N,Y),N,M,Y)
split(N,nil) -> pair(nil,nil)
)


Problem 1: 

Innermost Equivalent Processor:
-> Rules:
 append(add(N,X),Y) -> add(N,append(X,Y))
 append(nil,Y) -> Y
 fu951(pair(X,Z),N,M,Y) -> fu952(lt(N,M),N,M,Y,X,Z)
 fu952(ffalse,N,M,Y,X,Z) -> pair(add(M,X),Z)
 fu952(ftrue,N,M,Y,X,Z) -> pair(X,add(M,Z))
 fu953(pair(Y,Z),N,X) -> append(qsort(Y),add(X,qsort(Z)))
 lt(num0,s(X)) -> ftrue
 lt(s(X),num0) -> ffalse
 lt(s(X),s(Y)) -> lt(X,Y)
 qsort(add(N,X)) -> fu953(split(N,X),N,X)
 qsort(nil) -> nil
 split(N,add(M,Y)) -> fu951(split(N,Y),N,M,Y)
 split(N,nil) -> pair(nil,nil)
-> The term rewriting system is non-overlaping or locally confluent overlay system. Therefore, innermost termination implies termination.
 

Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 APPEND(add(N,X),Y) -> APPEND(X,Y)
 FU951(pair(X,Z),N,M,Y) -> FU952(lt(N,M),N,M,Y,X,Z)
 FU951(pair(X,Z),N,M,Y) -> LT(N,M)
 FU953(pair(Y,Z),N,X) -> APPEND(qsort(Y),add(X,qsort(Z)))
 FU953(pair(Y,Z),N,X) -> QSORT(Y)
 FU953(pair(Y,Z),N,X) -> QSORT(Z)
 LT(s(X),s(Y)) -> LT(X,Y)
 QSORT(add(N,X)) -> FU953(split(N,X),N,X)
 QSORT(add(N,X)) -> SPLIT(N,X)
 SPLIT(N,add(M,Y)) -> FU951(split(N,Y),N,M,Y)
 SPLIT(N,add(M,Y)) -> SPLIT(N,Y)
-> Rules:
 append(add(N,X),Y) -> add(N,append(X,Y))
 append(nil,Y) -> Y
 fu951(pair(X,Z),N,M,Y) -> fu952(lt(N,M),N,M,Y,X,Z)
 fu952(ffalse,N,M,Y,X,Z) -> pair(add(M,X),Z)
 fu952(ftrue,N,M,Y,X,Z) -> pair(X,add(M,Z))
 fu953(pair(Y,Z),N,X) -> append(qsort(Y),add(X,qsort(Z)))
 lt(num0,s(X)) -> ftrue
 lt(s(X),num0) -> ffalse
 lt(s(X),s(Y)) -> lt(X,Y)
 qsort(add(N,X)) -> fu953(split(N,X),N,X)
 qsort(nil) -> nil
 split(N,add(M,Y)) -> fu951(split(N,Y),N,M,Y)
 split(N,nil) -> pair(nil,nil)

Problem 1: 

SCC Processor:
-> Pairs:
 APPEND(add(N,X),Y) -> APPEND(X,Y)
 FU951(pair(X,Z),N,M,Y) -> FU952(lt(N,M),N,M,Y,X,Z)
 FU951(pair(X,Z),N,M,Y) -> LT(N,M)
 FU953(pair(Y,Z),N,X) -> APPEND(qsort(Y),add(X,qsort(Z)))
 FU953(pair(Y,Z),N,X) -> QSORT(Y)
 FU953(pair(Y,Z),N,X) -> QSORT(Z)
 LT(s(X),s(Y)) -> LT(X,Y)
 QSORT(add(N,X)) -> FU953(split(N,X),N,X)
 QSORT(add(N,X)) -> SPLIT(N,X)
 SPLIT(N,add(M,Y)) -> FU951(split(N,Y),N,M,Y)
 SPLIT(N,add(M,Y)) -> SPLIT(N,Y)
-> Rules:
 append(add(N,X),Y) -> add(N,append(X,Y))
 append(nil,Y) -> Y
 fu951(pair(X,Z),N,M,Y) -> fu952(lt(N,M),N,M,Y,X,Z)
 fu952(ffalse,N,M,Y,X,Z) -> pair(add(M,X),Z)
 fu952(ftrue,N,M,Y,X,Z) -> pair(X,add(M,Z))
 fu953(pair(Y,Z),N,X) -> append(qsort(Y),add(X,qsort(Z)))
 lt(num0,s(X)) -> ftrue
 lt(s(X),num0) -> ffalse
 lt(s(X),s(Y)) -> lt(X,Y)
 qsort(add(N,X)) -> fu953(split(N,X),N,X)
 qsort(nil) -> nil
 split(N,add(M,Y)) -> fu951(split(N,Y),N,M,Y)
 split(N,nil) -> pair(nil,nil)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 LT(s(X),s(Y)) -> LT(X,Y)
->->-> Rules:
 append(add(N,X),Y) -> add(N,append(X,Y))
 append(nil,Y) -> Y
 fu951(pair(X,Z),N,M,Y) -> fu952(lt(N,M),N,M,Y,X,Z)
 fu952(ffalse,N,M,Y,X,Z) -> pair(add(M,X),Z)
 fu952(ftrue,N,M,Y,X,Z) -> pair(X,add(M,Z))
 fu953(pair(Y,Z),N,X) -> append(qsort(Y),add(X,qsort(Z)))
 lt(num0,s(X)) -> ftrue
 lt(s(X),num0) -> ffalse
 lt(s(X),s(Y)) -> lt(X,Y)
 qsort(add(N,X)) -> fu953(split(N,X),N,X)
 qsort(nil) -> nil
 split(N,add(M,Y)) -> fu951(split(N,Y),N,M,Y)
 split(N,nil) -> pair(nil,nil)
->->Cycle:
->->-> Pairs:
 SPLIT(N,add(M,Y)) -> SPLIT(N,Y)
->->-> Rules:
 append(add(N,X),Y) -> add(N,append(X,Y))
 append(nil,Y) -> Y
 fu951(pair(X,Z),N,M,Y) -> fu952(lt(N,M),N,M,Y,X,Z)
 fu952(ffalse,N,M,Y,X,Z) -> pair(add(M,X),Z)
 fu952(ftrue,N,M,Y,X,Z) -> pair(X,add(M,Z))
 fu953(pair(Y,Z),N,X) -> append(qsort(Y),add(X,qsort(Z)))
 lt(num0,s(X)) -> ftrue
 lt(s(X),num0) -> ffalse
 lt(s(X),s(Y)) -> lt(X,Y)
 qsort(add(N,X)) -> fu953(split(N,X),N,X)
 qsort(nil) -> nil
 split(N,add(M,Y)) -> fu951(split(N,Y),N,M,Y)
 split(N,nil) -> pair(nil,nil)
->->Cycle:
->->-> Pairs:
 APPEND(add(N,X),Y) -> APPEND(X,Y)
->->-> Rules:
 append(add(N,X),Y) -> add(N,append(X,Y))
 append(nil,Y) -> Y
 fu951(pair(X,Z),N,M,Y) -> fu952(lt(N,M),N,M,Y,X,Z)
 fu952(ffalse,N,M,Y,X,Z) -> pair(add(M,X),Z)
 fu952(ftrue,N,M,Y,X,Z) -> pair(X,add(M,Z))
 fu953(pair(Y,Z),N,X) -> append(qsort(Y),add(X,qsort(Z)))
 lt(num0,s(X)) -> ftrue
 lt(s(X),num0) -> ffalse
 lt(s(X),s(Y)) -> lt(X,Y)
 qsort(add(N,X)) -> fu953(split(N,X),N,X)
 qsort(nil) -> nil
 split(N,add(M,Y)) -> fu951(split(N,Y),N,M,Y)
 split(N,nil) -> pair(nil,nil)
->->Cycle:
->->-> Pairs:
 FU953(pair(Y,Z),N,X) -> QSORT(Y)
 FU953(pair(Y,Z),N,X) -> QSORT(Z)
 QSORT(add(N,X)) -> FU953(split(N,X),N,X)
->->-> Rules:
 append(add(N,X),Y) -> add(N,append(X,Y))
 append(nil,Y) -> Y
 fu951(pair(X,Z),N,M,Y) -> fu952(lt(N,M),N,M,Y,X,Z)
 fu952(ffalse,N,M,Y,X,Z) -> pair(add(M,X),Z)
 fu952(ftrue,N,M,Y,X,Z) -> pair(X,add(M,Z))
 fu953(pair(Y,Z),N,X) -> append(qsort(Y),add(X,qsort(Z)))
 lt(num0,s(X)) -> ftrue
 lt(s(X),num0) -> ffalse
 lt(s(X),s(Y)) -> lt(X,Y)
 qsort(add(N,X)) -> fu953(split(N,X),N,X)
 qsort(nil) -> nil
 split(N,add(M,Y)) -> fu951(split(N,Y),N,M,Y)
 split(N,nil) -> pair(nil,nil)


The problem is decomposed in 4 subproblems.

Problem 1.1: 

Subterm Processor:
-> Pairs:
 LT(s(X),s(Y)) -> LT(X,Y)
-> Rules:
 append(add(N,X),Y) -> add(N,append(X,Y))
 append(nil,Y) -> Y
 fu951(pair(X,Z),N,M,Y) -> fu952(lt(N,M),N,M,Y,X,Z)
 fu952(ffalse,N,M,Y,X,Z) -> pair(add(M,X),Z)
 fu952(ftrue,N,M,Y,X,Z) -> pair(X,add(M,Z))
 fu953(pair(Y,Z),N,X) -> append(qsort(Y),add(X,qsort(Z)))
 lt(num0,s(X)) -> ftrue
 lt(s(X),num0) -> ffalse
 lt(s(X),s(Y)) -> lt(X,Y)
 qsort(add(N,X)) -> fu953(split(N,X),N,X)
 qsort(nil) -> nil
 split(N,add(M,Y)) -> fu951(split(N,Y),N,M,Y)
 split(N,nil) -> pair(nil,nil)
->Projection:
 pi(LT) = 1

Problem 1.1: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 append(add(N,X),Y) -> add(N,append(X,Y))
 append(nil,Y) -> Y
 fu951(pair(X,Z),N,M,Y) -> fu952(lt(N,M),N,M,Y,X,Z)
 fu952(ffalse,N,M,Y,X,Z) -> pair(add(M,X),Z)
 fu952(ftrue,N,M,Y,X,Z) -> pair(X,add(M,Z))
 fu953(pair(Y,Z),N,X) -> append(qsort(Y),add(X,qsort(Z)))
 lt(num0,s(X)) -> ftrue
 lt(s(X),num0) -> ffalse
 lt(s(X),s(Y)) -> lt(X,Y)
 qsort(add(N,X)) -> fu953(split(N,X),N,X)
 qsort(nil) -> nil
 split(N,add(M,Y)) -> fu951(split(N,Y),N,M,Y)
 split(N,nil) -> pair(nil,nil)
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2: 

Subterm Processor:
-> Pairs:
 SPLIT(N,add(M,Y)) -> SPLIT(N,Y)
-> Rules:
 append(add(N,X),Y) -> add(N,append(X,Y))
 append(nil,Y) -> Y
 fu951(pair(X,Z),N,M,Y) -> fu952(lt(N,M),N,M,Y,X,Z)
 fu952(ffalse,N,M,Y,X,Z) -> pair(add(M,X),Z)
 fu952(ftrue,N,M,Y,X,Z) -> pair(X,add(M,Z))
 fu953(pair(Y,Z),N,X) -> append(qsort(Y),add(X,qsort(Z)))
 lt(num0,s(X)) -> ftrue
 lt(s(X),num0) -> ffalse
 lt(s(X),s(Y)) -> lt(X,Y)
 qsort(add(N,X)) -> fu953(split(N,X),N,X)
 qsort(nil) -> nil
 split(N,add(M,Y)) -> fu951(split(N,Y),N,M,Y)
 split(N,nil) -> pair(nil,nil)
->Projection:
 pi(SPLIT) = 2

Problem 1.2: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 append(add(N,X),Y) -> add(N,append(X,Y))
 append(nil,Y) -> Y
 fu951(pair(X,Z),N,M,Y) -> fu952(lt(N,M),N,M,Y,X,Z)
 fu952(ffalse,N,M,Y,X,Z) -> pair(add(M,X),Z)
 fu952(ftrue,N,M,Y,X,Z) -> pair(X,add(M,Z))
 fu953(pair(Y,Z),N,X) -> append(qsort(Y),add(X,qsort(Z)))
 lt(num0,s(X)) -> ftrue
 lt(s(X),num0) -> ffalse
 lt(s(X),s(Y)) -> lt(X,Y)
 qsort(add(N,X)) -> fu953(split(N,X),N,X)
 qsort(nil) -> nil
 split(N,add(M,Y)) -> fu951(split(N,Y),N,M,Y)
 split(N,nil) -> pair(nil,nil)
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.3: 

Subterm Processor:
-> Pairs:
 APPEND(add(N,X),Y) -> APPEND(X,Y)
-> Rules:
 append(add(N,X),Y) -> add(N,append(X,Y))
 append(nil,Y) -> Y
 fu951(pair(X,Z),N,M,Y) -> fu952(lt(N,M),N,M,Y,X,Z)
 fu952(ffalse,N,M,Y,X,Z) -> pair(add(M,X),Z)
 fu952(ftrue,N,M,Y,X,Z) -> pair(X,add(M,Z))
 fu953(pair(Y,Z),N,X) -> append(qsort(Y),add(X,qsort(Z)))
 lt(num0,s(X)) -> ftrue
 lt(s(X),num0) -> ffalse
 lt(s(X),s(Y)) -> lt(X,Y)
 qsort(add(N,X)) -> fu953(split(N,X),N,X)
 qsort(nil) -> nil
 split(N,add(M,Y)) -> fu951(split(N,Y),N,M,Y)
 split(N,nil) -> pair(nil,nil)
->Projection:
 pi(APPEND) = 1

Problem 1.3: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 append(add(N,X),Y) -> add(N,append(X,Y))
 append(nil,Y) -> Y
 fu951(pair(X,Z),N,M,Y) -> fu952(lt(N,M),N,M,Y,X,Z)
 fu952(ffalse,N,M,Y,X,Z) -> pair(add(M,X),Z)
 fu952(ftrue,N,M,Y,X,Z) -> pair(X,add(M,Z))
 fu953(pair(Y,Z),N,X) -> append(qsort(Y),add(X,qsort(Z)))
 lt(num0,s(X)) -> ftrue
 lt(s(X),num0) -> ffalse
 lt(s(X),s(Y)) -> lt(X,Y)
 qsort(add(N,X)) -> fu953(split(N,X),N,X)
 qsort(nil) -> nil
 split(N,add(M,Y)) -> fu951(split(N,Y),N,M,Y)
 split(N,nil) -> pair(nil,nil)
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.4: 

Reduction Pairs Processor:
-> Pairs:
 FU953(pair(Y,Z),N,X) -> QSORT(Y)
 FU953(pair(Y,Z),N,X) -> QSORT(Z)
 QSORT(add(N,X)) -> FU953(split(N,X),N,X)
-> Rules:
 append(add(N,X),Y) -> add(N,append(X,Y))
 append(nil,Y) -> Y
 fu951(pair(X,Z),N,M,Y) -> fu952(lt(N,M),N,M,Y,X,Z)
 fu952(ffalse,N,M,Y,X,Z) -> pair(add(M,X),Z)
 fu952(ftrue,N,M,Y,X,Z) -> pair(X,add(M,Z))
 fu953(pair(Y,Z),N,X) -> append(qsort(Y),add(X,qsort(Z)))
 lt(num0,s(X)) -> ftrue
 lt(s(X),num0) -> ffalse
 lt(s(X),s(Y)) -> lt(X,Y)
 qsort(add(N,X)) -> fu953(split(N,X),N,X)
 qsort(nil) -> nil
 split(N,add(M,Y)) -> fu951(split(N,Y),N,M,Y)
 split(N,nil) -> pair(nil,nil)
-> Usable rules:
 fu951(pair(X,Z),N,M,Y) -> fu952(lt(N,M),N,M,Y,X,Z)
 fu952(ffalse,N,M,Y,X,Z) -> pair(add(M,X),Z)
 fu952(ftrue,N,M,Y,X,Z) -> pair(X,add(M,Z))
 lt(num0,s(X)) -> ftrue
 lt(s(X),num0) -> ffalse
 lt(s(X),s(Y)) -> lt(X,Y)
 split(N,add(M,Y)) -> fu951(split(N,Y),N,M,Y)
 split(N,nil) -> pair(nil,nil)
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[append](X1,X2) = 0
[fu951](X1,X2,X3,X4) = 2.X1 + 2
[fu952](X1,X2,X3,X4,X5,X6) = 2.X1 + 2.X5 + 2.X6 + 2
[fu953](X1,X2,X3) = 0
[lt](X1,X2) = 2
[qsort](X) = 0
[split](X1,X2) = 2.X2 + 2
[num0] = 0
[add](X1,X2) = 2.X2 + 2
[fSNonEmpty] = 0
[ffalse] = 2
[nil] = 2
[pair](X1,X2) = X1 + X2 + 2
[s](X) = 1
[ftrue] = 2
[APPEND](X1,X2) = 0
[FU951](X1,X2,X3,X4) = 0
[FU952](X1,X2,X3,X4,X5,X6) = 0
[FU953](X1,X2,X3) = 2.X1 + 2
[LT](X1,X2) = 0
[QSORT](X) = 2.X + 2
[SPLIT](X1,X2) = 0

Problem 1.4: 

SCC Processor:
-> Pairs:
 FU953(pair(Y,Z),N,X) -> QSORT(Z)
 QSORT(add(N,X)) -> FU953(split(N,X),N,X)
-> Rules:
 append(add(N,X),Y) -> add(N,append(X,Y))
 append(nil,Y) -> Y
 fu951(pair(X,Z),N,M,Y) -> fu952(lt(N,M),N,M,Y,X,Z)
 fu952(ffalse,N,M,Y,X,Z) -> pair(add(M,X),Z)
 fu952(ftrue,N,M,Y,X,Z) -> pair(X,add(M,Z))
 fu953(pair(Y,Z),N,X) -> append(qsort(Y),add(X,qsort(Z)))
 lt(num0,s(X)) -> ftrue
 lt(s(X),num0) -> ffalse
 lt(s(X),s(Y)) -> lt(X,Y)
 qsort(add(N,X)) -> fu953(split(N,X),N,X)
 qsort(nil) -> nil
 split(N,add(M,Y)) -> fu951(split(N,Y),N,M,Y)
 split(N,nil) -> pair(nil,nil)
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 FU953(pair(Y,Z),N,X) -> QSORT(Z)
 QSORT(add(N,X)) -> FU953(split(N,X),N,X)
->->-> Rules:
 append(add(N,X),Y) -> add(N,append(X,Y))
 append(nil,Y) -> Y
 fu951(pair(X,Z),N,M,Y) -> fu952(lt(N,M),N,M,Y,X,Z)
 fu952(ffalse,N,M,Y,X,Z) -> pair(add(M,X),Z)
 fu952(ftrue,N,M,Y,X,Z) -> pair(X,add(M,Z))
 fu953(pair(Y,Z),N,X) -> append(qsort(Y),add(X,qsort(Z)))
 lt(num0,s(X)) -> ftrue
 lt(s(X),num0) -> ffalse
 lt(s(X),s(Y)) -> lt(X,Y)
 qsort(add(N,X)) -> fu953(split(N,X),N,X)
 qsort(nil) -> nil
 split(N,add(M,Y)) -> fu951(split(N,Y),N,M,Y)
 split(N,nil) -> pair(nil,nil)

Problem 1.4: 

Reduction Pairs Processor:
-> Pairs:
 FU953(pair(Y,Z),N,X) -> QSORT(Z)
 QSORT(add(N,X)) -> FU953(split(N,X),N,X)
-> Rules:
 append(add(N,X),Y) -> add(N,append(X,Y))
 append(nil,Y) -> Y
 fu951(pair(X,Z),N,M,Y) -> fu952(lt(N,M),N,M,Y,X,Z)
 fu952(ffalse,N,M,Y,X,Z) -> pair(add(M,X),Z)
 fu952(ftrue,N,M,Y,X,Z) -> pair(X,add(M,Z))
 fu953(pair(Y,Z),N,X) -> append(qsort(Y),add(X,qsort(Z)))
 lt(num0,s(X)) -> ftrue
 lt(s(X),num0) -> ffalse
 lt(s(X),s(Y)) -> lt(X,Y)
 qsort(add(N,X)) -> fu953(split(N,X),N,X)
 qsort(nil) -> nil
 split(N,add(M,Y)) -> fu951(split(N,Y),N,M,Y)
 split(N,nil) -> pair(nil,nil)
-> Usable rules:
 fu951(pair(X,Z),N,M,Y) -> fu952(lt(N,M),N,M,Y,X,Z)
 fu952(ffalse,N,M,Y,X,Z) -> pair(add(M,X),Z)
 fu952(ftrue,N,M,Y,X,Z) -> pair(X,add(M,Z))
 lt(num0,s(X)) -> ftrue
 lt(s(X),num0) -> ffalse
 lt(s(X),s(Y)) -> lt(X,Y)
 split(N,add(M,Y)) -> fu951(split(N,Y),N,M,Y)
 split(N,nil) -> pair(nil,nil)
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[append](X1,X2) = 0
[fu951](X1,X2,X3,X4) = 2.X1
[fu952](X1,X2,X3,X4,X5,X6) = 2.X1 + 2.X5 + 2.X6
[fu953](X1,X2,X3) = 0
[lt](X1,X2) = 2
[qsort](X) = 0
[split](X1,X2) = X2 + 2
[num0] = 0
[add](X1,X2) = 2.X2 + 2
[fSNonEmpty] = 0
[ffalse] = 2
[nil] = 0
[pair](X1,X2) = X1 + X2 + 2
[s](X) = X
[ftrue] = 2
[APPEND](X1,X2) = 0
[FU951](X1,X2,X3,X4) = 0
[FU952](X1,X2,X3,X4,X5,X6) = 0
[FU953](X1,X2,X3) = 2.X1 + 2.X3 + 2
[LT](X1,X2) = 0
[QSORT](X) = 2.X + 2
[SPLIT](X1,X2) = 0

Problem 1.4: 

SCC Processor:
-> Pairs:
 QSORT(add(N,X)) -> FU953(split(N,X),N,X)
-> Rules:
 append(add(N,X),Y) -> add(N,append(X,Y))
 append(nil,Y) -> Y
 fu951(pair(X,Z),N,M,Y) -> fu952(lt(N,M),N,M,Y,X,Z)
 fu952(ffalse,N,M,Y,X,Z) -> pair(add(M,X),Z)
 fu952(ftrue,N,M,Y,X,Z) -> pair(X,add(M,Z))
 fu953(pair(Y,Z),N,X) -> append(qsort(Y),add(X,qsort(Z)))
 lt(num0,s(X)) -> ftrue
 lt(s(X),num0) -> ffalse
 lt(s(X),s(Y)) -> lt(X,Y)
 qsort(add(N,X)) -> fu953(split(N,X),N,X)
 qsort(nil) -> nil
 split(N,add(M,Y)) -> fu951(split(N,Y),N,M,Y)
 split(N,nil) -> pair(nil,nil)
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
