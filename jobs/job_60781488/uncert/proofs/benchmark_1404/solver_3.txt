YES

Problem 1: 

(VAR vu95NonEmpty x y z)
(RULES
u43(O(x),O(y)) -> O(u43(x,y))
u43(O(x),I(y)) -> I(u43(x,y))
u43(num0,x) -> x
u43(I(x),O(y)) -> I(u43(x,y))
u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
u43(x,u43(y,z)) -> u43(u43(x,y),z)
u43(x,num0) -> x
u45(O(x),O(y)) -> O(u45(x,y))
u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
u45(num0,x) -> num0
u45(I(x),O(y)) -> I(u45(x,y))
u45(I(x),I(y)) -> O(u45(x,y))
u45(x,num0) -> x
BS(L(x)) -> ftrue
BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
Log(x) -> u45(Logu39(x),I(num0))
Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
Logu39(num0) -> num0
Logu39(I(x)) -> u43(Logu39(x),I(num0))
Max(L(x)) -> x
Max(N(x,l,r)) -> Max(r)
Min(L(x)) -> x
Min(N(x,l,r)) -> Min(l)
O(num0) -> num0
Size(L(x)) -> I(num0)
Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
Val(L(x)) -> x
Val(N(x,l,r)) -> x
WB(L(x)) -> ftrue
WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
and(x,ffalse) -> ffalse
and(x,ftrue) -> x
ge(O(x),O(y)) -> ge(x,y)
ge(O(x),I(y)) -> not(ge(y,x))
ge(num0,O(x)) -> ge(num0,x)
ge(num0,I(x)) -> ffalse
ge(I(x),O(y)) -> ge(x,y)
ge(I(x),I(y)) -> ge(x,y)
ge(x,num0) -> ftrue
if(ffalse,x,y) -> y
if(ftrue,x,y) -> x
not(ffalse) -> ftrue
not(ftrue) -> ffalse
)


Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 U43(O(x),O(y)) -> U43(x,y)
 U43(O(x),O(y)) -> OSharp(u43(x,y))
 U43(O(x),I(y)) -> U43(x,y)
 U43(I(x),O(y)) -> U43(x,y)
 U43(I(x),I(y)) -> U43(u43(x,y),I(num0))
 U43(I(x),I(y)) -> U43(x,y)
 U43(I(x),I(y)) -> OSharp(u43(u43(x,y),I(num0)))
 U43(x,u43(y,z)) -> U43(u43(x,y),z)
 U43(x,u43(y,z)) -> U43(x,y)
 U45(O(x),O(y)) -> U45(x,y)
 U45(O(x),O(y)) -> OSharp(u45(x,y))
 U45(O(x),I(y)) -> U45(u45(x,y),I(num1))
 U45(O(x),I(y)) -> U45(x,y)
 U45(I(x),O(y)) -> U45(x,y)
 U45(I(x),I(y)) -> U45(x,y)
 U45(I(x),I(y)) -> OSharp(u45(x,y))
 BSSharp(N(x,l,r)) -> AND(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 BSSharp(N(x,l,r)) -> AND(ge(x,Max(l)),ge(Min(r),x))
 BSSharp(N(x,l,r)) -> GE(Min(r),x)
 LOG(x) -> U45(Logu39(x),I(num0))
 LOG(x) -> LOGU39(x)
 LOGU39(O(x)) -> U43(Logu39(x),I(num0))
 LOGU39(O(x)) -> LOGU39(x)
 LOGU39(O(x)) -> GE(x,I(num0))
 LOGU39(O(x)) -> IF(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 LOGU39(I(x)) -> U43(Logu39(x),I(num0))
 LOGU39(I(x)) -> LOGU39(x)
 GE(O(x),O(y)) -> GE(x,y)
 GE(O(x),I(y)) -> GE(y,x)
 GE(O(x),I(y)) -> NOT(ge(y,x))
 GE(num0,O(x)) -> GE(num0,x)
 GE(I(x),O(y)) -> GE(x,y)
 GE(I(x),I(y)) -> GE(x,y)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse

Problem 1: 

SCC Processor:
-> Pairs:
 U43(O(x),O(y)) -> U43(x,y)
 U43(O(x),O(y)) -> OSharp(u43(x,y))
 U43(O(x),I(y)) -> U43(x,y)
 U43(I(x),O(y)) -> U43(x,y)
 U43(I(x),I(y)) -> U43(u43(x,y),I(num0))
 U43(I(x),I(y)) -> U43(x,y)
 U43(I(x),I(y)) -> OSharp(u43(u43(x,y),I(num0)))
 U43(x,u43(y,z)) -> U43(u43(x,y),z)
 U43(x,u43(y,z)) -> U43(x,y)
 U45(O(x),O(y)) -> U45(x,y)
 U45(O(x),O(y)) -> OSharp(u45(x,y))
 U45(O(x),I(y)) -> U45(u45(x,y),I(num1))
 U45(O(x),I(y)) -> U45(x,y)
 U45(I(x),O(y)) -> U45(x,y)
 U45(I(x),I(y)) -> U45(x,y)
 U45(I(x),I(y)) -> OSharp(u45(x,y))
 BSSharp(N(x,l,r)) -> AND(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 BSSharp(N(x,l,r)) -> AND(ge(x,Max(l)),ge(Min(r),x))
 BSSharp(N(x,l,r)) -> GE(Min(r),x)
 LOG(x) -> U45(Logu39(x),I(num0))
 LOG(x) -> LOGU39(x)
 LOGU39(O(x)) -> U43(Logu39(x),I(num0))
 LOGU39(O(x)) -> LOGU39(x)
 LOGU39(O(x)) -> GE(x,I(num0))
 LOGU39(O(x)) -> IF(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 LOGU39(I(x)) -> U43(Logu39(x),I(num0))
 LOGU39(I(x)) -> LOGU39(x)
 GE(O(x),O(y)) -> GE(x,y)
 GE(O(x),I(y)) -> GE(y,x)
 GE(O(x),I(y)) -> NOT(ge(y,x))
 GE(num0,O(x)) -> GE(num0,x)
 GE(I(x),O(y)) -> GE(x,y)
 GE(I(x),I(y)) -> GE(x,y)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 GE(num0,O(x)) -> GE(num0,x)
->->-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->->Cycle:
->->-> Pairs:
 GE(O(x),O(y)) -> GE(x,y)
 GE(O(x),I(y)) -> GE(y,x)
 GE(I(x),O(y)) -> GE(x,y)
 GE(I(x),I(y)) -> GE(x,y)
->->-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->->Cycle:
->->-> Pairs:
 U45(O(x),O(y)) -> U45(x,y)
 U45(O(x),I(y)) -> U45(u45(x,y),I(num1))
 U45(O(x),I(y)) -> U45(x,y)
 U45(I(x),O(y)) -> U45(x,y)
 U45(I(x),I(y)) -> U45(x,y)
->->-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->->Cycle:
->->-> Pairs:
 U43(O(x),O(y)) -> U43(x,y)
 U43(O(x),I(y)) -> U43(x,y)
 U43(I(x),O(y)) -> U43(x,y)
 U43(I(x),I(y)) -> U43(u43(x,y),I(num0))
 U43(I(x),I(y)) -> U43(x,y)
 U43(x,u43(y,z)) -> U43(u43(x,y),z)
 U43(x,u43(y,z)) -> U43(x,y)
->->-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->->Cycle:
->->-> Pairs:
 LOGU39(O(x)) -> LOGU39(x)
 LOGU39(I(x)) -> LOGU39(x)
->->-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse


The problem is decomposed in 5 subproblems.

Problem 1.1: 

Subterm Processor:
-> Pairs:
 GE(num0,O(x)) -> GE(num0,x)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->Projection:
 pi(GE) = 2

Problem 1.1: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2: 

Reduction Pair Processor:
-> Pairs:
 GE(O(x),O(y)) -> GE(x,y)
 GE(O(x),I(y)) -> GE(y,x)
 GE(I(x),O(y)) -> GE(x,y)
 GE(I(x),I(y)) -> GE(x,y)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
-> Usable rules:
 Empty
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[u43](X1,X2) = 0
[u45](X1,X2) = 0
[BS](X) = 0
[Log](X) = 0
[Logu39](X) = 0
[Max](X) = 0
[Min](X) = 0
[O](X) = 2.X + 2
[Size](X) = 0
[Val](X) = 0
[WB](X) = 0
[and](X1,X2) = 0
[ge](X1,X2) = 0
[if](X1,X2,X3) = 0
[not](X) = 0
[num0] = 0
[num1] = 0
[I](X) = X
[L](X) = 0
[N](X1,X2,X3) = 0
[fSNonEmpty] = 0
[ffalse] = 0
[l] = 0
[r] = 0
[ftrue] = 0
[U43](X1,X2) = 0
[U45](X1,X2) = 0
[BSSharp](X) = 0
[LOG](X) = 0
[LOGU39](X) = 0
[OSharp](X) = 0
[AND](X1,X2) = 0
[GE](X1,X2) = X1 + 2.X2
[IF](X1,X2,X3) = 0
[NOT](X) = 0

Problem 1.2: 

SCC Processor:
-> Pairs:
 GE(O(x),I(y)) -> GE(y,x)
 GE(I(x),O(y)) -> GE(x,y)
 GE(I(x),I(y)) -> GE(x,y)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 GE(O(x),I(y)) -> GE(y,x)
 GE(I(x),O(y)) -> GE(x,y)
 GE(I(x),I(y)) -> GE(x,y)
->->-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse

Problem 1.2: 

Reduction Pair Processor:
-> Pairs:
 GE(O(x),I(y)) -> GE(y,x)
 GE(I(x),O(y)) -> GE(x,y)
 GE(I(x),I(y)) -> GE(x,y)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
-> Usable rules:
 Empty
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[u43](X1,X2) = 0
[u45](X1,X2) = 0
[BS](X) = 0
[Log](X) = 0
[Logu39](X) = 0
[Max](X) = 0
[Min](X) = 0
[O](X) = 2.X + 2
[Size](X) = 0
[Val](X) = 0
[WB](X) = 0
[and](X1,X2) = 0
[ge](X1,X2) = 0
[if](X1,X2,X3) = 0
[not](X) = 0
[num0] = 0
[num1] = 0
[I](X) = 2.X
[L](X) = 0
[N](X1,X2,X3) = 0
[fSNonEmpty] = 0
[ffalse] = 0
[l] = 0
[r] = 0
[ftrue] = 0
[U43](X1,X2) = 0
[U45](X1,X2) = 0
[BSSharp](X) = 0
[LOG](X) = 0
[LOGU39](X) = 0
[OSharp](X) = 0
[AND](X1,X2) = 0
[GE](X1,X2) = 2.X1 + 2.X2
[IF](X1,X2,X3) = 0
[NOT](X) = 0

Problem 1.2: 

SCC Processor:
-> Pairs:
 GE(I(x),O(y)) -> GE(x,y)
 GE(I(x),I(y)) -> GE(x,y)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 GE(I(x),O(y)) -> GE(x,y)
 GE(I(x),I(y)) -> GE(x,y)
->->-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse

Problem 1.2: 

Subterm Processor:
-> Pairs:
 GE(I(x),O(y)) -> GE(x,y)
 GE(I(x),I(y)) -> GE(x,y)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->Projection:
 pi(GE) = 1

Problem 1.2: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.3: 

Reduction Pair Processor:
-> Pairs:
 U45(O(x),O(y)) -> U45(x,y)
 U45(O(x),I(y)) -> U45(u45(x,y),I(num1))
 U45(O(x),I(y)) -> U45(x,y)
 U45(I(x),O(y)) -> U45(x,y)
 U45(I(x),I(y)) -> U45(x,y)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
-> Usable rules:
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 O(num0) -> num0
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[u43](X1,X2) = 0
[u45](X1,X2) = X1 + 2.X2
[BS](X) = 0
[Log](X) = 0
[Logu39](X) = 0
[Max](X) = 0
[Min](X) = 0
[O](X) = X + 2
[Size](X) = 0
[Val](X) = 0
[WB](X) = 0
[and](X1,X2) = 0
[ge](X1,X2) = 0
[if](X1,X2,X3) = 0
[not](X) = 0
[num0] = 2
[num1] = 0
[I](X) = X + 2
[L](X) = 0
[N](X1,X2,X3) = 0
[fSNonEmpty] = 0
[ffalse] = 0
[l] = 0
[r] = 0
[ftrue] = 0
[U43](X1,X2) = 0
[U45](X1,X2) = X1 + 2.X2
[BSSharp](X) = 0
[LOG](X) = 0
[LOGU39](X) = 0
[OSharp](X) = 0
[AND](X1,X2) = 0
[GE](X1,X2) = 0
[IF](X1,X2,X3) = 0
[NOT](X) = 0

Problem 1.3: 

SCC Processor:
-> Pairs:
 U45(O(x),I(y)) -> U45(u45(x,y),I(num1))
 U45(O(x),I(y)) -> U45(x,y)
 U45(I(x),O(y)) -> U45(x,y)
 U45(I(x),I(y)) -> U45(x,y)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 U45(O(x),I(y)) -> U45(u45(x,y),I(num1))
 U45(O(x),I(y)) -> U45(x,y)
 U45(I(x),O(y)) -> U45(x,y)
 U45(I(x),I(y)) -> U45(x,y)
->->-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse

Problem 1.3: 

Reduction Pair Processor:
-> Pairs:
 U45(O(x),I(y)) -> U45(u45(x,y),I(num1))
 U45(O(x),I(y)) -> U45(x,y)
 U45(I(x),O(y)) -> U45(x,y)
 U45(I(x),I(y)) -> U45(x,y)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
-> Usable rules:
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 O(num0) -> num0
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[u43](X1,X2) = 0
[u45](X1,X2) = X1 + X2 + 1
[BS](X) = 0
[Log](X) = 0
[Logu39](X) = 0
[Max](X) = 0
[Min](X) = 0
[O](X) = X + 2
[Size](X) = 0
[Val](X) = 0
[WB](X) = 0
[and](X1,X2) = 0
[ge](X1,X2) = 0
[if](X1,X2,X3) = 0
[not](X) = 0
[num0] = 1
[num1] = 0
[I](X) = X + 1
[L](X) = 0
[N](X1,X2,X3) = 0
[fSNonEmpty] = 0
[ffalse] = 0
[l] = 0
[r] = 0
[ftrue] = 0
[U43](X1,X2) = 0
[U45](X1,X2) = 2.X1 + 2.X2
[BSSharp](X) = 0
[LOG](X) = 0
[LOGU39](X) = 0
[OSharp](X) = 0
[AND](X1,X2) = 0
[GE](X1,X2) = 0
[IF](X1,X2,X3) = 0
[NOT](X) = 0

Problem 1.3: 

SCC Processor:
-> Pairs:
 U45(O(x),I(y)) -> U45(x,y)
 U45(I(x),O(y)) -> U45(x,y)
 U45(I(x),I(y)) -> U45(x,y)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 U45(O(x),I(y)) -> U45(x,y)
 U45(I(x),O(y)) -> U45(x,y)
 U45(I(x),I(y)) -> U45(x,y)
->->-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse

Problem 1.3: 

Subterm Processor:
-> Pairs:
 U45(O(x),I(y)) -> U45(x,y)
 U45(I(x),O(y)) -> U45(x,y)
 U45(I(x),I(y)) -> U45(x,y)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->Projection:
 pi(U45) = 1

Problem 1.3: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.4: 

Reduction Pair Processor:
-> Pairs:
 U43(O(x),O(y)) -> U43(x,y)
 U43(O(x),I(y)) -> U43(x,y)
 U43(I(x),O(y)) -> U43(x,y)
 U43(I(x),I(y)) -> U43(u43(x,y),I(num0))
 U43(I(x),I(y)) -> U43(x,y)
 U43(x,u43(y,z)) -> U43(u43(x,y),z)
 U43(x,u43(y,z)) -> U43(x,y)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
-> Usable rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 O(num0) -> num0
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[u43](X1,X2) = X1 + 2.X2 + 1
[u45](X1,X2) = 0
[BS](X) = 0
[Log](X) = 0
[Logu39](X) = 0
[Max](X) = 0
[Min](X) = 0
[O](X) = X + 1
[Size](X) = 0
[Val](X) = 0
[WB](X) = 0
[and](X1,X2) = 0
[ge](X1,X2) = 0
[if](X1,X2,X3) = 0
[not](X) = 0
[num0] = 0
[num1] = 0
[I](X) = X + 2
[L](X) = 0
[N](X1,X2,X3) = 0
[fSNonEmpty] = 0
[ffalse] = 0
[l] = 0
[r] = 0
[ftrue] = 0
[U43](X1,X2) = X1 + 2.X2
[U45](X1,X2) = 0
[BSSharp](X) = 0
[LOG](X) = 0
[LOGU39](X) = 0
[OSharp](X) = 0
[AND](X1,X2) = 0
[GE](X1,X2) = 0
[IF](X1,X2,X3) = 0
[NOT](X) = 0

Problem 1.4: 

SCC Processor:
-> Pairs:
 U43(O(x),I(y)) -> U43(x,y)
 U43(I(x),O(y)) -> U43(x,y)
 U43(I(x),I(y)) -> U43(u43(x,y),I(num0))
 U43(I(x),I(y)) -> U43(x,y)
 U43(x,u43(y,z)) -> U43(u43(x,y),z)
 U43(x,u43(y,z)) -> U43(x,y)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 U43(O(x),I(y)) -> U43(x,y)
 U43(I(x),O(y)) -> U43(x,y)
 U43(I(x),I(y)) -> U43(u43(x,y),I(num0))
 U43(I(x),I(y)) -> U43(x,y)
 U43(x,u43(y,z)) -> U43(u43(x,y),z)
 U43(x,u43(y,z)) -> U43(x,y)
->->-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse

Problem 1.4: 

Reduction Pair Processor:
-> Pairs:
 U43(O(x),I(y)) -> U43(x,y)
 U43(I(x),O(y)) -> U43(x,y)
 U43(I(x),I(y)) -> U43(u43(x,y),I(num0))
 U43(I(x),I(y)) -> U43(x,y)
 U43(x,u43(y,z)) -> U43(u43(x,y),z)
 U43(x,u43(y,z)) -> U43(x,y)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
-> Usable rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 O(num0) -> num0
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[u43](X1,X2) = X1 + X2 + 1
[u45](X1,X2) = 0
[BS](X) = 0
[Log](X) = 0
[Logu39](X) = 0
[Max](X) = 0
[Min](X) = 0
[O](X) = X + 1
[Size](X) = 0
[Val](X) = 0
[WB](X) = 0
[and](X1,X2) = 0
[ge](X1,X2) = 0
[if](X1,X2,X3) = 0
[not](X) = 0
[num0] = 0
[num1] = 0
[I](X) = X + 2
[L](X) = 0
[N](X1,X2,X3) = 0
[fSNonEmpty] = 0
[ffalse] = 0
[l] = 0
[r] = 0
[ftrue] = 0
[U43](X1,X2) = X1 + X2
[U45](X1,X2) = 0
[BSSharp](X) = 0
[LOG](X) = 0
[LOGU39](X) = 0
[OSharp](X) = 0
[AND](X1,X2) = 0
[GE](X1,X2) = 0
[IF](X1,X2,X3) = 0
[NOT](X) = 0

Problem 1.4: 

SCC Processor:
-> Pairs:
 U43(I(x),O(y)) -> U43(x,y)
 U43(I(x),I(y)) -> U43(u43(x,y),I(num0))
 U43(I(x),I(y)) -> U43(x,y)
 U43(x,u43(y,z)) -> U43(u43(x,y),z)
 U43(x,u43(y,z)) -> U43(x,y)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 U43(I(x),O(y)) -> U43(x,y)
 U43(I(x),I(y)) -> U43(u43(x,y),I(num0))
 U43(I(x),I(y)) -> U43(x,y)
 U43(x,u43(y,z)) -> U43(u43(x,y),z)
 U43(x,u43(y,z)) -> U43(x,y)
->->-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse

Problem 1.4: 

Reduction Pair Processor:
-> Pairs:
 U43(I(x),O(y)) -> U43(x,y)
 U43(I(x),I(y)) -> U43(u43(x,y),I(num0))
 U43(I(x),I(y)) -> U43(x,y)
 U43(x,u43(y,z)) -> U43(u43(x,y),z)
 U43(x,u43(y,z)) -> U43(x,y)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
-> Usable rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 O(num0) -> num0
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[u43](X1,X2) = X1 + 2.X2
[u45](X1,X2) = 0
[BS](X) = 0
[Log](X) = 0
[Logu39](X) = 0
[Max](X) = 0
[Min](X) = 0
[O](X) = X + 2
[Size](X) = 0
[Val](X) = 0
[WB](X) = 0
[and](X1,X2) = 0
[ge](X1,X2) = 0
[if](X1,X2,X3) = 0
[not](X) = 0
[num0] = 0
[num1] = 0
[I](X) = X + 2
[L](X) = 0
[N](X1,X2,X3) = 0
[fSNonEmpty] = 0
[ffalse] = 0
[l] = 0
[r] = 0
[ftrue] = 0
[U43](X1,X2) = X1 + 2.X2
[U45](X1,X2) = 0
[BSSharp](X) = 0
[LOG](X) = 0
[LOGU39](X) = 0
[OSharp](X) = 0
[AND](X1,X2) = 0
[GE](X1,X2) = 0
[IF](X1,X2,X3) = 0
[NOT](X) = 0

Problem 1.4: 

SCC Processor:
-> Pairs:
 U43(I(x),I(y)) -> U43(u43(x,y),I(num0))
 U43(I(x),I(y)) -> U43(x,y)
 U43(x,u43(y,z)) -> U43(u43(x,y),z)
 U43(x,u43(y,z)) -> U43(x,y)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 U43(I(x),I(y)) -> U43(u43(x,y),I(num0))
 U43(I(x),I(y)) -> U43(x,y)
 U43(x,u43(y,z)) -> U43(u43(x,y),z)
 U43(x,u43(y,z)) -> U43(x,y)
->->-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse

Problem 1.4: 

Reduction Pair Processor:
-> Pairs:
 U43(I(x),I(y)) -> U43(u43(x,y),I(num0))
 U43(I(x),I(y)) -> U43(x,y)
 U43(x,u43(y,z)) -> U43(u43(x,y),z)
 U43(x,u43(y,z)) -> U43(x,y)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
-> Usable rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 O(num0) -> num0
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[u43](X1,X2) = X1 + 2.X2 + 1
[u45](X1,X2) = 0
[BS](X) = 0
[Log](X) = 0
[Logu39](X) = 0
[Max](X) = 0
[Min](X) = 0
[O](X) = X + 1
[Size](X) = 0
[Val](X) = 0
[WB](X) = 0
[and](X1,X2) = 0
[ge](X1,X2) = 0
[if](X1,X2,X3) = 0
[not](X) = 0
[num0] = 0
[num1] = 0
[I](X) = X + 2
[L](X) = 0
[N](X1,X2,X3) = 0
[fSNonEmpty] = 0
[ffalse] = 0
[l] = 0
[r] = 0
[ftrue] = 0
[U43](X1,X2) = X1 + 2.X2
[U45](X1,X2) = 0
[BSSharp](X) = 0
[LOG](X) = 0
[LOGU39](X) = 0
[OSharp](X) = 0
[AND](X1,X2) = 0
[GE](X1,X2) = 0
[IF](X1,X2,X3) = 0
[NOT](X) = 0

Problem 1.4: 

SCC Processor:
-> Pairs:
 U43(I(x),I(y)) -> U43(x,y)
 U43(x,u43(y,z)) -> U43(u43(x,y),z)
 U43(x,u43(y,z)) -> U43(x,y)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 U43(I(x),I(y)) -> U43(x,y)
 U43(x,u43(y,z)) -> U43(u43(x,y),z)
 U43(x,u43(y,z)) -> U43(x,y)
->->-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse

Problem 1.4: 

Subterm Processor:
-> Pairs:
 U43(I(x),I(y)) -> U43(x,y)
 U43(x,u43(y,z)) -> U43(u43(x,y),z)
 U43(x,u43(y,z)) -> U43(x,y)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->Projection:
 pi(U43) = 2

Problem 1.4: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.5: 

Subterm Processor:
-> Pairs:
 LOGU39(O(x)) -> LOGU39(x)
 LOGU39(I(x)) -> LOGU39(x)
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->Projection:
 pi(LOGU39) = 1

Problem 1.5: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 u43(O(x),O(y)) -> O(u43(x,y))
 u43(O(x),I(y)) -> I(u43(x,y))
 u43(num0,x) -> x
 u43(I(x),O(y)) -> I(u43(x,y))
 u43(I(x),I(y)) -> O(u43(u43(x,y),I(num0)))
 u43(x,u43(y,z)) -> u43(u43(x,y),z)
 u43(x,num0) -> x
 u45(O(x),O(y)) -> O(u45(x,y))
 u45(O(x),I(y)) -> I(u45(u45(x,y),I(num1)))
 u45(num0,x) -> num0
 u45(I(x),O(y)) -> I(u45(x,y))
 u45(I(x),I(y)) -> O(u45(x,y))
 u45(x,num0) -> x
 BS(L(x)) -> ftrue
 BS(N(x,l,r)) -> and(and(ge(x,Max(l)),ge(Min(r),x)),and(BS(l),BS(r)))
 Log(x) -> u45(Logu39(x),I(num0))
 Logu39(O(x)) -> if(ge(x,I(num0)),u43(Logu39(x),I(num0)),num0)
 Logu39(num0) -> num0
 Logu39(I(x)) -> u43(Logu39(x),I(num0))
 Max(L(x)) -> x
 Max(N(x,l,r)) -> Max(r)
 Min(L(x)) -> x
 Min(N(x,l,r)) -> Min(l)
 O(num0) -> num0
 Size(L(x)) -> I(num0)
 Size(N(x,l,r)) -> u43(u43(Size(l),Size(r)),I(num1))
 Val(L(x)) -> x
 Val(N(x,l,r)) -> x
 WB(L(x)) -> ftrue
 WB(N(x,l,r)) -> and(if(ge(Size(l),Size(r)),ge(I(num0),u45(Size(l),Size(r))),ge(I(num0),u45(Size(r),Size(l)))),and(WB(l),WB(r)))
 and(x,ffalse) -> ffalse
 and(x,ftrue) -> x
 ge(O(x),O(y)) -> ge(x,y)
 ge(O(x),I(y)) -> not(ge(y,x))
 ge(num0,O(x)) -> ge(num0,x)
 ge(num0,I(x)) -> ffalse
 ge(I(x),O(y)) -> ge(x,y)
 ge(I(x),I(y)) -> ge(x,y)
 ge(x,num0) -> ftrue
 if(ffalse,x,y) -> y
 if(ftrue,x,y) -> x
 not(ffalse) -> ftrue
 not(ftrue) -> ffalse
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
