NO

Problem 1: 

(VAR vu95NonEmpty L X Y)
(RULES
eq(num0,num0) -> ftrue
eq(s(X),s(Y)) -> eq(X,Y)
eq(X,Y) -> ffalse
inf(X) -> cons(X,inf(s(X)))
length(cons(X,L)) -> s(length(L))
length(nil) -> num0
take(num0,X) -> nil
take(s(X),cons(Y,L)) -> cons(Y,take(X,L))
)


Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 EQ(s(X),s(Y)) -> EQ(X,Y)
 INF(X) -> INF(s(X))
 LENGTH(cons(X,L)) -> LENGTH(L)
 TAKE(s(X),cons(Y,L)) -> TAKE(X,L)
-> Rules:
 eq(num0,num0) -> ftrue
 eq(s(X),s(Y)) -> eq(X,Y)
 eq(X,Y) -> ffalse
 inf(X) -> cons(X,inf(s(X)))
 length(cons(X,L)) -> s(length(L))
 length(nil) -> num0
 take(num0,X) -> nil
 take(s(X),cons(Y,L)) -> cons(Y,take(X,L))

Problem 1: 

Infiniteness Processor:
-> Pairs:
 EQ(s(X),s(Y)) -> EQ(X,Y)
 INF(X) -> INF(s(X))
 LENGTH(cons(X,L)) -> LENGTH(L)
 TAKE(s(X),cons(Y,L)) -> TAKE(X,L)
-> Rules:
 eq(num0,num0) -> ftrue
 eq(s(X),s(Y)) -> eq(X,Y)
 eq(X,Y) -> ffalse
 inf(X) -> cons(X,inf(s(X)))
 length(cons(X,L)) -> s(length(L))
 length(nil) -> num0
 take(num0,X) -> nil
 take(s(X),cons(Y,L)) -> cons(Y,take(X,L))
-> Pairs in cycle:
 INF(X) -> INF(s(X))

The problem is infinite.
