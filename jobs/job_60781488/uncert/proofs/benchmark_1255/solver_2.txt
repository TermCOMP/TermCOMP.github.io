YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/UedZZ.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) QTRSRRRProof [EQUIVALENT, 186 ms]
(2) QTRS
(3) QTRSRRRProof [EQUIVALENT, 0 ms]
(4) QTRS
(5) QTRSRRRProof [EQUIVALENT, 0 ms]
(6) QTRS
(7) RisEmptyProof [EQUIVALENT, 0 ms]
(8) YES


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   U11(tt, V1, V2) -> U12(isNat(activate(V1)), activate(V2))
   U12(tt, V2) -> U13(isNat(activate(V2)))
   U13(tt) -> tt
   U21(tt, V1) -> U22(isNat(activate(V1)))
   U22(tt) -> tt
   U31(tt, V1, V2) -> U32(isNat(activate(V1)), activate(V2))
   U32(tt, V2) -> U33(isNat(activate(V2)))
   U33(tt) -> tt
   U41(tt, N) -> activate(N)
   U51(tt, M, N) -> s(plus(activate(N), activate(M)))
   U61(tt) -> 0
   U71(tt, M, N) -> plus(x(activate(N), activate(M)), activate(N))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__plus(V1, V2)) -> U11(and(isNatKind(activate(V1)), n__isNatKind(activate(V2))), activate(V1), activate(V2))
   isNat(n__s(V1)) -> U21(isNatKind(activate(V1)), activate(V1))
   isNat(n__x(V1, V2)) -> U31(and(isNatKind(activate(V1)), n__isNatKind(activate(V2))), activate(V1), activate(V2))
   isNatKind(n__0) -> tt
   isNatKind(n__plus(V1, V2)) -> and(isNatKind(activate(V1)), n__isNatKind(activate(V2)))
   isNatKind(n__s(V1)) -> isNatKind(activate(V1))
   isNatKind(n__x(V1, V2)) -> and(isNatKind(activate(V1)), n__isNatKind(activate(V2)))
   plus(N, 0) -> U41(and(isNat(N), n__isNatKind(N)), N)
   plus(N, s(M)) -> U51(and(and(isNat(M), n__isNatKind(M)), n__and(n__isNat(N), n__isNatKind(N))), M, N)
   x(N, 0) -> U61(and(isNat(N), n__isNatKind(N)))
   x(N, s(M)) -> U71(and(and(isNat(M), n__isNatKind(M)), n__and(n__isNat(N), n__isNatKind(N))), M, N)
   0 -> n__0
   plus(X1, X2) -> n__plus(X1, X2)
   isNatKind(X) -> n__isNatKind(X)
   s(X) -> n__s(X)
   x(X1, X2) -> n__x(X1, X2)
   and(X1, X2) -> n__and(X1, X2)
   isNat(X) -> n__isNat(X)
   activate(n__0) -> 0
   activate(n__plus(X1, X2)) -> plus(activate(X1), activate(X2))
   activate(n__isNatKind(X)) -> isNatKind(X)
   activate(n__s(X)) -> s(activate(X))
   activate(n__x(X1, X2)) -> x(activate(X1), activate(X2))
   activate(n__and(X1, X2)) -> and(activate(X1), X2)
   activate(n__isNat(X)) -> isNat(X)
   activate(X) -> X

Q is empty.

----------------------------------------

(1) QTRSRRRProof (EQUIVALENT)
Used ordering:
U11/3(YES,YES,YES)
tt/0)
U12/2(YES,YES)
isNat/1)YES(
activate/1)YES(
U13/1(YES)
U21/2(YES,YES)
U22/1)YES(
U31/3(YES,YES,YES)
U32/2(YES,YES)
U33/1(YES)
U41/2(YES,YES)
U51/3(YES,YES,YES)
s/1(YES)
plus/2(YES,YES)
U61/1(YES)
0/0)
U71/3(YES,YES,YES)
x/2(YES,YES)
and/2(YES,YES)
n__0/0)
n__plus/2(YES,YES)
isNatKind/1)YES(
n__isNatKind/1)YES(
n__s/1(YES)
n__x/2(YES,YES)
n__and/2(YES,YES)
n__isNat/1)YES(

Quasi precedence:
[U71_3, x_2, n__x_2] > U31_3 > U32_2 > U33_1
[U71_3, x_2, n__x_2] > [U51_3, plus_2, n__plus_2] > U11_3 > [U12_2, U13_1] > tt > U33_1
[U71_3, x_2, n__x_2] > [U51_3, plus_2, n__plus_2] > U11_3 > [U12_2, U13_1] > tt > [s_1, n__s_1] > U21_2
[U71_3, x_2, n__x_2] > [U51_3, plus_2, n__plus_2] > U41_2
[U71_3, x_2, n__x_2] > [U51_3, plus_2, n__plus_2] > [and_2, n__and_2]
[U71_3, x_2, n__x_2] > U61_1 > [0, n__0] > tt > U33_1
[U71_3, x_2, n__x_2] > U61_1 > [0, n__0] > tt > [s_1, n__s_1] > U21_2
[U71_3, x_2, n__x_2] > U61_1 > [0, n__0] > U41_2
[U71_3, x_2, n__x_2] > U61_1 > [0, n__0] > [and_2, n__and_2]


Status:
U11_3: multiset status
tt: multiset status
U12_2: multiset status
U13_1: multiset status
U21_2: multiset status
U31_3: [3,2,1]
U32_2: [1,2]
U33_1: [1]
U41_2: multiset status
U51_3: [3,2,1]
s_1: multiset status
plus_2: [1,2]
U61_1: multiset status
0: multiset status
U71_3: [3,2,1]
x_2: [1,2]
and_2: multiset status
n__0: multiset status
n__plus_2: [1,2]
n__s_1: multiset status
n__x_2: [1,2]
n__and_2: multiset status

With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   U11(tt, V1, V2) -> U12(isNat(activate(V1)), activate(V2))
   U12(tt, V2) -> U13(isNat(activate(V2)))
   U13(tt) -> tt
   U21(tt, V1) -> U22(isNat(activate(V1)))
   U31(tt, V1, V2) -> U32(isNat(activate(V1)), activate(V2))
   U32(tt, V2) -> U33(isNat(activate(V2)))
   U33(tt) -> tt
   U41(tt, N) -> activate(N)
   U51(tt, M, N) -> s(plus(activate(N), activate(M)))
   U61(tt) -> 0
   U71(tt, M, N) -> plus(x(activate(N), activate(M)), activate(N))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__plus(V1, V2)) -> U11(and(isNatKind(activate(V1)), n__isNatKind(activate(V2))), activate(V1), activate(V2))
   isNat(n__s(V1)) -> U21(isNatKind(activate(V1)), activate(V1))
   isNat(n__x(V1, V2)) -> U31(and(isNatKind(activate(V1)), n__isNatKind(activate(V2))), activate(V1), activate(V2))
   isNatKind(n__0) -> tt
   isNatKind(n__plus(V1, V2)) -> and(isNatKind(activate(V1)), n__isNatKind(activate(V2)))
   isNatKind(n__s(V1)) -> isNatKind(activate(V1))
   isNatKind(n__x(V1, V2)) -> and(isNatKind(activate(V1)), n__isNatKind(activate(V2)))
   plus(N, 0) -> U41(and(isNat(N), n__isNatKind(N)), N)
   plus(N, s(M)) -> U51(and(and(isNat(M), n__isNatKind(M)), n__and(n__isNat(N), n__isNatKind(N))), M, N)
   x(N, 0) -> U61(and(isNat(N), n__isNatKind(N)))
   x(N, s(M)) -> U71(and(and(isNat(M), n__isNatKind(M)), n__and(n__isNat(N), n__isNatKind(N))), M, N)




----------------------------------------

(2)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   U22(tt) -> tt
   0 -> n__0
   plus(X1, X2) -> n__plus(X1, X2)
   isNatKind(X) -> n__isNatKind(X)
   s(X) -> n__s(X)
   x(X1, X2) -> n__x(X1, X2)
   and(X1, X2) -> n__and(X1, X2)
   isNat(X) -> n__isNat(X)
   activate(n__0) -> 0
   activate(n__plus(X1, X2)) -> plus(activate(X1), activate(X2))
   activate(n__isNatKind(X)) -> isNatKind(X)
   activate(n__s(X)) -> s(activate(X))
   activate(n__x(X1, X2)) -> x(activate(X1), activate(X2))
   activate(n__and(X1, X2)) -> and(activate(X1), X2)
   activate(n__isNat(X)) -> isNat(X)
   activate(X) -> X

Q is empty.

----------------------------------------

(3) QTRSRRRProof (EQUIVALENT)
Used ordering:
Polynomial interpretation [POLO]:

   POL(0) = 2
   POL(U22(x_1)) = 1 + x_1
   POL(activate(x_1)) = 2*x_1
   POL(and(x_1, x_2)) = x_1 + 2*x_2
   POL(isNat(x_1)) = 2*x_1
   POL(isNatKind(x_1)) = 1 + 2*x_1
   POL(n__0) = 2
   POL(n__and(x_1, x_2)) = x_1 + 2*x_2
   POL(n__isNat(x_1)) = x_1
   POL(n__isNatKind(x_1)) = 1 + 2*x_1
   POL(n__plus(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(n__s(x_1)) = 1 + x_1
   POL(n__x(x_1, x_2)) = 1 + x_1 + 2*x_2
   POL(plus(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(s(x_1)) = 1 + x_1
   POL(tt) = 0
   POL(x(x_1, x_2)) = 1 + x_1 + 2*x_2
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   U22(tt) -> tt
   activate(n__0) -> 0
   activate(n__isNatKind(X)) -> isNatKind(X)
   activate(n__s(X)) -> s(activate(X))
   activate(n__x(X1, X2)) -> x(activate(X1), activate(X2))




----------------------------------------

(4)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   0 -> n__0
   plus(X1, X2) -> n__plus(X1, X2)
   isNatKind(X) -> n__isNatKind(X)
   s(X) -> n__s(X)
   x(X1, X2) -> n__x(X1, X2)
   and(X1, X2) -> n__and(X1, X2)
   isNat(X) -> n__isNat(X)
   activate(n__plus(X1, X2)) -> plus(activate(X1), activate(X2))
   activate(n__and(X1, X2)) -> and(activate(X1), X2)
   activate(n__isNat(X)) -> isNat(X)
   activate(X) -> X

Q is empty.

----------------------------------------

(5) QTRSRRRProof (EQUIVALENT)
Used ordering:
Knuth-Bendix order [KBO] with precedence:activate_1 > isNat_1 > n__x_2 > s_1 > 0 > n__s_1 > x_2 > and_2 > n__0 > isNatKind_1 > n__isNatKind_1 > plus_2 > n__isNat_1 > n__and_2 > n__plus_2

and weight map:

   0=1
   n__0=1
   isNatKind_1=1
   n__isNatKind_1=1
   s_1=1
   n__s_1=1
   isNat_1=1
   n__isNat_1=1
   activate_1=0
   plus_2=0
   n__plus_2=0
   x_2=1
   n__x_2=0
   and_2=0
   n__and_2=0

The variable weight is 1With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   0 -> n__0
   plus(X1, X2) -> n__plus(X1, X2)
   isNatKind(X) -> n__isNatKind(X)
   s(X) -> n__s(X)
   x(X1, X2) -> n__x(X1, X2)
   and(X1, X2) -> n__and(X1, X2)
   isNat(X) -> n__isNat(X)
   activate(n__plus(X1, X2)) -> plus(activate(X1), activate(X2))
   activate(n__and(X1, X2)) -> and(activate(X1), X2)
   activate(n__isNat(X)) -> isNat(X)
   activate(X) -> X




----------------------------------------

(6)
Obligation:
Q restricted rewrite system:
R is empty.
Q is empty.

----------------------------------------

(7) RisEmptyProof (EQUIVALENT)
The TRS R is empty. Hence, termination is trivially proven.
----------------------------------------

(8)
YES
