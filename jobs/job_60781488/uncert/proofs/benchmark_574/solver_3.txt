YES

Problem 1: 

(VAR vu95NonEmpty K L M N X Y)
(RULES
eq(num0,num0) -> ftrue
eq(num0,s(Y)) -> ffalse
eq(s(X),num0) -> ffalse
eq(s(X),s(Y)) -> eq(X,Y)
ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
le(num0,Y) -> ftrue
le(s(X),num0) -> ffalse
le(s(X),s(Y)) -> le(X,Y)
min(cons(num0,nil)) -> num0
min(cons(s(N),nil)) -> s(N)
min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
replace(N,M,nil) -> nil
selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
selsort(nil) -> nil
)


Problem 1: 

Innermost Equivalent Processor:
-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil
-> The term rewriting system is non-overlaping or locally confluent overlay system. Therefore, innermost termination implies termination.
 

Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 EQ(s(X),s(Y)) -> EQ(X,Y)
 IFMIN(ffalse,cons(N,cons(M,L))) -> MIN(cons(M,L))
 IFMIN(ftrue,cons(N,cons(M,L))) -> MIN(cons(N,L))
 IFREPL(ffalse,N,M,cons(K,L)) -> REPLACE(N,M,L)
 IFSELSORT(ffalse,cons(N,L)) -> MIN(cons(N,L))
 IFSELSORT(ffalse,cons(N,L)) -> REPLACE(min(cons(N,L)),N,L)
 IFSELSORT(ffalse,cons(N,L)) -> SELSORT(replace(min(cons(N,L)),N,L))
 IFSELSORT(ftrue,cons(N,L)) -> SELSORT(L)
 LE(s(X),s(Y)) -> LE(X,Y)
 MIN(cons(N,cons(M,L))) -> IFMIN(le(N,M),cons(N,cons(M,L)))
 MIN(cons(N,cons(M,L))) -> LE(N,M)
 REPLACE(N,M,cons(K,L)) -> EQ(N,K)
 REPLACE(N,M,cons(K,L)) -> IFREPL(eq(N,K),N,M,cons(K,L))
 SELSORT(cons(N,L)) -> EQ(N,min(cons(N,L)))
 SELSORT(cons(N,L)) -> IFSELSORT(eq(N,min(cons(N,L))),cons(N,L))
 SELSORT(cons(N,L)) -> MIN(cons(N,L))
-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil

Problem 1: 

SCC Processor:
-> Pairs:
 EQ(s(X),s(Y)) -> EQ(X,Y)
 IFMIN(ffalse,cons(N,cons(M,L))) -> MIN(cons(M,L))
 IFMIN(ftrue,cons(N,cons(M,L))) -> MIN(cons(N,L))
 IFREPL(ffalse,N,M,cons(K,L)) -> REPLACE(N,M,L)
 IFSELSORT(ffalse,cons(N,L)) -> MIN(cons(N,L))
 IFSELSORT(ffalse,cons(N,L)) -> REPLACE(min(cons(N,L)),N,L)
 IFSELSORT(ffalse,cons(N,L)) -> SELSORT(replace(min(cons(N,L)),N,L))
 IFSELSORT(ftrue,cons(N,L)) -> SELSORT(L)
 LE(s(X),s(Y)) -> LE(X,Y)
 MIN(cons(N,cons(M,L))) -> IFMIN(le(N,M),cons(N,cons(M,L)))
 MIN(cons(N,cons(M,L))) -> LE(N,M)
 REPLACE(N,M,cons(K,L)) -> EQ(N,K)
 REPLACE(N,M,cons(K,L)) -> IFREPL(eq(N,K),N,M,cons(K,L))
 SELSORT(cons(N,L)) -> EQ(N,min(cons(N,L)))
 SELSORT(cons(N,L)) -> IFSELSORT(eq(N,min(cons(N,L))),cons(N,L))
 SELSORT(cons(N,L)) -> MIN(cons(N,L))
-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 LE(s(X),s(Y)) -> LE(X,Y)
->->-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil
->->Cycle:
->->-> Pairs:
 IFMIN(ffalse,cons(N,cons(M,L))) -> MIN(cons(M,L))
 IFMIN(ftrue,cons(N,cons(M,L))) -> MIN(cons(N,L))
 MIN(cons(N,cons(M,L))) -> IFMIN(le(N,M),cons(N,cons(M,L)))
->->-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil
->->Cycle:
->->-> Pairs:
 EQ(s(X),s(Y)) -> EQ(X,Y)
->->-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil
->->Cycle:
->->-> Pairs:
 IFREPL(ffalse,N,M,cons(K,L)) -> REPLACE(N,M,L)
 REPLACE(N,M,cons(K,L)) -> IFREPL(eq(N,K),N,M,cons(K,L))
->->-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil
->->Cycle:
->->-> Pairs:
 IFSELSORT(ffalse,cons(N,L)) -> SELSORT(replace(min(cons(N,L)),N,L))
 IFSELSORT(ftrue,cons(N,L)) -> SELSORT(L)
 SELSORT(cons(N,L)) -> IFSELSORT(eq(N,min(cons(N,L))),cons(N,L))
->->-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil


The problem is decomposed in 5 subproblems.

Problem 1.1: 

Subterm Processor:
-> Pairs:
 LE(s(X),s(Y)) -> LE(X,Y)
-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil
->Projection:
 pi(LE) = 1

Problem 1.1: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2: 

Reduction Pairs Processor:
-> Pairs:
 IFMIN(ffalse,cons(N,cons(M,L))) -> MIN(cons(M,L))
 IFMIN(ftrue,cons(N,cons(M,L))) -> MIN(cons(N,L))
 MIN(cons(N,cons(M,L))) -> IFMIN(le(N,M),cons(N,cons(M,L)))
-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil
-> Usable rules:
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[eq](X1,X2) = 0
[ifmin](X1,X2) = 0
[ifrepl](X1,X2,X3,X4) = 0
[ifselsort](X1,X2) = 0
[le](X1,X2) = 1
[min](X) = 0
[replace](X1,X2,X3) = 0
[selsort](X) = 0
[num0] = 2
[cons](X1,X2) = X2 + 2
[fSNonEmpty] = 0
[ffalse] = 1
[nil] = 0
[s](X) = X + 1
[ftrue] = 1
[EQ](X1,X2) = 0
[IFMIN](X1,X2) = 2.X1 + 2.X2
[IFREPL](X1,X2,X3,X4) = 0
[IFSELSORT](X1,X2) = 0
[LE](X1,X2) = 0
[MIN](X) = 2.X + 2
[REPLACE](X1,X2,X3) = 0
[SELSORT](X) = 0

Problem 1.2: 

SCC Processor:
-> Pairs:
 IFMIN(ftrue,cons(N,cons(M,L))) -> MIN(cons(N,L))
 MIN(cons(N,cons(M,L))) -> IFMIN(le(N,M),cons(N,cons(M,L)))
-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 IFMIN(ftrue,cons(N,cons(M,L))) -> MIN(cons(N,L))
 MIN(cons(N,cons(M,L))) -> IFMIN(le(N,M),cons(N,cons(M,L)))
->->-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil

Problem 1.2: 

Reduction Pairs Processor:
-> Pairs:
 IFMIN(ftrue,cons(N,cons(M,L))) -> MIN(cons(N,L))
 MIN(cons(N,cons(M,L))) -> IFMIN(le(N,M),cons(N,cons(M,L)))
-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil
-> Usable rules:
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[eq](X1,X2) = 0
[ifmin](X1,X2) = 0
[ifrepl](X1,X2,X3,X4) = 0
[ifselsort](X1,X2) = 0
[le](X1,X2) = 2
[min](X) = 0
[replace](X1,X2,X3) = 0
[selsort](X) = 0
[num0] = 0
[cons](X1,X2) = 2.X2 + 2
[fSNonEmpty] = 0
[ffalse] = 0
[nil] = 0
[s](X) = 2.X + 2
[ftrue] = 2
[EQ](X1,X2) = 0
[IFMIN](X1,X2) = 2.X1 + X2 + 2
[IFREPL](X1,X2,X3,X4) = 0
[IFSELSORT](X1,X2) = 0
[LE](X1,X2) = 0
[MIN](X) = 2.X + 2
[REPLACE](X1,X2,X3) = 0
[SELSORT](X) = 0

Problem 1.2: 

SCC Processor:
-> Pairs:
 MIN(cons(N,cons(M,L))) -> IFMIN(le(N,M),cons(N,cons(M,L)))
-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.3: 

Subterm Processor:
-> Pairs:
 EQ(s(X),s(Y)) -> EQ(X,Y)
-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil
->Projection:
 pi(EQ) = 1

Problem 1.3: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.4: 

Subterm Processor:
-> Pairs:
 IFREPL(ffalse,N,M,cons(K,L)) -> REPLACE(N,M,L)
 REPLACE(N,M,cons(K,L)) -> IFREPL(eq(N,K),N,M,cons(K,L))
-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil
->Projection:
 pi(IFREPL) = 4
 pi(REPLACE) = 3

Problem 1.4: 

SCC Processor:
-> Pairs:
 REPLACE(N,M,cons(K,L)) -> IFREPL(eq(N,K),N,M,cons(K,L))
-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.5: 

Reduction Pairs Processor:
-> Pairs:
 IFSELSORT(ffalse,cons(N,L)) -> SELSORT(replace(min(cons(N,L)),N,L))
 IFSELSORT(ftrue,cons(N,L)) -> SELSORT(L)
 SELSORT(cons(N,L)) -> IFSELSORT(eq(N,min(cons(N,L))),cons(N,L))
-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil
-> Usable rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[eq](X1,X2) = 2.X1 + 2.X2 + 2
[ifmin](X1,X2) = 2.X2 + 1
[ifrepl](X1,X2,X3,X4) = 2.X3 + X4
[ifselsort](X1,X2) = 0
[le](X1,X2) = 2.X2 + 2
[min](X) = 2.X + 1
[replace](X1,X2,X3) = 2.X2 + X3
[selsort](X) = 0
[num0] = 2
[cons](X1,X2) = 2.X1 + X2 + 2
[fSNonEmpty] = 0
[ffalse] = 0
[nil] = 0
[s](X) = 2.X + 2
[ftrue] = 0
[EQ](X1,X2) = 0
[IFMIN](X1,X2) = 0
[IFREPL](X1,X2,X3,X4) = 0
[IFSELSORT](X1,X2) = 2.X2 + 1
[LE](X1,X2) = 0
[MIN](X) = 0
[REPLACE](X1,X2,X3) = 0
[SELSORT](X) = 2.X + 1

Problem 1.5: 

SCC Processor:
-> Pairs:
 IFSELSORT(ftrue,cons(N,L)) -> SELSORT(L)
 SELSORT(cons(N,L)) -> IFSELSORT(eq(N,min(cons(N,L))),cons(N,L))
-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 IFSELSORT(ftrue,cons(N,L)) -> SELSORT(L)
 SELSORT(cons(N,L)) -> IFSELSORT(eq(N,min(cons(N,L))),cons(N,L))
->->-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil

Problem 1.5: 

Subterm Processor:
-> Pairs:
 IFSELSORT(ftrue,cons(N,L)) -> SELSORT(L)
 SELSORT(cons(N,L)) -> IFSELSORT(eq(N,min(cons(N,L))),cons(N,L))
-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil
->Projection:
 pi(IFSELSORT) = 2
 pi(SELSORT) = 1

Problem 1.5: 

SCC Processor:
-> Pairs:
 SELSORT(cons(N,L)) -> IFSELSORT(eq(N,min(cons(N,L))),cons(N,L))
-> Rules:
 eq(num0,num0) -> ftrue
 eq(num0,s(Y)) -> ffalse
 eq(s(X),num0) -> ffalse
 eq(s(X),s(Y)) -> eq(X,Y)
 ifmin(ffalse,cons(N,cons(M,L))) -> min(cons(M,L))
 ifmin(ftrue,cons(N,cons(M,L))) -> min(cons(N,L))
 ifrepl(ffalse,N,M,cons(K,L)) -> cons(K,replace(N,M,L))
 ifrepl(ftrue,N,M,cons(K,L)) -> cons(M,L)
 ifselsort(ffalse,cons(N,L)) -> cons(min(cons(N,L)),selsort(replace(min(cons(N,L)),N,L)))
 ifselsort(ftrue,cons(N,L)) -> cons(N,selsort(L))
 le(num0,Y) -> ftrue
 le(s(X),num0) -> ffalse
 le(s(X),s(Y)) -> le(X,Y)
 min(cons(num0,nil)) -> num0
 min(cons(s(N),nil)) -> s(N)
 min(cons(N,cons(M,L))) -> ifmin(le(N,M),cons(N,cons(M,L)))
 replace(N,M,cons(K,L)) -> ifrepl(eq(N,K),N,M,cons(K,L))
 replace(N,M,nil) -> nil
 selsort(cons(N,L)) -> ifselsort(eq(N,min(cons(N,L))),cons(N,L))
 selsort(nil) -> nil
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
