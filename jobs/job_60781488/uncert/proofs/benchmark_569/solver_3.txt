YES

Problem 1: 

(VAR vu95NonEmpty ALPHA BETA X)
(RULES
dx(a) -> zero
dx(div(ALPHA,BETA)) -> minus(div(dx(ALPHA),BETA),times(ALPHA,div(dx(BETA),exp(BETA,two))))
dx(exp(ALPHA,BETA)) -> plus(times(BETA,times(exp(ALPHA,minus(BETA,one)),dx(ALPHA))),times(exp(ALPHA,BETA),times(ln(ALPHA),dx(BETA))))
dx(ln(ALPHA)) -> div(dx(ALPHA),ALPHA)
dx(minus(ALPHA,BETA)) -> minus(dx(ALPHA),dx(BETA))
dx(neg(ALPHA)) -> neg(dx(ALPHA))
dx(plus(ALPHA,BETA)) -> plus(dx(ALPHA),dx(BETA))
dx(times(ALPHA,BETA)) -> plus(times(BETA,dx(ALPHA)),times(ALPHA,dx(BETA)))
dx(X) -> one
)


Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 DX(div(ALPHA,BETA)) -> DX(ALPHA)
 DX(div(ALPHA,BETA)) -> DX(BETA)
 DX(exp(ALPHA,BETA)) -> DX(ALPHA)
 DX(exp(ALPHA,BETA)) -> DX(BETA)
 DX(ln(ALPHA)) -> DX(ALPHA)
 DX(minus(ALPHA,BETA)) -> DX(ALPHA)
 DX(minus(ALPHA,BETA)) -> DX(BETA)
 DX(neg(ALPHA)) -> DX(ALPHA)
 DX(plus(ALPHA,BETA)) -> DX(ALPHA)
 DX(plus(ALPHA,BETA)) -> DX(BETA)
 DX(times(ALPHA,BETA)) -> DX(ALPHA)
 DX(times(ALPHA,BETA)) -> DX(BETA)
-> Rules:
 dx(a) -> zero
 dx(div(ALPHA,BETA)) -> minus(div(dx(ALPHA),BETA),times(ALPHA,div(dx(BETA),exp(BETA,two))))
 dx(exp(ALPHA,BETA)) -> plus(times(BETA,times(exp(ALPHA,minus(BETA,one)),dx(ALPHA))),times(exp(ALPHA,BETA),times(ln(ALPHA),dx(BETA))))
 dx(ln(ALPHA)) -> div(dx(ALPHA),ALPHA)
 dx(minus(ALPHA,BETA)) -> minus(dx(ALPHA),dx(BETA))
 dx(neg(ALPHA)) -> neg(dx(ALPHA))
 dx(plus(ALPHA,BETA)) -> plus(dx(ALPHA),dx(BETA))
 dx(times(ALPHA,BETA)) -> plus(times(BETA,dx(ALPHA)),times(ALPHA,dx(BETA)))
 dx(X) -> one

Problem 1: 

SCC Processor:
-> Pairs:
 DX(div(ALPHA,BETA)) -> DX(ALPHA)
 DX(div(ALPHA,BETA)) -> DX(BETA)
 DX(exp(ALPHA,BETA)) -> DX(ALPHA)
 DX(exp(ALPHA,BETA)) -> DX(BETA)
 DX(ln(ALPHA)) -> DX(ALPHA)
 DX(minus(ALPHA,BETA)) -> DX(ALPHA)
 DX(minus(ALPHA,BETA)) -> DX(BETA)
 DX(neg(ALPHA)) -> DX(ALPHA)
 DX(plus(ALPHA,BETA)) -> DX(ALPHA)
 DX(plus(ALPHA,BETA)) -> DX(BETA)
 DX(times(ALPHA,BETA)) -> DX(ALPHA)
 DX(times(ALPHA,BETA)) -> DX(BETA)
-> Rules:
 dx(a) -> zero
 dx(div(ALPHA,BETA)) -> minus(div(dx(ALPHA),BETA),times(ALPHA,div(dx(BETA),exp(BETA,two))))
 dx(exp(ALPHA,BETA)) -> plus(times(BETA,times(exp(ALPHA,minus(BETA,one)),dx(ALPHA))),times(exp(ALPHA,BETA),times(ln(ALPHA),dx(BETA))))
 dx(ln(ALPHA)) -> div(dx(ALPHA),ALPHA)
 dx(minus(ALPHA,BETA)) -> minus(dx(ALPHA),dx(BETA))
 dx(neg(ALPHA)) -> neg(dx(ALPHA))
 dx(plus(ALPHA,BETA)) -> plus(dx(ALPHA),dx(BETA))
 dx(times(ALPHA,BETA)) -> plus(times(BETA,dx(ALPHA)),times(ALPHA,dx(BETA)))
 dx(X) -> one
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 DX(div(ALPHA,BETA)) -> DX(ALPHA)
 DX(div(ALPHA,BETA)) -> DX(BETA)
 DX(exp(ALPHA,BETA)) -> DX(ALPHA)
 DX(exp(ALPHA,BETA)) -> DX(BETA)
 DX(ln(ALPHA)) -> DX(ALPHA)
 DX(minus(ALPHA,BETA)) -> DX(ALPHA)
 DX(minus(ALPHA,BETA)) -> DX(BETA)
 DX(neg(ALPHA)) -> DX(ALPHA)
 DX(plus(ALPHA,BETA)) -> DX(ALPHA)
 DX(plus(ALPHA,BETA)) -> DX(BETA)
 DX(times(ALPHA,BETA)) -> DX(ALPHA)
 DX(times(ALPHA,BETA)) -> DX(BETA)
->->-> Rules:
 dx(a) -> zero
 dx(div(ALPHA,BETA)) -> minus(div(dx(ALPHA),BETA),times(ALPHA,div(dx(BETA),exp(BETA,two))))
 dx(exp(ALPHA,BETA)) -> plus(times(BETA,times(exp(ALPHA,minus(BETA,one)),dx(ALPHA))),times(exp(ALPHA,BETA),times(ln(ALPHA),dx(BETA))))
 dx(ln(ALPHA)) -> div(dx(ALPHA),ALPHA)
 dx(minus(ALPHA,BETA)) -> minus(dx(ALPHA),dx(BETA))
 dx(neg(ALPHA)) -> neg(dx(ALPHA))
 dx(plus(ALPHA,BETA)) -> plus(dx(ALPHA),dx(BETA))
 dx(times(ALPHA,BETA)) -> plus(times(BETA,dx(ALPHA)),times(ALPHA,dx(BETA)))
 dx(X) -> one

Problem 1: 

Subterm Processor:
-> Pairs:
 DX(div(ALPHA,BETA)) -> DX(ALPHA)
 DX(div(ALPHA,BETA)) -> DX(BETA)
 DX(exp(ALPHA,BETA)) -> DX(ALPHA)
 DX(exp(ALPHA,BETA)) -> DX(BETA)
 DX(ln(ALPHA)) -> DX(ALPHA)
 DX(minus(ALPHA,BETA)) -> DX(ALPHA)
 DX(minus(ALPHA,BETA)) -> DX(BETA)
 DX(neg(ALPHA)) -> DX(ALPHA)
 DX(plus(ALPHA,BETA)) -> DX(ALPHA)
 DX(plus(ALPHA,BETA)) -> DX(BETA)
 DX(times(ALPHA,BETA)) -> DX(ALPHA)
 DX(times(ALPHA,BETA)) -> DX(BETA)
-> Rules:
 dx(a) -> zero
 dx(div(ALPHA,BETA)) -> minus(div(dx(ALPHA),BETA),times(ALPHA,div(dx(BETA),exp(BETA,two))))
 dx(exp(ALPHA,BETA)) -> plus(times(BETA,times(exp(ALPHA,minus(BETA,one)),dx(ALPHA))),times(exp(ALPHA,BETA),times(ln(ALPHA),dx(BETA))))
 dx(ln(ALPHA)) -> div(dx(ALPHA),ALPHA)
 dx(minus(ALPHA,BETA)) -> minus(dx(ALPHA),dx(BETA))
 dx(neg(ALPHA)) -> neg(dx(ALPHA))
 dx(plus(ALPHA,BETA)) -> plus(dx(ALPHA),dx(BETA))
 dx(times(ALPHA,BETA)) -> plus(times(BETA,dx(ALPHA)),times(ALPHA,dx(BETA)))
 dx(X) -> one
->Projection:
 pi(DX) = 1

Problem 1: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 dx(a) -> zero
 dx(div(ALPHA,BETA)) -> minus(div(dx(ALPHA),BETA),times(ALPHA,div(dx(BETA),exp(BETA,two))))
 dx(exp(ALPHA,BETA)) -> plus(times(BETA,times(exp(ALPHA,minus(BETA,one)),dx(ALPHA))),times(exp(ALPHA,BETA),times(ln(ALPHA),dx(BETA))))
 dx(ln(ALPHA)) -> div(dx(ALPHA),ALPHA)
 dx(minus(ALPHA,BETA)) -> minus(dx(ALPHA),dx(BETA))
 dx(neg(ALPHA)) -> neg(dx(ALPHA))
 dx(plus(ALPHA,BETA)) -> plus(dx(ALPHA),dx(BETA))
 dx(times(ALPHA,BETA)) -> plus(times(BETA,dx(ALPHA)),times(ALPHA,dx(BETA)))
 dx(X) -> one
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
