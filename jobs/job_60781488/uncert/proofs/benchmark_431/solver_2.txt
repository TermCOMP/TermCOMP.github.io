YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/6kb1B.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) AAECC Innermost [EQUIVALENT, 0 ms]
(2) QTRS
(3) DependencyPairsProof [EQUIVALENT, 0 ms]
(4) QDP
(5) DependencyGraphProof [EQUIVALENT, 0 ms]
(6) AND
    (7) QDP
        (8) UsableRulesProof [EQUIVALENT, 0 ms]
        (9) QDP
        (10) QReductionProof [EQUIVALENT, 0 ms]
        (11) QDP
        (12) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (13) YES
    (14) QDP
        (15) UsableRulesProof [EQUIVALENT, 0 ms]
        (16) QDP
        (17) QReductionProof [EQUIVALENT, 0 ms]
        (18) QDP
        (19) NonInfProof [EQUIVALENT, 0 ms]
        (20) AND
            (21) QDP
                (22) NonInfProof [EQUIVALENT, 0 ms]
                (23) QDP
                (24) DependencyGraphProof [EQUIVALENT, 0 ms]
                (25) TRUE
            (26) QDP
                (27) DependencyGraphProof [EQUIVALENT, 0 ms]
                (28) TRUE


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f(true, x, y, z) -> g(gt(x, y), x, y, z)
   g(true, x, y, z) -> f(gt(x, z), x, s(y), z)
   g(true, x, y, z) -> f(gt(x, z), x, y, s(z))
   gt(0, v) -> false
   gt(s(u), 0) -> true
   gt(s(u), s(v)) -> gt(u, v)

Q is empty.

----------------------------------------

(1) AAECC Innermost (EQUIVALENT)
We have applied [NOC,AAECCNOC] to switch to innermost. The TRS R 1 is 
   gt(0, v) -> false
   gt(s(u), 0) -> true
   gt(s(u), s(v)) -> gt(u, v)

The TRS R 2 is 
   f(true, x, y, z) -> g(gt(x, y), x, y, z)
   g(true, x, y, z) -> f(gt(x, z), x, s(y), z)
   g(true, x, y, z) -> f(gt(x, z), x, y, s(z))

The signature Sigma is {f_4, g_4}
----------------------------------------

(2)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   f(true, x, y, z) -> g(gt(x, y), x, y, z)
   g(true, x, y, z) -> f(gt(x, z), x, s(y), z)
   g(true, x, y, z) -> f(gt(x, z), x, y, s(z))
   gt(0, v) -> false
   gt(s(u), 0) -> true
   gt(s(u), s(v)) -> gt(u, v)

The set Q consists of the following terms:

   f(true, x0, x1, x2)
   g(true, x0, x1, x2)
   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))


----------------------------------------

(3) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(4)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F(true, x, y, z) -> G(gt(x, y), x, y, z)
   F(true, x, y, z) -> GT(x, y)
   G(true, x, y, z) -> F(gt(x, z), x, s(y), z)
   G(true, x, y, z) -> GT(x, z)
   G(true, x, y, z) -> F(gt(x, z), x, y, s(z))
   GT(s(u), s(v)) -> GT(u, v)

The TRS R consists of the following rules:

   f(true, x, y, z) -> g(gt(x, y), x, y, z)
   g(true, x, y, z) -> f(gt(x, z), x, s(y), z)
   g(true, x, y, z) -> f(gt(x, z), x, y, s(z))
   gt(0, v) -> false
   gt(s(u), 0) -> true
   gt(s(u), s(v)) -> gt(u, v)

The set Q consists of the following terms:

   f(true, x0, x1, x2)
   g(true, x0, x1, x2)
   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(5) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 2 less nodes.
----------------------------------------

(6)
Complex Obligation (AND)

----------------------------------------

(7)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   GT(s(u), s(v)) -> GT(u, v)

The TRS R consists of the following rules:

   f(true, x, y, z) -> g(gt(x, y), x, y, z)
   g(true, x, y, z) -> f(gt(x, z), x, s(y), z)
   g(true, x, y, z) -> f(gt(x, z), x, y, s(z))
   gt(0, v) -> false
   gt(s(u), 0) -> true
   gt(s(u), s(v)) -> gt(u, v)

The set Q consists of the following terms:

   f(true, x0, x1, x2)
   g(true, x0, x1, x2)
   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(8) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(9)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   GT(s(u), s(v)) -> GT(u, v)

R is empty.
The set Q consists of the following terms:

   f(true, x0, x1, x2)
   g(true, x0, x1, x2)
   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(10) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   f(true, x0, x1, x2)
   g(true, x0, x1, x2)
   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))


----------------------------------------

(11)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   GT(s(u), s(v)) -> GT(u, v)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(12) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*GT(s(u), s(v)) -> GT(u, v)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(13)
YES

----------------------------------------

(14)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(true, x, y, z) -> F(gt(x, z), x, s(y), z)
   F(true, x, y, z) -> G(gt(x, y), x, y, z)
   G(true, x, y, z) -> F(gt(x, z), x, y, s(z))

The TRS R consists of the following rules:

   f(true, x, y, z) -> g(gt(x, y), x, y, z)
   g(true, x, y, z) -> f(gt(x, z), x, s(y), z)
   g(true, x, y, z) -> f(gt(x, z), x, y, s(z))
   gt(0, v) -> false
   gt(s(u), 0) -> true
   gt(s(u), s(v)) -> gt(u, v)

The set Q consists of the following terms:

   f(true, x0, x1, x2)
   g(true, x0, x1, x2)
   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(15) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(16)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(true, x, y, z) -> F(gt(x, z), x, s(y), z)
   F(true, x, y, z) -> G(gt(x, y), x, y, z)
   G(true, x, y, z) -> F(gt(x, z), x, y, s(z))

The TRS R consists of the following rules:

   gt(0, v) -> false
   gt(s(u), 0) -> true
   gt(s(u), s(v)) -> gt(u, v)

The set Q consists of the following terms:

   f(true, x0, x1, x2)
   g(true, x0, x1, x2)
   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(17) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   f(true, x0, x1, x2)
   g(true, x0, x1, x2)


----------------------------------------

(18)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(true, x, y, z) -> F(gt(x, z), x, s(y), z)
   F(true, x, y, z) -> G(gt(x, y), x, y, z)
   G(true, x, y, z) -> F(gt(x, z), x, y, s(z))

The TRS R consists of the following rules:

   gt(0, v) -> false
   gt(s(u), 0) -> true
   gt(s(u), s(v)) -> gt(u, v)

The set Q consists of the following terms:

   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(19) NonInfProof (EQUIVALENT)
The DP Problem is simplified using the Induction Calculus [NONINF] with the following steps:

Note that final constraints are written in bold face.



For Pair G(true, x, y, z) -> F(gt(x, z), x, s(y), z) the following chains were created:
*We consider the chain F(true, x3, x4, x5) -> G(gt(x3, x4), x3, x4, x5), G(true, x6, x7, x8) -> F(gt(x6, x8), x6, s(x7), x8) which results in the following constraint:

(1)    (G(gt(x3, x4), x3, x4, x5)=G(true, x6, x7, x8)  ==>  G(true, x6, x7, x8)_>=_F(gt(x6, x8), x6, s(x7), x8))



We simplified constraint (1) using rules (I), (II), (III) which results in the following new constraint:

(2)    (gt(x3, x4)=true  ==>  G(true, x3, x4, x5)_>=_F(gt(x3, x5), x3, s(x4), x5))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on gt(x3, x4)=true which results in the following new constraints:

(3)    (true=true  ==>  G(true, s(x40), 0, x5)_>=_F(gt(s(x40), x5), s(x40), s(0), x5))

(4)    (gt(x42, x41)=true & (\/x43:gt(x42, x41)=true  ==>  G(true, x42, x41, x43)_>=_F(gt(x42, x43), x42, s(x41), x43))  ==>  G(true, s(x42), s(x41), x5)_>=_F(gt(s(x42), x5), s(x42), s(s(x41)), x5))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(5)    (G(true, s(x40), 0, x5)_>=_F(gt(s(x40), x5), s(x40), s(0), x5))



We simplified constraint (4) using rule (VI) where we applied the induction hypothesis (\/x43:gt(x42, x41)=true  ==>  G(true, x42, x41, x43)_>=_F(gt(x42, x43), x42, s(x41), x43)) with sigma = [x43 / x5] which results in the following new constraint:

(6)    (G(true, x42, x41, x5)_>=_F(gt(x42, x5), x42, s(x41), x5)  ==>  G(true, s(x42), s(x41), x5)_>=_F(gt(s(x42), x5), s(x42), s(s(x41)), x5))








For Pair F(true, x, y, z) -> G(gt(x, y), x, y, z) the following chains were created:
*We consider the chain G(true, x12, x13, x14) -> F(gt(x12, x14), x12, s(x13), x14), F(true, x15, x16, x17) -> G(gt(x15, x16), x15, x16, x17) which results in the following constraint:

(1)    (F(gt(x12, x14), x12, s(x13), x14)=F(true, x15, x16, x17)  ==>  F(true, x15, x16, x17)_>=_G(gt(x15, x16), x15, x16, x17))



We simplified constraint (1) using rules (I), (II), (III) which results in the following new constraint:

(2)    (gt(x12, x14)=true  ==>  F(true, x12, s(x13), x14)_>=_G(gt(x12, s(x13)), x12, s(x13), x14))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on gt(x12, x14)=true which results in the following new constraints:

(3)    (true=true  ==>  F(true, s(x45), s(x13), 0)_>=_G(gt(s(x45), s(x13)), s(x45), s(x13), 0))

(4)    (gt(x47, x46)=true & (\/x48:gt(x47, x46)=true  ==>  F(true, x47, s(x48), x46)_>=_G(gt(x47, s(x48)), x47, s(x48), x46))  ==>  F(true, s(x47), s(x13), s(x46))_>=_G(gt(s(x47), s(x13)), s(x47), s(x13), s(x46)))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(5)    (F(true, s(x45), s(x13), 0)_>=_G(gt(s(x45), s(x13)), s(x45), s(x13), 0))



We simplified constraint (4) using rule (VI) where we applied the induction hypothesis (\/x48:gt(x47, x46)=true  ==>  F(true, x47, s(x48), x46)_>=_G(gt(x47, s(x48)), x47, s(x48), x46)) with sigma = [x48 / x13] which results in the following new constraint:

(6)    (F(true, x47, s(x13), x46)_>=_G(gt(x47, s(x13)), x47, s(x13), x46)  ==>  F(true, s(x47), s(x13), s(x46))_>=_G(gt(s(x47), s(x13)), s(x47), s(x13), s(x46)))




*We consider the chain G(true, x21, x22, x23) -> F(gt(x21, x23), x21, x22, s(x23)), F(true, x24, x25, x26) -> G(gt(x24, x25), x24, x25, x26) which results in the following constraint:

(1)    (F(gt(x21, x23), x21, x22, s(x23))=F(true, x24, x25, x26)  ==>  F(true, x24, x25, x26)_>=_G(gt(x24, x25), x24, x25, x26))



We simplified constraint (1) using rules (I), (II), (III) which results in the following new constraint:

(2)    (gt(x21, x23)=true  ==>  F(true, x21, x22, s(x23))_>=_G(gt(x21, x22), x21, x22, s(x23)))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on gt(x21, x23)=true which results in the following new constraints:

(3)    (true=true  ==>  F(true, s(x50), x22, s(0))_>=_G(gt(s(x50), x22), s(x50), x22, s(0)))

(4)    (gt(x52, x51)=true & (\/x53:gt(x52, x51)=true  ==>  F(true, x52, x53, s(x51))_>=_G(gt(x52, x53), x52, x53, s(x51)))  ==>  F(true, s(x52), x22, s(s(x51)))_>=_G(gt(s(x52), x22), s(x52), x22, s(s(x51))))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(5)    (F(true, s(x50), x22, s(0))_>=_G(gt(s(x50), x22), s(x50), x22, s(0)))



We simplified constraint (4) using rule (VI) where we applied the induction hypothesis (\/x53:gt(x52, x51)=true  ==>  F(true, x52, x53, s(x51))_>=_G(gt(x52, x53), x52, x53, s(x51))) with sigma = [x53 / x22] which results in the following new constraint:

(6)    (F(true, x52, x22, s(x51))_>=_G(gt(x52, x22), x52, x22, s(x51))  ==>  F(true, s(x52), x22, s(s(x51)))_>=_G(gt(s(x52), x22), s(x52), x22, s(s(x51))))








For Pair G(true, x, y, z) -> F(gt(x, z), x, y, s(z)) the following chains were created:
*We consider the chain F(true, x30, x31, x32) -> G(gt(x30, x31), x30, x31, x32), G(true, x33, x34, x35) -> F(gt(x33, x35), x33, x34, s(x35)) which results in the following constraint:

(1)    (G(gt(x30, x31), x30, x31, x32)=G(true, x33, x34, x35)  ==>  G(true, x33, x34, x35)_>=_F(gt(x33, x35), x33, x34, s(x35)))



We simplified constraint (1) using rules (I), (II), (III) which results in the following new constraint:

(2)    (gt(x30, x31)=true  ==>  G(true, x30, x31, x32)_>=_F(gt(x30, x32), x30, x31, s(x32)))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on gt(x30, x31)=true which results in the following new constraints:

(3)    (true=true  ==>  G(true, s(x55), 0, x32)_>=_F(gt(s(x55), x32), s(x55), 0, s(x32)))

(4)    (gt(x57, x56)=true & (\/x58:gt(x57, x56)=true  ==>  G(true, x57, x56, x58)_>=_F(gt(x57, x58), x57, x56, s(x58)))  ==>  G(true, s(x57), s(x56), x32)_>=_F(gt(s(x57), x32), s(x57), s(x56), s(x32)))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(5)    (G(true, s(x55), 0, x32)_>=_F(gt(s(x55), x32), s(x55), 0, s(x32)))



We simplified constraint (4) using rule (VI) where we applied the induction hypothesis (\/x58:gt(x57, x56)=true  ==>  G(true, x57, x56, x58)_>=_F(gt(x57, x58), x57, x56, s(x58))) with sigma = [x58 / x32] which results in the following new constraint:

(6)    (G(true, x57, x56, x32)_>=_F(gt(x57, x32), x57, x56, s(x32))  ==>  G(true, s(x57), s(x56), x32)_>=_F(gt(s(x57), x32), s(x57), s(x56), s(x32)))








To summarize, we get the following constraints P__>=_ for the following pairs.

*G(true, x, y, z) -> F(gt(x, z), x, s(y), z)

*(G(true, s(x40), 0, x5)_>=_F(gt(s(x40), x5), s(x40), s(0), x5))


*(G(true, x42, x41, x5)_>=_F(gt(x42, x5), x42, s(x41), x5)  ==>  G(true, s(x42), s(x41), x5)_>=_F(gt(s(x42), x5), s(x42), s(s(x41)), x5))




*F(true, x, y, z) -> G(gt(x, y), x, y, z)

*(F(true, s(x45), s(x13), 0)_>=_G(gt(s(x45), s(x13)), s(x45), s(x13), 0))


*(F(true, x47, s(x13), x46)_>=_G(gt(x47, s(x13)), x47, s(x13), x46)  ==>  F(true, s(x47), s(x13), s(x46))_>=_G(gt(s(x47), s(x13)), s(x47), s(x13), s(x46)))


*(F(true, s(x50), x22, s(0))_>=_G(gt(s(x50), x22), s(x50), x22, s(0)))


*(F(true, x52, x22, s(x51))_>=_G(gt(x52, x22), x52, x22, s(x51))  ==>  F(true, s(x52), x22, s(s(x51)))_>=_G(gt(s(x52), x22), s(x52), x22, s(s(x51))))




*G(true, x, y, z) -> F(gt(x, z), x, y, s(z))

*(G(true, s(x55), 0, x32)_>=_F(gt(s(x55), x32), s(x55), 0, s(x32)))


*(G(true, x57, x56, x32)_>=_F(gt(x57, x32), x57, x56, s(x32))  ==>  G(true, s(x57), s(x56), x32)_>=_F(gt(s(x57), x32), s(x57), s(x56), s(x32)))








The constraints for P_> respective P_bound are constructed from P__>=_ where we just replace every occurence of "t _>=_ s" in P__>=_ by  "t > s" respective "t _>=_ c". Here c stands for the fresh constant used for P_bound. 

Using the following integer polynomial ordering the  resulting constraints can be solved 

Polynomial interpretation [NONINF]:

   POL(0) = 0
   POL(F(x_1, x_2, x_3, x_4)) = -1 + x_2 - x_4
   POL(G(x_1, x_2, x_3, x_4)) = -1 + x_1 + x_2 - x_4
   POL(c) = -1
   POL(false) = 0
   POL(gt(x_1, x_2)) = 0
   POL(s(x_1)) = 1 + x_1
   POL(true) = 0


The following pairs  are in P_>:
   G(true, x, y, z) -> F(gt(x, z), x, y, s(z))
The following pairs are in P_bound:
   F(true, x, y, z) -> G(gt(x, y), x, y, z)
The following rules are usable:
   gt(0, v) -> false
   gt(s(u), 0) -> true
   gt(s(u), s(v)) -> gt(u, v)

----------------------------------------

(20)
Complex Obligation (AND)

----------------------------------------

(21)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(true, x, y, z) -> F(gt(x, z), x, s(y), z)
   F(true, x, y, z) -> G(gt(x, y), x, y, z)

The TRS R consists of the following rules:

   gt(0, v) -> false
   gt(s(u), 0) -> true
   gt(s(u), s(v)) -> gt(u, v)

The set Q consists of the following terms:

   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(22) NonInfProof (EQUIVALENT)
The DP Problem is simplified using the Induction Calculus [NONINF] with the following steps:

Note that final constraints are written in bold face.



For Pair G(true, x, y, z) -> F(gt(x, z), x, s(y), z) the following chains were created:
*We consider the chain F(true, x3, x4, x5) -> G(gt(x3, x4), x3, x4, x5), G(true, x6, x7, x8) -> F(gt(x6, x8), x6, s(x7), x8) which results in the following constraint:

(1)    (G(gt(x3, x4), x3, x4, x5)=G(true, x6, x7, x8)  ==>  G(true, x6, x7, x8)_>=_F(gt(x6, x8), x6, s(x7), x8))



We simplified constraint (1) using rules (I), (II), (III) which results in the following new constraint:

(2)    (gt(x3, x4)=true  ==>  G(true, x3, x4, x5)_>=_F(gt(x3, x5), x3, s(x4), x5))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on gt(x3, x4)=true which results in the following new constraints:

(3)    (true=true  ==>  G(true, s(x40), 0, x5)_>=_F(gt(s(x40), x5), s(x40), s(0), x5))

(4)    (gt(x42, x41)=true & (\/x43:gt(x42, x41)=true  ==>  G(true, x42, x41, x43)_>=_F(gt(x42, x43), x42, s(x41), x43))  ==>  G(true, s(x42), s(x41), x5)_>=_F(gt(s(x42), x5), s(x42), s(s(x41)), x5))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(5)    (G(true, s(x40), 0, x5)_>=_F(gt(s(x40), x5), s(x40), s(0), x5))



We simplified constraint (4) using rule (VI) where we applied the induction hypothesis (\/x43:gt(x42, x41)=true  ==>  G(true, x42, x41, x43)_>=_F(gt(x42, x43), x42, s(x41), x43)) with sigma = [x43 / x5] which results in the following new constraint:

(6)    (G(true, x42, x41, x5)_>=_F(gt(x42, x5), x42, s(x41), x5)  ==>  G(true, s(x42), s(x41), x5)_>=_F(gt(s(x42), x5), s(x42), s(s(x41)), x5))








For Pair F(true, x, y, z) -> G(gt(x, y), x, y, z) the following chains were created:
*We consider the chain G(true, x12, x13, x14) -> F(gt(x12, x14), x12, s(x13), x14), F(true, x15, x16, x17) -> G(gt(x15, x16), x15, x16, x17) which results in the following constraint:

(1)    (F(gt(x12, x14), x12, s(x13), x14)=F(true, x15, x16, x17)  ==>  F(true, x15, x16, x17)_>=_G(gt(x15, x16), x15, x16, x17))



We simplified constraint (1) using rules (I), (II), (III) which results in the following new constraint:

(2)    (gt(x12, x14)=true  ==>  F(true, x12, s(x13), x14)_>=_G(gt(x12, s(x13)), x12, s(x13), x14))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on gt(x12, x14)=true which results in the following new constraints:

(3)    (true=true  ==>  F(true, s(x45), s(x13), 0)_>=_G(gt(s(x45), s(x13)), s(x45), s(x13), 0))

(4)    (gt(x47, x46)=true & (\/x48:gt(x47, x46)=true  ==>  F(true, x47, s(x48), x46)_>=_G(gt(x47, s(x48)), x47, s(x48), x46))  ==>  F(true, s(x47), s(x13), s(x46))_>=_G(gt(s(x47), s(x13)), s(x47), s(x13), s(x46)))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(5)    (F(true, s(x45), s(x13), 0)_>=_G(gt(s(x45), s(x13)), s(x45), s(x13), 0))



We simplified constraint (4) using rule (VI) where we applied the induction hypothesis (\/x48:gt(x47, x46)=true  ==>  F(true, x47, s(x48), x46)_>=_G(gt(x47, s(x48)), x47, s(x48), x46)) with sigma = [x48 / x13] which results in the following new constraint:

(6)    (F(true, x47, s(x13), x46)_>=_G(gt(x47, s(x13)), x47, s(x13), x46)  ==>  F(true, s(x47), s(x13), s(x46))_>=_G(gt(s(x47), s(x13)), s(x47), s(x13), s(x46)))








To summarize, we get the following constraints P__>=_ for the following pairs.

*G(true, x, y, z) -> F(gt(x, z), x, s(y), z)

*(G(true, s(x40), 0, x5)_>=_F(gt(s(x40), x5), s(x40), s(0), x5))


*(G(true, x42, x41, x5)_>=_F(gt(x42, x5), x42, s(x41), x5)  ==>  G(true, s(x42), s(x41), x5)_>=_F(gt(s(x42), x5), s(x42), s(s(x41)), x5))




*F(true, x, y, z) -> G(gt(x, y), x, y, z)

*(F(true, s(x45), s(x13), 0)_>=_G(gt(s(x45), s(x13)), s(x45), s(x13), 0))


*(F(true, x47, s(x13), x46)_>=_G(gt(x47, s(x13)), x47, s(x13), x46)  ==>  F(true, s(x47), s(x13), s(x46))_>=_G(gt(s(x47), s(x13)), s(x47), s(x13), s(x46)))








The constraints for P_> respective P_bound are constructed from P__>=_ where we just replace every occurence of "t _>=_ s" in P__>=_ by  "t > s" respective "t _>=_ c". Here c stands for the fresh constant used for P_bound. 

Using the following integer polynomial ordering the  resulting constraints can be solved 

Polynomial interpretation [NONINF]:

   POL(0) = 0
   POL(F(x_1, x_2, x_3, x_4)) = -x_1 + x_2 - x_3
   POL(G(x_1, x_2, x_3, x_4)) = -x_1 + x_2 - x_3
   POL(c) = -1
   POL(false) = 0
   POL(gt(x_1, x_2)) = 0
   POL(s(x_1)) = 1 + x_1
   POL(true) = 0


The following pairs  are in P_>:
   G(true, x, y, z) -> F(gt(x, z), x, s(y), z)
The following pairs are in P_bound:
   G(true, x, y, z) -> F(gt(x, z), x, s(y), z)
The following rules are usable:
   false -> gt(0, v)
   true -> gt(s(u), 0)
   gt(u, v) -> gt(s(u), s(v))

----------------------------------------

(23)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F(true, x, y, z) -> G(gt(x, y), x, y, z)

The TRS R consists of the following rules:

   gt(0, v) -> false
   gt(s(u), 0) -> true
   gt(s(u), s(v)) -> gt(u, v)

The set Q consists of the following terms:

   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(24) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 1 less node.
----------------------------------------

(25)
TRUE

----------------------------------------

(26)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   G(true, x, y, z) -> F(gt(x, z), x, s(y), z)
   G(true, x, y, z) -> F(gt(x, z), x, y, s(z))

The TRS R consists of the following rules:

   gt(0, v) -> false
   gt(s(u), 0) -> true
   gt(s(u), s(v)) -> gt(u, v)

The set Q consists of the following terms:

   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(27) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 2 less nodes.
----------------------------------------

(28)
TRUE
