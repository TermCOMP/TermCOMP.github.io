YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/0BkkX.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) Overlay + Local Confluence [EQUIVALENT, 0 ms]
(2) QTRS
(3) DependencyPairsProof [EQUIVALENT, 0 ms]
(4) QDP
(5) DependencyGraphProof [EQUIVALENT, 0 ms]
(6) AND
    (7) QDP
        (8) UsableRulesProof [EQUIVALENT, 0 ms]
        (9) QDP
        (10) QReductionProof [EQUIVALENT, 0 ms]
        (11) QDP
        (12) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (13) YES
    (14) QDP
        (15) UsableRulesProof [EQUIVALENT, 0 ms]
        (16) QDP
        (17) QReductionProof [EQUIVALENT, 0 ms]
        (18) QDP
        (19) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (20) YES
    (21) QDP
        (22) UsableRulesProof [EQUIVALENT, 0 ms]
        (23) QDP
        (24) QReductionProof [EQUIVALENT, 0 ms]
        (25) QDP
        (26) QDPQMonotonicMRRProof [EQUIVALENT, 20 ms]
        (27) QDP
        (28) TransformationProof [EQUIVALENT, 0 ms]
        (29) QDP
        (30) DependencyGraphProof [EQUIVALENT, 0 ms]
        (31) QDP
        (32) TransformationProof [EQUIVALENT, 0 ms]
        (33) QDP
        (34) TransformationProof [EQUIVALENT, 0 ms]
        (35) QDP
        (36) TransformationProof [EQUIVALENT, 1 ms]
        (37) QDP
        (38) TransformationProof [EQUIVALENT, 0 ms]
        (39) QDP
        (40) TransformationProof [EQUIVALENT, 0 ms]
        (41) QDP
        (42) TransformationProof [EQUIVALENT, 0 ms]
        (43) QDP
        (44) TransformationProof [EQUIVALENT, 0 ms]
        (45) QDP
        (46) TransformationProof [EQUIVALENT, 0 ms]
        (47) QDP
        (48) DependencyGraphProof [EQUIVALENT, 0 ms]
        (49) AND
            (50) QDP
                (51) TransformationProof [EQUIVALENT, 0 ms]
                (52) QDP
                (53) TransformationProof [EQUIVALENT, 0 ms]
                (54) QDP
                (55) UsableRulesProof [EQUIVALENT, 0 ms]
                (56) QDP
                (57) QReductionProof [EQUIVALENT, 0 ms]
                (58) QDP
                (59) TransformationProof [EQUIVALENT, 0 ms]
                (60) QDP
                (61) TransformationProof [EQUIVALENT, 0 ms]
                (62) QDP
                (63) TransformationProof [EQUIVALENT, 0 ms]
                (64) QDP
                (65) DependencyGraphProof [EQUIVALENT, 0 ms]
                (66) QDP
                (67) TransformationProof [EQUIVALENT, 0 ms]
                (68) QDP
                (69) UsableRulesProof [EQUIVALENT, 0 ms]
                (70) QDP
                (71) QReductionProof [EQUIVALENT, 0 ms]
                (72) QDP
                (73) TransformationProof [EQUIVALENT, 0 ms]
                (74) QDP
                (75) UsableRulesProof [EQUIVALENT, 0 ms]
                (76) QDP
                (77) QReductionProof [EQUIVALENT, 0 ms]
                (78) QDP
                (79) TransformationProof [EQUIVALENT, 0 ms]
                (80) QDP
                (81) DependencyGraphProof [EQUIVALENT, 0 ms]
                (82) QDP
                (83) UsableRulesProof [EQUIVALENT, 0 ms]
                (84) QDP
                (85) QReductionProof [EQUIVALENT, 0 ms]
                (86) QDP
                (87) TransformationProof [EQUIVALENT, 0 ms]
                (88) QDP
                (89) TransformationProof [EQUIVALENT, 0 ms]
                (90) QDP
                (91) TransformationProof [EQUIVALENT, 0 ms]
                (92) QDP
                (93) TransformationProof [EQUIVALENT, 0 ms]
                (94) QDP
                (95) TransformationProof [EQUIVALENT, 0 ms]
                (96) QDP
                (97) TransformationProof [EQUIVALENT, 0 ms]
                (98) QDP
                (99) TransformationProof [EQUIVALENT, 0 ms]
                (100) QDP
                (101) TransformationProof [EQUIVALENT, 0 ms]
                (102) QDP
                (103) TransformationProof [EQUIVALENT, 0 ms]
                (104) QDP
                (105) QDPQMonotonicMRRProof [EQUIVALENT, 27 ms]
                (106) QDP
                (107) DependencyGraphProof [EQUIVALENT, 0 ms]
                (108) QDP
                (109) QDPQMonotonicMRRProof [EQUIVALENT, 42 ms]
                (110) QDP
                (111) UsableRulesProof [EQUIVALENT, 0 ms]
                (112) QDP
                (113) QReductionProof [EQUIVALENT, 0 ms]
                (114) QDP
                (115) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                (116) YES
            (117) QDP
                (118) TransformationProof [EQUIVALENT, 0 ms]
                (119) QDP
                (120) TransformationProof [EQUIVALENT, 0 ms]
                (121) QDP
                (122) TransformationProof [EQUIVALENT, 0 ms]
                (123) QDP
                (124) TransformationProof [EQUIVALENT, 0 ms]
                (125) QDP
                (126) TransformationProof [EQUIVALENT, 0 ms]
                (127) QDP
                (128) DependencyGraphProof [EQUIVALENT, 0 ms]
                (129) QDP
                (130) TransformationProof [EQUIVALENT, 0 ms]
                (131) QDP
                (132) TransformationProof [EQUIVALENT, 0 ms]
                (133) QDP
                (134) TransformationProof [EQUIVALENT, 0 ms]
                (135) QDP
                (136) DependencyGraphProof [EQUIVALENT, 0 ms]
                (137) QDP
                (138) TransformationProof [EQUIVALENT, 0 ms]
                (139) QDP
                (140) TransformationProof [EQUIVALENT, 0 ms]
                (141) QDP
                (142) TransformationProof [EQUIVALENT, 0 ms]
                (143) QDP
                (144) TransformationProof [EQUIVALENT, 0 ms]
                (145) QDP
                (146) TransformationProof [EQUIVALENT, 0 ms]
                (147) QDP
                (148) UsableRulesProof [EQUIVALENT, 0 ms]
                (149) QDP
                (150) QReductionProof [EQUIVALENT, 0 ms]
                (151) QDP
                (152) TransformationProof [EQUIVALENT, 0 ms]
                (153) QDP
                (154) TransformationProof [EQUIVALENT, 0 ms]
                (155) QDP
                (156) TransformationProof [EQUIVALENT, 0 ms]
                (157) QDP
                (158) TransformationProof [EQUIVALENT, 0 ms]
                (159) QDP
                (160) DependencyGraphProof [EQUIVALENT, 0 ms]
                (161) QDP
                (162) TransformationProof [EQUIVALENT, 0 ms]
                (163) QDP
                (164) UsableRulesProof [EQUIVALENT, 0 ms]
                (165) QDP
                (166) QReductionProof [EQUIVALENT, 0 ms]
                (167) QDP
                (168) TransformationProof [EQUIVALENT, 0 ms]
                (169) QDP
                (170) UsableRulesProof [EQUIVALENT, 0 ms]
                (171) QDP
                (172) QReductionProof [EQUIVALENT, 0 ms]
                (173) QDP
                (174) TransformationProof [EQUIVALENT, 0 ms]
                (175) QDP
                (176) DependencyGraphProof [EQUIVALENT, 0 ms]
                (177) QDP
                (178) UsableRulesProof [EQUIVALENT, 0 ms]
                (179) QDP
                (180) QReductionProof [EQUIVALENT, 0 ms]
                (181) QDP
                (182) TransformationProof [EQUIVALENT, 0 ms]
                (183) QDP
                (184) TransformationProof [EQUIVALENT, 0 ms]
                (185) QDP
                (186) TransformationProof [EQUIVALENT, 0 ms]
                (187) QDP
                (188) TransformationProof [EQUIVALENT, 0 ms]
                (189) QDP
                (190) TransformationProof [EQUIVALENT, 0 ms]
                (191) QDP
                (192) TransformationProof [EQUIVALENT, 0 ms]
                (193) QDP
                (194) TransformationProof [EQUIVALENT, 0 ms]
                (195) QDP
                (196) TransformationProof [EQUIVALENT, 0 ms]
                (197) QDP
                (198) TransformationProof [EQUIVALENT, 0 ms]
                (199) QDP
                (200) TransformationProof [EQUIVALENT, 0 ms]
                (201) QDP
                (202) TransformationProof [EQUIVALENT, 0 ms]
                (203) QDP
                (204) TransformationProof [EQUIVALENT, 0 ms]
                (205) QDP
                (206) TransformationProof [EQUIVALENT, 0 ms]
                (207) QDP
                (208) TransformationProof [EQUIVALENT, 0 ms]
                (209) QDP
                (210) TransformationProof [EQUIVALENT, 0 ms]
                (211) QDP
                (212) TransformationProof [EQUIVALENT, 0 ms]
                (213) QDP
                (214) TransformationProof [EQUIVALENT, 0 ms]
                (215) QDP
                (216) TransformationProof [EQUIVALENT, 0 ms]
                (217) QDP
                (218) TransformationProof [EQUIVALENT, 0 ms]
                (219) QDP
                (220) TransformationProof [EQUIVALENT, 0 ms]
                (221) QDP
                (222) TransformationProof [EQUIVALENT, 0 ms]
                (223) QDP
                (224) TransformationProof [EQUIVALENT, 0 ms]
                (225) QDP
                (226) QDPQMonotonicMRRProof [EQUIVALENT, 60 ms]
                (227) QDP
                (228) DependencyGraphProof [EQUIVALENT, 0 ms]
                (229) AND
                    (230) QDP
                        (231) UsableRulesProof [EQUIVALENT, 0 ms]
                        (232) QDP
                        (233) QReductionProof [EQUIVALENT, 0 ms]
                        (234) QDP
                        (235) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                        (236) YES
                    (237) QDP
                        (238) UsableRulesProof [EQUIVALENT, 0 ms]
                        (239) QDP
                        (240) QReductionProof [EQUIVALENT, 0 ms]
                        (241) QDP
                        (242) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                        (243) YES


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   or(true, y) -> true
   or(false, y) -> y
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   isEmpty(empty) -> true
   isEmpty(edge(x, y, i)) -> false
   from(edge(x, y, i)) -> x
   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   reach(x, y, i, h) -> if1(eq(x, y), isEmpty(i), eq(x, from(i)), eq(y, to(i)), x, y, i, h)
   if1(true, b1, b2, b3, x, y, i, h) -> true
   if1(false, b1, b2, b3, x, y, i, h) -> if2(b1, b2, b3, x, y, i, h)
   if2(true, b2, b3, x, y, i, h) -> false
   if2(false, b2, b3, x, y, i, h) -> if3(b2, b3, x, y, i, h)
   if3(false, b3, x, y, i, h) -> reach(x, y, rest(i), edge(from(i), to(i), h))
   if3(true, b3, x, y, i, h) -> if4(b3, x, y, i, h)
   if4(true, x, y, i, h) -> true
   if4(false, x, y, i, h) -> or(reach(x, y, rest(i), h), reach(to(i), y, union(rest(i), h), empty))

Q is empty.

----------------------------------------

(1) Overlay + Local Confluence (EQUIVALENT)
The TRS is overlay and locally confluent. By [NOC] we can switch to innermost.
----------------------------------------

(2)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   or(true, y) -> true
   or(false, y) -> y
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   isEmpty(empty) -> true
   isEmpty(edge(x, y, i)) -> false
   from(edge(x, y, i)) -> x
   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   reach(x, y, i, h) -> if1(eq(x, y), isEmpty(i), eq(x, from(i)), eq(y, to(i)), x, y, i, h)
   if1(true, b1, b2, b3, x, y, i, h) -> true
   if1(false, b1, b2, b3, x, y, i, h) -> if2(b1, b2, b3, x, y, i, h)
   if2(true, b2, b3, x, y, i, h) -> false
   if2(false, b2, b3, x, y, i, h) -> if3(b2, b3, x, y, i, h)
   if3(false, b3, x, y, i, h) -> reach(x, y, rest(i), edge(from(i), to(i), h))
   if3(true, b3, x, y, i, h) -> if4(b3, x, y, i, h)
   if4(true, x, y, i, h) -> true
   if4(false, x, y, i, h) -> or(reach(x, y, rest(i), h), reach(to(i), y, union(rest(i), h), empty))

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   or(true, x0)
   or(false, x0)
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)
   reach(x0, x1, x2, x3)
   if1(true, x0, x1, x2, x3, x4, x5, x6)
   if1(false, x0, x1, x2, x3, x4, x5, x6)
   if2(true, x0, x1, x2, x3, x4, x5)
   if2(false, x0, x1, x2, x3, x4, x5)
   if3(false, x0, x1, x2, x3, x4)
   if3(true, x0, x1, x2, x3, x4)
   if4(true, x0, x1, x2, x3)
   if4(false, x0, x1, x2, x3)


----------------------------------------

(3) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(4)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   EQ(s(x), s(y)) -> EQ(x, y)
   UNION(edge(x, y, i), h) -> UNION(i, h)
   REACH(x, y, i, h) -> IF1(eq(x, y), isEmpty(i), eq(x, from(i)), eq(y, to(i)), x, y, i, h)
   REACH(x, y, i, h) -> EQ(x, y)
   REACH(x, y, i, h) -> ISEMPTY(i)
   REACH(x, y, i, h) -> EQ(x, from(i))
   REACH(x, y, i, h) -> FROM(i)
   REACH(x, y, i, h) -> EQ(y, to(i))
   REACH(x, y, i, h) -> TO(i)
   IF1(false, b1, b2, b3, x, y, i, h) -> IF2(b1, b2, b3, x, y, i, h)
   IF2(false, b2, b3, x, y, i, h) -> IF3(b2, b3, x, y, i, h)
   IF3(false, b3, x, y, i, h) -> REACH(x, y, rest(i), edge(from(i), to(i), h))
   IF3(false, b3, x, y, i, h) -> REST(i)
   IF3(false, b3, x, y, i, h) -> FROM(i)
   IF3(false, b3, x, y, i, h) -> TO(i)
   IF3(true, b3, x, y, i, h) -> IF4(b3, x, y, i, h)
   IF4(false, x, y, i, h) -> OR(reach(x, y, rest(i), h), reach(to(i), y, union(rest(i), h), empty))
   IF4(false, x, y, i, h) -> REACH(x, y, rest(i), h)
   IF4(false, x, y, i, h) -> REST(i)
   IF4(false, x, y, i, h) -> REACH(to(i), y, union(rest(i), h), empty)
   IF4(false, x, y, i, h) -> TO(i)
   IF4(false, x, y, i, h) -> UNION(rest(i), h)

The TRS R consists of the following rules:

   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   or(true, y) -> true
   or(false, y) -> y
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   isEmpty(empty) -> true
   isEmpty(edge(x, y, i)) -> false
   from(edge(x, y, i)) -> x
   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   reach(x, y, i, h) -> if1(eq(x, y), isEmpty(i), eq(x, from(i)), eq(y, to(i)), x, y, i, h)
   if1(true, b1, b2, b3, x, y, i, h) -> true
   if1(false, b1, b2, b3, x, y, i, h) -> if2(b1, b2, b3, x, y, i, h)
   if2(true, b2, b3, x, y, i, h) -> false
   if2(false, b2, b3, x, y, i, h) -> if3(b2, b3, x, y, i, h)
   if3(false, b3, x, y, i, h) -> reach(x, y, rest(i), edge(from(i), to(i), h))
   if3(true, b3, x, y, i, h) -> if4(b3, x, y, i, h)
   if4(true, x, y, i, h) -> true
   if4(false, x, y, i, h) -> or(reach(x, y, rest(i), h), reach(to(i), y, union(rest(i), h), empty))

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   or(true, x0)
   or(false, x0)
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)
   reach(x0, x1, x2, x3)
   if1(true, x0, x1, x2, x3, x4, x5, x6)
   if1(false, x0, x1, x2, x3, x4, x5, x6)
   if2(true, x0, x1, x2, x3, x4, x5)
   if2(false, x0, x1, x2, x3, x4, x5)
   if3(false, x0, x1, x2, x3, x4)
   if3(true, x0, x1, x2, x3, x4)
   if4(true, x0, x1, x2, x3)
   if4(false, x0, x1, x2, x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(5) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 3 SCCs with 13 less nodes.
----------------------------------------

(6)
Complex Obligation (AND)

----------------------------------------

(7)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   UNION(edge(x, y, i), h) -> UNION(i, h)

The TRS R consists of the following rules:

   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   or(true, y) -> true
   or(false, y) -> y
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   isEmpty(empty) -> true
   isEmpty(edge(x, y, i)) -> false
   from(edge(x, y, i)) -> x
   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   reach(x, y, i, h) -> if1(eq(x, y), isEmpty(i), eq(x, from(i)), eq(y, to(i)), x, y, i, h)
   if1(true, b1, b2, b3, x, y, i, h) -> true
   if1(false, b1, b2, b3, x, y, i, h) -> if2(b1, b2, b3, x, y, i, h)
   if2(true, b2, b3, x, y, i, h) -> false
   if2(false, b2, b3, x, y, i, h) -> if3(b2, b3, x, y, i, h)
   if3(false, b3, x, y, i, h) -> reach(x, y, rest(i), edge(from(i), to(i), h))
   if3(true, b3, x, y, i, h) -> if4(b3, x, y, i, h)
   if4(true, x, y, i, h) -> true
   if4(false, x, y, i, h) -> or(reach(x, y, rest(i), h), reach(to(i), y, union(rest(i), h), empty))

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   or(true, x0)
   or(false, x0)
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)
   reach(x0, x1, x2, x3)
   if1(true, x0, x1, x2, x3, x4, x5, x6)
   if1(false, x0, x1, x2, x3, x4, x5, x6)
   if2(true, x0, x1, x2, x3, x4, x5)
   if2(false, x0, x1, x2, x3, x4, x5)
   if3(false, x0, x1, x2, x3, x4)
   if3(true, x0, x1, x2, x3, x4)
   if4(true, x0, x1, x2, x3)
   if4(false, x0, x1, x2, x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(8) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(9)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   UNION(edge(x, y, i), h) -> UNION(i, h)

R is empty.
The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   or(true, x0)
   or(false, x0)
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)
   reach(x0, x1, x2, x3)
   if1(true, x0, x1, x2, x3, x4, x5, x6)
   if1(false, x0, x1, x2, x3, x4, x5, x6)
   if2(true, x0, x1, x2, x3, x4, x5)
   if2(false, x0, x1, x2, x3, x4, x5)
   if3(false, x0, x1, x2, x3, x4)
   if3(true, x0, x1, x2, x3, x4)
   if4(true, x0, x1, x2, x3)
   if4(false, x0, x1, x2, x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(10) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   or(true, x0)
   or(false, x0)
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)
   reach(x0, x1, x2, x3)
   if1(true, x0, x1, x2, x3, x4, x5, x6)
   if1(false, x0, x1, x2, x3, x4, x5, x6)
   if2(true, x0, x1, x2, x3, x4, x5)
   if2(false, x0, x1, x2, x3, x4, x5)
   if3(false, x0, x1, x2, x3, x4)
   if3(true, x0, x1, x2, x3, x4)
   if4(true, x0, x1, x2, x3)
   if4(false, x0, x1, x2, x3)


----------------------------------------

(11)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   UNION(edge(x, y, i), h) -> UNION(i, h)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(12) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*UNION(edge(x, y, i), h) -> UNION(i, h)
The graph contains the following edges 1 > 1, 2 >= 2


----------------------------------------

(13)
YES

----------------------------------------

(14)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   EQ(s(x), s(y)) -> EQ(x, y)

The TRS R consists of the following rules:

   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   or(true, y) -> true
   or(false, y) -> y
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   isEmpty(empty) -> true
   isEmpty(edge(x, y, i)) -> false
   from(edge(x, y, i)) -> x
   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   reach(x, y, i, h) -> if1(eq(x, y), isEmpty(i), eq(x, from(i)), eq(y, to(i)), x, y, i, h)
   if1(true, b1, b2, b3, x, y, i, h) -> true
   if1(false, b1, b2, b3, x, y, i, h) -> if2(b1, b2, b3, x, y, i, h)
   if2(true, b2, b3, x, y, i, h) -> false
   if2(false, b2, b3, x, y, i, h) -> if3(b2, b3, x, y, i, h)
   if3(false, b3, x, y, i, h) -> reach(x, y, rest(i), edge(from(i), to(i), h))
   if3(true, b3, x, y, i, h) -> if4(b3, x, y, i, h)
   if4(true, x, y, i, h) -> true
   if4(false, x, y, i, h) -> or(reach(x, y, rest(i), h), reach(to(i), y, union(rest(i), h), empty))

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   or(true, x0)
   or(false, x0)
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)
   reach(x0, x1, x2, x3)
   if1(true, x0, x1, x2, x3, x4, x5, x6)
   if1(false, x0, x1, x2, x3, x4, x5, x6)
   if2(true, x0, x1, x2, x3, x4, x5)
   if2(false, x0, x1, x2, x3, x4, x5)
   if3(false, x0, x1, x2, x3, x4)
   if3(true, x0, x1, x2, x3, x4)
   if4(true, x0, x1, x2, x3)
   if4(false, x0, x1, x2, x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(15) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(16)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   EQ(s(x), s(y)) -> EQ(x, y)

R is empty.
The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   or(true, x0)
   or(false, x0)
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)
   reach(x0, x1, x2, x3)
   if1(true, x0, x1, x2, x3, x4, x5, x6)
   if1(false, x0, x1, x2, x3, x4, x5, x6)
   if2(true, x0, x1, x2, x3, x4, x5)
   if2(false, x0, x1, x2, x3, x4, x5)
   if3(false, x0, x1, x2, x3, x4)
   if3(true, x0, x1, x2, x3, x4)
   if4(true, x0, x1, x2, x3)
   if4(false, x0, x1, x2, x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(17) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   or(true, x0)
   or(false, x0)
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)
   reach(x0, x1, x2, x3)
   if1(true, x0, x1, x2, x3, x4, x5, x6)
   if1(false, x0, x1, x2, x3, x4, x5, x6)
   if2(true, x0, x1, x2, x3, x4, x5)
   if2(false, x0, x1, x2, x3, x4, x5)
   if3(false, x0, x1, x2, x3, x4)
   if3(true, x0, x1, x2, x3, x4)
   if4(true, x0, x1, x2, x3)
   if4(false, x0, x1, x2, x3)


----------------------------------------

(18)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   EQ(s(x), s(y)) -> EQ(x, y)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(19) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*EQ(s(x), s(y)) -> EQ(x, y)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(20)
YES

----------------------------------------

(21)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(x, y, i, h) -> IF1(eq(x, y), isEmpty(i), eq(x, from(i)), eq(y, to(i)), x, y, i, h)
   IF1(false, b1, b2, b3, x, y, i, h) -> IF2(b1, b2, b3, x, y, i, h)
   IF2(false, b2, b3, x, y, i, h) -> IF3(b2, b3, x, y, i, h)
   IF3(false, b3, x, y, i, h) -> REACH(x, y, rest(i), edge(from(i), to(i), h))
   IF3(true, b3, x, y, i, h) -> IF4(b3, x, y, i, h)
   IF4(false, x, y, i, h) -> REACH(x, y, rest(i), h)
   IF4(false, x, y, i, h) -> REACH(to(i), y, union(rest(i), h), empty)

The TRS R consists of the following rules:

   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   or(true, y) -> true
   or(false, y) -> y
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   isEmpty(empty) -> true
   isEmpty(edge(x, y, i)) -> false
   from(edge(x, y, i)) -> x
   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   reach(x, y, i, h) -> if1(eq(x, y), isEmpty(i), eq(x, from(i)), eq(y, to(i)), x, y, i, h)
   if1(true, b1, b2, b3, x, y, i, h) -> true
   if1(false, b1, b2, b3, x, y, i, h) -> if2(b1, b2, b3, x, y, i, h)
   if2(true, b2, b3, x, y, i, h) -> false
   if2(false, b2, b3, x, y, i, h) -> if3(b2, b3, x, y, i, h)
   if3(false, b3, x, y, i, h) -> reach(x, y, rest(i), edge(from(i), to(i), h))
   if3(true, b3, x, y, i, h) -> if4(b3, x, y, i, h)
   if4(true, x, y, i, h) -> true
   if4(false, x, y, i, h) -> or(reach(x, y, rest(i), h), reach(to(i), y, union(rest(i), h), empty))

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   or(true, x0)
   or(false, x0)
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)
   reach(x0, x1, x2, x3)
   if1(true, x0, x1, x2, x3, x4, x5, x6)
   if1(false, x0, x1, x2, x3, x4, x5, x6)
   if2(true, x0, x1, x2, x3, x4, x5)
   if2(false, x0, x1, x2, x3, x4, x5)
   if3(false, x0, x1, x2, x3, x4)
   if3(true, x0, x1, x2, x3, x4)
   if4(true, x0, x1, x2, x3)
   if4(false, x0, x1, x2, x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(22) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(23)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(x, y, i, h) -> IF1(eq(x, y), isEmpty(i), eq(x, from(i)), eq(y, to(i)), x, y, i, h)
   IF1(false, b1, b2, b3, x, y, i, h) -> IF2(b1, b2, b3, x, y, i, h)
   IF2(false, b2, b3, x, y, i, h) -> IF3(b2, b3, x, y, i, h)
   IF3(false, b3, x, y, i, h) -> REACH(x, y, rest(i), edge(from(i), to(i), h))
   IF3(true, b3, x, y, i, h) -> IF4(b3, x, y, i, h)
   IF4(false, x, y, i, h) -> REACH(x, y, rest(i), h)
   IF4(false, x, y, i, h) -> REACH(to(i), y, union(rest(i), h), empty)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(empty) -> true
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   or(true, x0)
   or(false, x0)
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)
   reach(x0, x1, x2, x3)
   if1(true, x0, x1, x2, x3, x4, x5, x6)
   if1(false, x0, x1, x2, x3, x4, x5, x6)
   if2(true, x0, x1, x2, x3, x4, x5)
   if2(false, x0, x1, x2, x3, x4, x5)
   if3(false, x0, x1, x2, x3, x4)
   if3(true, x0, x1, x2, x3, x4)
   if4(true, x0, x1, x2, x3)
   if4(false, x0, x1, x2, x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(24) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   or(true, x0)
   or(false, x0)
   reach(x0, x1, x2, x3)
   if1(true, x0, x1, x2, x3, x4, x5, x6)
   if1(false, x0, x1, x2, x3, x4, x5, x6)
   if2(true, x0, x1, x2, x3, x4, x5)
   if2(false, x0, x1, x2, x3, x4, x5)
   if3(false, x0, x1, x2, x3, x4)
   if3(true, x0, x1, x2, x3, x4)
   if4(true, x0, x1, x2, x3)
   if4(false, x0, x1, x2, x3)


----------------------------------------

(25)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(x, y, i, h) -> IF1(eq(x, y), isEmpty(i), eq(x, from(i)), eq(y, to(i)), x, y, i, h)
   IF1(false, b1, b2, b3, x, y, i, h) -> IF2(b1, b2, b3, x, y, i, h)
   IF2(false, b2, b3, x, y, i, h) -> IF3(b2, b3, x, y, i, h)
   IF3(false, b3, x, y, i, h) -> REACH(x, y, rest(i), edge(from(i), to(i), h))
   IF3(true, b3, x, y, i, h) -> IF4(b3, x, y, i, h)
   IF4(false, x, y, i, h) -> REACH(x, y, rest(i), h)
   IF4(false, x, y, i, h) -> REACH(to(i), y, union(rest(i), h), empty)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(empty) -> true
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(26) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.


Strictly oriented rules of the TRS R:

   isEmpty(empty) -> true

Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 1
   POL(IF1(x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8)) = 2*x_2
   POL(IF2(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = 2*x_1
   POL(IF3(x_1, x_2, x_3, x_4, x_5, x_6)) = 2
   POL(IF4(x_1, x_2, x_3, x_4, x_5)) = 2
   POL(REACH(x_1, x_2, x_3, x_4)) = 2
   POL(edge(x_1, x_2, x_3)) = x_1 + 2*x_2 + x_3
   POL(empty) = 0
   POL(eq(x_1, x_2)) = 2 + 2*x_1
   POL(false) = 1
   POL(from(x_1)) = 2 + 2*x_1
   POL(isEmpty(x_1)) = 1
   POL(rest(x_1)) = 2 + 2*x_1
   POL(s(x_1)) = x_1
   POL(to(x_1)) = x_1
   POL(true) = 0
   POL(union(x_1, x_2)) = 2*x_1 + 2*x_2


----------------------------------------

(27)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(x, y, i, h) -> IF1(eq(x, y), isEmpty(i), eq(x, from(i)), eq(y, to(i)), x, y, i, h)
   IF1(false, b1, b2, b3, x, y, i, h) -> IF2(b1, b2, b3, x, y, i, h)
   IF2(false, b2, b3, x, y, i, h) -> IF3(b2, b3, x, y, i, h)
   IF3(false, b3, x, y, i, h) -> REACH(x, y, rest(i), edge(from(i), to(i), h))
   IF3(true, b3, x, y, i, h) -> IF4(b3, x, y, i, h)
   IF4(false, x, y, i, h) -> REACH(x, y, rest(i), h)
   IF4(false, x, y, i, h) -> REACH(to(i), y, union(rest(i), h), empty)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(28) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule REACH(x, y, i, h) -> IF1(eq(x, y), isEmpty(i), eq(x, from(i)), eq(y, to(i)), x, y, i, h) at position [0] we obtained the following new rules [LPAR04]:

   (REACH(0, 0, y2, y3) -> IF1(true, isEmpty(y2), eq(0, from(y2)), eq(0, to(y2)), 0, 0, y2, y3),REACH(0, 0, y2, y3) -> IF1(true, isEmpty(y2), eq(0, from(y2)), eq(0, to(y2)), 0, 0, y2, y3))
   (REACH(0, s(x0), y2, y3) -> IF1(false, isEmpty(y2), eq(0, from(y2)), eq(s(x0), to(y2)), 0, s(x0), y2, y3),REACH(0, s(x0), y2, y3) -> IF1(false, isEmpty(y2), eq(0, from(y2)), eq(s(x0), to(y2)), 0, s(x0), y2, y3))
   (REACH(s(x0), 0, y2, y3) -> IF1(false, isEmpty(y2), eq(s(x0), from(y2)), eq(0, to(y2)), s(x0), 0, y2, y3),REACH(s(x0), 0, y2, y3) -> IF1(false, isEmpty(y2), eq(s(x0), from(y2)), eq(0, to(y2)), s(x0), 0, y2, y3))
   (REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3),REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3))


----------------------------------------

(29)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF1(false, b1, b2, b3, x, y, i, h) -> IF2(b1, b2, b3, x, y, i, h)
   IF2(false, b2, b3, x, y, i, h) -> IF3(b2, b3, x, y, i, h)
   IF3(false, b3, x, y, i, h) -> REACH(x, y, rest(i), edge(from(i), to(i), h))
   IF3(true, b3, x, y, i, h) -> IF4(b3, x, y, i, h)
   IF4(false, x, y, i, h) -> REACH(x, y, rest(i), h)
   IF4(false, x, y, i, h) -> REACH(to(i), y, union(rest(i), h), empty)
   REACH(0, 0, y2, y3) -> IF1(true, isEmpty(y2), eq(0, from(y2)), eq(0, to(y2)), 0, 0, y2, y3)
   REACH(0, s(x0), y2, y3) -> IF1(false, isEmpty(y2), eq(0, from(y2)), eq(s(x0), to(y2)), 0, s(x0), y2, y3)
   REACH(s(x0), 0, y2, y3) -> IF1(false, isEmpty(y2), eq(s(x0), from(y2)), eq(0, to(y2)), s(x0), 0, y2, y3)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(30) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(31)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false, b2, b3, x, y, i, h) -> IF3(b2, b3, x, y, i, h)
   IF3(false, b3, x, y, i, h) -> REACH(x, y, rest(i), edge(from(i), to(i), h))
   REACH(0, s(x0), y2, y3) -> IF1(false, isEmpty(y2), eq(0, from(y2)), eq(s(x0), to(y2)), 0, s(x0), y2, y3)
   IF1(false, b1, b2, b3, x, y, i, h) -> IF2(b1, b2, b3, x, y, i, h)
   REACH(s(x0), 0, y2, y3) -> IF1(false, isEmpty(y2), eq(s(x0), from(y2)), eq(0, to(y2)), s(x0), 0, y2, y3)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF3(true, b3, x, y, i, h) -> IF4(b3, x, y, i, h)
   IF4(false, x, y, i, h) -> REACH(x, y, rest(i), h)
   IF4(false, x, y, i, h) -> REACH(to(i), y, union(rest(i), h), empty)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(32) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule IF4(false, x, y, i, h) -> REACH(to(i), y, union(rest(i), h), empty) at position [0] we obtained the following new rules [LPAR04]:

   (IF4(false, y0, y1, edge(x0, x1, x2), y3) -> REACH(x1, y1, union(rest(edge(x0, x1, x2)), y3), empty),IF4(false, y0, y1, edge(x0, x1, x2), y3) -> REACH(x1, y1, union(rest(edge(x0, x1, x2)), y3), empty))


----------------------------------------

(33)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false, b2, b3, x, y, i, h) -> IF3(b2, b3, x, y, i, h)
   IF3(false, b3, x, y, i, h) -> REACH(x, y, rest(i), edge(from(i), to(i), h))
   REACH(0, s(x0), y2, y3) -> IF1(false, isEmpty(y2), eq(0, from(y2)), eq(s(x0), to(y2)), 0, s(x0), y2, y3)
   IF1(false, b1, b2, b3, x, y, i, h) -> IF2(b1, b2, b3, x, y, i, h)
   REACH(s(x0), 0, y2, y3) -> IF1(false, isEmpty(y2), eq(s(x0), from(y2)), eq(0, to(y2)), s(x0), 0, y2, y3)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF3(true, b3, x, y, i, h) -> IF4(b3, x, y, i, h)
   IF4(false, x, y, i, h) -> REACH(x, y, rest(i), h)
   IF4(false, y0, y1, edge(x0, x1, x2), y3) -> REACH(x1, y1, union(rest(edge(x0, x1, x2)), y3), empty)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(34) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule IF4(false, y0, y1, edge(x0, x1, x2), y3) -> REACH(x1, y1, union(rest(edge(x0, x1, x2)), y3), empty) at position [2,0] we obtained the following new rules [LPAR04]:

   (IF4(false, y0, y1, edge(x0, x1, x2), y3) -> REACH(x1, y1, union(x2, y3), empty),IF4(false, y0, y1, edge(x0, x1, x2), y3) -> REACH(x1, y1, union(x2, y3), empty))


----------------------------------------

(35)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false, b2, b3, x, y, i, h) -> IF3(b2, b3, x, y, i, h)
   IF3(false, b3, x, y, i, h) -> REACH(x, y, rest(i), edge(from(i), to(i), h))
   REACH(0, s(x0), y2, y3) -> IF1(false, isEmpty(y2), eq(0, from(y2)), eq(s(x0), to(y2)), 0, s(x0), y2, y3)
   IF1(false, b1, b2, b3, x, y, i, h) -> IF2(b1, b2, b3, x, y, i, h)
   REACH(s(x0), 0, y2, y3) -> IF1(false, isEmpty(y2), eq(s(x0), from(y2)), eq(0, to(y2)), s(x0), 0, y2, y3)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF3(true, b3, x, y, i, h) -> IF4(b3, x, y, i, h)
   IF4(false, x, y, i, h) -> REACH(x, y, rest(i), h)
   IF4(false, y0, y1, edge(x0, x1, x2), y3) -> REACH(x1, y1, union(x2, y3), empty)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(36) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF1(false, b1, b2, b3, x, y, i, h) -> IF2(b1, b2, b3, x, y, i, h) we obtained the following new rules [LPAR04]:

   (IF1(false, y_0, y_2, y_4, 0, s(z0), z1, z2) -> IF2(y_0, y_2, y_4, 0, s(z0), z1, z2),IF1(false, y_0, y_2, y_4, 0, s(z0), z1, z2) -> IF2(y_0, y_2, y_4, 0, s(z0), z1, z2))
   (IF1(false, y_0, y_2, y_4, s(z0), 0, z1, z2) -> IF2(y_0, y_2, y_4, s(z0), 0, z1, z2),IF1(false, y_0, y_2, y_4, s(z0), 0, z1, z2) -> IF2(y_0, y_2, y_4, s(z0), 0, z1, z2))
   (IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3),IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3))


----------------------------------------

(37)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false, b2, b3, x, y, i, h) -> IF3(b2, b3, x, y, i, h)
   IF3(false, b3, x, y, i, h) -> REACH(x, y, rest(i), edge(from(i), to(i), h))
   REACH(0, s(x0), y2, y3) -> IF1(false, isEmpty(y2), eq(0, from(y2)), eq(s(x0), to(y2)), 0, s(x0), y2, y3)
   REACH(s(x0), 0, y2, y3) -> IF1(false, isEmpty(y2), eq(s(x0), from(y2)), eq(0, to(y2)), s(x0), 0, y2, y3)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF3(true, b3, x, y, i, h) -> IF4(b3, x, y, i, h)
   IF4(false, x, y, i, h) -> REACH(x, y, rest(i), h)
   IF4(false, y0, y1, edge(x0, x1, x2), y3) -> REACH(x1, y1, union(x2, y3), empty)
   IF1(false, y_0, y_2, y_4, 0, s(z0), z1, z2) -> IF2(y_0, y_2, y_4, 0, s(z0), z1, z2)
   IF1(false, y_0, y_2, y_4, s(z0), 0, z1, z2) -> IF2(y_0, y_2, y_4, s(z0), 0, z1, z2)
   IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(38) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF2(false, b2, b3, x, y, i, h) -> IF3(b2, b3, x, y, i, h) we obtained the following new rules [LPAR04]:

   (IF2(false, z1, z2, 0, s(z3), z4, z5) -> IF3(z1, z2, 0, s(z3), z4, z5),IF2(false, z1, z2, 0, s(z3), z4, z5) -> IF3(z1, z2, 0, s(z3), z4, z5))
   (IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5),IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5))
   (IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6),IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6))


----------------------------------------

(39)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(false, b3, x, y, i, h) -> REACH(x, y, rest(i), edge(from(i), to(i), h))
   REACH(0, s(x0), y2, y3) -> IF1(false, isEmpty(y2), eq(0, from(y2)), eq(s(x0), to(y2)), 0, s(x0), y2, y3)
   REACH(s(x0), 0, y2, y3) -> IF1(false, isEmpty(y2), eq(s(x0), from(y2)), eq(0, to(y2)), s(x0), 0, y2, y3)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF3(true, b3, x, y, i, h) -> IF4(b3, x, y, i, h)
   IF4(false, x, y, i, h) -> REACH(x, y, rest(i), h)
   IF4(false, y0, y1, edge(x0, x1, x2), y3) -> REACH(x1, y1, union(x2, y3), empty)
   IF1(false, y_0, y_2, y_4, 0, s(z0), z1, z2) -> IF2(y_0, y_2, y_4, 0, s(z0), z1, z2)
   IF1(false, y_0, y_2, y_4, s(z0), 0, z1, z2) -> IF2(y_0, y_2, y_4, s(z0), 0, z1, z2)
   IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3)
   IF2(false, z1, z2, 0, s(z3), z4, z5) -> IF3(z1, z2, 0, s(z3), z4, z5)
   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(40) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF3(false, b3, x, y, i, h) -> REACH(x, y, rest(i), edge(from(i), to(i), h)) we obtained the following new rules [LPAR04]:

   (IF3(false, z1, 0, s(z2), z3, z4) -> REACH(0, s(z2), rest(z3), edge(from(z3), to(z3), z4)),IF3(false, z1, 0, s(z2), z3, z4) -> REACH(0, s(z2), rest(z3), edge(from(z3), to(z3), z4)))
   (IF3(false, z1, s(z2), 0, z3, z4) -> REACH(s(z2), 0, rest(z3), edge(from(z3), to(z3), z4)),IF3(false, z1, s(z2), 0, z3, z4) -> REACH(s(z2), 0, rest(z3), edge(from(z3), to(z3), z4)))
   (IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5)),IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5)))


----------------------------------------

(41)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(0, s(x0), y2, y3) -> IF1(false, isEmpty(y2), eq(0, from(y2)), eq(s(x0), to(y2)), 0, s(x0), y2, y3)
   REACH(s(x0), 0, y2, y3) -> IF1(false, isEmpty(y2), eq(s(x0), from(y2)), eq(0, to(y2)), s(x0), 0, y2, y3)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF3(true, b3, x, y, i, h) -> IF4(b3, x, y, i, h)
   IF4(false, x, y, i, h) -> REACH(x, y, rest(i), h)
   IF4(false, y0, y1, edge(x0, x1, x2), y3) -> REACH(x1, y1, union(x2, y3), empty)
   IF1(false, y_0, y_2, y_4, 0, s(z0), z1, z2) -> IF2(y_0, y_2, y_4, 0, s(z0), z1, z2)
   IF1(false, y_0, y_2, y_4, s(z0), 0, z1, z2) -> IF2(y_0, y_2, y_4, s(z0), 0, z1, z2)
   IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3)
   IF2(false, z1, z2, 0, s(z3), z4, z5) -> IF3(z1, z2, 0, s(z3), z4, z5)
   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, 0, s(z2), z3, z4) -> REACH(0, s(z2), rest(z3), edge(from(z3), to(z3), z4))
   IF3(false, z1, s(z2), 0, z3, z4) -> REACH(s(z2), 0, rest(z3), edge(from(z3), to(z3), z4))
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(42) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF3(true, b3, x, y, i, h) -> IF4(b3, x, y, i, h) we obtained the following new rules [LPAR04]:

   (IF3(true, z1, 0, s(z2), z3, z4) -> IF4(z1, 0, s(z2), z3, z4),IF3(true, z1, 0, s(z2), z3, z4) -> IF4(z1, 0, s(z2), z3, z4))
   (IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4),IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4))
   (IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5),IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5))


----------------------------------------

(43)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(0, s(x0), y2, y3) -> IF1(false, isEmpty(y2), eq(0, from(y2)), eq(s(x0), to(y2)), 0, s(x0), y2, y3)
   REACH(s(x0), 0, y2, y3) -> IF1(false, isEmpty(y2), eq(s(x0), from(y2)), eq(0, to(y2)), s(x0), 0, y2, y3)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF4(false, x, y, i, h) -> REACH(x, y, rest(i), h)
   IF4(false, y0, y1, edge(x0, x1, x2), y3) -> REACH(x1, y1, union(x2, y3), empty)
   IF1(false, y_0, y_2, y_4, 0, s(z0), z1, z2) -> IF2(y_0, y_2, y_4, 0, s(z0), z1, z2)
   IF1(false, y_0, y_2, y_4, s(z0), 0, z1, z2) -> IF2(y_0, y_2, y_4, s(z0), 0, z1, z2)
   IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3)
   IF2(false, z1, z2, 0, s(z3), z4, z5) -> IF3(z1, z2, 0, s(z3), z4, z5)
   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, 0, s(z2), z3, z4) -> REACH(0, s(z2), rest(z3), edge(from(z3), to(z3), z4))
   IF3(false, z1, s(z2), 0, z3, z4) -> REACH(s(z2), 0, rest(z3), edge(from(z3), to(z3), z4))
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, 0, s(z2), z3, z4) -> IF4(z1, 0, s(z2), z3, z4)
   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(44) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF4(false, x, y, i, h) -> REACH(x, y, rest(i), h) we obtained the following new rules [LPAR04]:

   (IF4(false, 0, s(z1), z2, z3) -> REACH(0, s(z1), rest(z2), z3),IF4(false, 0, s(z1), z2, z3) -> REACH(0, s(z1), rest(z2), z3))
   (IF4(false, s(z1), 0, z2, z3) -> REACH(s(z1), 0, rest(z2), z3),IF4(false, s(z1), 0, z2, z3) -> REACH(s(z1), 0, rest(z2), z3))
   (IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4),IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4))


----------------------------------------

(45)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(0, s(x0), y2, y3) -> IF1(false, isEmpty(y2), eq(0, from(y2)), eq(s(x0), to(y2)), 0, s(x0), y2, y3)
   REACH(s(x0), 0, y2, y3) -> IF1(false, isEmpty(y2), eq(s(x0), from(y2)), eq(0, to(y2)), s(x0), 0, y2, y3)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF4(false, y0, y1, edge(x0, x1, x2), y3) -> REACH(x1, y1, union(x2, y3), empty)
   IF1(false, y_0, y_2, y_4, 0, s(z0), z1, z2) -> IF2(y_0, y_2, y_4, 0, s(z0), z1, z2)
   IF1(false, y_0, y_2, y_4, s(z0), 0, z1, z2) -> IF2(y_0, y_2, y_4, s(z0), 0, z1, z2)
   IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3)
   IF2(false, z1, z2, 0, s(z3), z4, z5) -> IF3(z1, z2, 0, s(z3), z4, z5)
   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, 0, s(z2), z3, z4) -> REACH(0, s(z2), rest(z3), edge(from(z3), to(z3), z4))
   IF3(false, z1, s(z2), 0, z3, z4) -> REACH(s(z2), 0, rest(z3), edge(from(z3), to(z3), z4))
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, 0, s(z2), z3, z4) -> IF4(z1, 0, s(z2), z3, z4)
   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, 0, s(z1), z2, z3) -> REACH(0, s(z1), rest(z2), z3)
   IF4(false, s(z1), 0, z2, z3) -> REACH(s(z1), 0, rest(z2), z3)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(46) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF4(false, y0, y1, edge(x0, x1, x2), y3) -> REACH(x1, y1, union(x2, y3), empty) we obtained the following new rules [LPAR04]:

   (IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty),IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty))
   (IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty),IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty))
   (IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty),IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty))


----------------------------------------

(47)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(0, s(x0), y2, y3) -> IF1(false, isEmpty(y2), eq(0, from(y2)), eq(s(x0), to(y2)), 0, s(x0), y2, y3)
   REACH(s(x0), 0, y2, y3) -> IF1(false, isEmpty(y2), eq(s(x0), from(y2)), eq(0, to(y2)), s(x0), 0, y2, y3)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF1(false, y_0, y_2, y_4, 0, s(z0), z1, z2) -> IF2(y_0, y_2, y_4, 0, s(z0), z1, z2)
   IF1(false, y_0, y_2, y_4, s(z0), 0, z1, z2) -> IF2(y_0, y_2, y_4, s(z0), 0, z1, z2)
   IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3)
   IF2(false, z1, z2, 0, s(z3), z4, z5) -> IF3(z1, z2, 0, s(z3), z4, z5)
   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, 0, s(z2), z3, z4) -> REACH(0, s(z2), rest(z3), edge(from(z3), to(z3), z4))
   IF3(false, z1, s(z2), 0, z3, z4) -> REACH(s(z2), 0, rest(z3), edge(from(z3), to(z3), z4))
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, 0, s(z2), z3, z4) -> IF4(z1, 0, s(z2), z3, z4)
   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, 0, s(z1), z2, z3) -> REACH(0, s(z1), rest(z2), z3)
   IF4(false, s(z1), 0, z2, z3) -> REACH(s(z1), 0, rest(z2), z3)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty)
   IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(48) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs.
----------------------------------------

(49)
Complex Obligation (AND)

----------------------------------------

(50)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF1(false, y_0, y_2, y_4, s(z0), 0, z1, z2) -> IF2(y_0, y_2, y_4, s(z0), 0, z1, z2)
   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF3(false, z1, s(z2), 0, z3, z4) -> REACH(s(z2), 0, rest(z3), edge(from(z3), to(z3), z4))
   REACH(s(x0), 0, y2, y3) -> IF1(false, isEmpty(y2), eq(s(x0), from(y2)), eq(0, to(y2)), s(x0), 0, y2, y3)
   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF4(false, s(z1), 0, z2, z3) -> REACH(s(z1), 0, rest(z2), z3)
   IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(51) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule IF1(false, y_0, y_2, y_4, s(z0), 0, z1, z2) -> IF2(y_0, y_2, y_4, s(z0), 0, z1, z2) we obtained the following new rules [LPAR04]:

   (IF1(false, false, x1, x2, s(x3), 0, x4, x5) -> IF2(false, x1, x2, s(x3), 0, x4, x5),IF1(false, false, x1, x2, s(x3), 0, x4, x5) -> IF2(false, x1, x2, s(x3), 0, x4, x5))


----------------------------------------

(52)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF3(false, z1, s(z2), 0, z3, z4) -> REACH(s(z2), 0, rest(z3), edge(from(z3), to(z3), z4))
   REACH(s(x0), 0, y2, y3) -> IF1(false, isEmpty(y2), eq(s(x0), from(y2)), eq(0, to(y2)), s(x0), 0, y2, y3)
   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF4(false, s(z1), 0, z2, z3) -> REACH(s(z1), 0, rest(z2), z3)
   IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty)
   IF1(false, false, x1, x2, s(x3), 0, x4, x5) -> IF2(false, x1, x2, s(x3), 0, x4, x5)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(53) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule REACH(s(x0), 0, y2, y3) -> IF1(false, isEmpty(y2), eq(s(x0), from(y2)), eq(0, to(y2)), s(x0), 0, y2, y3) at position [1] we obtained the following new rules [LPAR04]:

   (REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), from(edge(x0, x1, x2))), eq(0, to(edge(x0, x1, x2))), s(y0), 0, edge(x0, x1, x2), y2),REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), from(edge(x0, x1, x2))), eq(0, to(edge(x0, x1, x2))), s(y0), 0, edge(x0, x1, x2), y2))


----------------------------------------

(54)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF3(false, z1, s(z2), 0, z3, z4) -> REACH(s(z2), 0, rest(z3), edge(from(z3), to(z3), z4))
   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF4(false, s(z1), 0, z2, z3) -> REACH(s(z1), 0, rest(z2), z3)
   IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty)
   IF1(false, false, x1, x2, s(x3), 0, x4, x5) -> IF2(false, x1, x2, s(x3), 0, x4, x5)
   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), from(edge(x0, x1, x2))), eq(0, to(edge(x0, x1, x2))), s(y0), 0, edge(x0, x1, x2), y2)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(55) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(56)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF3(false, z1, s(z2), 0, z3, z4) -> REACH(s(z2), 0, rest(z3), edge(from(z3), to(z3), z4))
   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF4(false, s(z1), 0, z2, z3) -> REACH(s(z1), 0, rest(z2), z3)
   IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty)
   IF1(false, false, x1, x2, s(x3), 0, x4, x5) -> IF2(false, x1, x2, s(x3), 0, x4, x5)
   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), from(edge(x0, x1, x2))), eq(0, to(edge(x0, x1, x2))), s(y0), 0, edge(x0, x1, x2), y2)

The TRS R consists of the following rules:

   from(edge(x, y, i)) -> x
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   to(edge(x, y, i)) -> y
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(57) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))


----------------------------------------

(58)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF3(false, z1, s(z2), 0, z3, z4) -> REACH(s(z2), 0, rest(z3), edge(from(z3), to(z3), z4))
   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF4(false, s(z1), 0, z2, z3) -> REACH(s(z1), 0, rest(z2), z3)
   IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty)
   IF1(false, false, x1, x2, s(x3), 0, x4, x5) -> IF2(false, x1, x2, s(x3), 0, x4, x5)
   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), from(edge(x0, x1, x2))), eq(0, to(edge(x0, x1, x2))), s(y0), 0, edge(x0, x1, x2), y2)

The TRS R consists of the following rules:

   from(edge(x, y, i)) -> x
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   to(edge(x, y, i)) -> y
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(59) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), from(edge(x0, x1, x2))), eq(0, to(edge(x0, x1, x2))), s(y0), 0, edge(x0, x1, x2), y2) at position [2,1] we obtained the following new rules [LPAR04]:

   (REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, to(edge(x0, x1, x2))), s(y0), 0, edge(x0, x1, x2), y2),REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, to(edge(x0, x1, x2))), s(y0), 0, edge(x0, x1, x2), y2))


----------------------------------------

(60)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF3(false, z1, s(z2), 0, z3, z4) -> REACH(s(z2), 0, rest(z3), edge(from(z3), to(z3), z4))
   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF4(false, s(z1), 0, z2, z3) -> REACH(s(z1), 0, rest(z2), z3)
   IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty)
   IF1(false, false, x1, x2, s(x3), 0, x4, x5) -> IF2(false, x1, x2, s(x3), 0, x4, x5)
   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, to(edge(x0, x1, x2))), s(y0), 0, edge(x0, x1, x2), y2)

The TRS R consists of the following rules:

   from(edge(x, y, i)) -> x
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   to(edge(x, y, i)) -> y
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(61) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, to(edge(x0, x1, x2))), s(y0), 0, edge(x0, x1, x2), y2) at position [3,1] we obtained the following new rules [LPAR04]:

   (REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2),REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2))


----------------------------------------

(62)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF3(false, z1, s(z2), 0, z3, z4) -> REACH(s(z2), 0, rest(z3), edge(from(z3), to(z3), z4))
   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF4(false, s(z1), 0, z2, z3) -> REACH(s(z1), 0, rest(z2), z3)
   IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty)
   IF1(false, false, x1, x2, s(x3), 0, x4, x5) -> IF2(false, x1, x2, s(x3), 0, x4, x5)
   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)

The TRS R consists of the following rules:

   from(edge(x, y, i)) -> x
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   to(edge(x, y, i)) -> y
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(63) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule IF3(false, z1, s(z2), 0, z3, z4) -> REACH(s(z2), 0, rest(z3), edge(from(z3), to(z3), z4)) at position [2] we obtained the following new rules [LPAR04]:

   (IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(from(edge(x0, x1, x2)), to(edge(x0, x1, x2)), y3)),IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(from(edge(x0, x1, x2)), to(edge(x0, x1, x2)), y3)))
   (IF3(false, y0, s(y1), 0, empty, y3) -> REACH(s(y1), 0, empty, edge(from(empty), to(empty), y3)),IF3(false, y0, s(y1), 0, empty, y3) -> REACH(s(y1), 0, empty, edge(from(empty), to(empty), y3)))


----------------------------------------

(64)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF4(false, s(z1), 0, z2, z3) -> REACH(s(z1), 0, rest(z2), z3)
   IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty)
   IF1(false, false, x1, x2, s(x3), 0, x4, x5) -> IF2(false, x1, x2, s(x3), 0, x4, x5)
   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(from(edge(x0, x1, x2)), to(edge(x0, x1, x2)), y3))
   IF3(false, y0, s(y1), 0, empty, y3) -> REACH(s(y1), 0, empty, edge(from(empty), to(empty), y3))

The TRS R consists of the following rules:

   from(edge(x, y, i)) -> x
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   to(edge(x, y, i)) -> y
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(65) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(66)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF4(false, s(z1), 0, z2, z3) -> REACH(s(z1), 0, rest(z2), z3)
   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF1(false, false, x1, x2, s(x3), 0, x4, x5) -> IF2(false, x1, x2, s(x3), 0, x4, x5)
   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(from(edge(x0, x1, x2)), to(edge(x0, x1, x2)), y3))
   IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty)

The TRS R consists of the following rules:

   from(edge(x, y, i)) -> x
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   to(edge(x, y, i)) -> y
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(67) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(from(edge(x0, x1, x2)), to(edge(x0, x1, x2)), y3)) at position [3,0] we obtained the following new rules [LPAR04]:

   (IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(x0, to(edge(x0, x1, x2)), y3)),IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(x0, to(edge(x0, x1, x2)), y3)))


----------------------------------------

(68)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF4(false, s(z1), 0, z2, z3) -> REACH(s(z1), 0, rest(z2), z3)
   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF1(false, false, x1, x2, s(x3), 0, x4, x5) -> IF2(false, x1, x2, s(x3), 0, x4, x5)
   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty)
   IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(x0, to(edge(x0, x1, x2)), y3))

The TRS R consists of the following rules:

   from(edge(x, y, i)) -> x
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   to(edge(x, y, i)) -> y
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(69) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(70)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF4(false, s(z1), 0, z2, z3) -> REACH(s(z1), 0, rest(z2), z3)
   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF1(false, false, x1, x2, s(x3), 0, x4, x5) -> IF2(false, x1, x2, s(x3), 0, x4, x5)
   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty)
   IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(x0, to(edge(x0, x1, x2)), y3))

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(71) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   from(edge(x0, x1, x2))


----------------------------------------

(72)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF4(false, s(z1), 0, z2, z3) -> REACH(s(z1), 0, rest(z2), z3)
   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF1(false, false, x1, x2, s(x3), 0, x4, x5) -> IF2(false, x1, x2, s(x3), 0, x4, x5)
   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty)
   IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(x0, to(edge(x0, x1, x2)), y3))

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(73) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(x0, to(edge(x0, x1, x2)), y3)) at position [3,1] we obtained the following new rules [LPAR04]:

   (IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(x0, x1, y3)),IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(x0, x1, y3)))


----------------------------------------

(74)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF4(false, s(z1), 0, z2, z3) -> REACH(s(z1), 0, rest(z2), z3)
   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF1(false, false, x1, x2, s(x3), 0, x4, x5) -> IF2(false, x1, x2, s(x3), 0, x4, x5)
   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty)
   IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(x0, x1, y3))

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(75) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(76)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF4(false, s(z1), 0, z2, z3) -> REACH(s(z1), 0, rest(z2), z3)
   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF1(false, false, x1, x2, s(x3), 0, x4, x5) -> IF2(false, x1, x2, s(x3), 0, x4, x5)
   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty)
   IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(x0, x1, y3))

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(77) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   to(edge(x0, x1, x2))


----------------------------------------

(78)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF4(false, s(z1), 0, z2, z3) -> REACH(s(z1), 0, rest(z2), z3)
   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF1(false, false, x1, x2, s(x3), 0, x4, x5) -> IF2(false, x1, x2, s(x3), 0, x4, x5)
   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty)
   IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(x0, x1, y3))

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(79) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule IF4(false, s(z1), 0, z2, z3) -> REACH(s(z1), 0, rest(z2), z3) at position [2] we obtained the following new rules [LPAR04]:

   (IF4(false, s(y0), 0, edge(x0, x1, x2), y2) -> REACH(s(y0), 0, x2, y2),IF4(false, s(y0), 0, edge(x0, x1, x2), y2) -> REACH(s(y0), 0, x2, y2))
   (IF4(false, s(y0), 0, empty, y2) -> REACH(s(y0), 0, empty, y2),IF4(false, s(y0), 0, empty, y2) -> REACH(s(y0), 0, empty, y2))


----------------------------------------

(80)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF1(false, false, x1, x2, s(x3), 0, x4, x5) -> IF2(false, x1, x2, s(x3), 0, x4, x5)
   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty)
   IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(x0, x1, y3))
   IF4(false, s(y0), 0, edge(x0, x1, x2), y2) -> REACH(s(y0), 0, x2, y2)
   IF4(false, s(y0), 0, empty, y2) -> REACH(s(y0), 0, empty, y2)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(81) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(82)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty)
   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF1(false, false, x1, x2, s(x3), 0, x4, x5) -> IF2(false, x1, x2, s(x3), 0, x4, x5)
   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF4(false, s(y0), 0, edge(x0, x1, x2), y2) -> REACH(s(y0), 0, x2, y2)
   IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(x0, x1, y3))

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(83) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(84)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty)
   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF1(false, false, x1, x2, s(x3), 0, x4, x5) -> IF2(false, x1, x2, s(x3), 0, x4, x5)
   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF4(false, s(y0), 0, edge(x0, x1, x2), y2) -> REACH(s(y0), 0, x2, y2)
   IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(x0, x1, y3))

The TRS R consists of the following rules:

   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(85) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   rest(edge(x0, x1, x2))
   rest(empty)


----------------------------------------

(86)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty)
   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF1(false, false, x1, x2, s(x3), 0, x4, x5) -> IF2(false, x1, x2, s(x3), 0, x4, x5)
   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF4(false, s(y0), 0, edge(x0, x1, x2), y2) -> REACH(s(y0), 0, x2, y2)
   IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(x0, x1, y3))

The TRS R consists of the following rules:

   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(87) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule IF4(false, s(z1), 0, edge(x2, x3, x4), z3) -> REACH(x3, 0, union(x4, z3), empty) at position [2] we obtained the following new rules [LPAR04]:

   (IF4(false, s(y0), 0, edge(y1, y2, empty), x0) -> REACH(y2, 0, x0, empty),IF4(false, s(y0), 0, edge(y1, y2, empty), x0) -> REACH(y2, 0, x0, empty))
   (IF4(false, s(y0), 0, edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, 0, edge(x0, x1, union(x2, x3)), empty),IF4(false, s(y0), 0, edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, 0, edge(x0, x1, union(x2, x3)), empty))


----------------------------------------

(88)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF1(false, false, x1, x2, s(x3), 0, x4, x5) -> IF2(false, x1, x2, s(x3), 0, x4, x5)
   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF4(false, s(y0), 0, edge(x0, x1, x2), y2) -> REACH(s(y0), 0, x2, y2)
   IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(x0, x1, y3))
   IF4(false, s(y0), 0, edge(y1, y2, empty), x0) -> REACH(y2, 0, x0, empty)
   IF4(false, s(y0), 0, edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, 0, edge(x0, x1, union(x2, x3)), empty)

The TRS R consists of the following rules:

   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(89) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF1(false, false, x1, x2, s(x3), 0, x4, x5) -> IF2(false, x1, x2, s(x3), 0, x4, x5) we obtained the following new rules [LPAR04]:

   (IF1(false, false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4),IF1(false, false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4))


----------------------------------------

(90)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5)
   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF4(false, s(y0), 0, edge(x0, x1, x2), y2) -> REACH(s(y0), 0, x2, y2)
   IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(x0, x1, y3))
   IF4(false, s(y0), 0, edge(y1, y2, empty), x0) -> REACH(y2, 0, x0, empty)
   IF4(false, s(y0), 0, edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, 0, edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4)

The TRS R consists of the following rules:

   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(91) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF2(false, z1, z2, s(z3), 0, z4, z5) -> IF3(z1, z2, s(z3), 0, z4, z5) we obtained the following new rules [LPAR04]:

   (IF2(false, z0, z1, s(z2), 0, edge(z3, z4, z5), z6) -> IF3(z0, z1, s(z2), 0, edge(z3, z4, z5), z6),IF2(false, z0, z1, s(z2), 0, edge(z3, z4, z5), z6) -> IF3(z0, z1, s(z2), 0, edge(z3, z4, z5), z6))


----------------------------------------

(92)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4)
   IF4(false, s(y0), 0, edge(x0, x1, x2), y2) -> REACH(s(y0), 0, x2, y2)
   IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(x0, x1, y3))
   IF4(false, s(y0), 0, edge(y1, y2, empty), x0) -> REACH(y2, 0, x0, empty)
   IF4(false, s(y0), 0, edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, 0, edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4)
   IF2(false, z0, z1, s(z2), 0, edge(z3, z4, z5), z6) -> IF3(z0, z1, s(z2), 0, edge(z3, z4, z5), z6)

The TRS R consists of the following rules:

   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(93) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF3(true, z1, s(z2), 0, z3, z4) -> IF4(z1, s(z2), 0, z3, z4) we obtained the following new rules [LPAR04]:

   (IF3(true, z1, s(z2), 0, edge(z3, z4, z5), z6) -> IF4(z1, s(z2), 0, edge(z3, z4, z5), z6),IF3(true, z1, s(z2), 0, edge(z3, z4, z5), z6) -> IF4(z1, s(z2), 0, edge(z3, z4, z5), z6))


----------------------------------------

(94)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF4(false, s(y0), 0, edge(x0, x1, x2), y2) -> REACH(s(y0), 0, x2, y2)
   IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(x0, x1, y3))
   IF4(false, s(y0), 0, edge(y1, y2, empty), x0) -> REACH(y2, 0, x0, empty)
   IF4(false, s(y0), 0, edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, 0, edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4)
   IF2(false, z0, z1, s(z2), 0, edge(z3, z4, z5), z6) -> IF3(z0, z1, s(z2), 0, edge(z3, z4, z5), z6)
   IF3(true, z1, s(z2), 0, edge(z3, z4, z5), z6) -> IF4(z1, s(z2), 0, edge(z3, z4, z5), z6)

The TRS R consists of the following rules:

   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(95) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule IF4(false, s(y0), 0, edge(x0, x1, x2), y2) -> REACH(s(y0), 0, x2, y2) we obtained the following new rules [LPAR04]:

   (IF4(false, s(x0), 0, edge(x1, x2, edge(y_1, y_2, y_3)), x4) -> REACH(s(x0), 0, edge(y_1, y_2, y_3), x4),IF4(false, s(x0), 0, edge(x1, x2, edge(y_1, y_2, y_3)), x4) -> REACH(s(x0), 0, edge(y_1, y_2, y_3), x4))


----------------------------------------

(96)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(x0, x1, y3))
   IF4(false, s(y0), 0, edge(y1, y2, empty), x0) -> REACH(y2, 0, x0, empty)
   IF4(false, s(y0), 0, edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, 0, edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4)
   IF2(false, z0, z1, s(z2), 0, edge(z3, z4, z5), z6) -> IF3(z0, z1, s(z2), 0, edge(z3, z4, z5), z6)
   IF3(true, z1, s(z2), 0, edge(z3, z4, z5), z6) -> IF4(z1, s(z2), 0, edge(z3, z4, z5), z6)
   IF4(false, s(x0), 0, edge(x1, x2, edge(y_1, y_2, y_3)), x4) -> REACH(s(x0), 0, edge(y_1, y_2, y_3), x4)

The TRS R consists of the following rules:

   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(97) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule IF3(false, y0, s(y1), 0, edge(x0, x1, x2), y3) -> REACH(s(y1), 0, x2, edge(x0, x1, y3)) we obtained the following new rules [LPAR04]:

   (IF3(false, x0, s(x1), 0, edge(x2, x3, edge(y_1, y_2, y_3)), x5) -> REACH(s(x1), 0, edge(y_1, y_2, y_3), edge(x2, x3, x5)),IF3(false, x0, s(x1), 0, edge(x2, x3, edge(y_1, y_2, y_3)), x5) -> REACH(s(x1), 0, edge(y_1, y_2, y_3), edge(x2, x3, x5)))


----------------------------------------

(98)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF4(false, s(y0), 0, edge(y1, y2, empty), x0) -> REACH(y2, 0, x0, empty)
   IF4(false, s(y0), 0, edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, 0, edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4)
   IF2(false, z0, z1, s(z2), 0, edge(z3, z4, z5), z6) -> IF3(z0, z1, s(z2), 0, edge(z3, z4, z5), z6)
   IF3(true, z1, s(z2), 0, edge(z3, z4, z5), z6) -> IF4(z1, s(z2), 0, edge(z3, z4, z5), z6)
   IF4(false, s(x0), 0, edge(x1, x2, edge(y_1, y_2, y_3)), x4) -> REACH(s(x0), 0, edge(y_1, y_2, y_3), x4)
   IF3(false, x0, s(x1), 0, edge(x2, x3, edge(y_1, y_2, y_3)), x5) -> REACH(s(x1), 0, edge(y_1, y_2, y_3), edge(x2, x3, x5))

The TRS R consists of the following rules:

   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(99) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule IF4(false, s(y0), 0, edge(y1, y2, empty), x0) -> REACH(y2, 0, x0, empty) we obtained the following new rules [LPAR04]:

   (IF4(false, s(x0), 0, edge(x1, s(y_0), empty), edge(y_1, y_2, y_3)) -> REACH(s(y_0), 0, edge(y_1, y_2, y_3), empty),IF4(false, s(x0), 0, edge(x1, s(y_0), empty), edge(y_1, y_2, y_3)) -> REACH(s(y_0), 0, edge(y_1, y_2, y_3), empty))


----------------------------------------

(100)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF4(false, s(y0), 0, edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, 0, edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4)
   IF2(false, z0, z1, s(z2), 0, edge(z3, z4, z5), z6) -> IF3(z0, z1, s(z2), 0, edge(z3, z4, z5), z6)
   IF3(true, z1, s(z2), 0, edge(z3, z4, z5), z6) -> IF4(z1, s(z2), 0, edge(z3, z4, z5), z6)
   IF4(false, s(x0), 0, edge(x1, x2, edge(y_1, y_2, y_3)), x4) -> REACH(s(x0), 0, edge(y_1, y_2, y_3), x4)
   IF3(false, x0, s(x1), 0, edge(x2, x3, edge(y_1, y_2, y_3)), x5) -> REACH(s(x1), 0, edge(y_1, y_2, y_3), edge(x2, x3, x5))
   IF4(false, s(x0), 0, edge(x1, s(y_0), empty), edge(y_1, y_2, y_3)) -> REACH(s(y_0), 0, edge(y_1, y_2, y_3), empty)

The TRS R consists of the following rules:

   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(101) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule IF2(false, z0, z1, s(z2), 0, edge(z3, z4, z5), z6) -> IF3(z0, z1, s(z2), 0, edge(z3, z4, z5), z6) we obtained the following new rules [LPAR04]:

   (IF2(false, true, x1, s(x2), 0, edge(x3, x4, x5), x6) -> IF3(true, x1, s(x2), 0, edge(x3, x4, x5), x6),IF2(false, true, x1, s(x2), 0, edge(x3, x4, x5), x6) -> IF3(true, x1, s(x2), 0, edge(x3, x4, x5), x6))
   (IF2(false, false, x1, s(x2), 0, edge(x3, x4, edge(y_4, y_5, y_6)), x6) -> IF3(false, x1, s(x2), 0, edge(x3, x4, edge(y_4, y_5, y_6)), x6),IF2(false, false, x1, s(x2), 0, edge(x3, x4, edge(y_4, y_5, y_6)), x6) -> IF3(false, x1, s(x2), 0, edge(x3, x4, edge(y_4, y_5, y_6)), x6))


----------------------------------------

(102)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF4(false, s(y0), 0, edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, 0, edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4)
   IF3(true, z1, s(z2), 0, edge(z3, z4, z5), z6) -> IF4(z1, s(z2), 0, edge(z3, z4, z5), z6)
   IF4(false, s(x0), 0, edge(x1, x2, edge(y_1, y_2, y_3)), x4) -> REACH(s(x0), 0, edge(y_1, y_2, y_3), x4)
   IF3(false, x0, s(x1), 0, edge(x2, x3, edge(y_1, y_2, y_3)), x5) -> REACH(s(x1), 0, edge(y_1, y_2, y_3), edge(x2, x3, x5))
   IF4(false, s(x0), 0, edge(x1, s(y_0), empty), edge(y_1, y_2, y_3)) -> REACH(s(y_0), 0, edge(y_1, y_2, y_3), empty)
   IF2(false, true, x1, s(x2), 0, edge(x3, x4, x5), x6) -> IF3(true, x1, s(x2), 0, edge(x3, x4, x5), x6)
   IF2(false, false, x1, s(x2), 0, edge(x3, x4, edge(y_4, y_5, y_6)), x6) -> IF3(false, x1, s(x2), 0, edge(x3, x4, edge(y_4, y_5, y_6)), x6)

The TRS R consists of the following rules:

   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(103) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule IF3(true, z1, s(z2), 0, edge(z3, z4, z5), z6) -> IF4(z1, s(z2), 0, edge(z3, z4, z5), z6) we obtained the following new rules [LPAR04]:

   (IF3(true, false, s(x1), 0, edge(x2, x3, edge(y_3, y_4, y_5)), x5) -> IF4(false, s(x1), 0, edge(x2, x3, edge(y_3, y_4, y_5)), x5),IF3(true, false, s(x1), 0, edge(x2, x3, edge(y_3, y_4, y_5)), x5) -> IF4(false, s(x1), 0, edge(x2, x3, edge(y_3, y_4, y_5)), x5))
   (IF3(true, false, s(x1), 0, edge(x2, s(y_2), empty), edge(y_3, y_4, y_5)) -> IF4(false, s(x1), 0, edge(x2, s(y_2), empty), edge(y_3, y_4, y_5)),IF3(true, false, s(x1), 0, edge(x2, s(y_2), empty), edge(y_3, y_4, y_5)) -> IF4(false, s(x1), 0, edge(x2, s(y_2), empty), edge(y_3, y_4, y_5)))


----------------------------------------

(104)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF4(false, s(y0), 0, edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, 0, edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4)
   IF4(false, s(x0), 0, edge(x1, x2, edge(y_1, y_2, y_3)), x4) -> REACH(s(x0), 0, edge(y_1, y_2, y_3), x4)
   IF3(false, x0, s(x1), 0, edge(x2, x3, edge(y_1, y_2, y_3)), x5) -> REACH(s(x1), 0, edge(y_1, y_2, y_3), edge(x2, x3, x5))
   IF4(false, s(x0), 0, edge(x1, s(y_0), empty), edge(y_1, y_2, y_3)) -> REACH(s(y_0), 0, edge(y_1, y_2, y_3), empty)
   IF2(false, true, x1, s(x2), 0, edge(x3, x4, x5), x6) -> IF3(true, x1, s(x2), 0, edge(x3, x4, x5), x6)
   IF2(false, false, x1, s(x2), 0, edge(x3, x4, edge(y_4, y_5, y_6)), x6) -> IF3(false, x1, s(x2), 0, edge(x3, x4, edge(y_4, y_5, y_6)), x6)
   IF3(true, false, s(x1), 0, edge(x2, x3, edge(y_3, y_4, y_5)), x5) -> IF4(false, s(x1), 0, edge(x2, x3, edge(y_3, y_4, y_5)), x5)
   IF3(true, false, s(x1), 0, edge(x2, s(y_2), empty), edge(y_3, y_4, y_5)) -> IF4(false, s(x1), 0, edge(x2, s(y_2), empty), edge(y_3, y_4, y_5))

The TRS R consists of the following rules:

   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(105) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   IF4(false, s(x0), 0, edge(x1, s(y_0), empty), edge(y_1, y_2, y_3)) -> REACH(s(y_0), 0, edge(y_1, y_2, y_3), empty)


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(IF1(x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8)) = 2*x_1 + 2*x_2 + 2*x_6 + x_7 + x_8
   POL(IF2(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = 2*x_1 + 2*x_5 + x_6 + x_7
   POL(IF3(x_1, x_2, x_3, x_4, x_5, x_6)) = 2*x_4 + x_5 + x_6
   POL(IF4(x_1, x_2, x_3, x_4, x_5)) = 2*x_1 + 2*x_3 + x_4 + x_5
   POL(REACH(x_1, x_2, x_3, x_4)) = 2*x_2 + x_3 + x_4
   POL(edge(x_1, x_2, x_3)) = 2*x_2 + x_3
   POL(empty) = 0
   POL(eq(x_1, x_2)) = 0
   POL(false) = 0
   POL(s(x_1)) = 2
   POL(true) = 0
   POL(union(x_1, x_2)) = x_1 + x_2


----------------------------------------

(106)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF4(false, s(y0), 0, edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, 0, edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4)
   IF4(false, s(x0), 0, edge(x1, x2, edge(y_1, y_2, y_3)), x4) -> REACH(s(x0), 0, edge(y_1, y_2, y_3), x4)
   IF3(false, x0, s(x1), 0, edge(x2, x3, edge(y_1, y_2, y_3)), x5) -> REACH(s(x1), 0, edge(y_1, y_2, y_3), edge(x2, x3, x5))
   IF2(false, true, x1, s(x2), 0, edge(x3, x4, x5), x6) -> IF3(true, x1, s(x2), 0, edge(x3, x4, x5), x6)
   IF2(false, false, x1, s(x2), 0, edge(x3, x4, edge(y_4, y_5, y_6)), x6) -> IF3(false, x1, s(x2), 0, edge(x3, x4, edge(y_4, y_5, y_6)), x6)
   IF3(true, false, s(x1), 0, edge(x2, x3, edge(y_3, y_4, y_5)), x5) -> IF4(false, s(x1), 0, edge(x2, x3, edge(y_3, y_4, y_5)), x5)
   IF3(true, false, s(x1), 0, edge(x2, s(y_2), empty), edge(y_3, y_4, y_5)) -> IF4(false, s(x1), 0, edge(x2, s(y_2), empty), edge(y_3, y_4, y_5))

The TRS R consists of the following rules:

   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(107) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(108)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF1(false, false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4)
   IF2(false, true, x1, s(x2), 0, edge(x3, x4, x5), x6) -> IF3(true, x1, s(x2), 0, edge(x3, x4, x5), x6)
   IF3(true, false, s(x1), 0, edge(x2, x3, edge(y_3, y_4, y_5)), x5) -> IF4(false, s(x1), 0, edge(x2, x3, edge(y_3, y_4, y_5)), x5)
   IF4(false, s(y0), 0, edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, 0, edge(x0, x1, union(x2, x3)), empty)
   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF4(false, s(x0), 0, edge(x1, x2, edge(y_1, y_2, y_3)), x4) -> REACH(s(x0), 0, edge(y_1, y_2, y_3), x4)
   IF2(false, false, x1, s(x2), 0, edge(x3, x4, edge(y_4, y_5, y_6)), x6) -> IF3(false, x1, s(x2), 0, edge(x3, x4, edge(y_4, y_5, y_6)), x6)
   IF3(false, x0, s(x1), 0, edge(x2, x3, edge(y_1, y_2, y_3)), x5) -> REACH(s(x1), 0, edge(y_1, y_2, y_3), edge(x2, x3, x5))

The TRS R consists of the following rules:

   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(109) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   IF4(false, s(y0), 0, edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, 0, edge(x0, x1, union(x2, x3)), empty)


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(IF1(x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8)) = 1 + 2*x_1 + 2*x_2 + 2*x_6 + x_7 + x_8
   POL(IF2(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = 1 + 2*x_1 + 2*x_5 + x_6 + x_7
   POL(IF3(x_1, x_2, x_3, x_4, x_5, x_6)) = 1 + 2*x_4 + x_5 + x_6
   POL(IF4(x_1, x_2, x_3, x_4, x_5)) = 1 + 2*x_1 + 2*x_3 + x_4 + x_5
   POL(REACH(x_1, x_2, x_3, x_4)) = x_1 + 2*x_2 + x_3 + x_4
   POL(edge(x_1, x_2, x_3)) = 2*x_2 + x_3
   POL(empty) = 0
   POL(eq(x_1, x_2)) = 0
   POL(false) = 0
   POL(s(x_1)) = 1
   POL(true) = 0
   POL(union(x_1, x_2)) = x_1 + x_2


----------------------------------------

(110)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF1(false, false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4)
   IF2(false, true, x1, s(x2), 0, edge(x3, x4, x5), x6) -> IF3(true, x1, s(x2), 0, edge(x3, x4, x5), x6)
   IF3(true, false, s(x1), 0, edge(x2, x3, edge(y_3, y_4, y_5)), x5) -> IF4(false, s(x1), 0, edge(x2, x3, edge(y_3, y_4, y_5)), x5)
   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF4(false, s(x0), 0, edge(x1, x2, edge(y_1, y_2, y_3)), x4) -> REACH(s(x0), 0, edge(y_1, y_2, y_3), x4)
   IF2(false, false, x1, s(x2), 0, edge(x3, x4, edge(y_4, y_5, y_6)), x6) -> IF3(false, x1, s(x2), 0, edge(x3, x4, edge(y_4, y_5, y_6)), x6)
   IF3(false, x0, s(x1), 0, edge(x2, x3, edge(y_1, y_2, y_3)), x5) -> REACH(s(x1), 0, edge(y_1, y_2, y_3), edge(x2, x3, x5))

The TRS R consists of the following rules:

   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(111) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(112)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF1(false, false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4)
   IF2(false, true, x1, s(x2), 0, edge(x3, x4, x5), x6) -> IF3(true, x1, s(x2), 0, edge(x3, x4, x5), x6)
   IF3(true, false, s(x1), 0, edge(x2, x3, edge(y_3, y_4, y_5)), x5) -> IF4(false, s(x1), 0, edge(x2, x3, edge(y_3, y_4, y_5)), x5)
   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF4(false, s(x0), 0, edge(x1, x2, edge(y_1, y_2, y_3)), x4) -> REACH(s(x0), 0, edge(y_1, y_2, y_3), x4)
   IF2(false, false, x1, s(x2), 0, edge(x3, x4, edge(y_4, y_5, y_6)), x6) -> IF3(false, x1, s(x2), 0, edge(x3, x4, edge(y_4, y_5, y_6)), x6)
   IF3(false, x0, s(x1), 0, edge(x2, x3, edge(y_1, y_2, y_3)), x5) -> REACH(s(x1), 0, edge(y_1, y_2, y_3), edge(x2, x3, x5))

The TRS R consists of the following rules:

   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(113) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   union(empty, x0)
   union(edge(x0, x1, x2), x3)


----------------------------------------

(114)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF1(false, false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4)
   IF2(false, true, x1, s(x2), 0, edge(x3, x4, x5), x6) -> IF3(true, x1, s(x2), 0, edge(x3, x4, x5), x6)
   IF3(true, false, s(x1), 0, edge(x2, x3, edge(y_3, y_4, y_5)), x5) -> IF4(false, s(x1), 0, edge(x2, x3, edge(y_3, y_4, y_5)), x5)
   REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
   IF4(false, s(x0), 0, edge(x1, x2, edge(y_1, y_2, y_3)), x4) -> REACH(s(x0), 0, edge(y_1, y_2, y_3), x4)
   IF2(false, false, x1, s(x2), 0, edge(x3, x4, edge(y_4, y_5, y_6)), x6) -> IF3(false, x1, s(x2), 0, edge(x3, x4, edge(y_4, y_5, y_6)), x6)
   IF3(false, x0, s(x1), 0, edge(x2, x3, edge(y_1, y_2, y_3)), x5) -> REACH(s(x1), 0, edge(y_1, y_2, y_3), edge(x2, x3, x5))

The TRS R consists of the following rules:

   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(115) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*REACH(s(y0), 0, edge(x0, x1, x2), y2) -> IF1(false, false, eq(s(y0), x0), eq(0, x1), s(y0), 0, edge(x0, x1, x2), y2)
The graph contains the following edges 1 >= 5, 2 >= 6, 3 >= 7, 4 >= 8


*IF3(true, false, s(x1), 0, edge(x2, x3, edge(y_3, y_4, y_5)), x5) -> IF4(false, s(x1), 0, edge(x2, x3, edge(y_3, y_4, y_5)), x5)
The graph contains the following edges 2 >= 1, 3 >= 2, 4 >= 3, 5 >= 4, 6 >= 5


*IF1(false, false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, s(z0), 0, edge(z1, z2, z3), z4)
The graph contains the following edges 1 >= 1, 2 >= 1, 3 >= 2, 4 >= 3, 5 >= 4, 6 >= 5, 7 >= 6, 8 >= 7


*IF2(false, true, x1, s(x2), 0, edge(x3, x4, x5), x6) -> IF3(true, x1, s(x2), 0, edge(x3, x4, x5), x6)
The graph contains the following edges 2 >= 1, 3 >= 2, 4 >= 3, 5 >= 4, 6 >= 5, 7 >= 6


*IF2(false, false, x1, s(x2), 0, edge(x3, x4, edge(y_4, y_5, y_6)), x6) -> IF3(false, x1, s(x2), 0, edge(x3, x4, edge(y_4, y_5, y_6)), x6)
The graph contains the following edges 1 >= 1, 2 >= 1, 3 >= 2, 4 >= 3, 5 >= 4, 6 >= 5, 7 >= 6


*IF4(false, s(x0), 0, edge(x1, x2, edge(y_1, y_2, y_3)), x4) -> REACH(s(x0), 0, edge(y_1, y_2, y_3), x4)
The graph contains the following edges 2 >= 1, 3 >= 2, 4 > 3, 5 >= 4


*IF3(false, x0, s(x1), 0, edge(x2, x3, edge(y_1, y_2, y_3)), x5) -> REACH(s(x1), 0, edge(y_1, y_2, y_3), edge(x2, x3, x5))
The graph contains the following edges 3 >= 1, 4 >= 2, 5 > 3


----------------------------------------

(116)
YES

----------------------------------------

(117)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF1(false, y_0, y_2, y_4, 0, s(z0), z1, z2) -> IF2(y_0, y_2, y_4, 0, s(z0), z1, z2)
   IF2(false, z1, z2, 0, s(z3), z4, z5) -> IF3(z1, z2, 0, s(z3), z4, z5)
   IF3(false, z1, 0, s(z2), z3, z4) -> REACH(0, s(z2), rest(z3), edge(from(z3), to(z3), z4))
   REACH(0, s(x0), y2, y3) -> IF1(false, isEmpty(y2), eq(0, from(y2)), eq(s(x0), to(y2)), 0, s(x0), y2, y3)
   IF3(true, z1, 0, s(z2), z3, z4) -> IF4(z1, 0, s(z2), z3, z4)
   IF4(false, 0, s(z1), z2, z3) -> REACH(0, s(z1), rest(z2), z3)
   IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(118) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule IF1(false, y_0, y_2, y_4, 0, s(z0), z1, z2) -> IF2(y_0, y_2, y_4, 0, s(z0), z1, z2) we obtained the following new rules [LPAR04]:

   (IF1(false, false, x1, x2, 0, s(x3), x4, x5) -> IF2(false, x1, x2, 0, s(x3), x4, x5),IF1(false, false, x1, x2, 0, s(x3), x4, x5) -> IF2(false, x1, x2, 0, s(x3), x4, x5))


----------------------------------------

(119)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false, z1, z2, 0, s(z3), z4, z5) -> IF3(z1, z2, 0, s(z3), z4, z5)
   IF3(false, z1, 0, s(z2), z3, z4) -> REACH(0, s(z2), rest(z3), edge(from(z3), to(z3), z4))
   REACH(0, s(x0), y2, y3) -> IF1(false, isEmpty(y2), eq(0, from(y2)), eq(s(x0), to(y2)), 0, s(x0), y2, y3)
   IF3(true, z1, 0, s(z2), z3, z4) -> IF4(z1, 0, s(z2), z3, z4)
   IF4(false, 0, s(z1), z2, z3) -> REACH(0, s(z1), rest(z2), z3)
   IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   IF1(false, false, x1, x2, 0, s(x3), x4, x5) -> IF2(false, x1, x2, 0, s(x3), x4, x5)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(120) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule REACH(0, s(x0), y2, y3) -> IF1(false, isEmpty(y2), eq(0, from(y2)), eq(s(x0), to(y2)), 0, s(x0), y2, y3) at position [1] we obtained the following new rules [LPAR04]:

   (REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, from(edge(x0, x1, x2))), eq(s(y0), to(edge(x0, x1, x2))), 0, s(y0), edge(x0, x1, x2), y2),REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, from(edge(x0, x1, x2))), eq(s(y0), to(edge(x0, x1, x2))), 0, s(y0), edge(x0, x1, x2), y2))


----------------------------------------

(121)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false, z1, z2, 0, s(z3), z4, z5) -> IF3(z1, z2, 0, s(z3), z4, z5)
   IF3(false, z1, 0, s(z2), z3, z4) -> REACH(0, s(z2), rest(z3), edge(from(z3), to(z3), z4))
   IF3(true, z1, 0, s(z2), z3, z4) -> IF4(z1, 0, s(z2), z3, z4)
   IF4(false, 0, s(z1), z2, z3) -> REACH(0, s(z1), rest(z2), z3)
   IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   IF1(false, false, x1, x2, 0, s(x3), x4, x5) -> IF2(false, x1, x2, 0, s(x3), x4, x5)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, from(edge(x0, x1, x2))), eq(s(y0), to(edge(x0, x1, x2))), 0, s(y0), edge(x0, x1, x2), y2)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(122) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, from(edge(x0, x1, x2))), eq(s(y0), to(edge(x0, x1, x2))), 0, s(y0), edge(x0, x1, x2), y2) at position [2,1] we obtained the following new rules [LPAR04]:

   (REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), to(edge(x0, x1, x2))), 0, s(y0), edge(x0, x1, x2), y2),REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), to(edge(x0, x1, x2))), 0, s(y0), edge(x0, x1, x2), y2))


----------------------------------------

(123)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false, z1, z2, 0, s(z3), z4, z5) -> IF3(z1, z2, 0, s(z3), z4, z5)
   IF3(false, z1, 0, s(z2), z3, z4) -> REACH(0, s(z2), rest(z3), edge(from(z3), to(z3), z4))
   IF3(true, z1, 0, s(z2), z3, z4) -> IF4(z1, 0, s(z2), z3, z4)
   IF4(false, 0, s(z1), z2, z3) -> REACH(0, s(z1), rest(z2), z3)
   IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   IF1(false, false, x1, x2, 0, s(x3), x4, x5) -> IF2(false, x1, x2, 0, s(x3), x4, x5)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), to(edge(x0, x1, x2))), 0, s(y0), edge(x0, x1, x2), y2)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(124) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), to(edge(x0, x1, x2))), 0, s(y0), edge(x0, x1, x2), y2) at position [3,1] we obtained the following new rules [LPAR04]:

   (REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2),REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2))


----------------------------------------

(125)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false, z1, z2, 0, s(z3), z4, z5) -> IF3(z1, z2, 0, s(z3), z4, z5)
   IF3(false, z1, 0, s(z2), z3, z4) -> REACH(0, s(z2), rest(z3), edge(from(z3), to(z3), z4))
   IF3(true, z1, 0, s(z2), z3, z4) -> IF4(z1, 0, s(z2), z3, z4)
   IF4(false, 0, s(z1), z2, z3) -> REACH(0, s(z1), rest(z2), z3)
   IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   IF1(false, false, x1, x2, 0, s(x3), x4, x5) -> IF2(false, x1, x2, 0, s(x3), x4, x5)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(126) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule IF3(false, z1, 0, s(z2), z3, z4) -> REACH(0, s(z2), rest(z3), edge(from(z3), to(z3), z4)) at position [2] we obtained the following new rules [LPAR04]:

   (IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(from(edge(x0, x1, x2)), to(edge(x0, x1, x2)), y3)),IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(from(edge(x0, x1, x2)), to(edge(x0, x1, x2)), y3)))
   (IF3(false, y0, 0, s(y1), empty, y3) -> REACH(0, s(y1), empty, edge(from(empty), to(empty), y3)),IF3(false, y0, 0, s(y1), empty, y3) -> REACH(0, s(y1), empty, edge(from(empty), to(empty), y3)))


----------------------------------------

(127)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false, z1, z2, 0, s(z3), z4, z5) -> IF3(z1, z2, 0, s(z3), z4, z5)
   IF3(true, z1, 0, s(z2), z3, z4) -> IF4(z1, 0, s(z2), z3, z4)
   IF4(false, 0, s(z1), z2, z3) -> REACH(0, s(z1), rest(z2), z3)
   IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   IF1(false, false, x1, x2, 0, s(x3), x4, x5) -> IF2(false, x1, x2, 0, s(x3), x4, x5)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(from(edge(x0, x1, x2)), to(edge(x0, x1, x2)), y3))
   IF3(false, y0, 0, s(y1), empty, y3) -> REACH(0, s(y1), empty, edge(from(empty), to(empty), y3))

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(128) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(129)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(true, z1, 0, s(z2), z3, z4) -> IF4(z1, 0, s(z2), z3, z4)
   IF4(false, 0, s(z1), z2, z3) -> REACH(0, s(z1), rest(z2), z3)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF1(false, false, x1, x2, 0, s(x3), x4, x5) -> IF2(false, x1, x2, 0, s(x3), x4, x5)
   IF2(false, z1, z2, 0, s(z3), z4, z5) -> IF3(z1, z2, 0, s(z3), z4, z5)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(from(edge(x0, x1, x2)), to(edge(x0, x1, x2)), y3))
   IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(130) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(from(edge(x0, x1, x2)), to(edge(x0, x1, x2)), y3)) at position [3,0] we obtained the following new rules [LPAR04]:

   (IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, to(edge(x0, x1, x2)), y3)),IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, to(edge(x0, x1, x2)), y3)))


----------------------------------------

(131)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(true, z1, 0, s(z2), z3, z4) -> IF4(z1, 0, s(z2), z3, z4)
   IF4(false, 0, s(z1), z2, z3) -> REACH(0, s(z1), rest(z2), z3)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF1(false, false, x1, x2, 0, s(x3), x4, x5) -> IF2(false, x1, x2, 0, s(x3), x4, x5)
   IF2(false, z1, z2, 0, s(z3), z4, z5) -> IF3(z1, z2, 0, s(z3), z4, z5)
   IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, to(edge(x0, x1, x2)), y3))

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(132) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, to(edge(x0, x1, x2)), y3)) at position [3,1] we obtained the following new rules [LPAR04]:

   (IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3)),IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3)))


----------------------------------------

(133)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(true, z1, 0, s(z2), z3, z4) -> IF4(z1, 0, s(z2), z3, z4)
   IF4(false, 0, s(z1), z2, z3) -> REACH(0, s(z1), rest(z2), z3)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF1(false, false, x1, x2, 0, s(x3), x4, x5) -> IF2(false, x1, x2, 0, s(x3), x4, x5)
   IF2(false, z1, z2, 0, s(z3), z4, z5) -> IF3(z1, z2, 0, s(z3), z4, z5)
   IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(134) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule IF4(false, 0, s(z1), z2, z3) -> REACH(0, s(z1), rest(z2), z3) at position [2] we obtained the following new rules [LPAR04]:

   (IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2),IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2))
   (IF4(false, 0, s(y0), empty, y2) -> REACH(0, s(y0), empty, y2),IF4(false, 0, s(y0), empty, y2) -> REACH(0, s(y0), empty, y2))


----------------------------------------

(135)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(true, z1, 0, s(z2), z3, z4) -> IF4(z1, 0, s(z2), z3, z4)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF1(false, false, x1, x2, 0, s(x3), x4, x5) -> IF2(false, x1, x2, 0, s(x3), x4, x5)
   IF2(false, z1, z2, 0, s(z3), z4, z5) -> IF3(z1, z2, 0, s(z3), z4, z5)
   IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF4(false, 0, s(y0), empty, y2) -> REACH(0, s(y0), empty, y2)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(136) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(137)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF1(false, false, x1, x2, 0, s(x3), x4, x5) -> IF2(false, x1, x2, 0, s(x3), x4, x5)
   IF2(false, z1, z2, 0, s(z3), z4, z5) -> IF3(z1, z2, 0, s(z3), z4, z5)
   IF3(true, z1, 0, s(z2), z3, z4) -> IF4(z1, 0, s(z2), z3, z4)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(138) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF1(false, false, x1, x2, 0, s(x3), x4, x5) -> IF2(false, x1, x2, 0, s(x3), x4, x5) we obtained the following new rules [LPAR04]:

   (IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4),IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4))


----------------------------------------

(139)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF2(false, z1, z2, 0, s(z3), z4, z5) -> IF3(z1, z2, 0, s(z3), z4, z5)
   IF3(true, z1, 0, s(z2), z3, z4) -> IF4(z1, 0, s(z2), z3, z4)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(140) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF2(false, z1, z2, 0, s(z3), z4, z5) -> IF3(z1, z2, 0, s(z3), z4, z5) we obtained the following new rules [LPAR04]:

   (IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6),IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6))


----------------------------------------

(141)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF3(true, z1, 0, s(z2), z3, z4) -> IF4(z1, 0, s(z2), z3, z4)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(142) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF3(true, z1, 0, s(z2), z3, z4) -> IF4(z1, 0, s(z2), z3, z4) we obtained the following new rules [LPAR04]:

   (IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6),IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6))


----------------------------------------

(143)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(144) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule IF1(false, y_1, y_3, y_5, s(z0), s(z1), z2, z3) -> IF2(y_1, y_3, y_5, s(z0), s(z1), z2, z3) we obtained the following new rules [LPAR04]:

   (IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6),IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6))


----------------------------------------

(145)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty)
   REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(146) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule REACH(s(x0), s(x1), y2, y3) -> IF1(eq(x0, x1), isEmpty(y2), eq(s(x0), from(y2)), eq(s(x1), to(y2)), s(x0), s(x1), y2, y3) at position [1] we obtained the following new rules [LPAR04]:

   (REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), from(edge(x0, x1, x2))), eq(s(y1), to(edge(x0, x1, x2))), s(y0), s(y1), edge(x0, x1, x2), y3),REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), from(edge(x0, x1, x2))), eq(s(y1), to(edge(x0, x1, x2))), s(y0), s(y1), edge(x0, x1, x2), y3))


----------------------------------------

(147)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), from(edge(x0, x1, x2))), eq(s(y1), to(edge(x0, x1, x2))), s(y0), s(y1), edge(x0, x1, x2), y3)

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   from(edge(x, y, i)) -> x
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   isEmpty(edge(x, y, i)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(148) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(149)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), from(edge(x0, x1, x2))), eq(s(y1), to(edge(x0, x1, x2))), s(y0), s(y1), edge(x0, x1, x2), y3)

The TRS R consists of the following rules:

   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   from(edge(x, y, i)) -> x
   to(edge(x, y, i)) -> y
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(150) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   isEmpty(empty)
   isEmpty(edge(x0, x1, x2))


----------------------------------------

(151)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), from(edge(x0, x1, x2))), eq(s(y1), to(edge(x0, x1, x2))), s(y0), s(y1), edge(x0, x1, x2), y3)

The TRS R consists of the following rules:

   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   from(edge(x, y, i)) -> x
   to(edge(x, y, i)) -> y
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(152) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), from(edge(x0, x1, x2))), eq(s(y1), to(edge(x0, x1, x2))), s(y0), s(y1), edge(x0, x1, x2), y3) at position [2,1] we obtained the following new rules [LPAR04]:

   (REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), to(edge(x0, x1, x2))), s(y0), s(y1), edge(x0, x1, x2), y3),REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), to(edge(x0, x1, x2))), s(y0), s(y1), edge(x0, x1, x2), y3))


----------------------------------------

(153)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), to(edge(x0, x1, x2))), s(y0), s(y1), edge(x0, x1, x2), y3)

The TRS R consists of the following rules:

   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   from(edge(x, y, i)) -> x
   to(edge(x, y, i)) -> y
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(154) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), to(edge(x0, x1, x2))), s(y0), s(y1), edge(x0, x1, x2), y3) at position [3,1] we obtained the following new rules [LPAR04]:

   (REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3),REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3))


----------------------------------------

(155)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)

The TRS R consists of the following rules:

   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   from(edge(x, y, i)) -> x
   to(edge(x, y, i)) -> y
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(156) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule IF4(false, 0, s(z1), edge(x2, x3, x4), z3) -> REACH(x3, s(z1), union(x4, z3), empty) at position [2] we obtained the following new rules [LPAR04]:

   (IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty),IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty))
   (IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty),IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty))


----------------------------------------

(157)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5))
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)

The TRS R consists of the following rules:

   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   from(edge(x, y, i)) -> x
   to(edge(x, y, i)) -> y
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(158) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule IF3(false, z1, s(z2), s(z3), z4, z5) -> REACH(s(z2), s(z3), rest(z4), edge(from(z4), to(z4), z5)) at position [2] we obtained the following new rules [LPAR04]:

   (IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(from(edge(x0, x1, x2)), to(edge(x0, x1, x2)), y4)),IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(from(edge(x0, x1, x2)), to(edge(x0, x1, x2)), y4)))
   (IF3(false, y0, s(y1), s(y2), empty, y4) -> REACH(s(y1), s(y2), empty, edge(from(empty), to(empty), y4)),IF3(false, y0, s(y1), s(y2), empty, y4) -> REACH(s(y1), s(y2), empty, edge(from(empty), to(empty), y4)))


----------------------------------------

(159)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(from(edge(x0, x1, x2)), to(edge(x0, x1, x2)), y4))
   IF3(false, y0, s(y1), s(y2), empty, y4) -> REACH(s(y1), s(y2), empty, edge(from(empty), to(empty), y4))

The TRS R consists of the following rules:

   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   from(edge(x, y, i)) -> x
   to(edge(x, y, i)) -> y
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(160) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(161)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(from(edge(x0, x1, x2)), to(edge(x0, x1, x2)), y4))
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)

The TRS R consists of the following rules:

   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   from(edge(x, y, i)) -> x
   to(edge(x, y, i)) -> y
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(162) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(from(edge(x0, x1, x2)), to(edge(x0, x1, x2)), y4)) at position [3,0] we obtained the following new rules [LPAR04]:

   (IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, to(edge(x0, x1, x2)), y4)),IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, to(edge(x0, x1, x2)), y4)))


----------------------------------------

(163)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, to(edge(x0, x1, x2)), y4))

The TRS R consists of the following rules:

   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   from(edge(x, y, i)) -> x
   to(edge(x, y, i)) -> y
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(164) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(165)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, to(edge(x0, x1, x2)), y4))

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   from(edge(x0, x1, x2))
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(166) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   from(edge(x0, x1, x2))


----------------------------------------

(167)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, to(edge(x0, x1, x2)), y4))

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(168) TransformationProof (EQUIVALENT)
By rewriting [LPAR04] the rule IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, to(edge(x0, x1, x2)), y4)) at position [3,1] we obtained the following new rules [LPAR04]:

   (IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4)),IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4)))


----------------------------------------

(169)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4))

The TRS R consists of the following rules:

   to(edge(x, y, i)) -> y
   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(170) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(171)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4))

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   to(edge(x0, x1, x2))
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(172) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   to(edge(x0, x1, x2))


----------------------------------------

(173)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4))

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(174) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule IF4(false, s(z1), s(z2), z3, z4) -> REACH(s(z1), s(z2), rest(z3), z4) at position [2] we obtained the following new rules [LPAR04]:

   (IF4(false, s(y0), s(y1), edge(x0, x1, x2), y3) -> REACH(s(y0), s(y1), x2, y3),IF4(false, s(y0), s(y1), edge(x0, x1, x2), y3) -> REACH(s(y0), s(y1), x2, y3))
   (IF4(false, s(y0), s(y1), empty, y3) -> REACH(s(y0), s(y1), empty, y3),IF4(false, s(y0), s(y1), empty, y3) -> REACH(s(y0), s(y1), empty, y3))


----------------------------------------

(175)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4))
   IF4(false, s(y0), s(y1), edge(x0, x1, x2), y3) -> REACH(s(y0), s(y1), x2, y3)
   IF4(false, s(y0), s(y1), empty, y3) -> REACH(s(y0), s(y1), empty, y3)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(176) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(177)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(y0), s(y1), edge(x0, x1, x2), y3) -> REACH(s(y0), s(y1), x2, y3)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4))
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   rest(edge(x, y, i)) -> i
   rest(empty) -> empty

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(178) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(179)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(y0), s(y1), edge(x0, x1, x2), y3) -> REACH(s(y0), s(y1), x2, y3)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4))
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)
   rest(edge(x0, x1, x2))
   rest(empty)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(180) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   rest(edge(x0, x1, x2))
   rest(empty)


----------------------------------------

(181)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty)
   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(y0), s(y1), edge(x0, x1, x2), y3) -> REACH(s(y0), s(y1), x2, y3)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4))
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(182) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule IF4(false, s(z1), s(z2), edge(x2, x3, x4), z4) -> REACH(x3, s(z2), union(x4, z4), empty) at position [2] we obtained the following new rules [LPAR04]:

   (IF4(false, s(y0), s(y1), edge(y2, y3, empty), x0) -> REACH(y3, s(y1), x0, empty),IF4(false, s(y0), s(y1), edge(y2, y3, empty), x0) -> REACH(y3, s(y1), x0, empty))
   (IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty),IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty))


----------------------------------------

(183)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(y0), s(y1), edge(x0, x1, x2), y3) -> REACH(s(y0), s(y1), x2, y3)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4))
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, empty), x0) -> REACH(y3, s(y1), x0, empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(184) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF1(false, false, x1, x2, s(x3), s(x4), x5, x6) -> IF2(false, x1, x2, s(x3), s(x4), x5, x6) we obtained the following new rules [LPAR04]:

   (IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5),IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5))


----------------------------------------

(185)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6)
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(y0), s(y1), edge(x0, x1, x2), y3) -> REACH(s(y0), s(y1), x2, y3)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4))
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, empty), x0) -> REACH(y3, s(y1), x0, empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(186) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF2(false, z1, z2, s(z3), s(z4), z5, z6) -> IF3(z1, z2, s(z3), s(z4), z5, z6) we obtained the following new rules [LPAR04]:

   (IF2(false, z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF3(z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7),IF2(false, z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF3(z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7))


----------------------------------------

(187)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5)
   IF4(false, s(y0), s(y1), edge(x0, x1, x2), y3) -> REACH(s(y0), s(y1), x2, y3)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4))
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, empty), x0) -> REACH(y3, s(y1), x0, empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF3(z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(188) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF3(true, z1, s(z2), s(z3), z4, z5) -> IF4(z1, s(z2), s(z3), z4, z5) we obtained the following new rules [LPAR04]:

   (IF3(true, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF4(z1, s(z2), s(z3), edge(z4, z5, z6), z7),IF3(true, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF4(z1, s(z2), s(z3), edge(z4, z5, z6), z7))


----------------------------------------

(189)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF4(false, s(y0), s(y1), edge(x0, x1, x2), y3) -> REACH(s(y0), s(y1), x2, y3)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4))
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, empty), x0) -> REACH(y3, s(y1), x0, empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF3(z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF3(true, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF4(z1, s(z2), s(z3), edge(z4, z5, z6), z7)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(190) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule IF2(false, z0, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF3(z0, z1, 0, s(z2), edge(z3, z4, z5), z6) we obtained the following new rules [LPAR04]:

   (IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6),IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6))
   (IF2(false, true, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(true, x1, 0, s(x2), edge(x3, x4, x5), x6),IF2(false, true, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(true, x1, 0, s(x2), edge(x3, x4, x5), x6))


----------------------------------------

(191)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF4(false, s(y0), s(y1), edge(x0, x1, x2), y3) -> REACH(s(y0), s(y1), x2, y3)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4))
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, empty), x0) -> REACH(y3, s(y1), x0, empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF3(z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF3(true, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF4(z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF2(false, true, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(true, x1, 0, s(x2), edge(x3, x4, x5), x6)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(192) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule IF1(false, false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) -> IF2(false, y_0, y_1, 0, s(z0), edge(z1, z2, z3), z4) we obtained the following new rules [LPAR04]:

   (IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6),IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6))
   (IF1(false, false, true, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, true, x1, 0, s(x2), edge(x3, x4, x5), x6),IF1(false, false, true, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, true, x1, 0, s(x2), edge(x3, x4, x5), x6))


----------------------------------------

(193)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2)
   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF4(false, s(y0), s(y1), edge(x0, x1, x2), y3) -> REACH(s(y0), s(y1), x2, y3)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4))
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, empty), x0) -> REACH(y3, s(y1), x0, empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF3(z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF3(true, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF4(z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF2(false, true, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(true, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF1(false, false, true, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, true, x1, 0, s(x2), edge(x3, x4, x5), x6)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(194) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule REACH(0, s(y0), edge(x0, x1, x2), y2) -> IF1(false, false, eq(0, x0), eq(s(y0), x1), 0, s(y0), edge(x0, x1, x2), y2) at position [2] we obtained the following new rules [LPAR04]:

   (REACH(0, s(y0), edge(0, y2, y3), y4) -> IF1(false, false, true, eq(s(y0), y2), 0, s(y0), edge(0, y2, y3), y4),REACH(0, s(y0), edge(0, y2, y3), y4) -> IF1(false, false, true, eq(s(y0), y2), 0, s(y0), edge(0, y2, y3), y4))
   (REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4),REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4))


----------------------------------------

(195)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF4(false, s(y0), s(y1), edge(x0, x1, x2), y3) -> REACH(s(y0), s(y1), x2, y3)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4))
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, empty), x0) -> REACH(y3, s(y1), x0, empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF3(z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF3(true, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF4(z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF2(false, true, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(true, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF1(false, false, true, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, true, x1, 0, s(x2), edge(x3, x4, x5), x6)
   REACH(0, s(y0), edge(0, y2, y3), y4) -> IF1(false, false, true, eq(s(y0), y2), 0, s(y0), edge(0, y2, y3), y4)
   REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(196) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF1(false, false, true, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, true, x1, 0, s(x2), edge(x3, x4, x5), x6) we obtained the following new rules [LPAR04]:

   (IF1(false, false, true, y_0, 0, s(z0), edge(0, z1, z2), z3) -> IF2(false, true, y_0, 0, s(z0), edge(0, z1, z2), z3),IF1(false, false, true, y_0, 0, s(z0), edge(0, z1, z2), z3) -> IF2(false, true, y_0, 0, s(z0), edge(0, z1, z2), z3))


----------------------------------------

(197)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF4(false, s(y0), s(y1), edge(x0, x1, x2), y3) -> REACH(s(y0), s(y1), x2, y3)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4))
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, empty), x0) -> REACH(y3, s(y1), x0, empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF3(z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF3(true, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF4(z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF2(false, true, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(true, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   REACH(0, s(y0), edge(0, y2, y3), y4) -> IF1(false, false, true, eq(s(y0), y2), 0, s(y0), edge(0, y2, y3), y4)
   REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4)
   IF1(false, false, true, y_0, 0, s(z0), edge(0, z1, z2), z3) -> IF2(false, true, y_0, 0, s(z0), edge(0, z1, z2), z3)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(198) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF2(false, true, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(true, x1, 0, s(x2), edge(x3, x4, x5), x6) we obtained the following new rules [LPAR04]:

   (IF2(false, true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4),IF2(false, true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4))


----------------------------------------

(199)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6)
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF4(false, s(y0), s(y1), edge(x0, x1, x2), y3) -> REACH(s(y0), s(y1), x2, y3)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4))
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, empty), x0) -> REACH(y3, s(y1), x0, empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF3(z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF3(true, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF4(z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   REACH(0, s(y0), edge(0, y2, y3), y4) -> IF1(false, false, true, eq(s(y0), y2), 0, s(y0), edge(0, y2, y3), y4)
   REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4)
   IF1(false, false, true, y_0, 0, s(z0), edge(0, z1, z2), z3) -> IF2(false, true, y_0, 0, s(z0), edge(0, z1, z2), z3)
   IF2(false, true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(200) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF3(true, z1, 0, s(z2), edge(z3, z4, z5), z6) -> IF4(z1, 0, s(z2), edge(z3, z4, z5), z6) we obtained the following new rules [LPAR04]:

   (IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF4(z0, 0, s(z1), edge(0, z2, z3), z4),IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF4(z0, 0, s(z1), edge(0, z2, z3), z4))


----------------------------------------

(201)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2)
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF4(false, s(y0), s(y1), edge(x0, x1, x2), y3) -> REACH(s(y0), s(y1), x2, y3)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4))
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, empty), x0) -> REACH(y3, s(y1), x0, empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF3(z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF3(true, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF4(z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   REACH(0, s(y0), edge(0, y2, y3), y4) -> IF1(false, false, true, eq(s(y0), y2), 0, s(y0), edge(0, y2, y3), y4)
   REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4)
   IF1(false, false, true, y_0, 0, s(z0), edge(0, z1, z2), z3) -> IF2(false, true, y_0, 0, s(z0), edge(0, z1, z2), z3)
   IF2(false, true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4)
   IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF4(z0, 0, s(z1), edge(0, z2, z3), z4)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(202) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF4(false, 0, s(y0), edge(x0, x1, x2), y2) -> REACH(0, s(y0), x2, y2) we obtained the following new rules [LPAR04]:

   (IF4(false, 0, s(z1), edge(0, z2, z3), z4) -> REACH(0, s(z1), z3, z4),IF4(false, 0, s(z1), edge(0, z2, z3), z4) -> REACH(0, s(z1), z3, z4))


----------------------------------------

(203)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty)
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF4(false, s(y0), s(y1), edge(x0, x1, x2), y3) -> REACH(s(y0), s(y1), x2, y3)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4))
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, empty), x0) -> REACH(y3, s(y1), x0, empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF3(z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF3(true, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF4(z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   REACH(0, s(y0), edge(0, y2, y3), y4) -> IF1(false, false, true, eq(s(y0), y2), 0, s(y0), edge(0, y2, y3), y4)
   REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4)
   IF1(false, false, true, y_0, 0, s(z0), edge(0, z1, z2), z3) -> IF2(false, true, y_0, 0, s(z0), edge(0, z1, z2), z3)
   IF2(false, true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4)
   IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF4(z0, 0, s(z1), edge(0, z2, z3), z4)
   IF4(false, 0, s(z1), edge(0, z2, z3), z4) -> REACH(0, s(z1), z3, z4)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(204) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF4(false, 0, s(y0), edge(y1, y2, empty), x0) -> REACH(y2, s(y0), x0, empty) we obtained the following new rules [LPAR04]:

   (IF4(false, 0, s(z1), edge(0, z2, empty), z4) -> REACH(z2, s(z1), z4, empty),IF4(false, 0, s(z1), edge(0, z2, empty), z4) -> REACH(z2, s(z1), z4, empty))


----------------------------------------

(205)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF4(false, s(y0), s(y1), edge(x0, x1, x2), y3) -> REACH(s(y0), s(y1), x2, y3)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4))
   IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, empty), x0) -> REACH(y3, s(y1), x0, empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF3(z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF3(true, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF4(z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   REACH(0, s(y0), edge(0, y2, y3), y4) -> IF1(false, false, true, eq(s(y0), y2), 0, s(y0), edge(0, y2, y3), y4)
   REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4)
   IF1(false, false, true, y_0, 0, s(z0), edge(0, z1, z2), z3) -> IF2(false, true, y_0, 0, s(z0), edge(0, z1, z2), z3)
   IF2(false, true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4)
   IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF4(z0, 0, s(z1), edge(0, z2, z3), z4)
   IF4(false, 0, s(z1), edge(0, z2, z3), z4) -> REACH(0, s(z1), z3, z4)
   IF4(false, 0, s(z1), edge(0, z2, empty), z4) -> REACH(z2, s(z1), z4, empty)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(206) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule IF4(false, 0, s(y0), edge(y1, y2, edge(x0, x1, x2)), x3) -> REACH(y2, s(y0), edge(x0, x1, union(x2, x3)), empty) we obtained the following new rules [LPAR04]:

   (IF4(false, 0, s(z1), edge(0, z2, edge(x3, x4, x5)), z4) -> REACH(z2, s(z1), edge(x3, x4, union(x5, z4)), empty),IF4(false, 0, s(z1), edge(0, z2, edge(x3, x4, x5)), z4) -> REACH(z2, s(z1), edge(x3, x4, union(x5, z4)), empty))


----------------------------------------

(207)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3))
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF4(false, s(y0), s(y1), edge(x0, x1, x2), y3) -> REACH(s(y0), s(y1), x2, y3)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4))
   IF4(false, s(y0), s(y1), edge(y2, y3, empty), x0) -> REACH(y3, s(y1), x0, empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF3(z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF3(true, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF4(z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   REACH(0, s(y0), edge(0, y2, y3), y4) -> IF1(false, false, true, eq(s(y0), y2), 0, s(y0), edge(0, y2, y3), y4)
   REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4)
   IF1(false, false, true, y_0, 0, s(z0), edge(0, z1, z2), z3) -> IF2(false, true, y_0, 0, s(z0), edge(0, z1, z2), z3)
   IF2(false, true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4)
   IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF4(z0, 0, s(z1), edge(0, z2, z3), z4)
   IF4(false, 0, s(z1), edge(0, z2, z3), z4) -> REACH(0, s(z1), z3, z4)
   IF4(false, 0, s(z1), edge(0, z2, empty), z4) -> REACH(z2, s(z1), z4, empty)
   IF4(false, 0, s(z1), edge(0, z2, edge(x3, x4, x5)), z4) -> REACH(z2, s(z1), edge(x3, x4, union(x5, z4)), empty)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(208) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule IF3(false, y0, 0, s(y1), edge(x0, x1, x2), y3) -> REACH(0, s(y1), x2, edge(x0, x1, y3)) we obtained the following new rules [LPAR04]:

   (IF3(false, x0, 0, s(x1), edge(x2, x3, edge(0, y_1, y_2)), x5) -> REACH(0, s(x1), edge(0, y_1, y_2), edge(x2, x3, x5)),IF3(false, x0, 0, s(x1), edge(x2, x3, edge(0, y_1, y_2)), x5) -> REACH(0, s(x1), edge(0, y_1, y_2), edge(x2, x3, x5)))
   (IF3(false, x0, 0, s(x1), edge(x2, x3, edge(s(y_1), y_2, y_3)), x5) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), edge(x2, x3, x5)),IF3(false, x0, 0, s(x1), edge(x2, x3, edge(s(y_1), y_2, y_3)), x5) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), edge(x2, x3, x5)))


----------------------------------------

(209)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF4(false, s(y0), s(y1), edge(x0, x1, x2), y3) -> REACH(s(y0), s(y1), x2, y3)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4))
   IF4(false, s(y0), s(y1), edge(y2, y3, empty), x0) -> REACH(y3, s(y1), x0, empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF3(z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF3(true, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF4(z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   REACH(0, s(y0), edge(0, y2, y3), y4) -> IF1(false, false, true, eq(s(y0), y2), 0, s(y0), edge(0, y2, y3), y4)
   REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4)
   IF1(false, false, true, y_0, 0, s(z0), edge(0, z1, z2), z3) -> IF2(false, true, y_0, 0, s(z0), edge(0, z1, z2), z3)
   IF2(false, true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4)
   IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF4(z0, 0, s(z1), edge(0, z2, z3), z4)
   IF4(false, 0, s(z1), edge(0, z2, z3), z4) -> REACH(0, s(z1), z3, z4)
   IF4(false, 0, s(z1), edge(0, z2, empty), z4) -> REACH(z2, s(z1), z4, empty)
   IF4(false, 0, s(z1), edge(0, z2, edge(x3, x4, x5)), z4) -> REACH(z2, s(z1), edge(x3, x4, union(x5, z4)), empty)
   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(0, y_1, y_2)), x5) -> REACH(0, s(x1), edge(0, y_1, y_2), edge(x2, x3, x5))
   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(s(y_1), y_2, y_3)), x5) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), edge(x2, x3, x5))

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(210) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule IF4(false, s(y0), s(y1), edge(x0, x1, x2), y3) -> REACH(s(y0), s(y1), x2, y3) we obtained the following new rules [LPAR04]:

   (IF4(false, s(x0), s(x1), edge(x2, x3, edge(y_2, y_3, y_4)), x5) -> REACH(s(x0), s(x1), edge(y_2, y_3, y_4), x5),IF4(false, s(x0), s(x1), edge(x2, x3, edge(y_2, y_3, y_4)), x5) -> REACH(s(x0), s(x1), edge(y_2, y_3, y_4), x5))


----------------------------------------

(211)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4))
   IF4(false, s(y0), s(y1), edge(y2, y3, empty), x0) -> REACH(y3, s(y1), x0, empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF3(z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF3(true, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF4(z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   REACH(0, s(y0), edge(0, y2, y3), y4) -> IF1(false, false, true, eq(s(y0), y2), 0, s(y0), edge(0, y2, y3), y4)
   REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4)
   IF1(false, false, true, y_0, 0, s(z0), edge(0, z1, z2), z3) -> IF2(false, true, y_0, 0, s(z0), edge(0, z1, z2), z3)
   IF2(false, true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4)
   IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF4(z0, 0, s(z1), edge(0, z2, z3), z4)
   IF4(false, 0, s(z1), edge(0, z2, z3), z4) -> REACH(0, s(z1), z3, z4)
   IF4(false, 0, s(z1), edge(0, z2, empty), z4) -> REACH(z2, s(z1), z4, empty)
   IF4(false, 0, s(z1), edge(0, z2, edge(x3, x4, x5)), z4) -> REACH(z2, s(z1), edge(x3, x4, union(x5, z4)), empty)
   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(0, y_1, y_2)), x5) -> REACH(0, s(x1), edge(0, y_1, y_2), edge(x2, x3, x5))
   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(s(y_1), y_2, y_3)), x5) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), edge(x2, x3, x5))
   IF4(false, s(x0), s(x1), edge(x2, x3, edge(y_2, y_3, y_4)), x5) -> REACH(s(x0), s(x1), edge(y_2, y_3, y_4), x5)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(212) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule IF3(false, y0, s(y1), s(y2), edge(x0, x1, x2), y4) -> REACH(s(y1), s(y2), x2, edge(x0, x1, y4)) we obtained the following new rules [LPAR04]:

   (IF3(false, x0, s(x1), s(x2), edge(x3, x4, edge(y_2, y_3, y_4)), x6) -> REACH(s(x1), s(x2), edge(y_2, y_3, y_4), edge(x3, x4, x6)),IF3(false, x0, s(x1), s(x2), edge(x3, x4, edge(y_2, y_3, y_4)), x6) -> REACH(s(x1), s(x2), edge(y_2, y_3, y_4), edge(x3, x4, x6)))


----------------------------------------

(213)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF4(false, s(y0), s(y1), edge(y2, y3, empty), x0) -> REACH(y3, s(y1), x0, empty)
   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF3(z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF3(true, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF4(z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   REACH(0, s(y0), edge(0, y2, y3), y4) -> IF1(false, false, true, eq(s(y0), y2), 0, s(y0), edge(0, y2, y3), y4)
   REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4)
   IF1(false, false, true, y_0, 0, s(z0), edge(0, z1, z2), z3) -> IF2(false, true, y_0, 0, s(z0), edge(0, z1, z2), z3)
   IF2(false, true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4)
   IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF4(z0, 0, s(z1), edge(0, z2, z3), z4)
   IF4(false, 0, s(z1), edge(0, z2, z3), z4) -> REACH(0, s(z1), z3, z4)
   IF4(false, 0, s(z1), edge(0, z2, empty), z4) -> REACH(z2, s(z1), z4, empty)
   IF4(false, 0, s(z1), edge(0, z2, edge(x3, x4, x5)), z4) -> REACH(z2, s(z1), edge(x3, x4, union(x5, z4)), empty)
   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(0, y_1, y_2)), x5) -> REACH(0, s(x1), edge(0, y_1, y_2), edge(x2, x3, x5))
   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(s(y_1), y_2, y_3)), x5) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), edge(x2, x3, x5))
   IF4(false, s(x0), s(x1), edge(x2, x3, edge(y_2, y_3, y_4)), x5) -> REACH(s(x0), s(x1), edge(y_2, y_3, y_4), x5)
   IF3(false, x0, s(x1), s(x2), edge(x3, x4, edge(y_2, y_3, y_4)), x6) -> REACH(s(x1), s(x2), edge(y_2, y_3, y_4), edge(x3, x4, x6))

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(214) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule IF4(false, s(y0), s(y1), edge(y2, y3, empty), x0) -> REACH(y3, s(y1), x0, empty) we obtained the following new rules [LPAR04]:

   (IF4(false, s(x0), s(x1), edge(x2, s(y_0), empty), edge(y_2, y_3, y_4)) -> REACH(s(y_0), s(x1), edge(y_2, y_3, y_4), empty),IF4(false, s(x0), s(x1), edge(x2, s(y_0), empty), edge(y_2, y_3, y_4)) -> REACH(s(y_0), s(x1), edge(y_2, y_3, y_4), empty))
   (IF4(false, s(x0), s(x1), edge(x2, 0, empty), edge(0, y_1, y_2)) -> REACH(0, s(x1), edge(0, y_1, y_2), empty),IF4(false, s(x0), s(x1), edge(x2, 0, empty), edge(0, y_1, y_2)) -> REACH(0, s(x1), edge(0, y_1, y_2), empty))
   (IF4(false, s(x0), s(x1), edge(x2, 0, empty), edge(s(y_1), y_2, y_3)) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), empty),IF4(false, s(x0), s(x1), edge(x2, 0, empty), edge(s(y_1), y_2, y_3)) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), empty))


----------------------------------------

(215)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF3(z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF3(true, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF4(z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   REACH(0, s(y0), edge(0, y2, y3), y4) -> IF1(false, false, true, eq(s(y0), y2), 0, s(y0), edge(0, y2, y3), y4)
   REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4)
   IF1(false, false, true, y_0, 0, s(z0), edge(0, z1, z2), z3) -> IF2(false, true, y_0, 0, s(z0), edge(0, z1, z2), z3)
   IF2(false, true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4)
   IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF4(z0, 0, s(z1), edge(0, z2, z3), z4)
   IF4(false, 0, s(z1), edge(0, z2, z3), z4) -> REACH(0, s(z1), z3, z4)
   IF4(false, 0, s(z1), edge(0, z2, empty), z4) -> REACH(z2, s(z1), z4, empty)
   IF4(false, 0, s(z1), edge(0, z2, edge(x3, x4, x5)), z4) -> REACH(z2, s(z1), edge(x3, x4, union(x5, z4)), empty)
   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(0, y_1, y_2)), x5) -> REACH(0, s(x1), edge(0, y_1, y_2), edge(x2, x3, x5))
   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(s(y_1), y_2, y_3)), x5) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), edge(x2, x3, x5))
   IF4(false, s(x0), s(x1), edge(x2, x3, edge(y_2, y_3, y_4)), x5) -> REACH(s(x0), s(x1), edge(y_2, y_3, y_4), x5)
   IF3(false, x0, s(x1), s(x2), edge(x3, x4, edge(y_2, y_3, y_4)), x6) -> REACH(s(x1), s(x2), edge(y_2, y_3, y_4), edge(x3, x4, x6))
   IF4(false, s(x0), s(x1), edge(x2, s(y_0), empty), edge(y_2, y_3, y_4)) -> REACH(s(y_0), s(x1), edge(y_2, y_3, y_4), empty)
   IF4(false, s(x0), s(x1), edge(x2, 0, empty), edge(0, y_1, y_2)) -> REACH(0, s(x1), edge(0, y_1, y_2), empty)
   IF4(false, s(x0), s(x1), edge(x2, 0, empty), edge(s(y_1), y_2, y_3)) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), empty)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(216) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule IF2(false, z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF3(z0, z1, s(z2), s(z3), edge(z4, z5, z6), z7) we obtained the following new rules [LPAR04]:

   (IF2(false, true, x1, s(x2), s(x3), edge(x4, x5, x6), x7) -> IF3(true, x1, s(x2), s(x3), edge(x4, x5, x6), x7),IF2(false, true, x1, s(x2), s(x3), edge(x4, x5, x6), x7) -> IF3(true, x1, s(x2), s(x3), edge(x4, x5, x6), x7))
   (IF2(false, false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7) -> IF3(false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7),IF2(false, false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7) -> IF3(false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7))


----------------------------------------

(217)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF3(true, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF4(z1, s(z2), s(z3), edge(z4, z5, z6), z7)
   IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   REACH(0, s(y0), edge(0, y2, y3), y4) -> IF1(false, false, true, eq(s(y0), y2), 0, s(y0), edge(0, y2, y3), y4)
   REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4)
   IF1(false, false, true, y_0, 0, s(z0), edge(0, z1, z2), z3) -> IF2(false, true, y_0, 0, s(z0), edge(0, z1, z2), z3)
   IF2(false, true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4)
   IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF4(z0, 0, s(z1), edge(0, z2, z3), z4)
   IF4(false, 0, s(z1), edge(0, z2, z3), z4) -> REACH(0, s(z1), z3, z4)
   IF4(false, 0, s(z1), edge(0, z2, empty), z4) -> REACH(z2, s(z1), z4, empty)
   IF4(false, 0, s(z1), edge(0, z2, edge(x3, x4, x5)), z4) -> REACH(z2, s(z1), edge(x3, x4, union(x5, z4)), empty)
   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(0, y_1, y_2)), x5) -> REACH(0, s(x1), edge(0, y_1, y_2), edge(x2, x3, x5))
   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(s(y_1), y_2, y_3)), x5) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), edge(x2, x3, x5))
   IF4(false, s(x0), s(x1), edge(x2, x3, edge(y_2, y_3, y_4)), x5) -> REACH(s(x0), s(x1), edge(y_2, y_3, y_4), x5)
   IF3(false, x0, s(x1), s(x2), edge(x3, x4, edge(y_2, y_3, y_4)), x6) -> REACH(s(x1), s(x2), edge(y_2, y_3, y_4), edge(x3, x4, x6))
   IF4(false, s(x0), s(x1), edge(x2, s(y_0), empty), edge(y_2, y_3, y_4)) -> REACH(s(y_0), s(x1), edge(y_2, y_3, y_4), empty)
   IF4(false, s(x0), s(x1), edge(x2, 0, empty), edge(0, y_1, y_2)) -> REACH(0, s(x1), edge(0, y_1, y_2), empty)
   IF4(false, s(x0), s(x1), edge(x2, 0, empty), edge(s(y_1), y_2, y_3)) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), empty)
   IF2(false, true, x1, s(x2), s(x3), edge(x4, x5, x6), x7) -> IF3(true, x1, s(x2), s(x3), edge(x4, x5, x6), x7)
   IF2(false, false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7) -> IF3(false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(218) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule IF3(true, z1, s(z2), s(z3), edge(z4, z5, z6), z7) -> IF4(z1, s(z2), s(z3), edge(z4, z5, z6), z7) we obtained the following new rules [LPAR04]:

   (IF3(true, false, s(x1), s(x2), edge(x3, x4, edge(y_4, y_5, y_6)), x6) -> IF4(false, s(x1), s(x2), edge(x3, x4, edge(y_4, y_5, y_6)), x6),IF3(true, false, s(x1), s(x2), edge(x3, x4, edge(y_4, y_5, y_6)), x6) -> IF4(false, s(x1), s(x2), edge(x3, x4, edge(y_4, y_5, y_6)), x6))
   (IF3(true, false, s(x1), s(x2), edge(x3, s(y_3), empty), edge(y_4, y_5, y_6)) -> IF4(false, s(x1), s(x2), edge(x3, s(y_3), empty), edge(y_4, y_5, y_6)),IF3(true, false, s(x1), s(x2), edge(x3, s(y_3), empty), edge(y_4, y_5, y_6)) -> IF4(false, s(x1), s(x2), edge(x3, s(y_3), empty), edge(y_4, y_5, y_6)))
   (IF3(true, false, s(x1), s(x2), edge(x3, 0, empty), edge(0, y_3, y_4)) -> IF4(false, s(x1), s(x2), edge(x3, 0, empty), edge(0, y_3, y_4)),IF3(true, false, s(x1), s(x2), edge(x3, 0, empty), edge(0, y_3, y_4)) -> IF4(false, s(x1), s(x2), edge(x3, 0, empty), edge(0, y_3, y_4)))
   (IF3(true, false, s(x1), s(x2), edge(x3, 0, empty), edge(s(y_3), y_4, y_5)) -> IF4(false, s(x1), s(x2), edge(x3, 0, empty), edge(s(y_3), y_4, y_5)),IF3(true, false, s(x1), s(x2), edge(x3, 0, empty), edge(s(y_3), y_4, y_5)) -> IF4(false, s(x1), s(x2), edge(x3, 0, empty), edge(s(y_3), y_4, y_5)))


----------------------------------------

(219)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   REACH(0, s(y0), edge(0, y2, y3), y4) -> IF1(false, false, true, eq(s(y0), y2), 0, s(y0), edge(0, y2, y3), y4)
   REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4)
   IF1(false, false, true, y_0, 0, s(z0), edge(0, z1, z2), z3) -> IF2(false, true, y_0, 0, s(z0), edge(0, z1, z2), z3)
   IF2(false, true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4)
   IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF4(z0, 0, s(z1), edge(0, z2, z3), z4)
   IF4(false, 0, s(z1), edge(0, z2, z3), z4) -> REACH(0, s(z1), z3, z4)
   IF4(false, 0, s(z1), edge(0, z2, empty), z4) -> REACH(z2, s(z1), z4, empty)
   IF4(false, 0, s(z1), edge(0, z2, edge(x3, x4, x5)), z4) -> REACH(z2, s(z1), edge(x3, x4, union(x5, z4)), empty)
   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(0, y_1, y_2)), x5) -> REACH(0, s(x1), edge(0, y_1, y_2), edge(x2, x3, x5))
   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(s(y_1), y_2, y_3)), x5) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), edge(x2, x3, x5))
   IF4(false, s(x0), s(x1), edge(x2, x3, edge(y_2, y_3, y_4)), x5) -> REACH(s(x0), s(x1), edge(y_2, y_3, y_4), x5)
   IF3(false, x0, s(x1), s(x2), edge(x3, x4, edge(y_2, y_3, y_4)), x6) -> REACH(s(x1), s(x2), edge(y_2, y_3, y_4), edge(x3, x4, x6))
   IF4(false, s(x0), s(x1), edge(x2, s(y_0), empty), edge(y_2, y_3, y_4)) -> REACH(s(y_0), s(x1), edge(y_2, y_3, y_4), empty)
   IF4(false, s(x0), s(x1), edge(x2, 0, empty), edge(0, y_1, y_2)) -> REACH(0, s(x1), edge(0, y_1, y_2), empty)
   IF4(false, s(x0), s(x1), edge(x2, 0, empty), edge(s(y_1), y_2, y_3)) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), empty)
   IF2(false, true, x1, s(x2), s(x3), edge(x4, x5, x6), x7) -> IF3(true, x1, s(x2), s(x3), edge(x4, x5, x6), x7)
   IF2(false, false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7) -> IF3(false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7)
   IF3(true, false, s(x1), s(x2), edge(x3, x4, edge(y_4, y_5, y_6)), x6) -> IF4(false, s(x1), s(x2), edge(x3, x4, edge(y_4, y_5, y_6)), x6)
   IF3(true, false, s(x1), s(x2), edge(x3, s(y_3), empty), edge(y_4, y_5, y_6)) -> IF4(false, s(x1), s(x2), edge(x3, s(y_3), empty), edge(y_4, y_5, y_6))
   IF3(true, false, s(x1), s(x2), edge(x3, 0, empty), edge(0, y_3, y_4)) -> IF4(false, s(x1), s(x2), edge(x3, 0, empty), edge(0, y_3, y_4))
   IF3(true, false, s(x1), s(x2), edge(x3, 0, empty), edge(s(y_3), y_4, y_5)) -> IF4(false, s(x1), s(x2), edge(x3, 0, empty), edge(s(y_3), y_4, y_5))

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(220) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF4(z0, 0, s(z1), edge(0, z2, z3), z4) we obtained the following new rules [LPAR04]:

   (IF3(true, false, 0, s(x1), edge(0, x2, x3), x4) -> IF4(false, 0, s(x1), edge(0, x2, x3), x4),IF3(true, false, 0, s(x1), edge(0, x2, x3), x4) -> IF4(false, 0, s(x1), edge(0, x2, x3), x4))
   (IF3(true, false, 0, s(x1), edge(0, x2, empty), x4) -> IF4(false, 0, s(x1), edge(0, x2, empty), x4),IF3(true, false, 0, s(x1), edge(0, x2, empty), x4) -> IF4(false, 0, s(x1), edge(0, x2, empty), x4))
   (IF3(true, false, 0, s(x1), edge(0, x2, edge(y_2, y_3, y_4)), x4) -> IF4(false, 0, s(x1), edge(0, x2, edge(y_2, y_3, y_4)), x4),IF3(true, false, 0, s(x1), edge(0, x2, edge(y_2, y_3, y_4)), x4) -> IF4(false, 0, s(x1), edge(0, x2, edge(y_2, y_3, y_4)), x4))


----------------------------------------

(221)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   REACH(0, s(y0), edge(0, y2, y3), y4) -> IF1(false, false, true, eq(s(y0), y2), 0, s(y0), edge(0, y2, y3), y4)
   REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4)
   IF1(false, false, true, y_0, 0, s(z0), edge(0, z1, z2), z3) -> IF2(false, true, y_0, 0, s(z0), edge(0, z1, z2), z3)
   IF2(false, true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4)
   IF4(false, 0, s(z1), edge(0, z2, z3), z4) -> REACH(0, s(z1), z3, z4)
   IF4(false, 0, s(z1), edge(0, z2, empty), z4) -> REACH(z2, s(z1), z4, empty)
   IF4(false, 0, s(z1), edge(0, z2, edge(x3, x4, x5)), z4) -> REACH(z2, s(z1), edge(x3, x4, union(x5, z4)), empty)
   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(0, y_1, y_2)), x5) -> REACH(0, s(x1), edge(0, y_1, y_2), edge(x2, x3, x5))
   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(s(y_1), y_2, y_3)), x5) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), edge(x2, x3, x5))
   IF4(false, s(x0), s(x1), edge(x2, x3, edge(y_2, y_3, y_4)), x5) -> REACH(s(x0), s(x1), edge(y_2, y_3, y_4), x5)
   IF3(false, x0, s(x1), s(x2), edge(x3, x4, edge(y_2, y_3, y_4)), x6) -> REACH(s(x1), s(x2), edge(y_2, y_3, y_4), edge(x3, x4, x6))
   IF4(false, s(x0), s(x1), edge(x2, s(y_0), empty), edge(y_2, y_3, y_4)) -> REACH(s(y_0), s(x1), edge(y_2, y_3, y_4), empty)
   IF4(false, s(x0), s(x1), edge(x2, 0, empty), edge(0, y_1, y_2)) -> REACH(0, s(x1), edge(0, y_1, y_2), empty)
   IF4(false, s(x0), s(x1), edge(x2, 0, empty), edge(s(y_1), y_2, y_3)) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), empty)
   IF2(false, true, x1, s(x2), s(x3), edge(x4, x5, x6), x7) -> IF3(true, x1, s(x2), s(x3), edge(x4, x5, x6), x7)
   IF2(false, false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7) -> IF3(false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7)
   IF3(true, false, s(x1), s(x2), edge(x3, x4, edge(y_4, y_5, y_6)), x6) -> IF4(false, s(x1), s(x2), edge(x3, x4, edge(y_4, y_5, y_6)), x6)
   IF3(true, false, s(x1), s(x2), edge(x3, s(y_3), empty), edge(y_4, y_5, y_6)) -> IF4(false, s(x1), s(x2), edge(x3, s(y_3), empty), edge(y_4, y_5, y_6))
   IF3(true, false, s(x1), s(x2), edge(x3, 0, empty), edge(0, y_3, y_4)) -> IF4(false, s(x1), s(x2), edge(x3, 0, empty), edge(0, y_3, y_4))
   IF3(true, false, s(x1), s(x2), edge(x3, 0, empty), edge(s(y_3), y_4, y_5)) -> IF4(false, s(x1), s(x2), edge(x3, 0, empty), edge(s(y_3), y_4, y_5))
   IF3(true, false, 0, s(x1), edge(0, x2, x3), x4) -> IF4(false, 0, s(x1), edge(0, x2, x3), x4)
   IF3(true, false, 0, s(x1), edge(0, x2, empty), x4) -> IF4(false, 0, s(x1), edge(0, x2, empty), x4)
   IF3(true, false, 0, s(x1), edge(0, x2, edge(y_2, y_3, y_4)), x4) -> IF4(false, 0, s(x1), edge(0, x2, edge(y_2, y_3, y_4)), x4)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(222) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule IF4(false, 0, s(z1), edge(0, z2, z3), z4) -> REACH(0, s(z1), z3, z4) we obtained the following new rules [LPAR04]:

   (IF4(false, 0, s(x0), edge(0, x1, edge(0, y_1, y_2)), x3) -> REACH(0, s(x0), edge(0, y_1, y_2), x3),IF4(false, 0, s(x0), edge(0, x1, edge(0, y_1, y_2)), x3) -> REACH(0, s(x0), edge(0, y_1, y_2), x3))
   (IF4(false, 0, s(x0), edge(0, x1, edge(s(y_1), y_2, y_3)), x3) -> REACH(0, s(x0), edge(s(y_1), y_2, y_3), x3),IF4(false, 0, s(x0), edge(0, x1, edge(s(y_1), y_2, y_3)), x3) -> REACH(0, s(x0), edge(s(y_1), y_2, y_3), x3))


----------------------------------------

(223)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   REACH(0, s(y0), edge(0, y2, y3), y4) -> IF1(false, false, true, eq(s(y0), y2), 0, s(y0), edge(0, y2, y3), y4)
   REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4)
   IF1(false, false, true, y_0, 0, s(z0), edge(0, z1, z2), z3) -> IF2(false, true, y_0, 0, s(z0), edge(0, z1, z2), z3)
   IF2(false, true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4)
   IF4(false, 0, s(z1), edge(0, z2, empty), z4) -> REACH(z2, s(z1), z4, empty)
   IF4(false, 0, s(z1), edge(0, z2, edge(x3, x4, x5)), z4) -> REACH(z2, s(z1), edge(x3, x4, union(x5, z4)), empty)
   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(0, y_1, y_2)), x5) -> REACH(0, s(x1), edge(0, y_1, y_2), edge(x2, x3, x5))
   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(s(y_1), y_2, y_3)), x5) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), edge(x2, x3, x5))
   IF4(false, s(x0), s(x1), edge(x2, x3, edge(y_2, y_3, y_4)), x5) -> REACH(s(x0), s(x1), edge(y_2, y_3, y_4), x5)
   IF3(false, x0, s(x1), s(x2), edge(x3, x4, edge(y_2, y_3, y_4)), x6) -> REACH(s(x1), s(x2), edge(y_2, y_3, y_4), edge(x3, x4, x6))
   IF4(false, s(x0), s(x1), edge(x2, s(y_0), empty), edge(y_2, y_3, y_4)) -> REACH(s(y_0), s(x1), edge(y_2, y_3, y_4), empty)
   IF4(false, s(x0), s(x1), edge(x2, 0, empty), edge(0, y_1, y_2)) -> REACH(0, s(x1), edge(0, y_1, y_2), empty)
   IF4(false, s(x0), s(x1), edge(x2, 0, empty), edge(s(y_1), y_2, y_3)) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), empty)
   IF2(false, true, x1, s(x2), s(x3), edge(x4, x5, x6), x7) -> IF3(true, x1, s(x2), s(x3), edge(x4, x5, x6), x7)
   IF2(false, false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7) -> IF3(false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7)
   IF3(true, false, s(x1), s(x2), edge(x3, x4, edge(y_4, y_5, y_6)), x6) -> IF4(false, s(x1), s(x2), edge(x3, x4, edge(y_4, y_5, y_6)), x6)
   IF3(true, false, s(x1), s(x2), edge(x3, s(y_3), empty), edge(y_4, y_5, y_6)) -> IF4(false, s(x1), s(x2), edge(x3, s(y_3), empty), edge(y_4, y_5, y_6))
   IF3(true, false, s(x1), s(x2), edge(x3, 0, empty), edge(0, y_3, y_4)) -> IF4(false, s(x1), s(x2), edge(x3, 0, empty), edge(0, y_3, y_4))
   IF3(true, false, s(x1), s(x2), edge(x3, 0, empty), edge(s(y_3), y_4, y_5)) -> IF4(false, s(x1), s(x2), edge(x3, 0, empty), edge(s(y_3), y_4, y_5))
   IF3(true, false, 0, s(x1), edge(0, x2, x3), x4) -> IF4(false, 0, s(x1), edge(0, x2, x3), x4)
   IF3(true, false, 0, s(x1), edge(0, x2, empty), x4) -> IF4(false, 0, s(x1), edge(0, x2, empty), x4)
   IF3(true, false, 0, s(x1), edge(0, x2, edge(y_2, y_3, y_4)), x4) -> IF4(false, 0, s(x1), edge(0, x2, edge(y_2, y_3, y_4)), x4)
   IF4(false, 0, s(x0), edge(0, x1, edge(0, y_1, y_2)), x3) -> REACH(0, s(x0), edge(0, y_1, y_2), x3)
   IF4(false, 0, s(x0), edge(0, x1, edge(s(y_1), y_2, y_3)), x3) -> REACH(0, s(x0), edge(s(y_1), y_2, y_3), x3)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(224) TransformationProof (EQUIVALENT)
By forward instantiating [JAR06] the rule IF4(false, 0, s(z1), edge(0, z2, empty), z4) -> REACH(z2, s(z1), z4, empty) we obtained the following new rules [LPAR04]:

   (IF4(false, 0, s(x0), edge(0, s(y_0), empty), edge(y_2, y_3, y_4)) -> REACH(s(y_0), s(x0), edge(y_2, y_3, y_4), empty),IF4(false, 0, s(x0), edge(0, s(y_0), empty), edge(y_2, y_3, y_4)) -> REACH(s(y_0), s(x0), edge(y_2, y_3, y_4), empty))
   (IF4(false, 0, s(x0), edge(0, 0, empty), edge(0, y_1, y_2)) -> REACH(0, s(x0), edge(0, y_1, y_2), empty),IF4(false, 0, s(x0), edge(0, 0, empty), edge(0, y_1, y_2)) -> REACH(0, s(x0), edge(0, y_1, y_2), empty))
   (IF4(false, 0, s(x0), edge(0, 0, empty), edge(s(y_1), y_2, y_3)) -> REACH(0, s(x0), edge(s(y_1), y_2, y_3), empty),IF4(false, 0, s(x0), edge(0, 0, empty), edge(s(y_1), y_2, y_3)) -> REACH(0, s(x0), edge(s(y_1), y_2, y_3), empty))


----------------------------------------

(225)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)
   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   REACH(0, s(y0), edge(0, y2, y3), y4) -> IF1(false, false, true, eq(s(y0), y2), 0, s(y0), edge(0, y2, y3), y4)
   REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4)
   IF1(false, false, true, y_0, 0, s(z0), edge(0, z1, z2), z3) -> IF2(false, true, y_0, 0, s(z0), edge(0, z1, z2), z3)
   IF2(false, true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4)
   IF4(false, 0, s(z1), edge(0, z2, edge(x3, x4, x5)), z4) -> REACH(z2, s(z1), edge(x3, x4, union(x5, z4)), empty)
   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(0, y_1, y_2)), x5) -> REACH(0, s(x1), edge(0, y_1, y_2), edge(x2, x3, x5))
   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(s(y_1), y_2, y_3)), x5) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), edge(x2, x3, x5))
   IF4(false, s(x0), s(x1), edge(x2, x3, edge(y_2, y_3, y_4)), x5) -> REACH(s(x0), s(x1), edge(y_2, y_3, y_4), x5)
   IF3(false, x0, s(x1), s(x2), edge(x3, x4, edge(y_2, y_3, y_4)), x6) -> REACH(s(x1), s(x2), edge(y_2, y_3, y_4), edge(x3, x4, x6))
   IF4(false, s(x0), s(x1), edge(x2, s(y_0), empty), edge(y_2, y_3, y_4)) -> REACH(s(y_0), s(x1), edge(y_2, y_3, y_4), empty)
   IF4(false, s(x0), s(x1), edge(x2, 0, empty), edge(0, y_1, y_2)) -> REACH(0, s(x1), edge(0, y_1, y_2), empty)
   IF4(false, s(x0), s(x1), edge(x2, 0, empty), edge(s(y_1), y_2, y_3)) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), empty)
   IF2(false, true, x1, s(x2), s(x3), edge(x4, x5, x6), x7) -> IF3(true, x1, s(x2), s(x3), edge(x4, x5, x6), x7)
   IF2(false, false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7) -> IF3(false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7)
   IF3(true, false, s(x1), s(x2), edge(x3, x4, edge(y_4, y_5, y_6)), x6) -> IF4(false, s(x1), s(x2), edge(x3, x4, edge(y_4, y_5, y_6)), x6)
   IF3(true, false, s(x1), s(x2), edge(x3, s(y_3), empty), edge(y_4, y_5, y_6)) -> IF4(false, s(x1), s(x2), edge(x3, s(y_3), empty), edge(y_4, y_5, y_6))
   IF3(true, false, s(x1), s(x2), edge(x3, 0, empty), edge(0, y_3, y_4)) -> IF4(false, s(x1), s(x2), edge(x3, 0, empty), edge(0, y_3, y_4))
   IF3(true, false, s(x1), s(x2), edge(x3, 0, empty), edge(s(y_3), y_4, y_5)) -> IF4(false, s(x1), s(x2), edge(x3, 0, empty), edge(s(y_3), y_4, y_5))
   IF3(true, false, 0, s(x1), edge(0, x2, x3), x4) -> IF4(false, 0, s(x1), edge(0, x2, x3), x4)
   IF3(true, false, 0, s(x1), edge(0, x2, empty), x4) -> IF4(false, 0, s(x1), edge(0, x2, empty), x4)
   IF3(true, false, 0, s(x1), edge(0, x2, edge(y_2, y_3, y_4)), x4) -> IF4(false, 0, s(x1), edge(0, x2, edge(y_2, y_3, y_4)), x4)
   IF4(false, 0, s(x0), edge(0, x1, edge(0, y_1, y_2)), x3) -> REACH(0, s(x0), edge(0, y_1, y_2), x3)
   IF4(false, 0, s(x0), edge(0, x1, edge(s(y_1), y_2, y_3)), x3) -> REACH(0, s(x0), edge(s(y_1), y_2, y_3), x3)
   IF4(false, 0, s(x0), edge(0, s(y_0), empty), edge(y_2, y_3, y_4)) -> REACH(s(y_0), s(x0), edge(y_2, y_3, y_4), empty)
   IF4(false, 0, s(x0), edge(0, 0, empty), edge(0, y_1, y_2)) -> REACH(0, s(x0), edge(0, y_1, y_2), empty)
   IF4(false, 0, s(x0), edge(0, 0, empty), edge(s(y_1), y_2, y_3)) -> REACH(0, s(x0), edge(s(y_1), y_2, y_3), empty)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(226) QDPQMonotonicMRRProof (EQUIVALENT)
By using the Q-monotonic rule removal processor with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented such that it always occurs at a strongly monotonic position in a (P,Q,R)-chain.

Strictly oriented dependency pairs:

   IF4(false, s(y0), s(y1), edge(y2, y3, edge(x0, x1, x2)), x3) -> REACH(y3, s(y1), edge(x0, x1, union(x2, x3)), empty)
   IF4(false, s(x0), s(x1), edge(x2, x3, edge(y_2, y_3, y_4)), x5) -> REACH(s(x0), s(x1), edge(y_2, y_3, y_4), x5)
   IF4(false, s(x0), s(x1), edge(x2, s(y_0), empty), edge(y_2, y_3, y_4)) -> REACH(s(y_0), s(x1), edge(y_2, y_3, y_4), empty)
   IF4(false, s(x0), s(x1), edge(x2, 0, empty), edge(0, y_1, y_2)) -> REACH(0, s(x1), edge(0, y_1, y_2), empty)
   IF4(false, s(x0), s(x1), edge(x2, 0, empty), edge(s(y_1), y_2, y_3)) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), empty)
   IF3(true, false, s(x1), s(x2), edge(x3, x4, edge(y_4, y_5, y_6)), x6) -> IF4(false, s(x1), s(x2), edge(x3, x4, edge(y_4, y_5, y_6)), x6)
   IF3(true, false, s(x1), s(x2), edge(x3, s(y_3), empty), edge(y_4, y_5, y_6)) -> IF4(false, s(x1), s(x2), edge(x3, s(y_3), empty), edge(y_4, y_5, y_6))
   IF3(true, false, s(x1), s(x2), edge(x3, 0, empty), edge(0, y_3, y_4)) -> IF4(false, s(x1), s(x2), edge(x3, 0, empty), edge(0, y_3, y_4))
   IF3(true, false, s(x1), s(x2), edge(x3, 0, empty), edge(s(y_3), y_4, y_5)) -> IF4(false, s(x1), s(x2), edge(x3, 0, empty), edge(s(y_3), y_4, y_5))
   IF3(true, false, 0, s(x1), edge(0, x2, x3), x4) -> IF4(false, 0, s(x1), edge(0, x2, x3), x4)
   IF3(true, false, 0, s(x1), edge(0, x2, empty), x4) -> IF4(false, 0, s(x1), edge(0, x2, empty), x4)
   IF3(true, false, 0, s(x1), edge(0, x2, edge(y_2, y_3, y_4)), x4) -> IF4(false, 0, s(x1), edge(0, x2, edge(y_2, y_3, y_4)), x4)


Used ordering: Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(IF1(x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8)) = 2 + 2*x_2 + x_7 + x_8
   POL(IF2(x_1, x_2, x_3, x_4, x_5, x_6, x_7)) = 2 + 2*x_1 + x_6 + x_7
   POL(IF3(x_1, x_2, x_3, x_4, x_5, x_6)) = 2 + x_5 + x_6
   POL(IF4(x_1, x_2, x_3, x_4, x_5)) = 2*x_1 + x_2 + x_4 + x_5
   POL(REACH(x_1, x_2, x_3, x_4)) = 1 + x_2 + x_3 + x_4
   POL(edge(x_1, x_2, x_3)) = 2 + x_3
   POL(empty) = 0
   POL(eq(x_1, x_2)) = 0
   POL(false) = 0
   POL(s(x_1)) = 1
   POL(true) = 0
   POL(union(x_1, x_2)) = x_1 + x_2


----------------------------------------

(227)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   REACH(0, s(y0), edge(0, y2, y3), y4) -> IF1(false, false, true, eq(s(y0), y2), 0, s(y0), edge(0, y2, y3), y4)
   REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4)
   IF1(false, false, true, y_0, 0, s(z0), edge(0, z1, z2), z3) -> IF2(false, true, y_0, 0, s(z0), edge(0, z1, z2), z3)
   IF2(false, true, z0, 0, s(z1), edge(0, z2, z3), z4) -> IF3(true, z0, 0, s(z1), edge(0, z2, z3), z4)
   IF4(false, 0, s(z1), edge(0, z2, edge(x3, x4, x5)), z4) -> REACH(z2, s(z1), edge(x3, x4, union(x5, z4)), empty)
   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(0, y_1, y_2)), x5) -> REACH(0, s(x1), edge(0, y_1, y_2), edge(x2, x3, x5))
   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(s(y_1), y_2, y_3)), x5) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), edge(x2, x3, x5))
   IF3(false, x0, s(x1), s(x2), edge(x3, x4, edge(y_2, y_3, y_4)), x6) -> REACH(s(x1), s(x2), edge(y_2, y_3, y_4), edge(x3, x4, x6))
   IF2(false, true, x1, s(x2), s(x3), edge(x4, x5, x6), x7) -> IF3(true, x1, s(x2), s(x3), edge(x4, x5, x6), x7)
   IF2(false, false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7) -> IF3(false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7)
   IF4(false, 0, s(x0), edge(0, x1, edge(0, y_1, y_2)), x3) -> REACH(0, s(x0), edge(0, y_1, y_2), x3)
   IF4(false, 0, s(x0), edge(0, x1, edge(s(y_1), y_2, y_3)), x3) -> REACH(0, s(x0), edge(s(y_1), y_2, y_3), x3)
   IF4(false, 0, s(x0), edge(0, s(y_0), empty), edge(y_2, y_3, y_4)) -> REACH(s(y_0), s(x0), edge(y_2, y_3, y_4), empty)
   IF4(false, 0, s(x0), edge(0, 0, empty), edge(0, y_1, y_2)) -> REACH(0, s(x0), edge(0, y_1, y_2), empty)
   IF4(false, 0, s(x0), edge(0, 0, empty), edge(s(y_1), y_2, y_3)) -> REACH(0, s(x0), edge(s(y_1), y_2, y_3), empty)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(228) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 11 less nodes.
----------------------------------------

(229)
Complex Obligation (AND)

----------------------------------------

(230)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(s(y_1), y_2, y_3)), x5) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), edge(x2, x3, x5))
   REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4)
   IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(231) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(232)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(s(y_1), y_2, y_3)), x5) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), edge(x2, x3, x5))
   REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4)
   IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)

The TRS R consists of the following rules:

   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(233) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   union(empty, x0)
   union(edge(x0, x1, x2), x3)


----------------------------------------

(234)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF3(false, x0, 0, s(x1), edge(x2, x3, edge(s(y_1), y_2, y_3)), x5) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), edge(x2, x3, x5))
   REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4)
   IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6)
   IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)

The TRS R consists of the following rules:

   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   eq(0, 0) -> true
   eq(0, s(x)) -> false

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(235) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*REACH(0, s(y0), edge(s(x0), y2, y3), y4) -> IF1(false, false, false, eq(s(y0), y2), 0, s(y0), edge(s(x0), y2, y3), y4)
The graph contains the following edges 1 >= 5, 2 >= 6, 3 >= 7, 4 >= 8


*IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF3(false, x1, 0, s(x2), edge(x3, x4, x5), x6)
The graph contains the following edges 1 >= 1, 2 >= 1, 3 >= 2, 4 >= 3, 5 >= 4, 6 >= 5, 7 >= 6


*IF1(false, false, false, x1, 0, s(x2), edge(x3, x4, x5), x6) -> IF2(false, false, x1, 0, s(x2), edge(x3, x4, x5), x6)
The graph contains the following edges 1 >= 1, 2 >= 1, 3 >= 1, 1 >= 2, 2 >= 2, 3 >= 2, 4 >= 3, 5 >= 4, 6 >= 5, 7 >= 6, 8 >= 7


*IF3(false, x0, 0, s(x1), edge(x2, x3, edge(s(y_1), y_2, y_3)), x5) -> REACH(0, s(x1), edge(s(y_1), y_2, y_3), edge(x2, x3, x5))
The graph contains the following edges 3 >= 1, 4 >= 2, 5 > 3


----------------------------------------

(236)
YES

----------------------------------------

(237)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7) -> IF3(false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7)
   IF3(false, x0, s(x1), s(x2), edge(x3, x4, edge(y_2, y_3, y_4)), x6) -> REACH(s(x1), s(x2), edge(y_2, y_3, y_4), edge(x3, x4, x6))
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)

The TRS R consists of the following rules:

   union(empty, h) -> h
   union(edge(x, y, i), h) -> edge(x, y, union(i, h))
   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(238) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(239)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7) -> IF3(false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7)
   IF3(false, x0, s(x1), s(x2), edge(x3, x4, edge(y_2, y_3, y_4)), x6) -> REACH(s(x1), s(x2), edge(y_2, y_3, y_4), edge(x3, x4, x6))
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)

The TRS R consists of the following rules:

   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   union(empty, x0)
   union(edge(x0, x1, x2), x3)

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(240) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   union(empty, x0)
   union(edge(x0, x1, x2), x3)


----------------------------------------

(241)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
   IF2(false, false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7) -> IF3(false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7)
   IF3(false, x0, s(x1), s(x2), edge(x3, x4, edge(y_2, y_3, y_4)), x6) -> REACH(s(x1), s(x2), edge(y_2, y_3, y_4), edge(x3, x4, x6))
   REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)

The TRS R consists of the following rules:

   eq(0, 0) -> true
   eq(0, s(x)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(242) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*IF2(false, false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7) -> IF3(false, x1, s(x2), s(x3), edge(x4, x5, edge(y_5, y_6, y_7)), x7)
The graph contains the following edges 1 >= 1, 2 >= 1, 3 >= 2, 4 >= 3, 5 >= 4, 6 >= 5, 7 >= 6


*REACH(s(y0), s(y1), edge(x0, x1, x2), y3) -> IF1(eq(y0, y1), false, eq(s(y0), x0), eq(s(y1), x1), s(y0), s(y1), edge(x0, x1, x2), y3)
The graph contains the following edges 1 >= 5, 2 >= 6, 3 >= 7, 4 >= 8


*IF3(false, x0, s(x1), s(x2), edge(x3, x4, edge(y_2, y_3, y_4)), x6) -> REACH(s(x1), s(x2), edge(y_2, y_3, y_4), edge(x3, x4, x6))
The graph contains the following edges 3 >= 1, 4 >= 2, 5 > 3


*IF1(false, false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5) -> IF2(false, y_1, y_2, s(z0), s(z1), edge(z2, z3, z4), z5)
The graph contains the following edges 1 >= 1, 2 >= 1, 3 >= 2, 4 >= 3, 5 >= 4, 6 >= 5, 7 >= 6, 8 >= 7


----------------------------------------

(243)
YES
