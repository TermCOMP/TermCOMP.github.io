YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/MJhUt.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) QTRSRRRProof [EQUIVALENT, 76 ms]
(2) QTRS
(3) QTRSRRRProof [EQUIVALENT, 0 ms]
(4) QTRS
(5) RisEmptyProof [EQUIVALENT, 0 ms]
(6) YES


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   U11(tt, N) -> activate(N)
   U21(tt, M, N) -> s(plus(activate(N), activate(M)))
   U31(tt) -> 0
   U41(tt, M, N) -> plus(x(activate(N), activate(M)), activate(N))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__plus(V1, V2)) -> and(isNat(activate(V1)), n__isNat(activate(V2)))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNat(n__x(V1, V2)) -> and(isNat(activate(V1)), n__isNat(activate(V2)))
   plus(N, 0) -> U11(isNat(N), N)
   plus(N, s(M)) -> U21(and(isNat(M), n__isNat(N)), M, N)
   x(N, 0) -> U31(isNat(N))
   x(N, s(M)) -> U41(and(isNat(M), n__isNat(N)), M, N)
   0 -> n__0
   plus(X1, X2) -> n__plus(X1, X2)
   isNat(X) -> n__isNat(X)
   s(X) -> n__s(X)
   x(X1, X2) -> n__x(X1, X2)
   activate(n__0) -> 0
   activate(n__plus(X1, X2)) -> plus(activate(X1), activate(X2))
   activate(n__isNat(X)) -> isNat(X)
   activate(n__s(X)) -> s(activate(X))
   activate(n__x(X1, X2)) -> x(activate(X1), activate(X2))
   activate(X) -> X

Q is empty.

----------------------------------------

(1) QTRSRRRProof (EQUIVALENT)
Used ordering:
U11/2(YES,YES)
tt/0)
activate/1)YES(
U21/3(YES,YES,YES)
s/1(YES)
plus/2(YES,YES)
U31/1(YES)
0/0)
U41/3(YES,YES,YES)
x/2(YES,YES)
and/2(YES,YES)
isNat/1(YES)
n__0/0)
n__plus/2(YES,YES)
n__isNat/1(YES)
n__s/1(YES)
n__x/2(YES,YES)

Quasi precedence:
[U41_3, x_2, n__x_2] > [U21_3, plus_2, n__plus_2] > [U11_2, tt, s_1, and_2, isNat_1, n__isNat_1, n__s_1]
[U41_3, x_2, n__x_2] > [U31_1, 0, n__0] > [U11_2, tt, s_1, and_2, isNat_1, n__isNat_1, n__s_1]


Status:
U11_2: multiset status
tt: multiset status
U21_3: [2,3,1]
s_1: multiset status
plus_2: [2,1]
U31_1: multiset status
0: multiset status
U41_3: [2,3,1]
x_2: [2,1]
and_2: multiset status
isNat_1: multiset status
n__0: multiset status
n__plus_2: [2,1]
n__isNat_1: multiset status
n__s_1: multiset status
n__x_2: [2,1]

With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   U11(tt, N) -> activate(N)
   U21(tt, M, N) -> s(plus(activate(N), activate(M)))
   U31(tt) -> 0
   U41(tt, M, N) -> plus(x(activate(N), activate(M)), activate(N))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__plus(V1, V2)) -> and(isNat(activate(V1)), n__isNat(activate(V2)))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNat(n__x(V1, V2)) -> and(isNat(activate(V1)), n__isNat(activate(V2)))
   plus(N, 0) -> U11(isNat(N), N)
   plus(N, s(M)) -> U21(and(isNat(M), n__isNat(N)), M, N)
   x(N, 0) -> U31(isNat(N))
   x(N, s(M)) -> U41(and(isNat(M), n__isNat(N)), M, N)




----------------------------------------

(2)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   0 -> n__0
   plus(X1, X2) -> n__plus(X1, X2)
   isNat(X) -> n__isNat(X)
   s(X) -> n__s(X)
   x(X1, X2) -> n__x(X1, X2)
   activate(n__0) -> 0
   activate(n__plus(X1, X2)) -> plus(activate(X1), activate(X2))
   activate(n__isNat(X)) -> isNat(X)
   activate(n__s(X)) -> s(activate(X))
   activate(n__x(X1, X2)) -> x(activate(X1), activate(X2))
   activate(X) -> X

Q is empty.

----------------------------------------

(3) QTRSRRRProof (EQUIVALENT)
Used ordering:
Knuth-Bendix order [KBO] with precedence:activate_1 > isNat_1 > x_2 > n__x_2 > s_1 > n__s_1 > n__isNat_1 > plus_2 > 0 > n__plus_2 > n__0

and weight map:

   0=1
   n__0=1
   isNat_1=1
   n__isNat_1=1
   s_1=1
   n__s_1=1
   activate_1=0
   plus_2=0
   n__plus_2=0
   x_2=0
   n__x_2=0

The variable weight is 1With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   0 -> n__0
   plus(X1, X2) -> n__plus(X1, X2)
   isNat(X) -> n__isNat(X)
   s(X) -> n__s(X)
   x(X1, X2) -> n__x(X1, X2)
   activate(n__0) -> 0
   activate(n__plus(X1, X2)) -> plus(activate(X1), activate(X2))
   activate(n__isNat(X)) -> isNat(X)
   activate(n__s(X)) -> s(activate(X))
   activate(n__x(X1, X2)) -> x(activate(X1), activate(X2))
   activate(X) -> X




----------------------------------------

(4)
Obligation:
Q restricted rewrite system:
R is empty.
Q is empty.

----------------------------------------

(5) RisEmptyProof (EQUIVALENT)
The TRS R is empty. Hence, termination is trivially proven.
----------------------------------------

(6)
YES
