NO
proof of /hpcwork/ff862203/termcomp25/benchmarks/bSgTZ.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be disproven:

(0) QTRS
(1) DependencyPairsProof [EQUIVALENT, 0 ms]
(2) QDP
(3) DependencyGraphProof [EQUIVALENT, 0 ms]
(4) QDP
(5) QDPOrderProof [EQUIVALENT, 113 ms]
(6) QDP
(7) DependencyGraphProof [EQUIVALENT, 0 ms]
(8) QDP
(9) QDPOrderProof [EQUIVALENT, 33 ms]
(10) QDP
(11) QDPOrderProof [EQUIVALENT, 28 ms]
(12) QDP
(13) DependencyGraphProof [EQUIVALENT, 0 ms]
(14) AND
    (15) QDP
        (16) TransformationProof [EQUIVALENT, 0 ms]
        (17) QDP
        (18) TransformationProof [EQUIVALENT, 0 ms]
        (19) QDP
        (20) DependencyGraphProof [EQUIVALENT, 0 ms]
        (21) QDP
        (22) TransformationProof [EQUIVALENT, 0 ms]
        (23) QDP
        (24) DependencyGraphProof [EQUIVALENT, 0 ms]
        (25) QDP
        (26) TransformationProof [EQUIVALENT, 0 ms]
        (27) QDP
        (28) TransformationProof [EQUIVALENT, 0 ms]
        (29) QDP
        (30) DependencyGraphProof [EQUIVALENT, 0 ms]
        (31) QDP
        (32) TransformationProof [EQUIVALENT, 0 ms]
        (33) QDP
        (34) DependencyGraphProof [EQUIVALENT, 0 ms]
        (35) QDP
        (36) TransformationProof [EQUIVALENT, 0 ms]
        (37) QDP
        (38) DependencyGraphProof [EQUIVALENT, 0 ms]
        (39) QDP
        (40) TransformationProof [EQUIVALENT, 0 ms]
        (41) QDP
        (42) DependencyGraphProof [EQUIVALENT, 0 ms]
        (43) QDP
        (44) QDPOrderProof [EQUIVALENT, 43 ms]
        (45) QDP
        (46) QDPOrderProof [EQUIVALENT, 12 ms]
        (47) QDP
        (48) QDPOrderProof [EQUIVALENT, 22 ms]
        (49) QDP
        (50) QDPOrderProof [EQUIVALENT, 32 ms]
        (51) QDP
    (52) QDP
        (53) QDPOrderProof [EQUIVALENT, 20 ms]
        (54) QDP
        (55) DependencyGraphProof [EQUIVALENT, 0 ms]
        (56) AND
            (57) QDP
                (58) QDPOrderProof [EQUIVALENT, 33 ms]
                (59) QDP
                (60) TransformationProof [EQUIVALENT, 0 ms]
                (61) QDP
                (62) DependencyGraphProof [EQUIVALENT, 0 ms]
                (63) AND
                    (64) QDP
                        (65) TransformationProof [EQUIVALENT, 0 ms]
                        (66) QDP
                        (67) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (68) QDP
                        (69) QDPOrderProof [EQUIVALENT, 76 ms]
                        (70) QDP
                        (71) QDPOrderProof [EQUIVALENT, 14 ms]
                        (72) QDP
                        (73) QDPOrderProof [EQUIVALENT, 124 ms]
                        (74) QDP
                        (75) QDPOrderProof [EQUIVALENT, 35 ms]
                        (76) QDP
                        (77) QDPOrderProof [EQUIVALENT, 12 ms]
                        (78) QDP
                        (79) QDPOrderProof [EQUIVALENT, 12 ms]
                        (80) QDP
                    (81) QDP
                        (82) TransformationProof [EQUIVALENT, 0 ms]
                        (83) QDP
                        (84) DependencyGraphProof [EQUIVALENT, 0 ms]
                        (85) QDP
                        (86) QDPOrderProof [EQUIVALENT, 88 ms]
                        (87) QDP
                        (88) QDPOrderProof [EQUIVALENT, 13 ms]
                        (89) QDP
                        (90) QDPOrderProof [EQUIVALENT, 21 ms]
                        (91) QDP
                        (92) NonTerminationLoopProof [COMPLETE, 1453 ms]
                        (93) NO
            (94) QDP
                (95) TransformationProof [EQUIVALENT, 0 ms]
                (96) QDP
                (97) TransformationProof [EQUIVALENT, 0 ms]
                (98) QDP
                (99) DependencyGraphProof [EQUIVALENT, 0 ms]
                (100) QDP
                (101) TransformationProof [EQUIVALENT, 0 ms]
                (102) QDP
                (103) DependencyGraphProof [EQUIVALENT, 0 ms]
                (104) QDP
                (105) TransformationProof [EQUIVALENT, 0 ms]
                (106) QDP
                (107) DependencyGraphProof [EQUIVALENT, 0 ms]
                (108) QDP
                (109) TransformationProof [EQUIVALENT, 0 ms]
                (110) QDP
                (111) DependencyGraphProof [EQUIVALENT, 0 ms]
                (112) QDP
                (113) QDPOrderProof [EQUIVALENT, 63 ms]
                (114) QDP
                (115) QDPOrderProof [EQUIVALENT, 62 ms]
                (116) QDP
                (117) QDPOrderProof [EQUIVALENT, 20 ms]
                (118) QDP


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.

----------------------------------------

(1) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(2)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ZEROS -> CONS(0, n__zeros)
   ZEROS -> 0^1
   U11^1(tt, L) -> S(length(activate(L)))
   U11^1(tt, L) -> LENGTH(activate(L))
   U11^1(tt, L) -> ACTIVATE(L)
   U21^1(tt) -> NIL
   U31^1(tt, IL, M, N) -> CONS(activate(N), n__take(activate(M), activate(IL)))
   U31^1(tt, IL, M, N) -> ACTIVATE(N)
   U31^1(tt, IL, M, N) -> ACTIVATE(M)
   U31^1(tt, IL, M, N) -> ACTIVATE(IL)
   AND(tt, X) -> ACTIVATE(X)
   ISNAT(n__length(V1)) -> ISNATLIST(activate(V1))
   ISNAT(n__length(V1)) -> ACTIVATE(V1)
   ISNAT(n__s(V1)) -> ISNAT(activate(V1))
   ISNAT(n__s(V1)) -> ACTIVATE(V1)
   ISNATILIST(V) -> ISNATLIST(activate(V))
   ISNATILIST(V) -> ACTIVATE(V)
   ISNATILIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatIList(activate(V2)))
   ISNATILIST(n__cons(V1, V2)) -> ISNAT(activate(V1))
   ISNATILIST(n__cons(V1, V2)) -> ACTIVATE(V1)
   ISNATILIST(n__cons(V1, V2)) -> ACTIVATE(V2)
   ISNATLIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatList(activate(V2)))
   ISNATLIST(n__cons(V1, V2)) -> ISNAT(activate(V1))
   ISNATLIST(n__cons(V1, V2)) -> ACTIVATE(V1)
   ISNATLIST(n__cons(V1, V2)) -> ACTIVATE(V2)
   ISNATLIST(n__take(V1, V2)) -> AND(isNat(activate(V1)), n__isNatIList(activate(V2)))
   ISNATLIST(n__take(V1, V2)) -> ISNAT(activate(V1))
   ISNATLIST(n__take(V1, V2)) -> ACTIVATE(V1)
   ISNATLIST(n__take(V1, V2)) -> ACTIVATE(V2)
   LENGTH(nil) -> 0^1
   LENGTH(cons(N, L)) -> U11^1(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   LENGTH(cons(N, L)) -> AND(isNatList(activate(L)), n__isNat(N))
   LENGTH(cons(N, L)) -> ISNATLIST(activate(L))
   LENGTH(cons(N, L)) -> ACTIVATE(L)
   TAKE(0, IL) -> U21^1(isNatIList(IL))
   TAKE(0, IL) -> ISNATILIST(IL)
   TAKE(s(M), cons(N, IL)) -> U31^1(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   TAKE(s(M), cons(N, IL)) -> AND(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N)))
   TAKE(s(M), cons(N, IL)) -> ISNATILIST(activate(IL))
   TAKE(s(M), cons(N, IL)) -> ACTIVATE(IL)
   TAKE(s(M), cons(N, IL)) -> ISNAT(M)
   ACTIVATE(n__zeros) -> ZEROS
   ACTIVATE(n__take(X1, X2)) -> TAKE(X1, X2)
   ACTIVATE(n__0) -> 0^1
   ACTIVATE(n__length(X)) -> LENGTH(X)
   ACTIVATE(n__s(X)) -> S(X)
   ACTIVATE(n__cons(X1, X2)) -> CONS(X1, X2)
   ACTIVATE(n__isNatIList(X)) -> ISNATILIST(X)
   ACTIVATE(n__nil) -> NIL
   ACTIVATE(n__isNatList(X)) -> ISNATLIST(X)
   ACTIVATE(n__isNat(X)) -> ISNAT(X)
   ACTIVATE(n__and(X1, X2)) -> AND(X1, X2)

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(3) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 12 less nodes.
----------------------------------------

(4)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVATE(n__take(X1, X2)) -> TAKE(X1, X2)
   TAKE(0, IL) -> ISNATILIST(IL)
   ISNATILIST(V) -> ISNATLIST(activate(V))
   ISNATLIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatList(activate(V2)))
   AND(tt, X) -> ACTIVATE(X)
   ACTIVATE(n__length(X)) -> LENGTH(X)
   LENGTH(cons(N, L)) -> U11^1(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11^1(tt, L) -> LENGTH(activate(L))
   LENGTH(cons(N, L)) -> AND(isNatList(activate(L)), n__isNat(N))
   LENGTH(cons(N, L)) -> ISNATLIST(activate(L))
   ISNATLIST(n__cons(V1, V2)) -> ISNAT(activate(V1))
   ISNAT(n__length(V1)) -> ISNATLIST(activate(V1))
   ISNATLIST(n__cons(V1, V2)) -> ACTIVATE(V1)
   ACTIVATE(n__isNatIList(X)) -> ISNATILIST(X)
   ISNATILIST(V) -> ACTIVATE(V)
   ACTIVATE(n__isNatList(X)) -> ISNATLIST(X)
   ISNATLIST(n__cons(V1, V2)) -> ACTIVATE(V2)
   ACTIVATE(n__isNat(X)) -> ISNAT(X)
   ISNAT(n__length(V1)) -> ACTIVATE(V1)
   ACTIVATE(n__and(X1, X2)) -> AND(X1, X2)
   ISNAT(n__s(V1)) -> ISNAT(activate(V1))
   ISNAT(n__s(V1)) -> ACTIVATE(V1)
   ISNATLIST(n__take(V1, V2)) -> AND(isNat(activate(V1)), n__isNatIList(activate(V2)))
   ISNATLIST(n__take(V1, V2)) -> ISNAT(activate(V1))
   ISNATLIST(n__take(V1, V2)) -> ACTIVATE(V1)
   ISNATLIST(n__take(V1, V2)) -> ACTIVATE(V2)
   ISNATILIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatIList(activate(V2)))
   ISNATILIST(n__cons(V1, V2)) -> ISNAT(activate(V1))
   ISNATILIST(n__cons(V1, V2)) -> ACTIVATE(V1)
   ISNATILIST(n__cons(V1, V2)) -> ACTIVATE(V2)
   LENGTH(cons(N, L)) -> ACTIVATE(L)
   U11^1(tt, L) -> ACTIVATE(L)
   TAKE(s(M), cons(N, IL)) -> U31^1(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   U31^1(tt, IL, M, N) -> ACTIVATE(N)
   U31^1(tt, IL, M, N) -> ACTIVATE(M)
   U31^1(tt, IL, M, N) -> ACTIVATE(IL)
   TAKE(s(M), cons(N, IL)) -> AND(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N)))
   TAKE(s(M), cons(N, IL)) -> ISNATILIST(activate(IL))
   TAKE(s(M), cons(N, IL)) -> ACTIVATE(IL)
   TAKE(s(M), cons(N, IL)) -> ISNAT(M)

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(5) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   LENGTH(cons(N, L)) -> AND(isNatList(activate(L)), n__isNat(N))
   ISNATLIST(n__cons(V1, V2)) -> ISNAT(activate(V1))
   ISNAT(n__length(V1)) -> ISNATLIST(activate(V1))
   ISNATLIST(n__cons(V1, V2)) -> ACTIVATE(V1)
   ISNATILIST(V) -> ACTIVATE(V)
   ISNATLIST(n__cons(V1, V2)) -> ACTIVATE(V2)
   ISNAT(n__length(V1)) -> ACTIVATE(V1)
   ISNATLIST(n__take(V1, V2)) -> AND(isNat(activate(V1)), n__isNatIList(activate(V2)))
   ISNATLIST(n__take(V1, V2)) -> ISNAT(activate(V1))
   ISNATLIST(n__take(V1, V2)) -> ACTIVATE(V1)
   ISNATLIST(n__take(V1, V2)) -> ACTIVATE(V2)
   ISNATILIST(n__cons(V1, V2)) -> ISNAT(activate(V1))
   ISNATILIST(n__cons(V1, V2)) -> ACTIVATE(V1)
   ISNATILIST(n__cons(V1, V2)) -> ACTIVATE(V2)
   LENGTH(cons(N, L)) -> ACTIVATE(L)
   U11^1(tt, L) -> ACTIVATE(L)
   TAKE(s(M), cons(N, IL)) -> U31^1(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   TAKE(s(M), cons(N, IL)) -> AND(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N)))
   TAKE(s(M), cons(N, IL)) -> ACTIVATE(IL)
   TAKE(s(M), cons(N, IL)) -> ISNAT(M)
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( AND_2(x_1, x_2) ) = x_2
POL( ISNAT_1(x_1) ) = 2x_1
POL( ISNATILIST_1(x_1) ) = x_1 + 2
POL( ISNATLIST_1(x_1) ) = x_1 + 2
POL( LENGTH_1(x_1) ) = 2x_1 + 2
POL( U11^1_2(x_1, x_2) ) = 2x_2 + 2
POL( U31^1_4(x_1, ..., x_4) ) = 2x_2 + x_3 + x_4
POL( n__and_2(x_1, x_2) ) = x_2
POL( n__isNatIList_1(x_1) ) = x_1 + 2
POL( n__isNatList_1(x_1) ) = x_1 + 2
POL( activate_1(x_1) ) = x_1
POL( n__zeros ) = 2
POL( zeros ) = 2
POL( n__take_2(x_1, x_2) ) = 2x_1 + 2x_2 + 2
POL( take_2(x_1, x_2) ) = 2x_1 + 2x_2 + 2
POL( n__0 ) = 0
POL( 0 ) = 0
POL( n__length_1(x_1) ) = 2x_1 + 2
POL( length_1(x_1) ) = 2x_1 + 2
POL( n__s_1(x_1) ) = x_1
POL( s_1(x_1) ) = x_1
POL( n__cons_2(x_1, x_2) ) = 2x_1 + x_2
POL( cons_2(x_1, x_2) ) = 2x_1 + x_2
POL( isNatIList_1(x_1) ) = x_1 + 2
POL( isNatList_1(x_1) ) = x_1 + 2
POL( and_2(x_1, x_2) ) = x_2
POL( isNat_1(x_1) ) = 2x_1
POL( tt ) = 0
POL( n__isNat_1(x_1) ) = 2x_1
POL( n__nil ) = 0
POL( nil ) = 0
POL( U21_1(x_1) ) = 2
POL( U11_2(x_1, x_2) ) = x_1 + 2x_2 + 2
POL( U31_4(x_1, ..., x_4) ) = 2x_2 + 2x_3 + 2x_4 + 2
POL( ACTIVATE_1(x_1) ) = x_1
POL( TAKE_2(x_1, x_2) ) = 2x_1 + 2x_2 + 2

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   isNatIList(V) -> isNatList(activate(V))
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   and(tt, X) -> activate(X)
   activate(n__isNatList(X)) -> isNatList(X)
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__isNat(X)) -> isNat(X)
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   activate(n__and(X1, X2)) -> and(X1, X2)
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__nil) -> nil
   activate(X) -> X
   isNat(n__0) -> tt
   isNat(X) -> n__isNat(X)
   isNatList(n__nil) -> tt
   isNatList(X) -> n__isNatList(X)
   and(X1, X2) -> n__and(X1, X2)
   isNatIList(n__zeros) -> tt
   isNatIList(X) -> n__isNatIList(X)
   take(X1, X2) -> n__take(X1, X2)
   take(0, IL) -> U21(isNatIList(IL))
   U21(tt) -> nil
   length(nil) -> 0
   length(X) -> n__length(X)
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11(tt, L) -> s(length(activate(L)))
   s(X) -> n__s(X)
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   cons(X1, X2) -> n__cons(X1, X2)
   zeros -> cons(0, n__zeros)
   zeros -> n__zeros
   0 -> n__0
   nil -> n__nil


----------------------------------------

(6)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVATE(n__take(X1, X2)) -> TAKE(X1, X2)
   TAKE(0, IL) -> ISNATILIST(IL)
   ISNATILIST(V) -> ISNATLIST(activate(V))
   ISNATLIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatList(activate(V2)))
   AND(tt, X) -> ACTIVATE(X)
   ACTIVATE(n__length(X)) -> LENGTH(X)
   LENGTH(cons(N, L)) -> U11^1(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11^1(tt, L) -> LENGTH(activate(L))
   LENGTH(cons(N, L)) -> ISNATLIST(activate(L))
   ACTIVATE(n__isNatIList(X)) -> ISNATILIST(X)
   ACTIVATE(n__isNatList(X)) -> ISNATLIST(X)
   ACTIVATE(n__isNat(X)) -> ISNAT(X)
   ACTIVATE(n__and(X1, X2)) -> AND(X1, X2)
   ISNAT(n__s(V1)) -> ISNAT(activate(V1))
   ISNAT(n__s(V1)) -> ACTIVATE(V1)
   ISNATILIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatIList(activate(V2)))
   U31^1(tt, IL, M, N) -> ACTIVATE(N)
   U31^1(tt, IL, M, N) -> ACTIVATE(M)
   U31^1(tt, IL, M, N) -> ACTIVATE(IL)
   TAKE(s(M), cons(N, IL)) -> ISNATILIST(activate(IL))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(7) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 3 less nodes.
----------------------------------------

(8)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TAKE(0, IL) -> ISNATILIST(IL)
   ISNATILIST(V) -> ISNATLIST(activate(V))
   ISNATLIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatList(activate(V2)))
   AND(tt, X) -> ACTIVATE(X)
   ACTIVATE(n__take(X1, X2)) -> TAKE(X1, X2)
   TAKE(s(M), cons(N, IL)) -> ISNATILIST(activate(IL))
   ISNATILIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatIList(activate(V2)))
   ACTIVATE(n__length(X)) -> LENGTH(X)
   LENGTH(cons(N, L)) -> U11^1(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11^1(tt, L) -> LENGTH(activate(L))
   LENGTH(cons(N, L)) -> ISNATLIST(activate(L))
   ACTIVATE(n__isNatIList(X)) -> ISNATILIST(X)
   ACTIVATE(n__isNatList(X)) -> ISNATLIST(X)
   ACTIVATE(n__isNat(X)) -> ISNAT(X)
   ISNAT(n__s(V1)) -> ISNAT(activate(V1))
   ISNAT(n__s(V1)) -> ACTIVATE(V1)
   ACTIVATE(n__and(X1, X2)) -> AND(X1, X2)

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(9) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   TAKE(0, IL) -> ISNATILIST(IL)
   ACTIVATE(n__take(X1, X2)) -> TAKE(X1, X2)
   TAKE(s(M), cons(N, IL)) -> ISNATILIST(activate(IL))
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( AND_2(x_1, x_2) ) = 2x_2
POL( ISNAT_1(x_1) ) = x_1
POL( ISNATILIST_1(x_1) ) = 0
POL( ISNATLIST_1(x_1) ) = 0
POL( LENGTH_1(x_1) ) = 0
POL( U11^1_2(x_1, x_2) ) = max{0, -2}
POL( n__isNatIList_1(x_1) ) = max{0, -2}
POL( n__isNatList_1(x_1) ) = max{0, -2}
POL( activate_1(x_1) ) = 2x_1
POL( n__zeros ) = 0
POL( zeros ) = 0
POL( n__take_2(x_1, x_2) ) = 1
POL( take_2(x_1, x_2) ) = 2
POL( n__0 ) = 0
POL( 0 ) = 0
POL( n__length_1(x_1) ) = 0
POL( length_1(x_1) ) = max{0, -2}
POL( n__s_1(x_1) ) = 2x_1
POL( s_1(x_1) ) = 2x_1
POL( n__cons_2(x_1, x_2) ) = 0
POL( cons_2(x_1, x_2) ) = 0
POL( isNatIList_1(x_1) ) = max{0, -2}
POL( isNatList_1(x_1) ) = max{0, -2}
POL( and_2(x_1, x_2) ) = 2x_2
POL( isNat_1(x_1) ) = x_1
POL( tt ) = 0
POL( n__isNat_1(x_1) ) = x_1
POL( n__and_2(x_1, x_2) ) = 2x_2
POL( n__nil ) = 0
POL( nil ) = 0
POL( U21_1(x_1) ) = max{0, -2}
POL( U11_2(x_1, x_2) ) = max{0, -2}
POL( U31_4(x_1, ..., x_4) ) = max{0, -2}
POL( TAKE_2(x_1, x_2) ) = 1
POL( ACTIVATE_1(x_1) ) = 2x_1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   isNatIList(V) -> isNatList(activate(V))
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   and(tt, X) -> activate(X)
   activate(n__isNatList(X)) -> isNatList(X)
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__isNat(X)) -> isNat(X)
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   activate(n__and(X1, X2)) -> and(X1, X2)
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__nil) -> nil
   activate(X) -> X
   isNat(n__0) -> tt
   isNat(X) -> n__isNat(X)
   isNatList(n__nil) -> tt
   isNatList(X) -> n__isNatList(X)
   and(X1, X2) -> n__and(X1, X2)
   take(X1, X2) -> n__take(X1, X2)
   take(0, IL) -> U21(isNatIList(IL))
   isNatIList(n__zeros) -> tt
   isNatIList(X) -> n__isNatIList(X)
   U21(tt) -> nil
   length(nil) -> 0
   length(X) -> n__length(X)
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11(tt, L) -> s(length(activate(L)))
   s(X) -> n__s(X)
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   cons(X1, X2) -> n__cons(X1, X2)
   zeros -> cons(0, n__zeros)
   zeros -> n__zeros
   0 -> n__0
   nil -> n__nil


----------------------------------------

(10)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNATILIST(V) -> ISNATLIST(activate(V))
   ISNATLIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatList(activate(V2)))
   AND(tt, X) -> ACTIVATE(X)
   ISNATILIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatIList(activate(V2)))
   ACTIVATE(n__length(X)) -> LENGTH(X)
   LENGTH(cons(N, L)) -> U11^1(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11^1(tt, L) -> LENGTH(activate(L))
   LENGTH(cons(N, L)) -> ISNATLIST(activate(L))
   ACTIVATE(n__isNatIList(X)) -> ISNATILIST(X)
   ACTIVATE(n__isNatList(X)) -> ISNATLIST(X)
   ACTIVATE(n__isNat(X)) -> ISNAT(X)
   ISNAT(n__s(V1)) -> ISNAT(activate(V1))
   ISNAT(n__s(V1)) -> ACTIVATE(V1)
   ACTIVATE(n__and(X1, X2)) -> AND(X1, X2)

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(11) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ISNAT(n__s(V1)) -> ACTIVATE(V1)
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( AND_2(x_1, x_2) ) = 2x_2
POL( ISNAT_1(x_1) ) = 2x_1 + 2
POL( ISNATLIST_1(x_1) ) = max{0, -2}
POL( LENGTH_1(x_1) ) = max{0, -2}
POL( U11^1_2(x_1, x_2) ) = max{0, -2}
POL( n__isNatIList_1(x_1) ) = max{0, -2}
POL( n__isNatList_1(x_1) ) = max{0, -2}
POL( activate_1(x_1) ) = 2x_1
POL( n__zeros ) = 0
POL( zeros ) = 0
POL( n__take_2(x_1, x_2) ) = max{0, -2}
POL( take_2(x_1, x_2) ) = 0
POL( n__0 ) = 0
POL( 0 ) = 0
POL( n__length_1(x_1) ) = 0
POL( length_1(x_1) ) = max{0, -2}
POL( n__s_1(x_1) ) = 2x_1
POL( s_1(x_1) ) = 2x_1
POL( n__cons_2(x_1, x_2) ) = 0
POL( cons_2(x_1, x_2) ) = 0
POL( isNatIList_1(x_1) ) = 0
POL( isNatList_1(x_1) ) = max{0, -2}
POL( and_2(x_1, x_2) ) = 2x_2
POL( isNat_1(x_1) ) = x_1 + 1
POL( tt ) = 0
POL( n__isNat_1(x_1) ) = x_1 + 1
POL( n__and_2(x_1, x_2) ) = 2x_2
POL( n__nil ) = 0
POL( nil ) = 0
POL( U21_1(x_1) ) = max{0, -2}
POL( U11_2(x_1, x_2) ) = max{0, -2}
POL( U31_4(x_1, ..., x_4) ) = max{0, -2}
POL( ISNATILIST_1(x_1) ) = 0
POL( ACTIVATE_1(x_1) ) = 2x_1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   isNatIList(V) -> isNatList(activate(V))
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   and(tt, X) -> activate(X)
   activate(n__isNatList(X)) -> isNatList(X)
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__isNat(X)) -> isNat(X)
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   activate(n__and(X1, X2)) -> and(X1, X2)
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__nil) -> nil
   activate(X) -> X
   isNat(n__0) -> tt
   isNat(X) -> n__isNat(X)
   isNatList(n__nil) -> tt
   isNatList(X) -> n__isNatList(X)
   and(X1, X2) -> n__and(X1, X2)
   take(X1, X2) -> n__take(X1, X2)
   take(0, IL) -> U21(isNatIList(IL))
   isNatIList(n__zeros) -> tt
   isNatIList(X) -> n__isNatIList(X)
   U21(tt) -> nil
   length(nil) -> 0
   length(X) -> n__length(X)
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11(tt, L) -> s(length(activate(L)))
   s(X) -> n__s(X)
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   cons(X1, X2) -> n__cons(X1, X2)
   zeros -> cons(0, n__zeros)
   zeros -> n__zeros
   0 -> n__0
   nil -> n__nil


----------------------------------------

(12)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNATILIST(V) -> ISNATLIST(activate(V))
   ISNATLIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatList(activate(V2)))
   AND(tt, X) -> ACTIVATE(X)
   ISNATILIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatIList(activate(V2)))
   ACTIVATE(n__length(X)) -> LENGTH(X)
   LENGTH(cons(N, L)) -> U11^1(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11^1(tt, L) -> LENGTH(activate(L))
   LENGTH(cons(N, L)) -> ISNATLIST(activate(L))
   ACTIVATE(n__isNatIList(X)) -> ISNATILIST(X)
   ACTIVATE(n__isNatList(X)) -> ISNATLIST(X)
   ACTIVATE(n__isNat(X)) -> ISNAT(X)
   ISNAT(n__s(V1)) -> ISNAT(activate(V1))
   ACTIVATE(n__and(X1, X2)) -> AND(X1, X2)

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(13) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 1 less node.
----------------------------------------

(14)
Complex Obligation (AND)

----------------------------------------

(15)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNAT(n__s(V1)) -> ISNAT(activate(V1))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(16) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule ISNAT(n__s(V1)) -> ISNAT(activate(V1)) at position [0] we obtained the following new rules [LPAR04]:

   (ISNAT(n__s(n__zeros)) -> ISNAT(zeros),ISNAT(n__s(n__zeros)) -> ISNAT(zeros))
   (ISNAT(n__s(n__take(x0, x1))) -> ISNAT(take(x0, x1)),ISNAT(n__s(n__take(x0, x1))) -> ISNAT(take(x0, x1)))
   (ISNAT(n__s(n__0)) -> ISNAT(0),ISNAT(n__s(n__0)) -> ISNAT(0))
   (ISNAT(n__s(n__length(x0))) -> ISNAT(length(x0)),ISNAT(n__s(n__length(x0))) -> ISNAT(length(x0)))
   (ISNAT(n__s(n__s(x0))) -> ISNAT(s(x0)),ISNAT(n__s(n__s(x0))) -> ISNAT(s(x0)))
   (ISNAT(n__s(n__cons(x0, x1))) -> ISNAT(cons(x0, x1)),ISNAT(n__s(n__cons(x0, x1))) -> ISNAT(cons(x0, x1)))
   (ISNAT(n__s(n__isNatIList(x0))) -> ISNAT(isNatIList(x0)),ISNAT(n__s(n__isNatIList(x0))) -> ISNAT(isNatIList(x0)))
   (ISNAT(n__s(n__nil)) -> ISNAT(nil),ISNAT(n__s(n__nil)) -> ISNAT(nil))
   (ISNAT(n__s(n__isNatList(x0))) -> ISNAT(isNatList(x0)),ISNAT(n__s(n__isNatList(x0))) -> ISNAT(isNatList(x0)))
   (ISNAT(n__s(n__isNat(x0))) -> ISNAT(isNat(x0)),ISNAT(n__s(n__isNat(x0))) -> ISNAT(isNat(x0)))
   (ISNAT(n__s(n__and(x0, x1))) -> ISNAT(and(x0, x1)),ISNAT(n__s(n__and(x0, x1))) -> ISNAT(and(x0, x1)))
   (ISNAT(n__s(x0)) -> ISNAT(x0),ISNAT(n__s(x0)) -> ISNAT(x0))


----------------------------------------

(17)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNAT(n__s(n__zeros)) -> ISNAT(zeros)
   ISNAT(n__s(n__take(x0, x1))) -> ISNAT(take(x0, x1))
   ISNAT(n__s(n__0)) -> ISNAT(0)
   ISNAT(n__s(n__length(x0))) -> ISNAT(length(x0))
   ISNAT(n__s(n__s(x0))) -> ISNAT(s(x0))
   ISNAT(n__s(n__cons(x0, x1))) -> ISNAT(cons(x0, x1))
   ISNAT(n__s(n__isNatIList(x0))) -> ISNAT(isNatIList(x0))
   ISNAT(n__s(n__nil)) -> ISNAT(nil)
   ISNAT(n__s(n__isNatList(x0))) -> ISNAT(isNatList(x0))
   ISNAT(n__s(n__isNat(x0))) -> ISNAT(isNat(x0))
   ISNAT(n__s(n__and(x0, x1))) -> ISNAT(and(x0, x1))
   ISNAT(n__s(x0)) -> ISNAT(x0)

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(18) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule ISNAT(n__s(n__zeros)) -> ISNAT(zeros) at position [0] we obtained the following new rules [LPAR04]:

   (ISNAT(n__s(n__zeros)) -> ISNAT(cons(0, n__zeros)),ISNAT(n__s(n__zeros)) -> ISNAT(cons(0, n__zeros)))
   (ISNAT(n__s(n__zeros)) -> ISNAT(n__zeros),ISNAT(n__s(n__zeros)) -> ISNAT(n__zeros))


----------------------------------------

(19)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNAT(n__s(n__take(x0, x1))) -> ISNAT(take(x0, x1))
   ISNAT(n__s(n__0)) -> ISNAT(0)
   ISNAT(n__s(n__length(x0))) -> ISNAT(length(x0))
   ISNAT(n__s(n__s(x0))) -> ISNAT(s(x0))
   ISNAT(n__s(n__cons(x0, x1))) -> ISNAT(cons(x0, x1))
   ISNAT(n__s(n__isNatIList(x0))) -> ISNAT(isNatIList(x0))
   ISNAT(n__s(n__nil)) -> ISNAT(nil)
   ISNAT(n__s(n__isNatList(x0))) -> ISNAT(isNatList(x0))
   ISNAT(n__s(n__isNat(x0))) -> ISNAT(isNat(x0))
   ISNAT(n__s(n__and(x0, x1))) -> ISNAT(and(x0, x1))
   ISNAT(n__s(x0)) -> ISNAT(x0)
   ISNAT(n__s(n__zeros)) -> ISNAT(cons(0, n__zeros))
   ISNAT(n__s(n__zeros)) -> ISNAT(n__zeros)

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(20) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(21)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNAT(n__s(n__take(x0, x1))) -> ISNAT(take(x0, x1))
   ISNAT(n__s(n__0)) -> ISNAT(0)
   ISNAT(n__s(n__length(x0))) -> ISNAT(length(x0))
   ISNAT(n__s(n__s(x0))) -> ISNAT(s(x0))
   ISNAT(n__s(n__cons(x0, x1))) -> ISNAT(cons(x0, x1))
   ISNAT(n__s(n__isNatIList(x0))) -> ISNAT(isNatIList(x0))
   ISNAT(n__s(n__nil)) -> ISNAT(nil)
   ISNAT(n__s(n__isNatList(x0))) -> ISNAT(isNatList(x0))
   ISNAT(n__s(n__isNat(x0))) -> ISNAT(isNat(x0))
   ISNAT(n__s(n__and(x0, x1))) -> ISNAT(and(x0, x1))
   ISNAT(n__s(x0)) -> ISNAT(x0)
   ISNAT(n__s(n__zeros)) -> ISNAT(cons(0, n__zeros))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(22) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule ISNAT(n__s(n__0)) -> ISNAT(0) at position [0] we obtained the following new rules [LPAR04]:

   (ISNAT(n__s(n__0)) -> ISNAT(n__0),ISNAT(n__s(n__0)) -> ISNAT(n__0))


----------------------------------------

(23)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNAT(n__s(n__take(x0, x1))) -> ISNAT(take(x0, x1))
   ISNAT(n__s(n__length(x0))) -> ISNAT(length(x0))
   ISNAT(n__s(n__s(x0))) -> ISNAT(s(x0))
   ISNAT(n__s(n__cons(x0, x1))) -> ISNAT(cons(x0, x1))
   ISNAT(n__s(n__isNatIList(x0))) -> ISNAT(isNatIList(x0))
   ISNAT(n__s(n__nil)) -> ISNAT(nil)
   ISNAT(n__s(n__isNatList(x0))) -> ISNAT(isNatList(x0))
   ISNAT(n__s(n__isNat(x0))) -> ISNAT(isNat(x0))
   ISNAT(n__s(n__and(x0, x1))) -> ISNAT(and(x0, x1))
   ISNAT(n__s(x0)) -> ISNAT(x0)
   ISNAT(n__s(n__zeros)) -> ISNAT(cons(0, n__zeros))
   ISNAT(n__s(n__0)) -> ISNAT(n__0)

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(24) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(25)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNAT(n__s(n__take(x0, x1))) -> ISNAT(take(x0, x1))
   ISNAT(n__s(n__length(x0))) -> ISNAT(length(x0))
   ISNAT(n__s(n__s(x0))) -> ISNAT(s(x0))
   ISNAT(n__s(n__cons(x0, x1))) -> ISNAT(cons(x0, x1))
   ISNAT(n__s(n__isNatIList(x0))) -> ISNAT(isNatIList(x0))
   ISNAT(n__s(n__nil)) -> ISNAT(nil)
   ISNAT(n__s(n__isNatList(x0))) -> ISNAT(isNatList(x0))
   ISNAT(n__s(n__isNat(x0))) -> ISNAT(isNat(x0))
   ISNAT(n__s(n__and(x0, x1))) -> ISNAT(and(x0, x1))
   ISNAT(n__s(x0)) -> ISNAT(x0)
   ISNAT(n__s(n__zeros)) -> ISNAT(cons(0, n__zeros))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(26) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule ISNAT(n__s(n__s(x0))) -> ISNAT(s(x0)) at position [0] we obtained the following new rules [LPAR04]:

   (ISNAT(n__s(n__s(x0))) -> ISNAT(n__s(x0)),ISNAT(n__s(n__s(x0))) -> ISNAT(n__s(x0)))


----------------------------------------

(27)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNAT(n__s(n__take(x0, x1))) -> ISNAT(take(x0, x1))
   ISNAT(n__s(n__length(x0))) -> ISNAT(length(x0))
   ISNAT(n__s(n__cons(x0, x1))) -> ISNAT(cons(x0, x1))
   ISNAT(n__s(n__isNatIList(x0))) -> ISNAT(isNatIList(x0))
   ISNAT(n__s(n__nil)) -> ISNAT(nil)
   ISNAT(n__s(n__isNatList(x0))) -> ISNAT(isNatList(x0))
   ISNAT(n__s(n__isNat(x0))) -> ISNAT(isNat(x0))
   ISNAT(n__s(n__and(x0, x1))) -> ISNAT(and(x0, x1))
   ISNAT(n__s(x0)) -> ISNAT(x0)
   ISNAT(n__s(n__zeros)) -> ISNAT(cons(0, n__zeros))
   ISNAT(n__s(n__s(x0))) -> ISNAT(n__s(x0))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(28) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule ISNAT(n__s(n__cons(x0, x1))) -> ISNAT(cons(x0, x1)) at position [0] we obtained the following new rules [LPAR04]:

   (ISNAT(n__s(n__cons(x0, x1))) -> ISNAT(n__cons(x0, x1)),ISNAT(n__s(n__cons(x0, x1))) -> ISNAT(n__cons(x0, x1)))


----------------------------------------

(29)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNAT(n__s(n__take(x0, x1))) -> ISNAT(take(x0, x1))
   ISNAT(n__s(n__length(x0))) -> ISNAT(length(x0))
   ISNAT(n__s(n__isNatIList(x0))) -> ISNAT(isNatIList(x0))
   ISNAT(n__s(n__nil)) -> ISNAT(nil)
   ISNAT(n__s(n__isNatList(x0))) -> ISNAT(isNatList(x0))
   ISNAT(n__s(n__isNat(x0))) -> ISNAT(isNat(x0))
   ISNAT(n__s(n__and(x0, x1))) -> ISNAT(and(x0, x1))
   ISNAT(n__s(x0)) -> ISNAT(x0)
   ISNAT(n__s(n__zeros)) -> ISNAT(cons(0, n__zeros))
   ISNAT(n__s(n__s(x0))) -> ISNAT(n__s(x0))
   ISNAT(n__s(n__cons(x0, x1))) -> ISNAT(n__cons(x0, x1))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(30) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(31)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNAT(n__s(n__take(x0, x1))) -> ISNAT(take(x0, x1))
   ISNAT(n__s(n__length(x0))) -> ISNAT(length(x0))
   ISNAT(n__s(n__isNatIList(x0))) -> ISNAT(isNatIList(x0))
   ISNAT(n__s(n__nil)) -> ISNAT(nil)
   ISNAT(n__s(n__isNatList(x0))) -> ISNAT(isNatList(x0))
   ISNAT(n__s(n__isNat(x0))) -> ISNAT(isNat(x0))
   ISNAT(n__s(n__and(x0, x1))) -> ISNAT(and(x0, x1))
   ISNAT(n__s(x0)) -> ISNAT(x0)
   ISNAT(n__s(n__zeros)) -> ISNAT(cons(0, n__zeros))
   ISNAT(n__s(n__s(x0))) -> ISNAT(n__s(x0))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(32) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule ISNAT(n__s(n__nil)) -> ISNAT(nil) at position [0] we obtained the following new rules [LPAR04]:

   (ISNAT(n__s(n__nil)) -> ISNAT(n__nil),ISNAT(n__s(n__nil)) -> ISNAT(n__nil))


----------------------------------------

(33)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNAT(n__s(n__take(x0, x1))) -> ISNAT(take(x0, x1))
   ISNAT(n__s(n__length(x0))) -> ISNAT(length(x0))
   ISNAT(n__s(n__isNatIList(x0))) -> ISNAT(isNatIList(x0))
   ISNAT(n__s(n__isNatList(x0))) -> ISNAT(isNatList(x0))
   ISNAT(n__s(n__isNat(x0))) -> ISNAT(isNat(x0))
   ISNAT(n__s(n__and(x0, x1))) -> ISNAT(and(x0, x1))
   ISNAT(n__s(x0)) -> ISNAT(x0)
   ISNAT(n__s(n__zeros)) -> ISNAT(cons(0, n__zeros))
   ISNAT(n__s(n__s(x0))) -> ISNAT(n__s(x0))
   ISNAT(n__s(n__nil)) -> ISNAT(n__nil)

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(34) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(35)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNAT(n__s(n__take(x0, x1))) -> ISNAT(take(x0, x1))
   ISNAT(n__s(n__length(x0))) -> ISNAT(length(x0))
   ISNAT(n__s(n__isNatIList(x0))) -> ISNAT(isNatIList(x0))
   ISNAT(n__s(n__isNatList(x0))) -> ISNAT(isNatList(x0))
   ISNAT(n__s(n__isNat(x0))) -> ISNAT(isNat(x0))
   ISNAT(n__s(n__and(x0, x1))) -> ISNAT(and(x0, x1))
   ISNAT(n__s(x0)) -> ISNAT(x0)
   ISNAT(n__s(n__zeros)) -> ISNAT(cons(0, n__zeros))
   ISNAT(n__s(n__s(x0))) -> ISNAT(n__s(x0))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(36) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule ISNAT(n__s(n__zeros)) -> ISNAT(cons(0, n__zeros)) at position [0] we obtained the following new rules [LPAR04]:

   (ISNAT(n__s(n__zeros)) -> ISNAT(n__cons(0, n__zeros)),ISNAT(n__s(n__zeros)) -> ISNAT(n__cons(0, n__zeros)))
   (ISNAT(n__s(n__zeros)) -> ISNAT(cons(n__0, n__zeros)),ISNAT(n__s(n__zeros)) -> ISNAT(cons(n__0, n__zeros)))


----------------------------------------

(37)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNAT(n__s(n__take(x0, x1))) -> ISNAT(take(x0, x1))
   ISNAT(n__s(n__length(x0))) -> ISNAT(length(x0))
   ISNAT(n__s(n__isNatIList(x0))) -> ISNAT(isNatIList(x0))
   ISNAT(n__s(n__isNatList(x0))) -> ISNAT(isNatList(x0))
   ISNAT(n__s(n__isNat(x0))) -> ISNAT(isNat(x0))
   ISNAT(n__s(n__and(x0, x1))) -> ISNAT(and(x0, x1))
   ISNAT(n__s(x0)) -> ISNAT(x0)
   ISNAT(n__s(n__s(x0))) -> ISNAT(n__s(x0))
   ISNAT(n__s(n__zeros)) -> ISNAT(n__cons(0, n__zeros))
   ISNAT(n__s(n__zeros)) -> ISNAT(cons(n__0, n__zeros))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(38) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(39)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNAT(n__s(n__take(x0, x1))) -> ISNAT(take(x0, x1))
   ISNAT(n__s(n__length(x0))) -> ISNAT(length(x0))
   ISNAT(n__s(n__isNatIList(x0))) -> ISNAT(isNatIList(x0))
   ISNAT(n__s(n__isNatList(x0))) -> ISNAT(isNatList(x0))
   ISNAT(n__s(n__isNat(x0))) -> ISNAT(isNat(x0))
   ISNAT(n__s(n__and(x0, x1))) -> ISNAT(and(x0, x1))
   ISNAT(n__s(x0)) -> ISNAT(x0)
   ISNAT(n__s(n__s(x0))) -> ISNAT(n__s(x0))
   ISNAT(n__s(n__zeros)) -> ISNAT(cons(n__0, n__zeros))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(40) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule ISNAT(n__s(n__zeros)) -> ISNAT(cons(n__0, n__zeros)) at position [0] we obtained the following new rules [LPAR04]:

   (ISNAT(n__s(n__zeros)) -> ISNAT(n__cons(n__0, n__zeros)),ISNAT(n__s(n__zeros)) -> ISNAT(n__cons(n__0, n__zeros)))


----------------------------------------

(41)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNAT(n__s(n__take(x0, x1))) -> ISNAT(take(x0, x1))
   ISNAT(n__s(n__length(x0))) -> ISNAT(length(x0))
   ISNAT(n__s(n__isNatIList(x0))) -> ISNAT(isNatIList(x0))
   ISNAT(n__s(n__isNatList(x0))) -> ISNAT(isNatList(x0))
   ISNAT(n__s(n__isNat(x0))) -> ISNAT(isNat(x0))
   ISNAT(n__s(n__and(x0, x1))) -> ISNAT(and(x0, x1))
   ISNAT(n__s(x0)) -> ISNAT(x0)
   ISNAT(n__s(n__s(x0))) -> ISNAT(n__s(x0))
   ISNAT(n__s(n__zeros)) -> ISNAT(n__cons(n__0, n__zeros))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(42) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(43)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNAT(n__s(n__take(x0, x1))) -> ISNAT(take(x0, x1))
   ISNAT(n__s(n__length(x0))) -> ISNAT(length(x0))
   ISNAT(n__s(n__isNatIList(x0))) -> ISNAT(isNatIList(x0))
   ISNAT(n__s(n__isNatList(x0))) -> ISNAT(isNatList(x0))
   ISNAT(n__s(n__isNat(x0))) -> ISNAT(isNat(x0))
   ISNAT(n__s(n__and(x0, x1))) -> ISNAT(and(x0, x1))
   ISNAT(n__s(x0)) -> ISNAT(x0)
   ISNAT(n__s(n__s(x0))) -> ISNAT(n__s(x0))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(44) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ISNAT(n__s(n__take(x0, x1))) -> ISNAT(take(x0, x1))
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( ISNAT_1(x_1) ) = 2x_1
POL( take_2(x_1, x_2) ) = 2
POL( 0 ) = 0
POL( U21_1(x_1) ) = max{0, -2}
POL( isNatIList_1(x_1) ) = 0
POL( s_1(x_1) ) = 2x_1
POL( cons_2(x_1, x_2) ) = max{0, -2}
POL( U31_4(x_1, ..., x_4) ) = max{0, -2}
POL( and_2(x_1, x_2) ) = 2x_2
POL( activate_1(x_1) ) = 2x_1
POL( n__and_2(x_1, x_2) ) = 2x_2
POL( isNat_1(x_1) ) = max{0, -2}
POL( n__isNat_1(x_1) ) = 0
POL( n__take_2(x_1, x_2) ) = 2
POL( length_1(x_1) ) = max{0, -2}
POL( nil ) = 0
POL( U11_2(x_1, x_2) ) = max{0, -2}
POL( isNatList_1(x_1) ) = 0
POL( n__length_1(x_1) ) = 0
POL( n__isNatIList_1(x_1) ) = max{0, -2}
POL( n__cons_2(x_1, x_2) ) = 0
POL( n__isNatList_1(x_1) ) = 0
POL( tt ) = 0
POL( n__s_1(x_1) ) = 2x_1
POL( n__zeros ) = 2
POL( n__nil ) = 0
POL( n__0 ) = 0
POL( zeros ) = 2

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   take(X1, X2) -> n__take(X1, X2)
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   length(X) -> n__length(X)
   activate(n__isNatIList(X)) -> isNatIList(X)
   isNatIList(V) -> isNatList(activate(V))
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   and(tt, X) -> activate(X)
   activate(n__isNatList(X)) -> isNatList(X)
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__isNat(X)) -> isNat(X)
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   activate(n__and(X1, X2)) -> and(X1, X2)
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatIList(n__zeros) -> tt
   isNatIList(X) -> n__isNatIList(X)
   isNatList(n__nil) -> tt
   isNatList(X) -> n__isNatList(X)
   isNat(n__0) -> tt
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__take(X1, X2)) -> take(X1, X2)
   U21(tt) -> nil
   activate(n__zeros) -> zeros
   activate(n__0) -> 0
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__nil) -> nil
   activate(X) -> X
   activate(n__length(X)) -> length(X)
   U11(tt, L) -> s(length(activate(L)))
   s(X) -> n__s(X)
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   cons(X1, X2) -> n__cons(X1, X2)
   zeros -> cons(0, n__zeros)
   zeros -> n__zeros
   0 -> n__0
   nil -> n__nil


----------------------------------------

(45)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNAT(n__s(n__length(x0))) -> ISNAT(length(x0))
   ISNAT(n__s(n__isNatIList(x0))) -> ISNAT(isNatIList(x0))
   ISNAT(n__s(n__isNatList(x0))) -> ISNAT(isNatList(x0))
   ISNAT(n__s(n__isNat(x0))) -> ISNAT(isNat(x0))
   ISNAT(n__s(n__and(x0, x1))) -> ISNAT(and(x0, x1))
   ISNAT(n__s(x0)) -> ISNAT(x0)
   ISNAT(n__s(n__s(x0))) -> ISNAT(n__s(x0))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(46) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ISNAT(n__s(n__isNat(x0))) -> ISNAT(isNat(x0))
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( ISNAT_1(x_1) ) = 2x_1
POL( length_1(x_1) ) = max{0, -2}
POL( nil ) = 0
POL( 0 ) = 0
POL( cons_2(x_1, x_2) ) = max{0, -2}
POL( U11_2(x_1, x_2) ) = max{0, -2}
POL( and_2(x_1, x_2) ) = 2x_2
POL( isNatList_1(x_1) ) = max{0, -2}
POL( activate_1(x_1) ) = x_1
POL( n__isNat_1(x_1) ) = 1
POL( n__length_1(x_1) ) = 0
POL( n__isNatIList_1(x_1) ) = max{0, -2}
POL( isNatIList_1(x_1) ) = max{0, -2}
POL( n__cons_2(x_1, x_2) ) = 0
POL( isNat_1(x_1) ) = 1
POL( n__isNatList_1(x_1) ) = max{0, -2}
POL( tt ) = 0
POL( n__take_2(x_1, x_2) ) = 2
POL( n__s_1(x_1) ) = 2x_1
POL( n__and_2(x_1, x_2) ) = 2x_2
POL( n__zeros ) = 0
POL( n__nil ) = 0
POL( n__0 ) = 0
POL( take_2(x_1, x_2) ) = 2
POL( U21_1(x_1) ) = 0
POL( zeros ) = 0
POL( s_1(x_1) ) = 2x_1
POL( U31_4(x_1, ..., x_4) ) = max{0, -2}

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   length(X) -> n__length(X)
   activate(n__isNatIList(X)) -> isNatIList(X)
   isNatIList(V) -> isNatList(activate(V))
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   and(tt, X) -> activate(X)
   activate(n__isNatList(X)) -> isNatList(X)
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__isNat(X)) -> isNat(X)
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   activate(n__and(X1, X2)) -> and(X1, X2)
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatIList(n__zeros) -> tt
   isNatIList(X) -> n__isNatIList(X)
   isNatList(n__nil) -> tt
   isNatList(X) -> n__isNatList(X)
   isNat(n__0) -> tt
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__take(X1, X2)) -> take(X1, X2)
   take(X1, X2) -> n__take(X1, X2)
   take(0, IL) -> U21(isNatIList(IL))
   U21(tt) -> nil
   activate(n__zeros) -> zeros
   activate(n__0) -> 0
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__nil) -> nil
   activate(X) -> X
   activate(n__length(X)) -> length(X)
   U11(tt, L) -> s(length(activate(L)))
   s(X) -> n__s(X)
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   cons(X1, X2) -> n__cons(X1, X2)
   zeros -> cons(0, n__zeros)
   zeros -> n__zeros
   0 -> n__0
   nil -> n__nil


----------------------------------------

(47)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNAT(n__s(n__length(x0))) -> ISNAT(length(x0))
   ISNAT(n__s(n__isNatIList(x0))) -> ISNAT(isNatIList(x0))
   ISNAT(n__s(n__isNatList(x0))) -> ISNAT(isNatList(x0))
   ISNAT(n__s(n__and(x0, x1))) -> ISNAT(and(x0, x1))
   ISNAT(n__s(x0)) -> ISNAT(x0)
   ISNAT(n__s(n__s(x0))) -> ISNAT(n__s(x0))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(48) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ISNAT(n__s(n__isNatIList(x0))) -> ISNAT(isNatIList(x0))
   ISNAT(n__s(n__isNatList(x0))) -> ISNAT(isNatList(x0))
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( ISNAT_1(x_1) ) = x_1 + 2
POL( length_1(x_1) ) = max{0, -2}
POL( nil ) = 0
POL( 0 ) = 0
POL( cons_2(x_1, x_2) ) = max{0, -2}
POL( U11_2(x_1, x_2) ) = max{0, -2}
POL( and_2(x_1, x_2) ) = x_2
POL( isNatList_1(x_1) ) = 2
POL( activate_1(x_1) ) = x_1
POL( n__isNat_1(x_1) ) = 2
POL( n__length_1(x_1) ) = 0
POL( n__isNatIList_1(x_1) ) = 2
POL( isNatIList_1(x_1) ) = 2
POL( n__cons_2(x_1, x_2) ) = 0
POL( isNat_1(x_1) ) = 2
POL( n__isNatList_1(x_1) ) = 2
POL( tt ) = 0
POL( n__take_2(x_1, x_2) ) = 2
POL( n__s_1(x_1) ) = 2x_1
POL( n__and_2(x_1, x_2) ) = x_2
POL( n__zeros ) = 0
POL( n__nil ) = 0
POL( take_2(x_1, x_2) ) = 2
POL( U21_1(x_1) ) = max{0, -2}
POL( zeros ) = 0
POL( n__0 ) = 0
POL( s_1(x_1) ) = 2x_1
POL( U31_4(x_1, ..., x_4) ) = 2

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   length(X) -> n__length(X)
   activate(n__isNatIList(X)) -> isNatIList(X)
   isNatIList(V) -> isNatList(activate(V))
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   and(tt, X) -> activate(X)
   activate(n__isNatList(X)) -> isNatList(X)
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__isNat(X)) -> isNat(X)
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   activate(n__and(X1, X2)) -> and(X1, X2)
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatIList(n__zeros) -> tt
   isNatIList(X) -> n__isNatIList(X)
   isNatList(n__nil) -> tt
   isNatList(X) -> n__isNatList(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__take(X1, X2)) -> take(X1, X2)
   take(X1, X2) -> n__take(X1, X2)
   take(0, IL) -> U21(isNatIList(IL))
   U21(tt) -> nil
   activate(n__zeros) -> zeros
   activate(n__0) -> 0
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__nil) -> nil
   activate(X) -> X
   isNat(n__0) -> tt
   isNat(X) -> n__isNat(X)
   activate(n__length(X)) -> length(X)
   U11(tt, L) -> s(length(activate(L)))
   s(X) -> n__s(X)
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   cons(X1, X2) -> n__cons(X1, X2)
   zeros -> cons(0, n__zeros)
   zeros -> n__zeros
   0 -> n__0
   nil -> n__nil


----------------------------------------

(49)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNAT(n__s(n__length(x0))) -> ISNAT(length(x0))
   ISNAT(n__s(n__and(x0, x1))) -> ISNAT(and(x0, x1))
   ISNAT(n__s(x0)) -> ISNAT(x0)
   ISNAT(n__s(n__s(x0))) -> ISNAT(n__s(x0))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(50) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ISNAT(n__s(n__and(x0, x1))) -> ISNAT(and(x0, x1))
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( ISNAT_1(x_1) ) = 2x_1 + 2
POL( length_1(x_1) ) = max{0, -2}
POL( nil ) = 0
POL( 0 ) = 0
POL( cons_2(x_1, x_2) ) = max{0, -2}
POL( U11_2(x_1, x_2) ) = max{0, -2}
POL( and_2(x_1, x_2) ) = 2x_2 + 1
POL( isNatList_1(x_1) ) = 1
POL( activate_1(x_1) ) = 2x_1 + 1
POL( n__isNat_1(x_1) ) = 1
POL( n__length_1(x_1) ) = 0
POL( n__isNatIList_1(x_1) ) = max{0, -2}
POL( isNatIList_1(x_1) ) = 1
POL( n__cons_2(x_1, x_2) ) = 0
POL( isNat_1(x_1) ) = 1
POL( n__isNatList_1(x_1) ) = 0
POL( tt ) = 1
POL( n__take_2(x_1, x_2) ) = max{0, -2}
POL( n__s_1(x_1) ) = 2x_1
POL( n__and_2(x_1, x_2) ) = 2x_2 + 1
POL( take_2(x_1, x_2) ) = 0
POL( U21_1(x_1) ) = max{0, 2x_1 - 2}
POL( n__zeros ) = 0
POL( zeros ) = 0
POL( n__0 ) = 0
POL( s_1(x_1) ) = 2x_1
POL( n__nil ) = 0
POL( U31_4(x_1, ..., x_4) ) = max{0, -2}

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   length(X) -> n__length(X)
   activate(n__isNatIList(X)) -> isNatIList(X)
   isNatIList(V) -> isNatList(activate(V))
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   and(tt, X) -> activate(X)
   activate(n__isNatList(X)) -> isNatList(X)
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__isNat(X)) -> isNat(X)
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   activate(n__and(X1, X2)) -> and(X1, X2)
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   and(X1, X2) -> n__and(X1, X2)
   activate(n__take(X1, X2)) -> take(X1, X2)
   take(X1, X2) -> n__take(X1, X2)
   take(0, IL) -> U21(isNatIList(IL))
   isNatIList(n__zeros) -> tt
   isNatIList(X) -> n__isNatIList(X)
   U21(tt) -> nil
   activate(n__zeros) -> zeros
   activate(n__0) -> 0
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__nil) -> nil
   activate(X) -> X
   isNatList(n__nil) -> tt
   isNatList(X) -> n__isNatList(X)
   isNat(n__0) -> tt
   isNat(X) -> n__isNat(X)
   activate(n__length(X)) -> length(X)
   U11(tt, L) -> s(length(activate(L)))
   s(X) -> n__s(X)
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   cons(X1, X2) -> n__cons(X1, X2)
   zeros -> cons(0, n__zeros)
   zeros -> n__zeros
   0 -> n__0
   nil -> n__nil


----------------------------------------

(51)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNAT(n__s(n__length(x0))) -> ISNAT(length(x0))
   ISNAT(n__s(x0)) -> ISNAT(x0)
   ISNAT(n__s(n__s(x0))) -> ISNAT(n__s(x0))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(52)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNATLIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatList(activate(V2)))
   AND(tt, X) -> ACTIVATE(X)
   ACTIVATE(n__length(X)) -> LENGTH(X)
   LENGTH(cons(N, L)) -> U11^1(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11^1(tt, L) -> LENGTH(activate(L))
   LENGTH(cons(N, L)) -> ISNATLIST(activate(L))
   ACTIVATE(n__isNatIList(X)) -> ISNATILIST(X)
   ISNATILIST(V) -> ISNATLIST(activate(V))
   ISNATILIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatIList(activate(V2)))
   ACTIVATE(n__isNatList(X)) -> ISNATLIST(X)
   ACTIVATE(n__and(X1, X2)) -> AND(X1, X2)

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(53) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ACTIVATE(n__length(X)) -> LENGTH(X)
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( AND_2(x_1, x_2) ) = 2x_2
POL( ISNATLIST_1(x_1) ) = max{0, -2}
POL( LENGTH_1(x_1) ) = 2x_1
POL( U11^1_2(x_1, x_2) ) = 2x_2
POL( n__isNatIList_1(x_1) ) = max{0, -2}
POL( n__isNatList_1(x_1) ) = 0
POL( activate_1(x_1) ) = x_1
POL( n__zeros ) = 0
POL( zeros ) = 0
POL( n__take_2(x_1, x_2) ) = max{0, -2}
POL( take_2(x_1, x_2) ) = 0
POL( n__0 ) = 0
POL( 0 ) = 0
POL( n__length_1(x_1) ) = 2x_1 + 2
POL( length_1(x_1) ) = 2x_1 + 2
POL( n__s_1(x_1) ) = 0
POL( s_1(x_1) ) = max{0, -2}
POL( n__cons_2(x_1, x_2) ) = x_2
POL( cons_2(x_1, x_2) ) = x_2
POL( isNatIList_1(x_1) ) = max{0, -2}
POL( isNatList_1(x_1) ) = max{0, -2}
POL( and_2(x_1, x_2) ) = 2x_2
POL( isNat_1(x_1) ) = max{0, -2}
POL( tt ) = 0
POL( n__isNat_1(x_1) ) = 0
POL( n__and_2(x_1, x_2) ) = 2x_2
POL( n__nil ) = 0
POL( nil ) = 0
POL( U21_1(x_1) ) = max{0, -2}
POL( U11_2(x_1, x_2) ) = max{0, -2}
POL( U31_4(x_1, ..., x_4) ) = max{0, -2}
POL( ACTIVATE_1(x_1) ) = x_1
POL( ISNATILIST_1(x_1) ) = 0

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   isNatIList(V) -> isNatList(activate(V))
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   and(tt, X) -> activate(X)
   activate(n__isNatList(X)) -> isNatList(X)
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__isNat(X)) -> isNat(X)
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   activate(n__and(X1, X2)) -> and(X1, X2)
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__nil) -> nil
   activate(X) -> X
   isNat(n__0) -> tt
   isNat(X) -> n__isNat(X)
   isNatList(n__nil) -> tt
   isNatList(X) -> n__isNatList(X)
   and(X1, X2) -> n__and(X1, X2)
   take(X1, X2) -> n__take(X1, X2)
   take(0, IL) -> U21(isNatIList(IL))
   isNatIList(n__zeros) -> tt
   isNatIList(X) -> n__isNatIList(X)
   U21(tt) -> nil
   length(nil) -> 0
   length(X) -> n__length(X)
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11(tt, L) -> s(length(activate(L)))
   s(X) -> n__s(X)
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   cons(X1, X2) -> n__cons(X1, X2)
   zeros -> cons(0, n__zeros)
   zeros -> n__zeros
   0 -> n__0
   nil -> n__nil


----------------------------------------

(54)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNATLIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatList(activate(V2)))
   AND(tt, X) -> ACTIVATE(X)
   LENGTH(cons(N, L)) -> U11^1(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11^1(tt, L) -> LENGTH(activate(L))
   LENGTH(cons(N, L)) -> ISNATLIST(activate(L))
   ACTIVATE(n__isNatIList(X)) -> ISNATILIST(X)
   ISNATILIST(V) -> ISNATLIST(activate(V))
   ISNATILIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatIList(activate(V2)))
   ACTIVATE(n__isNatList(X)) -> ISNATLIST(X)
   ACTIVATE(n__and(X1, X2)) -> AND(X1, X2)

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(55) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 1 less node.
----------------------------------------

(56)
Complex Obligation (AND)

----------------------------------------

(57)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   AND(tt, X) -> ACTIVATE(X)
   ACTIVATE(n__isNatIList(X)) -> ISNATILIST(X)
   ISNATILIST(V) -> ISNATLIST(activate(V))
   ISNATLIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatList(activate(V2)))
   ISNATILIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatIList(activate(V2)))
   ACTIVATE(n__isNatList(X)) -> ISNATLIST(X)
   ACTIVATE(n__and(X1, X2)) -> AND(X1, X2)

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(58) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ACTIVATE(n__and(X1, X2)) -> AND(X1, X2)
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( AND_2(x_1, x_2) ) = max{0, x_1 + 2x_2 - 1}
POL( ISNATLIST_1(x_1) ) = 1
POL( n__isNatIList_1(x_1) ) = 0
POL( n__isNatList_1(x_1) ) = 0
POL( activate_1(x_1) ) = 2x_1 + 2
POL( n__zeros ) = 0
POL( zeros ) = 1
POL( n__take_2(x_1, x_2) ) = 0
POL( take_2(x_1, x_2) ) = 0
POL( n__0 ) = 0
POL( 0 ) = 0
POL( n__length_1(x_1) ) = 0
POL( length_1(x_1) ) = max{0, -2}
POL( n__s_1(x_1) ) = 0
POL( s_1(x_1) ) = max{0, -2}
POL( n__cons_2(x_1, x_2) ) = 0
POL( cons_2(x_1, x_2) ) = max{0, -2}
POL( isNatIList_1(x_1) ) = 2
POL( isNatList_1(x_1) ) = 2
POL( and_2(x_1, x_2) ) = x_1 + 2x_2
POL( isNat_1(x_1) ) = 2
POL( tt ) = 2
POL( n__isNat_1(x_1) ) = 0
POL( n__and_2(x_1, x_2) ) = x_1 + x_2
POL( n__nil ) = 0
POL( nil ) = 0
POL( U21_1(x_1) ) = max{0, x_1 - 2}
POL( U11_2(x_1, x_2) ) = max{0, -2}
POL( U31_4(x_1, ..., x_4) ) = 0
POL( ACTIVATE_1(x_1) ) = 2x_1 + 1
POL( ISNATILIST_1(x_1) ) = 1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   isNatIList(V) -> isNatList(activate(V))
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   and(tt, X) -> activate(X)
   activate(n__isNatList(X)) -> isNatList(X)
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__isNat(X)) -> isNat(X)
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   activate(n__and(X1, X2)) -> and(X1, X2)
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__nil) -> nil
   activate(X) -> X
   isNat(n__0) -> tt
   isNat(X) -> n__isNat(X)
   take(X1, X2) -> n__take(X1, X2)
   take(0, IL) -> U21(isNatIList(IL))
   isNatIList(n__zeros) -> tt
   isNatIList(X) -> n__isNatIList(X)
   U21(tt) -> nil
   isNatList(n__nil) -> tt
   isNatList(X) -> n__isNatList(X)
   and(X1, X2) -> n__and(X1, X2)
   length(nil) -> 0
   length(X) -> n__length(X)
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11(tt, L) -> s(length(activate(L)))
   s(X) -> n__s(X)
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   cons(X1, X2) -> n__cons(X1, X2)
   zeros -> cons(0, n__zeros)
   zeros -> n__zeros
   0 -> n__0
   nil -> n__nil


----------------------------------------

(59)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   AND(tt, X) -> ACTIVATE(X)
   ACTIVATE(n__isNatIList(X)) -> ISNATILIST(X)
   ISNATILIST(V) -> ISNATLIST(activate(V))
   ISNATLIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatList(activate(V2)))
   ISNATILIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatIList(activate(V2)))
   ACTIVATE(n__isNatList(X)) -> ISNATLIST(X)

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(60) TransformationProof (EQUIVALENT)
By instantiating [LPAR04] the rule AND(tt, X) -> ACTIVATE(X) we obtained the following new rules [LPAR04]:

   (AND(tt, n__isNatList(y_4)) -> ACTIVATE(n__isNatList(y_4)),AND(tt, n__isNatList(y_4)) -> ACTIVATE(n__isNatList(y_4)))
   (AND(tt, n__isNatIList(y_4)) -> ACTIVATE(n__isNatIList(y_4)),AND(tt, n__isNatIList(y_4)) -> ACTIVATE(n__isNatIList(y_4)))


----------------------------------------

(61)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVATE(n__isNatIList(X)) -> ISNATILIST(X)
   ISNATILIST(V) -> ISNATLIST(activate(V))
   ISNATLIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatList(activate(V2)))
   ISNATILIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatIList(activate(V2)))
   ACTIVATE(n__isNatList(X)) -> ISNATLIST(X)
   AND(tt, n__isNatList(y_4)) -> ACTIVATE(n__isNatList(y_4))
   AND(tt, n__isNatIList(y_4)) -> ACTIVATE(n__isNatIList(y_4))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(62) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 1 less node.
----------------------------------------

(63)
Complex Obligation (AND)

----------------------------------------

(64)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   AND(tt, n__isNatList(y_4)) -> ACTIVATE(n__isNatList(y_4))
   ACTIVATE(n__isNatList(X)) -> ISNATLIST(X)
   ISNATLIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatList(activate(V2)))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(65) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule ISNATLIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatList(activate(V2))) at position [0] we obtained the following new rules [LPAR04]:

   (ISNATLIST(n__cons(y0, y1)) -> AND(n__isNat(activate(y0)), n__isNatList(activate(y1))),ISNATLIST(n__cons(y0, y1)) -> AND(n__isNat(activate(y0)), n__isNatList(activate(y1))))
   (ISNATLIST(n__cons(n__zeros, y1)) -> AND(isNat(zeros), n__isNatList(activate(y1))),ISNATLIST(n__cons(n__zeros, y1)) -> AND(isNat(zeros), n__isNatList(activate(y1))))
   (ISNATLIST(n__cons(n__take(x0, x1), y1)) -> AND(isNat(take(x0, x1)), n__isNatList(activate(y1))),ISNATLIST(n__cons(n__take(x0, x1), y1)) -> AND(isNat(take(x0, x1)), n__isNatList(activate(y1))))
   (ISNATLIST(n__cons(n__0, y1)) -> AND(isNat(0), n__isNatList(activate(y1))),ISNATLIST(n__cons(n__0, y1)) -> AND(isNat(0), n__isNatList(activate(y1))))
   (ISNATLIST(n__cons(n__length(x0), y1)) -> AND(isNat(length(x0)), n__isNatList(activate(y1))),ISNATLIST(n__cons(n__length(x0), y1)) -> AND(isNat(length(x0)), n__isNatList(activate(y1))))
   (ISNATLIST(n__cons(n__s(x0), y1)) -> AND(isNat(s(x0)), n__isNatList(activate(y1))),ISNATLIST(n__cons(n__s(x0), y1)) -> AND(isNat(s(x0)), n__isNatList(activate(y1))))
   (ISNATLIST(n__cons(n__cons(x0, x1), y1)) -> AND(isNat(cons(x0, x1)), n__isNatList(activate(y1))),ISNATLIST(n__cons(n__cons(x0, x1), y1)) -> AND(isNat(cons(x0, x1)), n__isNatList(activate(y1))))
   (ISNATLIST(n__cons(n__isNatIList(x0), y1)) -> AND(isNat(isNatIList(x0)), n__isNatList(activate(y1))),ISNATLIST(n__cons(n__isNatIList(x0), y1)) -> AND(isNat(isNatIList(x0)), n__isNatList(activate(y1))))
   (ISNATLIST(n__cons(n__nil, y1)) -> AND(isNat(nil), n__isNatList(activate(y1))),ISNATLIST(n__cons(n__nil, y1)) -> AND(isNat(nil), n__isNatList(activate(y1))))
   (ISNATLIST(n__cons(n__isNatList(x0), y1)) -> AND(isNat(isNatList(x0)), n__isNatList(activate(y1))),ISNATLIST(n__cons(n__isNatList(x0), y1)) -> AND(isNat(isNatList(x0)), n__isNatList(activate(y1))))
   (ISNATLIST(n__cons(n__isNat(x0), y1)) -> AND(isNat(isNat(x0)), n__isNatList(activate(y1))),ISNATLIST(n__cons(n__isNat(x0), y1)) -> AND(isNat(isNat(x0)), n__isNatList(activate(y1))))
   (ISNATLIST(n__cons(n__and(x0, x1), y1)) -> AND(isNat(and(x0, x1)), n__isNatList(activate(y1))),ISNATLIST(n__cons(n__and(x0, x1), y1)) -> AND(isNat(and(x0, x1)), n__isNatList(activate(y1))))
   (ISNATLIST(n__cons(x0, y1)) -> AND(isNat(x0), n__isNatList(activate(y1))),ISNATLIST(n__cons(x0, y1)) -> AND(isNat(x0), n__isNatList(activate(y1))))


----------------------------------------

(66)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   AND(tt, n__isNatList(y_4)) -> ACTIVATE(n__isNatList(y_4))
   ACTIVATE(n__isNatList(X)) -> ISNATLIST(X)
   ISNATLIST(n__cons(y0, y1)) -> AND(n__isNat(activate(y0)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__zeros, y1)) -> AND(isNat(zeros), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__take(x0, x1), y1)) -> AND(isNat(take(x0, x1)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__0, y1)) -> AND(isNat(0), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__length(x0), y1)) -> AND(isNat(length(x0)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__s(x0), y1)) -> AND(isNat(s(x0)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__cons(x0, x1), y1)) -> AND(isNat(cons(x0, x1)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__isNatIList(x0), y1)) -> AND(isNat(isNatIList(x0)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__nil, y1)) -> AND(isNat(nil), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__isNatList(x0), y1)) -> AND(isNat(isNatList(x0)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__isNat(x0), y1)) -> AND(isNat(isNat(x0)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__and(x0, x1), y1)) -> AND(isNat(and(x0, x1)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(x0, y1)) -> AND(isNat(x0), n__isNatList(activate(y1)))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(67) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(68)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVATE(n__isNatList(X)) -> ISNATLIST(X)
   ISNATLIST(n__cons(n__zeros, y1)) -> AND(isNat(zeros), n__isNatList(activate(y1)))
   AND(tt, n__isNatList(y_4)) -> ACTIVATE(n__isNatList(y_4))
   ISNATLIST(n__cons(n__take(x0, x1), y1)) -> AND(isNat(take(x0, x1)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__0, y1)) -> AND(isNat(0), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__length(x0), y1)) -> AND(isNat(length(x0)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__s(x0), y1)) -> AND(isNat(s(x0)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__cons(x0, x1), y1)) -> AND(isNat(cons(x0, x1)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__isNatIList(x0), y1)) -> AND(isNat(isNatIList(x0)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__nil, y1)) -> AND(isNat(nil), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__isNatList(x0), y1)) -> AND(isNat(isNatList(x0)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__isNat(x0), y1)) -> AND(isNat(isNat(x0)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__and(x0, x1), y1)) -> AND(isNat(and(x0, x1)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(x0, y1)) -> AND(isNat(x0), n__isNatList(activate(y1)))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(69) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ISNATLIST(n__cons(n__isNatIList(x0), y1)) -> AND(isNat(isNatIList(x0)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__isNatList(x0), y1)) -> AND(isNat(isNatList(x0)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__isNat(x0), y1)) -> AND(isNat(isNat(x0)), n__isNatList(activate(y1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( AND_2(x_1, x_2) ) = max{0, x_2 - 2}
POL( n__isNatList_1(x_1) ) = 2x_1 + 2
POL( zeros ) = 0
POL( cons_2(x_1, x_2) ) = x_1 + 2x_2
POL( 0 ) = 0
POL( n__zeros ) = 0
POL( isNat_1(x_1) ) = x_1 + 2
POL( n__0 ) = 0
POL( tt ) = 2
POL( activate_1(x_1) ) = x_1
POL( n__isNatIList_1(x_1) ) = 2x_1 + 2
POL( isNatIList_1(x_1) ) = 2x_1 + 2
POL( isNatList_1(x_1) ) = 2x_1 + 2
POL( n__cons_2(x_1, x_2) ) = x_1 + 2x_2
POL( and_2(x_1, x_2) ) = x_2
POL( n__take_2(x_1, x_2) ) = x_2
POL( n__isNat_1(x_1) ) = x_1 + 2
POL( n__length_1(x_1) ) = 2x_1
POL( n__s_1(x_1) ) = x_1
POL( n__and_2(x_1, x_2) ) = x_2
POL( take_2(x_1, x_2) ) = x_2
POL( length_1(x_1) ) = 2x_1
POL( s_1(x_1) ) = x_1
POL( n__nil ) = 0
POL( nil ) = 0
POL( U21_1(x_1) ) = max{0, -2}
POL( U31_4(x_1, ..., x_4) ) = 2x_2 + x_4
POL( U11_2(x_1, x_2) ) = max{0, x_1 + 2x_2 - 2}
POL( ACTIVATE_1(x_1) ) = max{0, x_1 - 2}
POL( ISNATLIST_1(x_1) ) = 2x_1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   zeros -> cons(0, n__zeros)
   zeros -> n__zeros
   isNat(n__0) -> tt
   activate(n__isNatIList(X)) -> isNatIList(X)
   isNatIList(V) -> isNatList(activate(V))
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   and(tt, X) -> activate(X)
   activate(n__isNatList(X)) -> isNatList(X)
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__isNat(X)) -> isNat(X)
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   activate(n__and(X1, X2)) -> and(X1, X2)
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNat(X) -> n__isNat(X)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__nil) -> nil
   activate(X) -> X
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(n__zeros) -> tt
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(n__nil) -> tt
   isNatList(X) -> n__isNatList(X)
   and(X1, X2) -> n__and(X1, X2)
   U21(tt) -> nil
   U11(tt, L) -> s(length(activate(L)))
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))


----------------------------------------

(70)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVATE(n__isNatList(X)) -> ISNATLIST(X)
   ISNATLIST(n__cons(n__zeros, y1)) -> AND(isNat(zeros), n__isNatList(activate(y1)))
   AND(tt, n__isNatList(y_4)) -> ACTIVATE(n__isNatList(y_4))
   ISNATLIST(n__cons(n__take(x0, x1), y1)) -> AND(isNat(take(x0, x1)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__0, y1)) -> AND(isNat(0), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__length(x0), y1)) -> AND(isNat(length(x0)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__s(x0), y1)) -> AND(isNat(s(x0)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__cons(x0, x1), y1)) -> AND(isNat(cons(x0, x1)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__nil, y1)) -> AND(isNat(nil), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__and(x0, x1), y1)) -> AND(isNat(and(x0, x1)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(x0, y1)) -> AND(isNat(x0), n__isNatList(activate(y1)))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(71) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ISNATLIST(n__cons(n__length(x0), y1)) -> AND(isNat(length(x0)), n__isNatList(activate(y1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( AND_2(x_1, x_2) ) = max{0, 2x_2 - 2}
POL( n__isNatList_1(x_1) ) = 2x_1 + 2
POL( zeros ) = 0
POL( cons_2(x_1, x_2) ) = x_1 + 2x_2
POL( 0 ) = 0
POL( n__zeros ) = 0
POL( isNat_1(x_1) ) = x_1 + 1
POL( n__0 ) = 0
POL( tt ) = 0
POL( activate_1(x_1) ) = x_1
POL( n__isNatIList_1(x_1) ) = 2x_1 + 2
POL( isNatIList_1(x_1) ) = 2x_1 + 2
POL( isNatList_1(x_1) ) = 2x_1 + 2
POL( n__cons_2(x_1, x_2) ) = x_1 + 2x_2
POL( and_2(x_1, x_2) ) = x_2
POL( n__take_2(x_1, x_2) ) = x_2
POL( n__isNat_1(x_1) ) = x_1 + 1
POL( n__length_1(x_1) ) = 2x_1 + 1
POL( n__s_1(x_1) ) = x_1
POL( n__and_2(x_1, x_2) ) = x_2
POL( take_2(x_1, x_2) ) = x_2
POL( length_1(x_1) ) = 2x_1 + 1
POL( s_1(x_1) ) = x_1
POL( n__nil ) = 0
POL( nil ) = 0
POL( U21_1(x_1) ) = 0
POL( U31_4(x_1, ..., x_4) ) = 2x_2 + x_4
POL( U11_2(x_1, x_2) ) = 2x_2 + 1
POL( ACTIVATE_1(x_1) ) = max{0, 2x_1 - 2}
POL( ISNATLIST_1(x_1) ) = 2x_1 + 2

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   zeros -> cons(0, n__zeros)
   zeros -> n__zeros
   isNat(n__0) -> tt
   activate(n__isNatIList(X)) -> isNatIList(X)
   isNatIList(V) -> isNatList(activate(V))
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   and(tt, X) -> activate(X)
   activate(n__isNatList(X)) -> isNatList(X)
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__isNat(X)) -> isNat(X)
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   activate(n__and(X1, X2)) -> and(X1, X2)
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNat(X) -> n__isNat(X)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__nil) -> nil
   activate(X) -> X
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   nil -> n__nil
   and(X1, X2) -> n__and(X1, X2)
   isNatIList(n__zeros) -> tt
   isNatIList(X) -> n__isNatIList(X)
   U21(tt) -> nil
   isNatList(n__nil) -> tt
   isNatList(X) -> n__isNatList(X)
   U11(tt, L) -> s(length(activate(L)))
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))


----------------------------------------

(72)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVATE(n__isNatList(X)) -> ISNATLIST(X)
   ISNATLIST(n__cons(n__zeros, y1)) -> AND(isNat(zeros), n__isNatList(activate(y1)))
   AND(tt, n__isNatList(y_4)) -> ACTIVATE(n__isNatList(y_4))
   ISNATLIST(n__cons(n__take(x0, x1), y1)) -> AND(isNat(take(x0, x1)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__0, y1)) -> AND(isNat(0), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__s(x0), y1)) -> AND(isNat(s(x0)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__cons(x0, x1), y1)) -> AND(isNat(cons(x0, x1)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__nil, y1)) -> AND(isNat(nil), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__and(x0, x1), y1)) -> AND(isNat(and(x0, x1)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(x0, y1)) -> AND(isNat(x0), n__isNatList(activate(y1)))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(73) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ISNATLIST(n__cons(n__take(x0, x1), y1)) -> AND(isNat(take(x0, x1)), n__isNatList(activate(y1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( AND_2(x_1, x_2) ) = 2x_2
POL( n__isNatList_1(x_1) ) = x_1
POL( zeros ) = 0
POL( cons_2(x_1, x_2) ) = x_1 + x_2
POL( 0 ) = 0
POL( n__zeros ) = 0
POL( isNat_1(x_1) ) = 2x_1
POL( n__0 ) = 0
POL( tt ) = 0
POL( activate_1(x_1) ) = x_1
POL( n__isNatIList_1(x_1) ) = x_1 + 1
POL( isNatIList_1(x_1) ) = x_1 + 1
POL( isNatList_1(x_1) ) = x_1
POL( n__cons_2(x_1, x_2) ) = x_1 + x_2
POL( and_2(x_1, x_2) ) = x_2
POL( n__take_2(x_1, x_2) ) = x_2 + 2
POL( n__isNat_1(x_1) ) = 2x_1
POL( n__length_1(x_1) ) = x_1
POL( n__s_1(x_1) ) = x_1
POL( n__and_2(x_1, x_2) ) = x_2
POL( take_2(x_1, x_2) ) = x_2 + 2
POL( length_1(x_1) ) = x_1
POL( s_1(x_1) ) = x_1
POL( n__nil ) = 0
POL( nil ) = 0
POL( U21_1(x_1) ) = max{0, -2}
POL( U31_4(x_1, ..., x_4) ) = x_2 + x_4 + 2
POL( U11_2(x_1, x_2) ) = x_2
POL( ACTIVATE_1(x_1) ) = 2x_1
POL( ISNATLIST_1(x_1) ) = 2x_1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   zeros -> cons(0, n__zeros)
   zeros -> n__zeros
   isNat(n__0) -> tt
   activate(n__isNatIList(X)) -> isNatIList(X)
   isNatIList(V) -> isNatList(activate(V))
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   and(tt, X) -> activate(X)
   activate(n__isNatList(X)) -> isNatList(X)
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__isNat(X)) -> isNat(X)
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   activate(n__and(X1, X2)) -> and(X1, X2)
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNat(X) -> n__isNat(X)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__nil) -> nil
   activate(X) -> X
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   nil -> n__nil
   and(X1, X2) -> n__and(X1, X2)
   isNatIList(n__zeros) -> tt
   isNatIList(X) -> n__isNatIList(X)
   U21(tt) -> nil
   isNatList(n__nil) -> tt
   isNatList(X) -> n__isNatList(X)
   length(nil) -> 0
   length(X) -> n__length(X)
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11(tt, L) -> s(length(activate(L)))
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))


----------------------------------------

(74)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVATE(n__isNatList(X)) -> ISNATLIST(X)
   ISNATLIST(n__cons(n__zeros, y1)) -> AND(isNat(zeros), n__isNatList(activate(y1)))
   AND(tt, n__isNatList(y_4)) -> ACTIVATE(n__isNatList(y_4))
   ISNATLIST(n__cons(n__0, y1)) -> AND(isNat(0), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__s(x0), y1)) -> AND(isNat(s(x0)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__cons(x0, x1), y1)) -> AND(isNat(cons(x0, x1)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__nil, y1)) -> AND(isNat(nil), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__and(x0, x1), y1)) -> AND(isNat(and(x0, x1)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(x0, y1)) -> AND(isNat(x0), n__isNatList(activate(y1)))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(75) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ISNATLIST(n__cons(n__zeros, y1)) -> AND(isNat(zeros), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__nil, y1)) -> AND(isNat(nil), n__isNatList(activate(y1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( AND_2(x_1, x_2) ) = max{0, 2x_2 - 2}
POL( n__isNatList_1(x_1) ) = x_1 + 2
POL( zeros ) = 1
POL( cons_2(x_1, x_2) ) = x_1 + x_2
POL( 0 ) = 0
POL( n__zeros ) = 1
POL( isNat_1(x_1) ) = 2x_1 + 2
POL( n__0 ) = 0
POL( tt ) = 0
POL( activate_1(x_1) ) = x_1
POL( n__isNatIList_1(x_1) ) = x_1 + 2
POL( isNatIList_1(x_1) ) = x_1 + 2
POL( isNatList_1(x_1) ) = x_1 + 2
POL( n__cons_2(x_1, x_2) ) = x_1 + x_2
POL( and_2(x_1, x_2) ) = x_2
POL( n__take_2(x_1, x_2) ) = 2x_2 + 1
POL( n__isNat_1(x_1) ) = 2x_1 + 2
POL( n__length_1(x_1) ) = 2x_1
POL( n__s_1(x_1) ) = x_1
POL( n__and_2(x_1, x_2) ) = x_2
POL( take_2(x_1, x_2) ) = 2x_2 + 1
POL( length_1(x_1) ) = 2x_1
POL( s_1(x_1) ) = x_1
POL( n__nil ) = 1
POL( nil ) = 1
POL( U21_1(x_1) ) = 1
POL( U11_2(x_1, x_2) ) = 2x_2
POL( U31_4(x_1, ..., x_4) ) = 2x_2 + x_4 + 1
POL( ACTIVATE_1(x_1) ) = max{0, 2x_1 - 2}
POL( ISNATLIST_1(x_1) ) = 2x_1 + 2

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   zeros -> cons(0, n__zeros)
   zeros -> n__zeros
   isNat(n__0) -> tt
   activate(n__isNatIList(X)) -> isNatIList(X)
   isNatIList(V) -> isNatList(activate(V))
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   and(tt, X) -> activate(X)
   activate(n__isNatList(X)) -> isNatList(X)
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__isNat(X)) -> isNat(X)
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   activate(n__and(X1, X2)) -> and(X1, X2)
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNat(X) -> n__isNat(X)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__nil) -> nil
   activate(X) -> X
   0 -> n__0
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   nil -> n__nil
   and(X1, X2) -> n__and(X1, X2)
   take(X1, X2) -> n__take(X1, X2)
   take(0, IL) -> U21(isNatIList(IL))
   isNatIList(n__zeros) -> tt
   isNatIList(X) -> n__isNatIList(X)
   U21(tt) -> nil
   isNatList(n__nil) -> tt
   isNatList(X) -> n__isNatList(X)
   length(nil) -> 0
   length(X) -> n__length(X)
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11(tt, L) -> s(length(activate(L)))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))


----------------------------------------

(76)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVATE(n__isNatList(X)) -> ISNATLIST(X)
   AND(tt, n__isNatList(y_4)) -> ACTIVATE(n__isNatList(y_4))
   ISNATLIST(n__cons(n__0, y1)) -> AND(isNat(0), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__s(x0), y1)) -> AND(isNat(s(x0)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__cons(x0, x1), y1)) -> AND(isNat(cons(x0, x1)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__and(x0, x1), y1)) -> AND(isNat(and(x0, x1)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(x0, y1)) -> AND(isNat(x0), n__isNatList(activate(y1)))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(77) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ISNATLIST(n__cons(n__s(x0), y1)) -> AND(isNat(s(x0)), n__isNatList(activate(y1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(ACTIVATE(x_1)) =  	[[0]] 	 +  	[[1, 1]] 	* 	x_1
>>>

   <<<
 POL(n__isNatList(x_1)) =  	[[0], [0]] 	 +  	[[1, 0], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(ISNATLIST(x_1)) =  	[[0]] 	 +  	[[1, 0]] 	* 	x_1
>>>

   <<<
 POL(AND(x_1, x_2)) =  	[[0]] 	 +  	[[0, 0]] 	* 	x_1 	 +  	[[1, 0]] 	* 	x_2
>>>

   <<<
 POL(tt) =  	[[0], [0]]
>>>

   <<<
 POL(n__cons(x_1, x_2)) =  	[[0], [0]] 	 +  	[[0, 1], [0, 0]] 	* 	x_1 	 +  	[[1, 0], [0, 0]] 	* 	x_2
>>>

   <<<
 POL(n__0) =  	[[0], [0]]
>>>

   <<<
 POL(isNat(x_1)) =  	[[0], [0]] 	 +  	[[1, 0], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[0], [0]]
>>>

   <<<
 POL(activate(x_1)) =  	[[0], [0]] 	 +  	[[1, 0], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(n__s(x_1)) =  	[[0], [1]] 	 +  	[[1, 0], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(s(x_1)) =  	[[0], [1]] 	 +  	[[1, 0], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[0], [0]] 	 +  	[[0, 1], [0, 0]] 	* 	x_1 	 +  	[[1, 0], [0, 0]] 	* 	x_2
>>>

   <<<
 POL(n__and(x_1, x_2)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 0]] 	* 	x_1 	 +  	[[1, 0], [0, 1]] 	* 	x_2
>>>

   <<<
 POL(and(x_1, x_2)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 0]] 	* 	x_1 	 +  	[[1, 0], [0, 1]] 	* 	x_2
>>>

   <<<
 POL(n__isNatIList(x_1)) =  	[[0], [0]] 	 +  	[[1, 0], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(isNatIList(x_1)) =  	[[0], [0]] 	 +  	[[1, 0], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(isNatList(x_1)) =  	[[0], [0]] 	 +  	[[1, 0], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(n__take(x_1, x_2)) =  	[[0], [1]] 	 +  	[[0, 0], [0, 0]] 	* 	x_1 	 +  	[[1, 0], [0, 0]] 	* 	x_2
>>>

   <<<
 POL(n__isNat(x_1)) =  	[[0], [0]] 	 +  	[[1, 0], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(n__length(x_1)) =  	[[0], [1]] 	 +  	[[1, 0], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(n__zeros) =  	[[0], [0]]
>>>

   <<<
 POL(zeros) =  	[[0], [0]]
>>>

   <<<
 POL(take(x_1, x_2)) =  	[[0], [1]] 	 +  	[[0, 0], [0, 0]] 	* 	x_1 	 +  	[[1, 0], [0, 0]] 	* 	x_2
>>>

   <<<
 POL(length(x_1)) =  	[[0], [1]] 	 +  	[[1, 0], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(n__nil) =  	[[0], [0]]
>>>

   <<<
 POL(nil) =  	[[0], [0]]
>>>

   <<<
 POL(U21(x_1)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(U11(x_1, x_2)) =  	[[0], [1]] 	 +  	[[0, 0], [0, 0]] 	* 	x_1 	 +  	[[1, 0], [0, 0]] 	* 	x_2
>>>

   <<<
 POL(U31(x_1, x_2, x_3, x_4)) =  	[[0], [1]] 	 +  	[[0, 0], [0, 0]] 	* 	x_1 	 +  	[[1, 0], [0, 0]] 	* 	x_2 	 +  	[[0, 0], [0, 0]] 	* 	x_3 	 +  	[[0, 1], [0, 0]] 	* 	x_4
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   0 -> n__0
   isNat(n__0) -> tt
   activate(n__isNatIList(X)) -> isNatIList(X)
   isNatIList(V) -> isNatList(activate(V))
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   and(tt, X) -> activate(X)
   activate(n__isNatList(X)) -> isNatList(X)
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__isNat(X)) -> isNat(X)
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   activate(n__and(X1, X2)) -> and(X1, X2)
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNat(X) -> n__isNat(X)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__nil) -> nil
   activate(X) -> X
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   and(X1, X2) -> n__and(X1, X2)
   take(X1, X2) -> n__take(X1, X2)
   take(0, IL) -> U21(isNatIList(IL))
   isNatIList(n__zeros) -> tt
   isNatIList(X) -> n__isNatIList(X)
   U21(tt) -> nil
   isNatList(n__nil) -> tt
   isNatList(X) -> n__isNatList(X)
   length(nil) -> 0
   length(X) -> n__length(X)
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11(tt, L) -> s(length(activate(L)))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   zeros -> cons(0, n__zeros)
   zeros -> n__zeros
   nil -> n__nil


----------------------------------------

(78)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVATE(n__isNatList(X)) -> ISNATLIST(X)
   AND(tt, n__isNatList(y_4)) -> ACTIVATE(n__isNatList(y_4))
   ISNATLIST(n__cons(n__0, y1)) -> AND(isNat(0), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__cons(x0, x1), y1)) -> AND(isNat(cons(x0, x1)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__and(x0, x1), y1)) -> AND(isNat(and(x0, x1)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(x0, y1)) -> AND(isNat(x0), n__isNatList(activate(y1)))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(79) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ISNATLIST(n__cons(n__cons(x0, x1), y1)) -> AND(isNat(cons(x0, x1)), n__isNatList(activate(y1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(ACTIVATE(x_1)) =  	[[0]] 	 +  	[[1, 1]] 	* 	x_1
>>>

   <<<
 POL(n__isNatList(x_1)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(ISNATLIST(x_1)) =  	[[0]] 	 +  	[[0, 1]] 	* 	x_1
>>>

   <<<
 POL(AND(x_1, x_2)) =  	[[0]] 	 +  	[[0, 0]] 	* 	x_1 	 +  	[[0, 1]] 	* 	x_2
>>>

   <<<
 POL(tt) =  	[[0], [0]]
>>>

   <<<
 POL(n__cons(x_1, x_2)) =  	[[1], [0]] 	 +  	[[0, 0], [1, 0]] 	* 	x_1 	 +  	[[0, 0], [0, 1]] 	* 	x_2
>>>

   <<<
 POL(n__0) =  	[[0], [0]]
>>>

   <<<
 POL(isNat(x_1)) =  	[[0], [0]] 	 +  	[[0, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[0], [0]]
>>>

   <<<
 POL(activate(x_1)) =  	[[0], [0]] 	 +  	[[1, 0], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[1], [0]] 	 +  	[[0, 0], [1, 0]] 	* 	x_1 	 +  	[[0, 0], [0, 1]] 	* 	x_2
>>>

   <<<
 POL(n__and(x_1, x_2)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 1]] 	* 	x_1 	 +  	[[1, 0], [0, 1]] 	* 	x_2
>>>

   <<<
 POL(and(x_1, x_2)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 1]] 	* 	x_1 	 +  	[[1, 0], [0, 1]] 	* 	x_2
>>>

   <<<
 POL(n__isNatIList(x_1)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(isNatIList(x_1)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(isNatList(x_1)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(n__take(x_1, x_2)) =  	[[1], [0]] 	 +  	[[1, 0], [1, 0]] 	* 	x_1 	 +  	[[1, 0], [0, 1]] 	* 	x_2
>>>

   <<<
 POL(n__isNat(x_1)) =  	[[0], [0]] 	 +  	[[0, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(n__length(x_1)) =  	[[0], [0]] 	 +  	[[0, 1], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(n__s(x_1)) =  	[[0], [0]] 	 +  	[[1, 1], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(n__zeros) =  	[[1], [0]]
>>>

   <<<
 POL(zeros) =  	[[1], [0]]
>>>

   <<<
 POL(take(x_1, x_2)) =  	[[1], [0]] 	 +  	[[1, 0], [1, 0]] 	* 	x_1 	 +  	[[1, 0], [0, 1]] 	* 	x_2
>>>

   <<<
 POL(length(x_1)) =  	[[0], [0]] 	 +  	[[0, 1], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(s(x_1)) =  	[[0], [0]] 	 +  	[[1, 1], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(n__nil) =  	[[0], [0]]
>>>

   <<<
 POL(nil) =  	[[0], [0]]
>>>

   <<<
 POL(U21(x_1)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(U11(x_1, x_2)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 0]] 	* 	x_1 	 +  	[[0, 1], [0, 0]] 	* 	x_2
>>>

   <<<
 POL(U31(x_1, x_2, x_3, x_4)) =  	[[1], [0]] 	 +  	[[0, 0], [0, 0]] 	* 	x_1 	 +  	[[0, 0], [0, 1]] 	* 	x_2 	 +  	[[0, 0], [1, 0]] 	* 	x_3 	 +  	[[0, 0], [1, 0]] 	* 	x_4
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   0 -> n__0
   isNat(n__0) -> tt
   activate(n__isNatIList(X)) -> isNatIList(X)
   isNatIList(V) -> isNatList(activate(V))
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   and(tt, X) -> activate(X)
   activate(n__isNatList(X)) -> isNatList(X)
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__isNat(X)) -> isNat(X)
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   activate(n__and(X1, X2)) -> and(X1, X2)
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNat(X) -> n__isNat(X)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__nil) -> nil
   activate(X) -> X
   cons(X1, X2) -> n__cons(X1, X2)
   and(X1, X2) -> n__and(X1, X2)
   take(X1, X2) -> n__take(X1, X2)
   take(0, IL) -> U21(isNatIList(IL))
   isNatIList(n__zeros) -> tt
   isNatIList(X) -> n__isNatIList(X)
   U21(tt) -> nil
   isNatList(n__nil) -> tt
   isNatList(X) -> n__isNatList(X)
   length(nil) -> 0
   length(X) -> n__length(X)
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11(tt, L) -> s(length(activate(L)))
   s(X) -> n__s(X)
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   zeros -> cons(0, n__zeros)
   zeros -> n__zeros
   nil -> n__nil


----------------------------------------

(80)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVATE(n__isNatList(X)) -> ISNATLIST(X)
   AND(tt, n__isNatList(y_4)) -> ACTIVATE(n__isNatList(y_4))
   ISNATLIST(n__cons(n__0, y1)) -> AND(isNat(0), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(n__and(x0, x1), y1)) -> AND(isNat(and(x0, x1)), n__isNatList(activate(y1)))
   ISNATLIST(n__cons(x0, y1)) -> AND(isNat(x0), n__isNatList(activate(y1)))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(81)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ISNATILIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatIList(activate(V2)))
   AND(tt, n__isNatIList(y_4)) -> ACTIVATE(n__isNatIList(y_4))
   ACTIVATE(n__isNatIList(X)) -> ISNATILIST(X)

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(82) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule ISNATILIST(n__cons(V1, V2)) -> AND(isNat(activate(V1)), n__isNatIList(activate(V2))) at position [0] we obtained the following new rules [LPAR04]:

   (ISNATILIST(n__cons(y0, y1)) -> AND(n__isNat(activate(y0)), n__isNatIList(activate(y1))),ISNATILIST(n__cons(y0, y1)) -> AND(n__isNat(activate(y0)), n__isNatIList(activate(y1))))
   (ISNATILIST(n__cons(n__zeros, y1)) -> AND(isNat(zeros), n__isNatIList(activate(y1))),ISNATILIST(n__cons(n__zeros, y1)) -> AND(isNat(zeros), n__isNatIList(activate(y1))))
   (ISNATILIST(n__cons(n__take(x0, x1), y1)) -> AND(isNat(take(x0, x1)), n__isNatIList(activate(y1))),ISNATILIST(n__cons(n__take(x0, x1), y1)) -> AND(isNat(take(x0, x1)), n__isNatIList(activate(y1))))
   (ISNATILIST(n__cons(n__0, y1)) -> AND(isNat(0), n__isNatIList(activate(y1))),ISNATILIST(n__cons(n__0, y1)) -> AND(isNat(0), n__isNatIList(activate(y1))))
   (ISNATILIST(n__cons(n__length(x0), y1)) -> AND(isNat(length(x0)), n__isNatIList(activate(y1))),ISNATILIST(n__cons(n__length(x0), y1)) -> AND(isNat(length(x0)), n__isNatIList(activate(y1))))
   (ISNATILIST(n__cons(n__s(x0), y1)) -> AND(isNat(s(x0)), n__isNatIList(activate(y1))),ISNATILIST(n__cons(n__s(x0), y1)) -> AND(isNat(s(x0)), n__isNatIList(activate(y1))))
   (ISNATILIST(n__cons(n__cons(x0, x1), y1)) -> AND(isNat(cons(x0, x1)), n__isNatIList(activate(y1))),ISNATILIST(n__cons(n__cons(x0, x1), y1)) -> AND(isNat(cons(x0, x1)), n__isNatIList(activate(y1))))
   (ISNATILIST(n__cons(n__isNatIList(x0), y1)) -> AND(isNat(isNatIList(x0)), n__isNatIList(activate(y1))),ISNATILIST(n__cons(n__isNatIList(x0), y1)) -> AND(isNat(isNatIList(x0)), n__isNatIList(activate(y1))))
   (ISNATILIST(n__cons(n__nil, y1)) -> AND(isNat(nil), n__isNatIList(activate(y1))),ISNATILIST(n__cons(n__nil, y1)) -> AND(isNat(nil), n__isNatIList(activate(y1))))
   (ISNATILIST(n__cons(n__isNatList(x0), y1)) -> AND(isNat(isNatList(x0)), n__isNatIList(activate(y1))),ISNATILIST(n__cons(n__isNatList(x0), y1)) -> AND(isNat(isNatList(x0)), n__isNatIList(activate(y1))))
   (ISNATILIST(n__cons(n__isNat(x0), y1)) -> AND(isNat(isNat(x0)), n__isNatIList(activate(y1))),ISNATILIST(n__cons(n__isNat(x0), y1)) -> AND(isNat(isNat(x0)), n__isNatIList(activate(y1))))
   (ISNATILIST(n__cons(n__and(x0, x1), y1)) -> AND(isNat(and(x0, x1)), n__isNatIList(activate(y1))),ISNATILIST(n__cons(n__and(x0, x1), y1)) -> AND(isNat(and(x0, x1)), n__isNatIList(activate(y1))))
   (ISNATILIST(n__cons(x0, y1)) -> AND(isNat(x0), n__isNatIList(activate(y1))),ISNATILIST(n__cons(x0, y1)) -> AND(isNat(x0), n__isNatIList(activate(y1))))


----------------------------------------

(83)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   AND(tt, n__isNatIList(y_4)) -> ACTIVATE(n__isNatIList(y_4))
   ACTIVATE(n__isNatIList(X)) -> ISNATILIST(X)
   ISNATILIST(n__cons(y0, y1)) -> AND(n__isNat(activate(y0)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__zeros, y1)) -> AND(isNat(zeros), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__take(x0, x1), y1)) -> AND(isNat(take(x0, x1)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__0, y1)) -> AND(isNat(0), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__length(x0), y1)) -> AND(isNat(length(x0)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__s(x0), y1)) -> AND(isNat(s(x0)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__cons(x0, x1), y1)) -> AND(isNat(cons(x0, x1)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__isNatIList(x0), y1)) -> AND(isNat(isNatIList(x0)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__nil, y1)) -> AND(isNat(nil), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__isNatList(x0), y1)) -> AND(isNat(isNatList(x0)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__isNat(x0), y1)) -> AND(isNat(isNat(x0)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__and(x0, x1), y1)) -> AND(isNat(and(x0, x1)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(x0, y1)) -> AND(isNat(x0), n__isNatIList(activate(y1)))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(84) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(85)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVATE(n__isNatIList(X)) -> ISNATILIST(X)
   ISNATILIST(n__cons(n__zeros, y1)) -> AND(isNat(zeros), n__isNatIList(activate(y1)))
   AND(tt, n__isNatIList(y_4)) -> ACTIVATE(n__isNatIList(y_4))
   ISNATILIST(n__cons(n__take(x0, x1), y1)) -> AND(isNat(take(x0, x1)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__0, y1)) -> AND(isNat(0), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__length(x0), y1)) -> AND(isNat(length(x0)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__s(x0), y1)) -> AND(isNat(s(x0)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__cons(x0, x1), y1)) -> AND(isNat(cons(x0, x1)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__isNatIList(x0), y1)) -> AND(isNat(isNatIList(x0)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__nil, y1)) -> AND(isNat(nil), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__isNatList(x0), y1)) -> AND(isNat(isNatList(x0)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__isNat(x0), y1)) -> AND(isNat(isNat(x0)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__and(x0, x1), y1)) -> AND(isNat(and(x0, x1)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(x0, y1)) -> AND(isNat(x0), n__isNatIList(activate(y1)))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(86) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ISNATILIST(n__cons(n__zeros, y1)) -> AND(isNat(zeros), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__take(x0, x1), y1)) -> AND(isNat(take(x0, x1)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__length(x0), y1)) -> AND(isNat(length(x0)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__isNatIList(x0), y1)) -> AND(isNat(isNatIList(x0)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__nil, y1)) -> AND(isNat(nil), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__isNatList(x0), y1)) -> AND(isNat(isNatList(x0)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__isNat(x0), y1)) -> AND(isNat(isNat(x0)), n__isNatIList(activate(y1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( AND_2(x_1, x_2) ) = max{0, x_2 - 1}
POL( n__isNatIList_1(x_1) ) = 2x_1 + 1
POL( zeros ) = 1
POL( cons_2(x_1, x_2) ) = x_1 + x_2
POL( 0 ) = 0
POL( n__zeros ) = 1
POL( isNat_1(x_1) ) = 2x_1 + 2
POL( n__0 ) = 0
POL( tt ) = 2
POL( activate_1(x_1) ) = x_1
POL( isNatIList_1(x_1) ) = 2x_1 + 1
POL( isNatList_1(x_1) ) = x_1 + 1
POL( n__cons_2(x_1, x_2) ) = x_1 + x_2
POL( and_2(x_1, x_2) ) = x_2
POL( n__isNatList_1(x_1) ) = x_1 + 1
POL( n__take_2(x_1, x_2) ) = 2x_2 + 1
POL( n__isNat_1(x_1) ) = 2x_1 + 2
POL( n__length_1(x_1) ) = 2x_1 + 1
POL( n__s_1(x_1) ) = x_1
POL( n__and_2(x_1, x_2) ) = x_2
POL( take_2(x_1, x_2) ) = 2x_2 + 1
POL( length_1(x_1) ) = 2x_1 + 1
POL( s_1(x_1) ) = x_1
POL( n__nil ) = 1
POL( nil ) = 1
POL( U21_1(x_1) ) = max{0, x_1 - 1}
POL( U31_4(x_1, ..., x_4) ) = 2x_2 + x_4 + 1
POL( U11_2(x_1, x_2) ) = max{0, x_1 + 2x_2 - 1}
POL( ACTIVATE_1(x_1) ) = max{0, x_1 - 1}
POL( ISNATILIST_1(x_1) ) = 2x_1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   zeros -> cons(0, n__zeros)
   zeros -> n__zeros
   isNat(n__0) -> tt
   activate(n__isNatIList(X)) -> isNatIList(X)
   isNatIList(V) -> isNatList(activate(V))
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   and(tt, X) -> activate(X)
   activate(n__isNatList(X)) -> isNatList(X)
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__isNat(X)) -> isNat(X)
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   activate(n__and(X1, X2)) -> and(X1, X2)
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNat(X) -> n__isNat(X)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__nil) -> nil
   activate(X) -> X
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(n__zeros) -> tt
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(n__nil) -> tt
   isNatList(X) -> n__isNatList(X)
   and(X1, X2) -> n__and(X1, X2)
   U21(tt) -> nil
   U11(tt, L) -> s(length(activate(L)))
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))


----------------------------------------

(87)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVATE(n__isNatIList(X)) -> ISNATILIST(X)
   AND(tt, n__isNatIList(y_4)) -> ACTIVATE(n__isNatIList(y_4))
   ISNATILIST(n__cons(n__0, y1)) -> AND(isNat(0), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__s(x0), y1)) -> AND(isNat(s(x0)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__cons(x0, x1), y1)) -> AND(isNat(cons(x0, x1)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__and(x0, x1), y1)) -> AND(isNat(and(x0, x1)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(x0, y1)) -> AND(isNat(x0), n__isNatIList(activate(y1)))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(88) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ISNATILIST(n__cons(n__s(x0), y1)) -> AND(isNat(s(x0)), n__isNatIList(activate(y1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(ACTIVATE(x_1)) =  	[[0]] 	 +  	[[1, 1]] 	* 	x_1
>>>

   <<<
 POL(n__isNatIList(x_1)) =  	[[0], [0]] 	 +  	[[0, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(ISNATILIST(x_1)) =  	[[0]] 	 +  	[[1, 0]] 	* 	x_1
>>>

   <<<
 POL(AND(x_1, x_2)) =  	[[0]] 	 +  	[[0, 0]] 	* 	x_1 	 +  	[[0, 1]] 	* 	x_2
>>>

   <<<
 POL(tt) =  	[[0], [0]]
>>>

   <<<
 POL(n__cons(x_1, x_2)) =  	[[0], [0]] 	 +  	[[1, 0], [0, 0]] 	* 	x_1 	 +  	[[1, 0], [0, 0]] 	* 	x_2
>>>

   <<<
 POL(n__0) =  	[[0], [0]]
>>>

   <<<
 POL(isNat(x_1)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[0], [0]]
>>>

   <<<
 POL(activate(x_1)) =  	[[0], [0]] 	 +  	[[1, 0], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(n__s(x_1)) =  	[[1], [0]] 	 +  	[[0, 0], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(s(x_1)) =  	[[1], [0]] 	 +  	[[0, 0], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[0], [0]] 	 +  	[[1, 0], [0, 0]] 	* 	x_1 	 +  	[[1, 0], [0, 0]] 	* 	x_2
>>>

   <<<
 POL(n__and(x_1, x_2)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 0]] 	* 	x_1 	 +  	[[1, 0], [0, 1]] 	* 	x_2
>>>

   <<<
 POL(and(x_1, x_2)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 0]] 	* 	x_1 	 +  	[[1, 0], [0, 1]] 	* 	x_2
>>>

   <<<
 POL(isNatIList(x_1)) =  	[[0], [0]] 	 +  	[[0, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(isNatList(x_1)) =  	[[0], [0]] 	 +  	[[0, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(n__isNatList(x_1)) =  	[[0], [0]] 	 +  	[[0, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(n__take(x_1, x_2)) =  	[[0], [0]] 	 +  	[[0, 1], [0, 0]] 	* 	x_1 	 +  	[[1, 0], [1, 0]] 	* 	x_2
>>>

   <<<
 POL(n__isNat(x_1)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(n__length(x_1)) =  	[[1], [0]] 	 +  	[[0, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(n__zeros) =  	[[0], [0]]
>>>

   <<<
 POL(zeros) =  	[[0], [0]]
>>>

   <<<
 POL(take(x_1, x_2)) =  	[[0], [0]] 	 +  	[[0, 1], [0, 0]] 	* 	x_1 	 +  	[[1, 0], [1, 0]] 	* 	x_2
>>>

   <<<
 POL(length(x_1)) =  	[[1], [0]] 	 +  	[[0, 0], [1, 0]] 	* 	x_1
>>>

   <<<
 POL(n__nil) =  	[[0], [0]]
>>>

   <<<
 POL(nil) =  	[[0], [0]]
>>>

   <<<
 POL(U21(x_1)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(U11(x_1, x_2)) =  	[[1], [0]] 	 +  	[[0, 0], [0, 0]] 	* 	x_1 	 +  	[[0, 0], [1, 0]] 	* 	x_2
>>>

   <<<
 POL(U31(x_1, x_2, x_3, x_4)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 0]] 	* 	x_1 	 +  	[[1, 0], [0, 0]] 	* 	x_2 	 +  	[[0, 1], [0, 0]] 	* 	x_3 	 +  	[[1, 0], [0, 0]] 	* 	x_4
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   0 -> n__0
   isNat(n__0) -> tt
   activate(n__isNatIList(X)) -> isNatIList(X)
   isNatIList(V) -> isNatList(activate(V))
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   and(tt, X) -> activate(X)
   activate(n__isNatList(X)) -> isNatList(X)
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__isNat(X)) -> isNat(X)
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   activate(n__and(X1, X2)) -> and(X1, X2)
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNat(X) -> n__isNat(X)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__nil) -> nil
   activate(X) -> X
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   and(X1, X2) -> n__and(X1, X2)
   take(X1, X2) -> n__take(X1, X2)
   take(0, IL) -> U21(isNatIList(IL))
   isNatIList(n__zeros) -> tt
   isNatIList(X) -> n__isNatIList(X)
   U21(tt) -> nil
   isNatList(n__nil) -> tt
   isNatList(X) -> n__isNatList(X)
   length(nil) -> 0
   length(X) -> n__length(X)
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11(tt, L) -> s(length(activate(L)))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   zeros -> cons(0, n__zeros)
   zeros -> n__zeros
   nil -> n__nil


----------------------------------------

(89)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVATE(n__isNatIList(X)) -> ISNATILIST(X)
   AND(tt, n__isNatIList(y_4)) -> ACTIVATE(n__isNatIList(y_4))
   ISNATILIST(n__cons(n__0, y1)) -> AND(isNat(0), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__cons(x0, x1), y1)) -> AND(isNat(cons(x0, x1)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__and(x0, x1), y1)) -> AND(isNat(and(x0, x1)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(x0, y1)) -> AND(isNat(x0), n__isNatIList(activate(y1)))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(90) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ISNATILIST(n__cons(n__cons(x0, x1), y1)) -> AND(isNat(cons(x0, x1)), n__isNatIList(activate(y1)))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] to (N^2, +, *, >=, >) :

   <<<
 POL(ACTIVATE(x_1)) =  	[[0]] 	 +  	[[1, 1]] 	* 	x_1
>>>

   <<<
 POL(n__isNatIList(x_1)) =  	[[0], [0]] 	 +  	[[0, 1], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(ISNATILIST(x_1)) =  	[[0]] 	 +  	[[0, 1]] 	* 	x_1
>>>

   <<<
 POL(AND(x_1, x_2)) =  	[[0]] 	 +  	[[0, 0]] 	* 	x_1 	 +  	[[1, 0]] 	* 	x_2
>>>

   <<<
 POL(tt) =  	[[0], [0]]
>>>

   <<<
 POL(n__cons(x_1, x_2)) =  	[[1], [0]] 	 +  	[[0, 0], [1, 0]] 	* 	x_1 	 +  	[[0, 0], [0, 1]] 	* 	x_2
>>>

   <<<
 POL(n__0) =  	[[0], [0]]
>>>

   <<<
 POL(isNat(x_1)) =  	[[0], [0]] 	 +  	[[0, 1], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(0) =  	[[0], [0]]
>>>

   <<<
 POL(activate(x_1)) =  	[[0], [0]] 	 +  	[[1, 0], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[1], [0]] 	 +  	[[0, 0], [1, 0]] 	* 	x_1 	 +  	[[0, 0], [0, 1]] 	* 	x_2
>>>

   <<<
 POL(n__and(x_1, x_2)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 0]] 	* 	x_1 	 +  	[[1, 0], [0, 1]] 	* 	x_2
>>>

   <<<
 POL(and(x_1, x_2)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 0]] 	* 	x_1 	 +  	[[1, 0], [0, 1]] 	* 	x_2
>>>

   <<<
 POL(isNatIList(x_1)) =  	[[0], [0]] 	 +  	[[0, 1], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(isNatList(x_1)) =  	[[0], [0]] 	 +  	[[0, 1], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(n__isNatList(x_1)) =  	[[0], [0]] 	 +  	[[0, 1], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(n__take(x_1, x_2)) =  	[[1], [1]] 	 +  	[[0, 0], [0, 0]] 	* 	x_1 	 +  	[[0, 0], [0, 1]] 	* 	x_2
>>>

   <<<
 POL(n__isNat(x_1)) =  	[[0], [0]] 	 +  	[[0, 1], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(n__length(x_1)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(n__s(x_1)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(n__zeros) =  	[[1], [0]]
>>>

   <<<
 POL(zeros) =  	[[1], [0]]
>>>

   <<<
 POL(take(x_1, x_2)) =  	[[1], [1]] 	 +  	[[0, 0], [0, 0]] 	* 	x_1 	 +  	[[0, 0], [0, 1]] 	* 	x_2
>>>

   <<<
 POL(length(x_1)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(s(x_1)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 1]] 	* 	x_1
>>>

   <<<
 POL(n__nil) =  	[[0], [0]]
>>>

   <<<
 POL(nil) =  	[[0], [0]]
>>>

   <<<
 POL(U21(x_1)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 0]] 	* 	x_1
>>>

   <<<
 POL(U11(x_1, x_2)) =  	[[0], [0]] 	 +  	[[0, 0], [0, 0]] 	* 	x_1 	 +  	[[0, 0], [0, 1]] 	* 	x_2
>>>

   <<<
 POL(U31(x_1, x_2, x_3, x_4)) =  	[[1], [1]] 	 +  	[[0, 0], [0, 0]] 	* 	x_1 	 +  	[[0, 0], [0, 1]] 	* 	x_2 	 +  	[[0, 0], [0, 0]] 	* 	x_3 	 +  	[[0, 0], [1, 0]] 	* 	x_4
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   0 -> n__0
   isNat(n__0) -> tt
   activate(n__isNatIList(X)) -> isNatIList(X)
   isNatIList(V) -> isNatList(activate(V))
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   and(tt, X) -> activate(X)
   activate(n__isNatList(X)) -> isNatList(X)
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__isNat(X)) -> isNat(X)
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   activate(n__and(X1, X2)) -> and(X1, X2)
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNat(X) -> n__isNat(X)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__nil) -> nil
   activate(X) -> X
   cons(X1, X2) -> n__cons(X1, X2)
   and(X1, X2) -> n__and(X1, X2)
   take(X1, X2) -> n__take(X1, X2)
   take(0, IL) -> U21(isNatIList(IL))
   isNatIList(n__zeros) -> tt
   isNatIList(X) -> n__isNatIList(X)
   U21(tt) -> nil
   isNatList(n__nil) -> tt
   isNatList(X) -> n__isNatList(X)
   length(nil) -> 0
   length(X) -> n__length(X)
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11(tt, L) -> s(length(activate(L)))
   s(X) -> n__s(X)
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   zeros -> cons(0, n__zeros)
   zeros -> n__zeros
   nil -> n__nil


----------------------------------------

(91)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVATE(n__isNatIList(X)) -> ISNATILIST(X)
   AND(tt, n__isNatIList(y_4)) -> ACTIVATE(n__isNatIList(y_4))
   ISNATILIST(n__cons(n__0, y1)) -> AND(isNat(0), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(n__and(x0, x1), y1)) -> AND(isNat(and(x0, x1)), n__isNatIList(activate(y1)))
   ISNATILIST(n__cons(x0, y1)) -> AND(isNat(x0), n__isNatIList(activate(y1)))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(92) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = ISNATILIST(activate(n__zeros)) evaluates to  t =ISNATILIST(activate(n__zeros))

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

ISNATILIST(activate(n__zeros)) -> ISNATILIST(zeros)
with rule activate(n__zeros) -> zeros at position [0] and matcher [ ]

ISNATILIST(zeros) -> ISNATILIST(cons(0, n__zeros))
with rule zeros -> cons(0, n__zeros) at position [0] and matcher [ ]

ISNATILIST(cons(0, n__zeros)) -> ISNATILIST(cons(n__0, n__zeros))
with rule 0 -> n__0 at position [0,0] and matcher [ ]

ISNATILIST(cons(n__0, n__zeros)) -> ISNATILIST(n__cons(n__0, n__zeros))
with rule cons(X1, X2) -> n__cons(X1, X2) at position [0] and matcher [X1 / n__0, X2 / n__zeros]

ISNATILIST(n__cons(n__0, n__zeros)) -> AND(isNat(n__0), n__isNatIList(activate(n__zeros)))
with rule ISNATILIST(n__cons(x0, y1)) -> AND(isNat(x0), n__isNatIList(activate(y1))) at position [] and matcher [x0 / n__0, y1 / n__zeros]

AND(isNat(n__0), n__isNatIList(activate(n__zeros))) -> AND(tt, n__isNatIList(activate(n__zeros)))
with rule isNat(n__0) -> tt at position [0] and matcher [ ]

AND(tt, n__isNatIList(activate(n__zeros))) -> ACTIVATE(n__isNatIList(activate(n__zeros)))
with rule AND(tt, n__isNatIList(y_4)) -> ACTIVATE(n__isNatIList(y_4)) at position [] and matcher [y_4 / activate(n__zeros)]

ACTIVATE(n__isNatIList(activate(n__zeros))) -> ISNATILIST(activate(n__zeros))
with rule ACTIVATE(n__isNatIList(X)) -> ISNATILIST(X)

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(93)
NO

----------------------------------------

(94)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LENGTH(cons(N, L)) -> U11^1(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11^1(tt, L) -> LENGTH(activate(L))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(95) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule U11^1(tt, L) -> LENGTH(activate(L)) at position [0] we obtained the following new rules [LPAR04]:

   (U11^1(tt, n__zeros) -> LENGTH(zeros),U11^1(tt, n__zeros) -> LENGTH(zeros))
   (U11^1(tt, n__take(x0, x1)) -> LENGTH(take(x0, x1)),U11^1(tt, n__take(x0, x1)) -> LENGTH(take(x0, x1)))
   (U11^1(tt, n__0) -> LENGTH(0),U11^1(tt, n__0) -> LENGTH(0))
   (U11^1(tt, n__length(x0)) -> LENGTH(length(x0)),U11^1(tt, n__length(x0)) -> LENGTH(length(x0)))
   (U11^1(tt, n__s(x0)) -> LENGTH(s(x0)),U11^1(tt, n__s(x0)) -> LENGTH(s(x0)))
   (U11^1(tt, n__cons(x0, x1)) -> LENGTH(cons(x0, x1)),U11^1(tt, n__cons(x0, x1)) -> LENGTH(cons(x0, x1)))
   (U11^1(tt, n__isNatIList(x0)) -> LENGTH(isNatIList(x0)),U11^1(tt, n__isNatIList(x0)) -> LENGTH(isNatIList(x0)))
   (U11^1(tt, n__nil) -> LENGTH(nil),U11^1(tt, n__nil) -> LENGTH(nil))
   (U11^1(tt, n__isNatList(x0)) -> LENGTH(isNatList(x0)),U11^1(tt, n__isNatList(x0)) -> LENGTH(isNatList(x0)))
   (U11^1(tt, n__isNat(x0)) -> LENGTH(isNat(x0)),U11^1(tt, n__isNat(x0)) -> LENGTH(isNat(x0)))
   (U11^1(tt, n__and(x0, x1)) -> LENGTH(and(x0, x1)),U11^1(tt, n__and(x0, x1)) -> LENGTH(and(x0, x1)))
   (U11^1(tt, x0) -> LENGTH(x0),U11^1(tt, x0) -> LENGTH(x0))


----------------------------------------

(96)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LENGTH(cons(N, L)) -> U11^1(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11^1(tt, n__zeros) -> LENGTH(zeros)
   U11^1(tt, n__take(x0, x1)) -> LENGTH(take(x0, x1))
   U11^1(tt, n__0) -> LENGTH(0)
   U11^1(tt, n__length(x0)) -> LENGTH(length(x0))
   U11^1(tt, n__s(x0)) -> LENGTH(s(x0))
   U11^1(tt, n__cons(x0, x1)) -> LENGTH(cons(x0, x1))
   U11^1(tt, n__isNatIList(x0)) -> LENGTH(isNatIList(x0))
   U11^1(tt, n__nil) -> LENGTH(nil)
   U11^1(tt, n__isNatList(x0)) -> LENGTH(isNatList(x0))
   U11^1(tt, n__isNat(x0)) -> LENGTH(isNat(x0))
   U11^1(tt, n__and(x0, x1)) -> LENGTH(and(x0, x1))
   U11^1(tt, x0) -> LENGTH(x0)

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(97) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule U11^1(tt, n__zeros) -> LENGTH(zeros) at position [0] we obtained the following new rules [LPAR04]:

   (U11^1(tt, n__zeros) -> LENGTH(cons(0, n__zeros)),U11^1(tt, n__zeros) -> LENGTH(cons(0, n__zeros)))
   (U11^1(tt, n__zeros) -> LENGTH(n__zeros),U11^1(tt, n__zeros) -> LENGTH(n__zeros))


----------------------------------------

(98)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LENGTH(cons(N, L)) -> U11^1(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11^1(tt, n__take(x0, x1)) -> LENGTH(take(x0, x1))
   U11^1(tt, n__0) -> LENGTH(0)
   U11^1(tt, n__length(x0)) -> LENGTH(length(x0))
   U11^1(tt, n__s(x0)) -> LENGTH(s(x0))
   U11^1(tt, n__cons(x0, x1)) -> LENGTH(cons(x0, x1))
   U11^1(tt, n__isNatIList(x0)) -> LENGTH(isNatIList(x0))
   U11^1(tt, n__nil) -> LENGTH(nil)
   U11^1(tt, n__isNatList(x0)) -> LENGTH(isNatList(x0))
   U11^1(tt, n__isNat(x0)) -> LENGTH(isNat(x0))
   U11^1(tt, n__and(x0, x1)) -> LENGTH(and(x0, x1))
   U11^1(tt, x0) -> LENGTH(x0)
   U11^1(tt, n__zeros) -> LENGTH(cons(0, n__zeros))
   U11^1(tt, n__zeros) -> LENGTH(n__zeros)

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(99) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(100)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U11^1(tt, n__take(x0, x1)) -> LENGTH(take(x0, x1))
   LENGTH(cons(N, L)) -> U11^1(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11^1(tt, n__0) -> LENGTH(0)
   U11^1(tt, n__length(x0)) -> LENGTH(length(x0))
   U11^1(tt, n__s(x0)) -> LENGTH(s(x0))
   U11^1(tt, n__cons(x0, x1)) -> LENGTH(cons(x0, x1))
   U11^1(tt, n__isNatIList(x0)) -> LENGTH(isNatIList(x0))
   U11^1(tt, n__nil) -> LENGTH(nil)
   U11^1(tt, n__isNatList(x0)) -> LENGTH(isNatList(x0))
   U11^1(tt, n__isNat(x0)) -> LENGTH(isNat(x0))
   U11^1(tt, n__and(x0, x1)) -> LENGTH(and(x0, x1))
   U11^1(tt, x0) -> LENGTH(x0)
   U11^1(tt, n__zeros) -> LENGTH(cons(0, n__zeros))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(101) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule U11^1(tt, n__0) -> LENGTH(0) at position [0] we obtained the following new rules [LPAR04]:

   (U11^1(tt, n__0) -> LENGTH(n__0),U11^1(tt, n__0) -> LENGTH(n__0))


----------------------------------------

(102)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U11^1(tt, n__take(x0, x1)) -> LENGTH(take(x0, x1))
   LENGTH(cons(N, L)) -> U11^1(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11^1(tt, n__length(x0)) -> LENGTH(length(x0))
   U11^1(tt, n__s(x0)) -> LENGTH(s(x0))
   U11^1(tt, n__cons(x0, x1)) -> LENGTH(cons(x0, x1))
   U11^1(tt, n__isNatIList(x0)) -> LENGTH(isNatIList(x0))
   U11^1(tt, n__nil) -> LENGTH(nil)
   U11^1(tt, n__isNatList(x0)) -> LENGTH(isNatList(x0))
   U11^1(tt, n__isNat(x0)) -> LENGTH(isNat(x0))
   U11^1(tt, n__and(x0, x1)) -> LENGTH(and(x0, x1))
   U11^1(tt, x0) -> LENGTH(x0)
   U11^1(tt, n__zeros) -> LENGTH(cons(0, n__zeros))
   U11^1(tt, n__0) -> LENGTH(n__0)

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(103) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(104)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LENGTH(cons(N, L)) -> U11^1(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11^1(tt, n__take(x0, x1)) -> LENGTH(take(x0, x1))
   U11^1(tt, n__length(x0)) -> LENGTH(length(x0))
   U11^1(tt, n__s(x0)) -> LENGTH(s(x0))
   U11^1(tt, n__cons(x0, x1)) -> LENGTH(cons(x0, x1))
   U11^1(tt, n__isNatIList(x0)) -> LENGTH(isNatIList(x0))
   U11^1(tt, n__nil) -> LENGTH(nil)
   U11^1(tt, n__isNatList(x0)) -> LENGTH(isNatList(x0))
   U11^1(tt, n__isNat(x0)) -> LENGTH(isNat(x0))
   U11^1(tt, n__and(x0, x1)) -> LENGTH(and(x0, x1))
   U11^1(tt, x0) -> LENGTH(x0)
   U11^1(tt, n__zeros) -> LENGTH(cons(0, n__zeros))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(105) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule U11^1(tt, n__s(x0)) -> LENGTH(s(x0)) at position [0] we obtained the following new rules [LPAR04]:

   (U11^1(tt, n__s(x0)) -> LENGTH(n__s(x0)),U11^1(tt, n__s(x0)) -> LENGTH(n__s(x0)))


----------------------------------------

(106)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LENGTH(cons(N, L)) -> U11^1(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11^1(tt, n__take(x0, x1)) -> LENGTH(take(x0, x1))
   U11^1(tt, n__length(x0)) -> LENGTH(length(x0))
   U11^1(tt, n__cons(x0, x1)) -> LENGTH(cons(x0, x1))
   U11^1(tt, n__isNatIList(x0)) -> LENGTH(isNatIList(x0))
   U11^1(tt, n__nil) -> LENGTH(nil)
   U11^1(tt, n__isNatList(x0)) -> LENGTH(isNatList(x0))
   U11^1(tt, n__isNat(x0)) -> LENGTH(isNat(x0))
   U11^1(tt, n__and(x0, x1)) -> LENGTH(and(x0, x1))
   U11^1(tt, x0) -> LENGTH(x0)
   U11^1(tt, n__zeros) -> LENGTH(cons(0, n__zeros))
   U11^1(tt, n__s(x0)) -> LENGTH(n__s(x0))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(107) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(108)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U11^1(tt, n__take(x0, x1)) -> LENGTH(take(x0, x1))
   LENGTH(cons(N, L)) -> U11^1(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11^1(tt, n__length(x0)) -> LENGTH(length(x0))
   U11^1(tt, n__cons(x0, x1)) -> LENGTH(cons(x0, x1))
   U11^1(tt, n__isNatIList(x0)) -> LENGTH(isNatIList(x0))
   U11^1(tt, n__nil) -> LENGTH(nil)
   U11^1(tt, n__isNatList(x0)) -> LENGTH(isNatList(x0))
   U11^1(tt, n__isNat(x0)) -> LENGTH(isNat(x0))
   U11^1(tt, n__and(x0, x1)) -> LENGTH(and(x0, x1))
   U11^1(tt, x0) -> LENGTH(x0)
   U11^1(tt, n__zeros) -> LENGTH(cons(0, n__zeros))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(109) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule U11^1(tt, n__nil) -> LENGTH(nil) at position [0] we obtained the following new rules [LPAR04]:

   (U11^1(tt, n__nil) -> LENGTH(n__nil),U11^1(tt, n__nil) -> LENGTH(n__nil))


----------------------------------------

(110)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   U11^1(tt, n__take(x0, x1)) -> LENGTH(take(x0, x1))
   LENGTH(cons(N, L)) -> U11^1(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11^1(tt, n__length(x0)) -> LENGTH(length(x0))
   U11^1(tt, n__cons(x0, x1)) -> LENGTH(cons(x0, x1))
   U11^1(tt, n__isNatIList(x0)) -> LENGTH(isNatIList(x0))
   U11^1(tt, n__isNatList(x0)) -> LENGTH(isNatList(x0))
   U11^1(tt, n__isNat(x0)) -> LENGTH(isNat(x0))
   U11^1(tt, n__and(x0, x1)) -> LENGTH(and(x0, x1))
   U11^1(tt, x0) -> LENGTH(x0)
   U11^1(tt, n__zeros) -> LENGTH(cons(0, n__zeros))
   U11^1(tt, n__nil) -> LENGTH(n__nil)

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(111) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(112)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LENGTH(cons(N, L)) -> U11^1(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11^1(tt, n__take(x0, x1)) -> LENGTH(take(x0, x1))
   U11^1(tt, n__length(x0)) -> LENGTH(length(x0))
   U11^1(tt, n__cons(x0, x1)) -> LENGTH(cons(x0, x1))
   U11^1(tt, n__isNatIList(x0)) -> LENGTH(isNatIList(x0))
   U11^1(tt, n__isNatList(x0)) -> LENGTH(isNatList(x0))
   U11^1(tt, n__isNat(x0)) -> LENGTH(isNat(x0))
   U11^1(tt, n__and(x0, x1)) -> LENGTH(and(x0, x1))
   U11^1(tt, x0) -> LENGTH(x0)
   U11^1(tt, n__zeros) -> LENGTH(cons(0, n__zeros))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(113) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   U11^1(tt, n__isNatIList(x0)) -> LENGTH(isNatIList(x0))
   U11^1(tt, n__isNatList(x0)) -> LENGTH(isNatList(x0))
   U11^1(tt, n__isNat(x0)) -> LENGTH(isNat(x0))
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( LENGTH_1(x_1) ) = x_1 + 2
POL( U11^1_2(x_1, x_2) ) = 2x_1 + 2x_2
POL( activate_1(x_1) ) = x_1
POL( n__zeros ) = 0
POL( zeros ) = 0
POL( n__take_2(x_1, x_2) ) = 0
POL( take_2(x_1, x_2) ) = 0
POL( n__0 ) = 0
POL( 0 ) = 0
POL( n__length_1(x_1) ) = 0
POL( length_1(x_1) ) = 0
POL( n__s_1(x_1) ) = 0
POL( s_1(x_1) ) = max{0, -2}
POL( n__cons_2(x_1, x_2) ) = 2x_2
POL( cons_2(x_1, x_2) ) = 2x_2
POL( n__isNatIList_1(x_1) ) = 1
POL( isNatIList_1(x_1) ) = 1
POL( isNatList_1(x_1) ) = 1
POL( and_2(x_1, x_2) ) = x_2
POL( isNat_1(x_1) ) = 1
POL( n__isNatList_1(x_1) ) = 1
POL( tt ) = 1
POL( n__isNat_1(x_1) ) = 1
POL( n__and_2(x_1, x_2) ) = x_2
POL( n__nil ) = 0
POL( nil ) = 0
POL( U21_1(x_1) ) = max{0, -2}
POL( U31_4(x_1, ..., x_4) ) = max{0, -2}
POL( U11_2(x_1, x_2) ) = max{0, -2}

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   isNatIList(V) -> isNatList(activate(V))
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   and(tt, X) -> activate(X)
   activate(n__isNatList(X)) -> isNatList(X)
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__isNat(X)) -> isNat(X)
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   activate(n__and(X1, X2)) -> and(X1, X2)
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__nil) -> nil
   activate(X) -> X
   isNatList(n__nil) -> tt
   isNatList(X) -> n__isNatList(X)
   and(X1, X2) -> n__and(X1, X2)
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   take(X1, X2) -> n__take(X1, X2)
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   length(X) -> n__length(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(n__zeros) -> tt
   isNatIList(X) -> n__isNatIList(X)
   isNat(n__0) -> tt
   isNat(X) -> n__isNat(X)
   0 -> n__0
   U21(tt) -> nil
   U11(tt, L) -> s(length(activate(L)))
   s(X) -> n__s(X)
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   zeros -> cons(0, n__zeros)
   zeros -> n__zeros
   nil -> n__nil


----------------------------------------

(114)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LENGTH(cons(N, L)) -> U11^1(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11^1(tt, n__take(x0, x1)) -> LENGTH(take(x0, x1))
   U11^1(tt, n__length(x0)) -> LENGTH(length(x0))
   U11^1(tt, n__cons(x0, x1)) -> LENGTH(cons(x0, x1))
   U11^1(tt, n__and(x0, x1)) -> LENGTH(and(x0, x1))
   U11^1(tt, x0) -> LENGTH(x0)
   U11^1(tt, n__zeros) -> LENGTH(cons(0, n__zeros))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(115) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   U11^1(tt, n__length(x0)) -> LENGTH(length(x0))
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( LENGTH_1(x_1) ) = x_1 + 2
POL( U11^1_2(x_1, x_2) ) = max{0, 2x_1 + 2x_2 - 2}
POL( activate_1(x_1) ) = x_1
POL( n__zeros ) = 0
POL( zeros ) = 0
POL( n__take_2(x_1, x_2) ) = x_2
POL( take_2(x_1, x_2) ) = x_2
POL( n__0 ) = 0
POL( 0 ) = 0
POL( n__length_1(x_1) ) = 1
POL( length_1(x_1) ) = 1
POL( n__s_1(x_1) ) = 0
POL( s_1(x_1) ) = 0
POL( n__cons_2(x_1, x_2) ) = 2x_1 + 2x_2
POL( cons_2(x_1, x_2) ) = 2x_1 + 2x_2
POL( n__isNatIList_1(x_1) ) = 2
POL( isNatIList_1(x_1) ) = 2
POL( isNatList_1(x_1) ) = 2
POL( and_2(x_1, x_2) ) = x_2
POL( isNat_1(x_1) ) = 2
POL( n__isNatList_1(x_1) ) = 2
POL( tt ) = 2
POL( n__isNat_1(x_1) ) = 2
POL( n__and_2(x_1, x_2) ) = x_2
POL( n__nil ) = 0
POL( nil ) = 0
POL( U21_1(x_1) ) = max{0, -2}
POL( U31_4(x_1, ..., x_4) ) = max{0, x_1 + 2x_2 + 2x_4 - 2}
POL( U11_2(x_1, x_2) ) = max{0, -2}

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   isNatIList(V) -> isNatList(activate(V))
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   and(tt, X) -> activate(X)
   activate(n__isNatList(X)) -> isNatList(X)
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__isNat(X)) -> isNat(X)
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   activate(n__and(X1, X2)) -> and(X1, X2)
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__nil) -> nil
   activate(X) -> X
   isNatList(n__nil) -> tt
   isNatList(X) -> n__isNatList(X)
   and(X1, X2) -> n__and(X1, X2)
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   take(X1, X2) -> n__take(X1, X2)
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   length(X) -> n__length(X)
   cons(X1, X2) -> n__cons(X1, X2)
   0 -> n__0
   isNatIList(n__zeros) -> tt
   isNatIList(X) -> n__isNatIList(X)
   U21(tt) -> nil
   isNat(n__0) -> tt
   isNat(X) -> n__isNat(X)
   U11(tt, L) -> s(length(activate(L)))
   s(X) -> n__s(X)
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   zeros -> cons(0, n__zeros)
   zeros -> n__zeros
   nil -> n__nil


----------------------------------------

(116)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LENGTH(cons(N, L)) -> U11^1(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11^1(tt, n__take(x0, x1)) -> LENGTH(take(x0, x1))
   U11^1(tt, n__cons(x0, x1)) -> LENGTH(cons(x0, x1))
   U11^1(tt, n__and(x0, x1)) -> LENGTH(and(x0, x1))
   U11^1(tt, x0) -> LENGTH(x0)
   U11^1(tt, n__zeros) -> LENGTH(cons(0, n__zeros))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(117) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   U11^1(tt, n__and(x0, x1)) -> LENGTH(and(x0, x1))
The remaining pairs can at least be oriented weakly.
Used ordering:  Matrix interpretation [MATRO] with arctic natural numbers [ARCTIC]:

   <<<
 POL(LENGTH(x_1)) =  	[[2A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(cons(x_1, x_2)) =  	[[0A]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[1A]] 	* 	x_2
>>>

   <<<
 POL(U11^1(x_1, x_2)) =  	[[2A]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[1A]] 	* 	x_2
>>>

   <<<
 POL(and(x_1, x_2)) =  	[[2A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(isNatList(x_1)) =  	[[2A]] 	 +  	[[-I]] 	* 	x_1
>>>

   <<<
 POL(activate(x_1)) =  	[[1A]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(n__isNat(x_1)) =  	[[2A]] 	 +  	[[-I]] 	* 	x_1
>>>

   <<<
 POL(tt) =  	[[0A]]
>>>

   <<<
 POL(n__take(x_1, x_2)) =  	[[0A]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[-I]] 	* 	x_2
>>>

   <<<
 POL(take(x_1, x_2)) =  	[[1A]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[-I]] 	* 	x_2
>>>

   <<<
 POL(n__cons(x_1, x_2)) =  	[[-I]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[1A]] 	* 	x_2
>>>

   <<<
 POL(n__and(x_1, x_2)) =  	[[2A]] 	 +  	[[0A]] 	* 	x_1 	 +  	[[0A]] 	* 	x_2
>>>

   <<<
 POL(n__zeros) =  	[[0A]]
>>>

   <<<
 POL(0) =  	[[0A]]
>>>

   <<<
 POL(zeros) =  	[[1A]]
>>>

   <<<
 POL(n__0) =  	[[0A]]
>>>

   <<<
 POL(n__length(x_1)) =  	[[0A]] 	 +  	[[-I]] 	* 	x_1
>>>

   <<<
 POL(length(x_1)) =  	[[0A]] 	 +  	[[-I]] 	* 	x_1
>>>

   <<<
 POL(n__s(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(s(x_1)) =  	[[-I]] 	 +  	[[0A]] 	* 	x_1
>>>

   <<<
 POL(n__isNatIList(x_1)) =  	[[2A]] 	 +  	[[-I]] 	* 	x_1
>>>

   <<<
 POL(isNatIList(x_1)) =  	[[2A]] 	 +  	[[-I]] 	* 	x_1
>>>

   <<<
 POL(isNat(x_1)) =  	[[2A]] 	 +  	[[-I]] 	* 	x_1
>>>

   <<<
 POL(n__isNatList(x_1)) =  	[[2A]] 	 +  	[[-I]] 	* 	x_1
>>>

   <<<
 POL(n__nil) =  	[[0A]]
>>>

   <<<
 POL(nil) =  	[[0A]]
>>>

   <<<
 POL(U21(x_1)) =  	[[1A]] 	 +  	[[-I]] 	* 	x_1
>>>

   <<<
 POL(U31(x_1, x_2, x_3, x_4)) =  	[[1A]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[-I]] 	* 	x_2 	 +  	[[-I]] 	* 	x_3 	 +  	[[-I]] 	* 	x_4
>>>

   <<<
 POL(U11(x_1, x_2)) =  	[[0A]] 	 +  	[[-I]] 	* 	x_1 	 +  	[[-I]] 	* 	x_2
>>>


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   isNatIList(V) -> isNatList(activate(V))
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   and(tt, X) -> activate(X)
   activate(n__isNatList(X)) -> isNatList(X)
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__isNat(X)) -> isNat(X)
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   activate(n__and(X1, X2)) -> and(X1, X2)
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   activate(n__nil) -> nil
   activate(X) -> X
   isNatList(n__nil) -> tt
   isNatList(X) -> n__isNatList(X)
   and(X1, X2) -> n__and(X1, X2)
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   take(X1, X2) -> n__take(X1, X2)
   cons(X1, X2) -> n__cons(X1, X2)
   0 -> n__0
   isNatIList(n__zeros) -> tt
   isNatIList(X) -> n__isNatIList(X)
   U21(tt) -> nil
   isNat(n__0) -> tt
   isNat(X) -> n__isNat(X)
   length(nil) -> 0
   length(X) -> n__length(X)
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11(tt, L) -> s(length(activate(L)))
   s(X) -> n__s(X)
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   zeros -> cons(0, n__zeros)
   zeros -> n__zeros
   nil -> n__nil


----------------------------------------

(118)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LENGTH(cons(N, L)) -> U11^1(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   U11^1(tt, n__take(x0, x1)) -> LENGTH(take(x0, x1))
   U11^1(tt, n__cons(x0, x1)) -> LENGTH(cons(x0, x1))
   U11^1(tt, x0) -> LENGTH(x0)
   U11^1(tt, n__zeros) -> LENGTH(cons(0, n__zeros))

The TRS R consists of the following rules:

   zeros -> cons(0, n__zeros)
   U11(tt, L) -> s(length(activate(L)))
   U21(tt) -> nil
   U31(tt, IL, M, N) -> cons(activate(N), n__take(activate(M), activate(IL)))
   and(tt, X) -> activate(X)
   isNat(n__0) -> tt
   isNat(n__length(V1)) -> isNatList(activate(V1))
   isNat(n__s(V1)) -> isNat(activate(V1))
   isNatIList(V) -> isNatList(activate(V))
   isNatIList(n__zeros) -> tt
   isNatIList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   isNatList(n__nil) -> tt
   isNatList(n__cons(V1, V2)) -> and(isNat(activate(V1)), n__isNatList(activate(V2)))
   isNatList(n__take(V1, V2)) -> and(isNat(activate(V1)), n__isNatIList(activate(V2)))
   length(nil) -> 0
   length(cons(N, L)) -> U11(and(isNatList(activate(L)), n__isNat(N)), activate(L))
   take(0, IL) -> U21(isNatIList(IL))
   take(s(M), cons(N, IL)) -> U31(and(isNatIList(activate(IL)), n__and(isNat(M), n__isNat(N))), activate(IL), M, N)
   zeros -> n__zeros
   take(X1, X2) -> n__take(X1, X2)
   0 -> n__0
   length(X) -> n__length(X)
   s(X) -> n__s(X)
   cons(X1, X2) -> n__cons(X1, X2)
   isNatIList(X) -> n__isNatIList(X)
   nil -> n__nil
   isNatList(X) -> n__isNatList(X)
   isNat(X) -> n__isNat(X)
   and(X1, X2) -> n__and(X1, X2)
   activate(n__zeros) -> zeros
   activate(n__take(X1, X2)) -> take(X1, X2)
   activate(n__0) -> 0
   activate(n__length(X)) -> length(X)
   activate(n__s(X)) -> s(X)
   activate(n__cons(X1, X2)) -> cons(X1, X2)
   activate(n__isNatIList(X)) -> isNatIList(X)
   activate(n__nil) -> nil
   activate(n__isNatList(X)) -> isNatList(X)
   activate(n__isNat(X)) -> isNat(X)
   activate(n__and(X1, X2)) -> and(X1, X2)
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.