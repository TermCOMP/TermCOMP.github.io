YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/rFkdB.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) Overlay + Local Confluence [EQUIVALENT, 0 ms]
(2) QTRS
(3) DependencyPairsProof [EQUIVALENT, 0 ms]
(4) QDP
(5) DependencyGraphProof [EQUIVALENT, 0 ms]
(6) AND
    (7) QDP
        (8) UsableRulesProof [EQUIVALENT, 0 ms]
        (9) QDP
        (10) QReductionProof [EQUIVALENT, 0 ms]
        (11) QDP
        (12) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (13) YES
    (14) QDP
        (15) UsableRulesProof [EQUIVALENT, 0 ms]
        (16) QDP
        (17) QReductionProof [EQUIVALENT, 0 ms]
        (18) QDP
        (19) QDPOrderProof [EQUIVALENT, 13 ms]
        (20) QDP
        (21) Induction-Processor [SOUND, 7 ms]
        (22) AND
            (23) QDP
                (24) DependencyGraphProof [EQUIVALENT, 0 ms]
                (25) TRUE
            (26) QTRS
                (27) QTRSRRRProof [EQUIVALENT, 0 ms]
                (28) QTRS
                (29) RisEmptyProof [EQUIVALENT, 0 ms]
                (30) YES


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   sub(0, 0) -> 0
   sub(s(x), 0) -> s(x)
   sub(0, s(x)) -> 0
   sub(s(x), s(y)) -> sub(x, y)
   zero(nil) -> zero2(0, nil)
   zero(cons(x, xs)) -> zero2(sub(x, x), cons(x, xs))
   zero2(0, nil) -> nil
   zero2(0, cons(x, xs)) -> cons(sub(x, x), zero(xs))
   zero2(s(y), nil) -> zero(nil)
   zero2(s(y), cons(x, xs)) -> zero(cons(x, xs))

Q is empty.

----------------------------------------

(1) Overlay + Local Confluence (EQUIVALENT)
The TRS is overlay and locally confluent. By [NOC] we can switch to innermost.
----------------------------------------

(2)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   sub(0, 0) -> 0
   sub(s(x), 0) -> s(x)
   sub(0, s(x)) -> 0
   sub(s(x), s(y)) -> sub(x, y)
   zero(nil) -> zero2(0, nil)
   zero(cons(x, xs)) -> zero2(sub(x, x), cons(x, xs))
   zero2(0, nil) -> nil
   zero2(0, cons(x, xs)) -> cons(sub(x, x), zero(xs))
   zero2(s(y), nil) -> zero(nil)
   zero2(s(y), cons(x, xs)) -> zero(cons(x, xs))

The set Q consists of the following terms:

   sub(0, 0)
   sub(s(x0), 0)
   sub(0, s(x0))
   sub(s(x0), s(x1))
   zero(nil)
   zero(cons(x0, x1))
   zero2(0, nil)
   zero2(0, cons(x0, x1))
   zero2(s(x0), nil)
   zero2(s(x0), cons(x1, x2))


----------------------------------------

(3) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(4)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   SUB(s(x), s(y)) -> SUB(x, y)
   ZERO(nil) -> ZERO2(0, nil)
   ZERO(cons(x, xs)) -> ZERO2(sub(x, x), cons(x, xs))
   ZERO(cons(x, xs)) -> SUB(x, x)
   ZERO2(0, cons(x, xs)) -> SUB(x, x)
   ZERO2(0, cons(x, xs)) -> ZERO(xs)
   ZERO2(s(y), nil) -> ZERO(nil)
   ZERO2(s(y), cons(x, xs)) -> ZERO(cons(x, xs))

The TRS R consists of the following rules:

   sub(0, 0) -> 0
   sub(s(x), 0) -> s(x)
   sub(0, s(x)) -> 0
   sub(s(x), s(y)) -> sub(x, y)
   zero(nil) -> zero2(0, nil)
   zero(cons(x, xs)) -> zero2(sub(x, x), cons(x, xs))
   zero2(0, nil) -> nil
   zero2(0, cons(x, xs)) -> cons(sub(x, x), zero(xs))
   zero2(s(y), nil) -> zero(nil)
   zero2(s(y), cons(x, xs)) -> zero(cons(x, xs))

The set Q consists of the following terms:

   sub(0, 0)
   sub(s(x0), 0)
   sub(0, s(x0))
   sub(s(x0), s(x1))
   zero(nil)
   zero(cons(x0, x1))
   zero2(0, nil)
   zero2(0, cons(x0, x1))
   zero2(s(x0), nil)
   zero2(s(x0), cons(x1, x2))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(5) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 2 SCCs with 4 less nodes.
----------------------------------------

(6)
Complex Obligation (AND)

----------------------------------------

(7)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   SUB(s(x), s(y)) -> SUB(x, y)

The TRS R consists of the following rules:

   sub(0, 0) -> 0
   sub(s(x), 0) -> s(x)
   sub(0, s(x)) -> 0
   sub(s(x), s(y)) -> sub(x, y)
   zero(nil) -> zero2(0, nil)
   zero(cons(x, xs)) -> zero2(sub(x, x), cons(x, xs))
   zero2(0, nil) -> nil
   zero2(0, cons(x, xs)) -> cons(sub(x, x), zero(xs))
   zero2(s(y), nil) -> zero(nil)
   zero2(s(y), cons(x, xs)) -> zero(cons(x, xs))

The set Q consists of the following terms:

   sub(0, 0)
   sub(s(x0), 0)
   sub(0, s(x0))
   sub(s(x0), s(x1))
   zero(nil)
   zero(cons(x0, x1))
   zero2(0, nil)
   zero2(0, cons(x0, x1))
   zero2(s(x0), nil)
   zero2(s(x0), cons(x1, x2))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(8) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(9)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   SUB(s(x), s(y)) -> SUB(x, y)

R is empty.
The set Q consists of the following terms:

   sub(0, 0)
   sub(s(x0), 0)
   sub(0, s(x0))
   sub(s(x0), s(x1))
   zero(nil)
   zero(cons(x0, x1))
   zero2(0, nil)
   zero2(0, cons(x0, x1))
   zero2(s(x0), nil)
   zero2(s(x0), cons(x1, x2))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(10) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   sub(0, 0)
   sub(s(x0), 0)
   sub(0, s(x0))
   sub(s(x0), s(x1))
   zero(nil)
   zero(cons(x0, x1))
   zero2(0, nil)
   zero2(0, cons(x0, x1))
   zero2(s(x0), nil)
   zero2(s(x0), cons(x1, x2))


----------------------------------------

(11)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   SUB(s(x), s(y)) -> SUB(x, y)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(12) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*SUB(s(x), s(y)) -> SUB(x, y)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(13)
YES

----------------------------------------

(14)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ZERO(cons(x, xs)) -> ZERO2(sub(x, x), cons(x, xs))
   ZERO2(0, cons(x, xs)) -> ZERO(xs)
   ZERO2(s(y), cons(x, xs)) -> ZERO(cons(x, xs))

The TRS R consists of the following rules:

   sub(0, 0) -> 0
   sub(s(x), 0) -> s(x)
   sub(0, s(x)) -> 0
   sub(s(x), s(y)) -> sub(x, y)
   zero(nil) -> zero2(0, nil)
   zero(cons(x, xs)) -> zero2(sub(x, x), cons(x, xs))
   zero2(0, nil) -> nil
   zero2(0, cons(x, xs)) -> cons(sub(x, x), zero(xs))
   zero2(s(y), nil) -> zero(nil)
   zero2(s(y), cons(x, xs)) -> zero(cons(x, xs))

The set Q consists of the following terms:

   sub(0, 0)
   sub(s(x0), 0)
   sub(0, s(x0))
   sub(s(x0), s(x1))
   zero(nil)
   zero(cons(x0, x1))
   zero2(0, nil)
   zero2(0, cons(x0, x1))
   zero2(s(x0), nil)
   zero2(s(x0), cons(x1, x2))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(15) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(16)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ZERO(cons(x, xs)) -> ZERO2(sub(x, x), cons(x, xs))
   ZERO2(0, cons(x, xs)) -> ZERO(xs)
   ZERO2(s(y), cons(x, xs)) -> ZERO(cons(x, xs))

The TRS R consists of the following rules:

   sub(0, 0) -> 0
   sub(s(x), s(y)) -> sub(x, y)
   sub(s(x), 0) -> s(x)
   sub(0, s(x)) -> 0

The set Q consists of the following terms:

   sub(0, 0)
   sub(s(x0), 0)
   sub(0, s(x0))
   sub(s(x0), s(x1))
   zero(nil)
   zero(cons(x0, x1))
   zero2(0, nil)
   zero2(0, cons(x0, x1))
   zero2(s(x0), nil)
   zero2(s(x0), cons(x1, x2))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(17) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   zero(nil)
   zero(cons(x0, x1))
   zero2(0, nil)
   zero2(0, cons(x0, x1))
   zero2(s(x0), nil)
   zero2(s(x0), cons(x1, x2))


----------------------------------------

(18)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ZERO(cons(x, xs)) -> ZERO2(sub(x, x), cons(x, xs))
   ZERO2(0, cons(x, xs)) -> ZERO(xs)
   ZERO2(s(y), cons(x, xs)) -> ZERO(cons(x, xs))

The TRS R consists of the following rules:

   sub(0, 0) -> 0
   sub(s(x), s(y)) -> sub(x, y)
   sub(s(x), 0) -> s(x)
   sub(0, s(x)) -> 0

The set Q consists of the following terms:

   sub(0, 0)
   sub(s(x0), 0)
   sub(0, s(x0))
   sub(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(19) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ZERO2(0, cons(x, xs)) -> ZERO(xs)
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
ZERO(x1)  =  x1

cons(x1, x2)  =  cons(x2)

ZERO2(x1, x2)  =  x2


Knuth-Bendix order [KBO] with precedence:trivial

and weight map:

   dummyConstant=1
   cons_1=1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:
none


----------------------------------------

(20)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ZERO(cons(x, xs)) -> ZERO2(sub(x, x), cons(x, xs))
   ZERO2(s(y), cons(x, xs)) -> ZERO(cons(x, xs))

The TRS R consists of the following rules:

   sub(0, 0) -> 0
   sub(s(x), s(y)) -> sub(x, y)
   sub(s(x), 0) -> s(x)
   sub(0, s(x)) -> 0

The set Q consists of the following terms:

   sub(0, 0)
   sub(s(x0), 0)
   sub(0, s(x0))
   sub(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(21) Induction-Processor (SOUND)

This DP could be deleted by the Induction-Processor:
ZERO(cons(x, xs)) -> ZERO2(sub(x, x), cons(x, xs))


This order was computed:
Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(ZERO(x_1)) = 1 + x_1
   POL(ZERO2(x_1, x_2)) = x_1 + x_2
   POL(cons(x_1, x_2)) = 1 + x_1 + x_2
   POL(s(x_1)) = 1
   POL(sub(x_1, x_2)) = 1

At least one of these decreasing rules is always used after the deleted DP:
sub(0, 0) -> 0
sub(0, s(x2)) -> 0


The following formula is valid:
x:sort[a12].sub'(x, x)=true


The transformed set:
sub'(0, 0) -> true
sub'(s(x''), s(y')) -> sub'(x'', y')
sub'(s(x1), 0) -> false
sub'(0, s(x2)) -> true
sub(0, 0) -> 0
sub(s(x''), s(y')) -> sub(x'', y')
sub(s(x1), 0) -> s(x1)
sub(0, s(x2)) -> 0
equal_bool(true, false) -> false
equal_bool(false, true) -> false
equal_bool(true, true) -> true
equal_bool(false, false) -> true
and(true, x) -> x
and(false, x) -> false
or(true, x) -> true
or(false, x) -> x
not(false) -> true
not(true) -> false
isa_true(true) -> true
isa_true(false) -> false
isa_false(true) -> false
isa_false(false) -> true
equal_sort[a12](0, 0) -> true
equal_sort[a12](0, s(v5)) -> false
equal_sort[a12](s(v6), 0) -> false
equal_sort[a12](s(v6), s(v7)) -> equal_sort[a12](v6, v7)
equal_sort[a5](witness_sort[a5], witness_sort[a5]) -> true
equal_sort[a19](cons(v8, v9), cons(v10, v11)) -> and(equal_sort[a12](v8, v10), equal_sort[a5](v9, v11))
equal_sort[a19](cons(v8, v9), witness_sort[a19]) -> false
equal_sort[a19](witness_sort[a19], cons(v12, v13)) -> false
equal_sort[a19](witness_sort[a19], witness_sort[a19]) -> true
equal_sort[a16](witness_sort[a16], witness_sort[a16]) -> true


The proof given by the theorem prover:
The following output was given by the internal theorem prover:proof of internal
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Partial correctness of the following Program

   [x, v5, v6, v7, v8, v9, v10, v11, v12, v13, x'', y', x1, x2]
   equal_bool(true, false) -> false
   equal_bool(false, true) -> false
   equal_bool(true, true) -> true
   equal_bool(false, false) -> true
   true and x -> x
   false and x -> false
   true or x -> true
   false or x -> x
   not(false) -> true
   not(true) -> false
   isa_true(true) -> true
   isa_true(false) -> false
   isa_false(true) -> false
   isa_false(false) -> true
   equal_sort[a12](0, 0) -> true
   equal_sort[a12](0, s(v5)) -> false
   equal_sort[a12](s(v6), 0) -> false
   equal_sort[a12](s(v6), s(v7)) -> equal_sort[a12](v6, v7)
   equal_sort[a5](witness_sort[a5], witness_sort[a5]) -> true
   equal_sort[a19](cons(v8, v9), cons(v10, v11)) -> equal_sort[a12](v8, v10) and equal_sort[a5](v9, v11)
   equal_sort[a19](cons(v8, v9), witness_sort[a19]) -> false
   equal_sort[a19](witness_sort[a19], cons(v12, v13)) -> false
   equal_sort[a19](witness_sort[a19], witness_sort[a19]) -> true
   equal_sort[a16](witness_sort[a16], witness_sort[a16]) -> true
   sub'(0, 0) -> true
   sub'(s(x''), s(y')) -> sub'(x'', y')
   sub'(s(x1), 0) -> false
   sub'(0, s(x2)) -> true
   sub(0, 0) -> 0
   sub(s(x''), s(y')) -> sub(x'', y')
   sub(s(x1), 0) -> s(x1)
   sub(0, s(x2)) -> 0

using the following formula:
x:sort[a12].sub'(x, x)=true

could be successfully shown:
(0) Formula
(1) Induction by data structure [EQUIVALENT, 0 ms]
(2) AND
    (3) Formula
        (4) Symbolic evaluation [EQUIVALENT, 0 ms]
        (5) YES
    (6) Formula
        (7) Symbolic evaluation under hypothesis [EQUIVALENT, 0 ms]
        (8) YES


----------------------------------------

(0)
Obligation:
Formula:
x:sort[a12].sub'(x, x)=true

There are no hypotheses.




----------------------------------------

(1) Induction by data structure (EQUIVALENT)
Induction by data structure sort[a12] generates the following cases:



1. Base Case:
Formula:
sub'(0, 0)=true

There are no hypotheses.





1. Step Case:
Formula:
n:sort[a12].sub'(s(n), s(n))=true

Hypotheses:
n:sort[a12].sub'(n, n)=true






----------------------------------------

(2)
Complex Obligation (AND)

----------------------------------------

(3)
Obligation:
Formula:
sub'(0, 0)=true

There are no hypotheses.




----------------------------------------

(4) Symbolic evaluation (EQUIVALENT)
Could be reduced to the following new obligation by simple symbolic evaluation:
True
----------------------------------------

(5)
YES

----------------------------------------

(6)
Obligation:
Formula:
n:sort[a12].sub'(s(n), s(n))=true

Hypotheses:
n:sort[a12].sub'(n, n)=true




----------------------------------------

(7) Symbolic evaluation under hypothesis (EQUIVALENT)
Could be shown using symbolic evaluation under hypothesis, by using the following hypotheses:

n:sort[a12].sub'(n, n)=true

----------------------------------------

(8)
YES

----------------------------------------

(22)
Complex Obligation (AND)

----------------------------------------

(23)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ZERO2(s(y), cons(x, xs)) -> ZERO(cons(x, xs))

The TRS R consists of the following rules:

   sub(0, 0) -> 0
   sub(s(x), s(y)) -> sub(x, y)
   sub(s(x), 0) -> s(x)
   sub(0, s(x)) -> 0

The set Q consists of the following terms:

   sub(0, 0)
   sub(s(x0), 0)
   sub(0, s(x0))
   sub(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(24) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 1 less node.
----------------------------------------

(25)
TRUE

----------------------------------------

(26)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   sub'(0, 0) -> true
   sub'(s(x''), s(y')) -> sub'(x'', y')
   sub'(s(x1), 0) -> false
   sub'(0, s(x2)) -> true
   sub(0, 0) -> 0
   sub(s(x''), s(y')) -> sub(x'', y')
   sub(s(x1), 0) -> s(x1)
   sub(0, s(x2)) -> 0
   equal_bool(true, false) -> false
   equal_bool(false, true) -> false
   equal_bool(true, true) -> true
   equal_bool(false, false) -> true
   and(true, x) -> x
   and(false, x) -> false
   or(true, x) -> true
   or(false, x) -> x
   not(false) -> true
   not(true) -> false
   isa_true(true) -> true
   isa_true(false) -> false
   isa_false(true) -> false
   isa_false(false) -> true
   equal_sort[a12](0, 0) -> true
   equal_sort[a12](0, s(v5)) -> false
   equal_sort[a12](s(v6), 0) -> false
   equal_sort[a12](s(v6), s(v7)) -> equal_sort[a12](v6, v7)
   equal_sort[a5](witness_sort[a5], witness_sort[a5]) -> true
   equal_sort[a19](cons(v8, v9), cons(v10, v11)) -> and(equal_sort[a12](v8, v10), equal_sort[a5](v9, v11))
   equal_sort[a19](cons(v8, v9), witness_sort[a19]) -> false
   equal_sort[a19](witness_sort[a19], cons(v12, v13)) -> false
   equal_sort[a19](witness_sort[a19], witness_sort[a19]) -> true
   equal_sort[a16](witness_sort[a16], witness_sort[a16]) -> true

Q is empty.

----------------------------------------

(27) QTRSRRRProof (EQUIVALENT)
Used ordering:
Knuth-Bendix order [KBO] with precedence:sub'_2 > 0 > sub_2 > witness_sort[a16] > equal_sort[a16]_2 > witness_sort[a19] > cons_2 > equal_sort[a19]_2 > witness_sort[a5] > equal_sort[a5]_2 > equal_sort[a12]_2 > isa_false_1 > equal_bool_2 > isa_true_1 > s_1 > true > and_2 > false > or_2 > not_1

and weight map:

   0=2
   true=3
   false=4
   witness_sort[a5]=1
   witness_sort[a19]=1
   witness_sort[a16]=1
   s_1=1
   not_1=2
   isa_true_1=1
   isa_false_1=2
   sub'_2=0
   sub_2=0
   equal_bool_2=0
   and_2=0
   or_2=0
   equal_sort[a12]_2=1
   equal_sort[a5]_2=1
   equal_sort[a19]_2=2
   cons_2=0
   equal_sort[a16]_2=1

The variable weight is 1With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   sub'(0, 0) -> true
   sub'(s(x''), s(y')) -> sub'(x'', y')
   sub'(s(x1), 0) -> false
   sub'(0, s(x2)) -> true
   sub(0, 0) -> 0
   sub(s(x''), s(y')) -> sub(x'', y')
   sub(s(x1), 0) -> s(x1)
   sub(0, s(x2)) -> 0
   equal_bool(true, false) -> false
   equal_bool(false, true) -> false
   equal_bool(true, true) -> true
   equal_bool(false, false) -> true
   and(true, x) -> x
   and(false, x) -> false
   or(true, x) -> true
   or(false, x) -> x
   not(false) -> true
   not(true) -> false
   isa_true(true) -> true
   isa_true(false) -> false
   isa_false(true) -> false
   isa_false(false) -> true
   equal_sort[a12](0, 0) -> true
   equal_sort[a12](0, s(v5)) -> false
   equal_sort[a12](s(v6), 0) -> false
   equal_sort[a12](s(v6), s(v7)) -> equal_sort[a12](v6, v7)
   equal_sort[a5](witness_sort[a5], witness_sort[a5]) -> true
   equal_sort[a19](cons(v8, v9), cons(v10, v11)) -> and(equal_sort[a12](v8, v10), equal_sort[a5](v9, v11))
   equal_sort[a19](cons(v8, v9), witness_sort[a19]) -> false
   equal_sort[a19](witness_sort[a19], cons(v12, v13)) -> false
   equal_sort[a19](witness_sort[a19], witness_sort[a19]) -> true
   equal_sort[a16](witness_sort[a16], witness_sort[a16]) -> true




----------------------------------------

(28)
Obligation:
Q restricted rewrite system:
R is empty.
Q is empty.

----------------------------------------

(29) RisEmptyProof (EQUIVALENT)
The TRS R is empty. Hence, termination is trivially proven.
----------------------------------------

(30)
YES
