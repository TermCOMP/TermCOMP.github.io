YES

Problem 1: 

(VAR vu95NonEmpty K L Lp S Sp T Tp X Xp Y Z)
(RULES
and(ffalse,ffalse) -> ffalse
and(ffalse,ftrue) -> ffalse
and(ftrue,ffalse) -> ffalse
and(ftrue,ftrue) -> ftrue
eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
eq(apply(T,S),lambda(X,Tp)) -> ffalse
eq(apply(T,S),var(L)) -> ffalse
eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
eq(cons(T,L),nil) -> ffalse
eq(lambda(X,T),apply(Tp,Sp)) -> ffalse
eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
eq(lambda(X,T),var(L)) -> ffalse
eq(nil,cons(T,L)) -> ffalse
eq(nil,nil) -> ftrue
eq(var(L),apply(T,S)) -> ffalse
eq(var(L),lambda(X,T)) -> ffalse
eq(var(L),var(Lp)) -> eq(L,Lp)
if(ffalse,var(K),var(L)) -> var(L)
if(ftrue,var(K),var(L)) -> var(K)
ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)))
)


Problem 1: 

Innermost Equivalent Processor:
-> Rules:
 and(ffalse,ffalse) -> ffalse
 and(ffalse,ftrue) -> ffalse
 and(ftrue,ffalse) -> ffalse
 and(ftrue,ftrue) -> ftrue
 eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
 eq(apply(T,S),lambda(X,Tp)) -> ffalse
 eq(apply(T,S),var(L)) -> ffalse
 eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
 eq(cons(T,L),nil) -> ffalse
 eq(lambda(X,T),apply(Tp,Sp)) -> ffalse
 eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
 eq(lambda(X,T),var(L)) -> ffalse
 eq(nil,cons(T,L)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(L),apply(T,S)) -> ffalse
 eq(var(L),lambda(X,T)) -> ffalse
 eq(var(L),var(Lp)) -> eq(L,Lp)
 if(ffalse,var(K),var(L)) -> var(L)
 if(ftrue,var(K),var(L)) -> var(K)
 ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
 ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
 ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)))
-> The term rewriting system is non-overlaping or locally confluent overlay system. Therefore, innermost termination implies termination.
 

Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 EQ(apply(T,S),apply(Tp,Sp)) -> AND(eq(T,Tp),eq(S,Sp))
 EQ(apply(T,S),apply(Tp,Sp)) -> EQ(S,Sp)
 EQ(apply(T,S),apply(Tp,Sp)) -> EQ(T,Tp)
 EQ(cons(T,L),cons(Tp,Lp)) -> AND(eq(T,Tp),eq(L,Lp))
 EQ(cons(T,L),cons(Tp,Lp)) -> EQ(L,Lp)
 EQ(cons(T,L),cons(Tp,Lp)) -> EQ(T,Tp)
 EQ(lambda(X,T),lambda(Xp,Tp)) -> AND(eq(T,Tp),eq(X,Xp))
 EQ(lambda(X,T),lambda(Xp,Tp)) -> EQ(T,Tp)
 EQ(lambda(X,T),lambda(Xp,Tp)) -> EQ(X,Xp)
 EQ(var(L),var(Lp)) -> EQ(L,Lp)
 REN(var(L),var(K),var(Lp)) -> EQ(L,Lp)
 REN(var(L),var(K),var(Lp)) -> IF(eq(L,Lp),var(K),var(Lp))
 REN(X,Y,apply(T,S)) -> REN(X,Y,S)
 REN(X,Y,apply(T,S)) -> REN(X,Y,T)
 REN(X,Y,lambda(Z,T)) -> REN(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T))
 REN(X,Y,lambda(Z,T)) -> REN(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)
-> Rules:
 and(ffalse,ffalse) -> ffalse
 and(ffalse,ftrue) -> ffalse
 and(ftrue,ffalse) -> ffalse
 and(ftrue,ftrue) -> ftrue
 eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
 eq(apply(T,S),lambda(X,Tp)) -> ffalse
 eq(apply(T,S),var(L)) -> ffalse
 eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
 eq(cons(T,L),nil) -> ffalse
 eq(lambda(X,T),apply(Tp,Sp)) -> ffalse
 eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
 eq(lambda(X,T),var(L)) -> ffalse
 eq(nil,cons(T,L)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(L),apply(T,S)) -> ffalse
 eq(var(L),lambda(X,T)) -> ffalse
 eq(var(L),var(Lp)) -> eq(L,Lp)
 if(ffalse,var(K),var(L)) -> var(L)
 if(ftrue,var(K),var(L)) -> var(K)
 ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
 ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
 ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)))

Problem 1: 

SCC Processor:
-> Pairs:
 EQ(apply(T,S),apply(Tp,Sp)) -> AND(eq(T,Tp),eq(S,Sp))
 EQ(apply(T,S),apply(Tp,Sp)) -> EQ(S,Sp)
 EQ(apply(T,S),apply(Tp,Sp)) -> EQ(T,Tp)
 EQ(cons(T,L),cons(Tp,Lp)) -> AND(eq(T,Tp),eq(L,Lp))
 EQ(cons(T,L),cons(Tp,Lp)) -> EQ(L,Lp)
 EQ(cons(T,L),cons(Tp,Lp)) -> EQ(T,Tp)
 EQ(lambda(X,T),lambda(Xp,Tp)) -> AND(eq(T,Tp),eq(X,Xp))
 EQ(lambda(X,T),lambda(Xp,Tp)) -> EQ(T,Tp)
 EQ(lambda(X,T),lambda(Xp,Tp)) -> EQ(X,Xp)
 EQ(var(L),var(Lp)) -> EQ(L,Lp)
 REN(var(L),var(K),var(Lp)) -> EQ(L,Lp)
 REN(var(L),var(K),var(Lp)) -> IF(eq(L,Lp),var(K),var(Lp))
 REN(X,Y,apply(T,S)) -> REN(X,Y,S)
 REN(X,Y,apply(T,S)) -> REN(X,Y,T)
 REN(X,Y,lambda(Z,T)) -> REN(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T))
 REN(X,Y,lambda(Z,T)) -> REN(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)
-> Rules:
 and(ffalse,ffalse) -> ffalse
 and(ffalse,ftrue) -> ffalse
 and(ftrue,ffalse) -> ffalse
 and(ftrue,ftrue) -> ftrue
 eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
 eq(apply(T,S),lambda(X,Tp)) -> ffalse
 eq(apply(T,S),var(L)) -> ffalse
 eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
 eq(cons(T,L),nil) -> ffalse
 eq(lambda(X,T),apply(Tp,Sp)) -> ffalse
 eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
 eq(lambda(X,T),var(L)) -> ffalse
 eq(nil,cons(T,L)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(L),apply(T,S)) -> ffalse
 eq(var(L),lambda(X,T)) -> ffalse
 eq(var(L),var(Lp)) -> eq(L,Lp)
 if(ffalse,var(K),var(L)) -> var(L)
 if(ftrue,var(K),var(L)) -> var(K)
 ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
 ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
 ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)))
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 EQ(apply(T,S),apply(Tp,Sp)) -> EQ(S,Sp)
 EQ(apply(T,S),apply(Tp,Sp)) -> EQ(T,Tp)
 EQ(cons(T,L),cons(Tp,Lp)) -> EQ(L,Lp)
 EQ(cons(T,L),cons(Tp,Lp)) -> EQ(T,Tp)
 EQ(lambda(X,T),lambda(Xp,Tp)) -> EQ(T,Tp)
 EQ(lambda(X,T),lambda(Xp,Tp)) -> EQ(X,Xp)
 EQ(var(L),var(Lp)) -> EQ(L,Lp)
->->-> Rules:
 and(ffalse,ffalse) -> ffalse
 and(ffalse,ftrue) -> ffalse
 and(ftrue,ffalse) -> ffalse
 and(ftrue,ftrue) -> ftrue
 eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
 eq(apply(T,S),lambda(X,Tp)) -> ffalse
 eq(apply(T,S),var(L)) -> ffalse
 eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
 eq(cons(T,L),nil) -> ffalse
 eq(lambda(X,T),apply(Tp,Sp)) -> ffalse
 eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
 eq(lambda(X,T),var(L)) -> ffalse
 eq(nil,cons(T,L)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(L),apply(T,S)) -> ffalse
 eq(var(L),lambda(X,T)) -> ffalse
 eq(var(L),var(Lp)) -> eq(L,Lp)
 if(ffalse,var(K),var(L)) -> var(L)
 if(ftrue,var(K),var(L)) -> var(K)
 ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
 ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
 ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)))
->->Cycle:
->->-> Pairs:
 REN(X,Y,apply(T,S)) -> REN(X,Y,S)
 REN(X,Y,apply(T,S)) -> REN(X,Y,T)
 REN(X,Y,lambda(Z,T)) -> REN(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T))
 REN(X,Y,lambda(Z,T)) -> REN(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)
->->-> Rules:
 and(ffalse,ffalse) -> ffalse
 and(ffalse,ftrue) -> ffalse
 and(ftrue,ffalse) -> ffalse
 and(ftrue,ftrue) -> ftrue
 eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
 eq(apply(T,S),lambda(X,Tp)) -> ffalse
 eq(apply(T,S),var(L)) -> ffalse
 eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
 eq(cons(T,L),nil) -> ffalse
 eq(lambda(X,T),apply(Tp,Sp)) -> ffalse
 eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
 eq(lambda(X,T),var(L)) -> ffalse
 eq(nil,cons(T,L)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(L),apply(T,S)) -> ffalse
 eq(var(L),lambda(X,T)) -> ffalse
 eq(var(L),var(Lp)) -> eq(L,Lp)
 if(ffalse,var(K),var(L)) -> var(L)
 if(ftrue,var(K),var(L)) -> var(K)
 ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
 ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
 ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)))


The problem is decomposed in 2 subproblems.

Problem 1.1: 

Subterm Processor:
-> Pairs:
 EQ(apply(T,S),apply(Tp,Sp)) -> EQ(S,Sp)
 EQ(apply(T,S),apply(Tp,Sp)) -> EQ(T,Tp)
 EQ(cons(T,L),cons(Tp,Lp)) -> EQ(L,Lp)
 EQ(cons(T,L),cons(Tp,Lp)) -> EQ(T,Tp)
 EQ(lambda(X,T),lambda(Xp,Tp)) -> EQ(T,Tp)
 EQ(lambda(X,T),lambda(Xp,Tp)) -> EQ(X,Xp)
 EQ(var(L),var(Lp)) -> EQ(L,Lp)
-> Rules:
 and(ffalse,ffalse) -> ffalse
 and(ffalse,ftrue) -> ffalse
 and(ftrue,ffalse) -> ffalse
 and(ftrue,ftrue) -> ftrue
 eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
 eq(apply(T,S),lambda(X,Tp)) -> ffalse
 eq(apply(T,S),var(L)) -> ffalse
 eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
 eq(cons(T,L),nil) -> ffalse
 eq(lambda(X,T),apply(Tp,Sp)) -> ffalse
 eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
 eq(lambda(X,T),var(L)) -> ffalse
 eq(nil,cons(T,L)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(L),apply(T,S)) -> ffalse
 eq(var(L),lambda(X,T)) -> ffalse
 eq(var(L),var(Lp)) -> eq(L,Lp)
 if(ffalse,var(K),var(L)) -> var(L)
 if(ftrue,var(K),var(L)) -> var(K)
 ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
 ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
 ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)))
->Projection:
 pi(EQ) = 1

Problem 1.1: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 and(ffalse,ffalse) -> ffalse
 and(ffalse,ftrue) -> ffalse
 and(ftrue,ffalse) -> ffalse
 and(ftrue,ftrue) -> ftrue
 eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
 eq(apply(T,S),lambda(X,Tp)) -> ffalse
 eq(apply(T,S),var(L)) -> ffalse
 eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
 eq(cons(T,L),nil) -> ffalse
 eq(lambda(X,T),apply(Tp,Sp)) -> ffalse
 eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
 eq(lambda(X,T),var(L)) -> ffalse
 eq(nil,cons(T,L)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(L),apply(T,S)) -> ffalse
 eq(var(L),lambda(X,T)) -> ffalse
 eq(var(L),var(Lp)) -> eq(L,Lp)
 if(ffalse,var(K),var(L)) -> var(L)
 if(ftrue,var(K),var(L)) -> var(K)
 ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
 ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
 ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)))
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2: 

Reduction Pairs Processor:
-> Pairs:
 REN(X,Y,apply(T,S)) -> REN(X,Y,S)
 REN(X,Y,apply(T,S)) -> REN(X,Y,T)
 REN(X,Y,lambda(Z,T)) -> REN(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T))
 REN(X,Y,lambda(Z,T)) -> REN(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)
-> Rules:
 and(ffalse,ffalse) -> ffalse
 and(ffalse,ftrue) -> ffalse
 and(ftrue,ffalse) -> ffalse
 and(ftrue,ftrue) -> ftrue
 eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
 eq(apply(T,S),lambda(X,Tp)) -> ffalse
 eq(apply(T,S),var(L)) -> ffalse
 eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
 eq(cons(T,L),nil) -> ffalse
 eq(lambda(X,T),apply(Tp,Sp)) -> ffalse
 eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
 eq(lambda(X,T),var(L)) -> ffalse
 eq(nil,cons(T,L)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(L),apply(T,S)) -> ffalse
 eq(var(L),lambda(X,T)) -> ffalse
 eq(var(L),var(Lp)) -> eq(L,Lp)
 if(ffalse,var(K),var(L)) -> var(L)
 if(ftrue,var(K),var(L)) -> var(K)
 ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
 ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
 ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)))
-> Usable rules:
 and(ffalse,ffalse) -> ffalse
 and(ffalse,ftrue) -> ffalse
 and(ftrue,ffalse) -> ffalse
 and(ftrue,ftrue) -> ftrue
 eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
 eq(apply(T,S),lambda(X,Tp)) -> ffalse
 eq(apply(T,S),var(L)) -> ffalse
 eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
 eq(cons(T,L),nil) -> ffalse
 eq(lambda(X,T),apply(Tp,Sp)) -> ffalse
 eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
 eq(lambda(X,T),var(L)) -> ffalse
 eq(nil,cons(T,L)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(L),apply(T,S)) -> ffalse
 eq(var(L),lambda(X,T)) -> ffalse
 eq(var(L),var(Lp)) -> eq(L,Lp)
 if(ffalse,var(K),var(L)) -> var(L)
 if(ftrue,var(K),var(L)) -> var(K)
 ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
 ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
 ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)))
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[and](X1,X2) = 2
[eq](X1,X2) = 2
[if](X1,X2,X3) = 2.X3
[ren](X1,X2,X3) = X3
[apply](X1,X2) = 2.X1 + 2.X2 + 2
[cons](X1,X2) = 1
[fSNonEmpty] = 0
[ffalse] = 2
[lambda](X1,X2) = X1 + X2 + 2
[nil] = 2
[ftrue] = 0
[var](X) = 0
[AND](X1,X2) = 0
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[REN](X1,X2,X3) = X1 + 2.X2 + 2.X3

Problem 1.2: 

SCC Processor:
-> Pairs:
 REN(X,Y,apply(T,S)) -> REN(X,Y,T)
 REN(X,Y,lambda(Z,T)) -> REN(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T))
 REN(X,Y,lambda(Z,T)) -> REN(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)
-> Rules:
 and(ffalse,ffalse) -> ffalse
 and(ffalse,ftrue) -> ffalse
 and(ftrue,ffalse) -> ffalse
 and(ftrue,ftrue) -> ftrue
 eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
 eq(apply(T,S),lambda(X,Tp)) -> ffalse
 eq(apply(T,S),var(L)) -> ffalse
 eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
 eq(cons(T,L),nil) -> ffalse
 eq(lambda(X,T),apply(Tp,Sp)) -> ffalse
 eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
 eq(lambda(X,T),var(L)) -> ffalse
 eq(nil,cons(T,L)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(L),apply(T,S)) -> ffalse
 eq(var(L),lambda(X,T)) -> ffalse
 eq(var(L),var(Lp)) -> eq(L,Lp)
 if(ffalse,var(K),var(L)) -> var(L)
 if(ftrue,var(K),var(L)) -> var(K)
 ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
 ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
 ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)))
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 REN(X,Y,apply(T,S)) -> REN(X,Y,T)
 REN(X,Y,lambda(Z,T)) -> REN(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T))
 REN(X,Y,lambda(Z,T)) -> REN(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)
->->-> Rules:
 and(ffalse,ffalse) -> ffalse
 and(ffalse,ftrue) -> ffalse
 and(ftrue,ffalse) -> ffalse
 and(ftrue,ftrue) -> ftrue
 eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
 eq(apply(T,S),lambda(X,Tp)) -> ffalse
 eq(apply(T,S),var(L)) -> ffalse
 eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
 eq(cons(T,L),nil) -> ffalse
 eq(lambda(X,T),apply(Tp,Sp)) -> ffalse
 eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
 eq(lambda(X,T),var(L)) -> ffalse
 eq(nil,cons(T,L)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(L),apply(T,S)) -> ffalse
 eq(var(L),lambda(X,T)) -> ffalse
 eq(var(L),var(Lp)) -> eq(L,Lp)
 if(ffalse,var(K),var(L)) -> var(L)
 if(ftrue,var(K),var(L)) -> var(K)
 ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
 ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
 ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)))

Problem 1.2: 

Reduction Pairs Processor:
-> Pairs:
 REN(X,Y,apply(T,S)) -> REN(X,Y,T)
 REN(X,Y,lambda(Z,T)) -> REN(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T))
 REN(X,Y,lambda(Z,T)) -> REN(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)
-> Rules:
 and(ffalse,ffalse) -> ffalse
 and(ffalse,ftrue) -> ffalse
 and(ftrue,ffalse) -> ffalse
 and(ftrue,ftrue) -> ftrue
 eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
 eq(apply(T,S),lambda(X,Tp)) -> ffalse
 eq(apply(T,S),var(L)) -> ffalse
 eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
 eq(cons(T,L),nil) -> ffalse
 eq(lambda(X,T),apply(Tp,Sp)) -> ffalse
 eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
 eq(lambda(X,T),var(L)) -> ffalse
 eq(nil,cons(T,L)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(L),apply(T,S)) -> ffalse
 eq(var(L),lambda(X,T)) -> ffalse
 eq(var(L),var(Lp)) -> eq(L,Lp)
 if(ffalse,var(K),var(L)) -> var(L)
 if(ftrue,var(K),var(L)) -> var(K)
 ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
 ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
 ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)))
-> Usable rules:
 and(ffalse,ffalse) -> ffalse
 and(ffalse,ftrue) -> ffalse
 and(ftrue,ffalse) -> ffalse
 and(ftrue,ftrue) -> ftrue
 eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
 eq(apply(T,S),lambda(X,Tp)) -> ffalse
 eq(apply(T,S),var(L)) -> ffalse
 eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
 eq(cons(T,L),nil) -> ffalse
 eq(lambda(X,T),apply(Tp,Sp)) -> ffalse
 eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
 eq(lambda(X,T),var(L)) -> ffalse
 eq(nil,cons(T,L)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(L),apply(T,S)) -> ffalse
 eq(var(L),lambda(X,T)) -> ffalse
 eq(var(L),var(Lp)) -> eq(L,Lp)
 if(ffalse,var(K),var(L)) -> var(L)
 if(ftrue,var(K),var(L)) -> var(K)
 ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
 ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
 ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)))
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[and](X1,X2) = X2
[eq](X1,X2) = 2
[if](X1,X2,X3) = 2.X2
[ren](X1,X2,X3) = X3
[apply](X1,X2) = 2.X1 + 2
[cons](X1,X2) = 0
[fSNonEmpty] = 0
[ffalse] = 2
[lambda](X1,X2) = 2.X1 + X2 + 1
[nil] = 0
[ftrue] = 2
[var](X) = 0
[AND](X1,X2) = 0
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[REN](X1,X2,X3) = 2.X1 + 2.X2 + 2.X3

Problem 1.2: 

SCC Processor:
-> Pairs:
 REN(X,Y,lambda(Z,T)) -> REN(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T))
 REN(X,Y,lambda(Z,T)) -> REN(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)
-> Rules:
 and(ffalse,ffalse) -> ffalse
 and(ffalse,ftrue) -> ffalse
 and(ftrue,ffalse) -> ffalse
 and(ftrue,ftrue) -> ftrue
 eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
 eq(apply(T,S),lambda(X,Tp)) -> ffalse
 eq(apply(T,S),var(L)) -> ffalse
 eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
 eq(cons(T,L),nil) -> ffalse
 eq(lambda(X,T),apply(Tp,Sp)) -> ffalse
 eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
 eq(lambda(X,T),var(L)) -> ffalse
 eq(nil,cons(T,L)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(L),apply(T,S)) -> ffalse
 eq(var(L),lambda(X,T)) -> ffalse
 eq(var(L),var(Lp)) -> eq(L,Lp)
 if(ffalse,var(K),var(L)) -> var(L)
 if(ftrue,var(K),var(L)) -> var(K)
 ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
 ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
 ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)))
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 REN(X,Y,lambda(Z,T)) -> REN(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T))
 REN(X,Y,lambda(Z,T)) -> REN(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)
->->-> Rules:
 and(ffalse,ffalse) -> ffalse
 and(ffalse,ftrue) -> ffalse
 and(ftrue,ffalse) -> ffalse
 and(ftrue,ftrue) -> ftrue
 eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
 eq(apply(T,S),lambda(X,Tp)) -> ffalse
 eq(apply(T,S),var(L)) -> ffalse
 eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
 eq(cons(T,L),nil) -> ffalse
 eq(lambda(X,T),apply(Tp,Sp)) -> ffalse
 eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
 eq(lambda(X,T),var(L)) -> ffalse
 eq(nil,cons(T,L)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(L),apply(T,S)) -> ffalse
 eq(var(L),lambda(X,T)) -> ffalse
 eq(var(L),var(Lp)) -> eq(L,Lp)
 if(ffalse,var(K),var(L)) -> var(L)
 if(ftrue,var(K),var(L)) -> var(K)
 ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
 ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
 ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)))

Problem 1.2: 

Reduction Pairs Processor:
-> Pairs:
 REN(X,Y,lambda(Z,T)) -> REN(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T))
 REN(X,Y,lambda(Z,T)) -> REN(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)
-> Rules:
 and(ffalse,ffalse) -> ffalse
 and(ffalse,ftrue) -> ffalse
 and(ftrue,ffalse) -> ffalse
 and(ftrue,ftrue) -> ftrue
 eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
 eq(apply(T,S),lambda(X,Tp)) -> ffalse
 eq(apply(T,S),var(L)) -> ffalse
 eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
 eq(cons(T,L),nil) -> ffalse
 eq(lambda(X,T),apply(Tp,Sp)) -> ffalse
 eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
 eq(lambda(X,T),var(L)) -> ffalse
 eq(nil,cons(T,L)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(L),apply(T,S)) -> ffalse
 eq(var(L),lambda(X,T)) -> ffalse
 eq(var(L),var(Lp)) -> eq(L,Lp)
 if(ffalse,var(K),var(L)) -> var(L)
 if(ftrue,var(K),var(L)) -> var(K)
 ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
 ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
 ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)))
-> Usable rules:
 and(ffalse,ffalse) -> ffalse
 and(ffalse,ftrue) -> ffalse
 and(ftrue,ffalse) -> ffalse
 and(ftrue,ftrue) -> ftrue
 eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
 eq(apply(T,S),lambda(X,Tp)) -> ffalse
 eq(apply(T,S),var(L)) -> ffalse
 eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
 eq(cons(T,L),nil) -> ffalse
 eq(lambda(X,T),apply(Tp,Sp)) -> ffalse
 eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
 eq(lambda(X,T),var(L)) -> ffalse
 eq(nil,cons(T,L)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(L),apply(T,S)) -> ffalse
 eq(var(L),lambda(X,T)) -> ffalse
 eq(var(L),var(Lp)) -> eq(L,Lp)
 if(ffalse,var(K),var(L)) -> var(L)
 if(ftrue,var(K),var(L)) -> var(K)
 ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
 ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
 ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)))
->Interpretation type:
 Linear
->Coefficients:
 Natural Numbers
->Dimension:
 1
->Bound:
 2
->Interpretation:
 
[and](X1,X2) = 2
[eq](X1,X2) = 2
[if](X1,X2,X3) = 0
[ren](X1,X2,X3) = X3
[apply](X1,X2) = 2.X1 + X2 + 2
[cons](X1,X2) = 0
[fSNonEmpty] = 0
[ffalse] = 0
[lambda](X1,X2) = X1 + 2.X2 + 2
[nil] = 2
[ftrue] = 2
[var](X) = 0
[AND](X1,X2) = 0
[EQ](X1,X2) = 0
[IF](X1,X2,X3) = 0
[REN](X1,X2,X3) = 2.X1 + 2.X2 + 2.X3

Problem 1.2: 

SCC Processor:
-> Pairs:
 REN(X,Y,lambda(Z,T)) -> REN(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)
-> Rules:
 and(ffalse,ffalse) -> ffalse
 and(ffalse,ftrue) -> ffalse
 and(ftrue,ffalse) -> ffalse
 and(ftrue,ftrue) -> ftrue
 eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
 eq(apply(T,S),lambda(X,Tp)) -> ffalse
 eq(apply(T,S),var(L)) -> ffalse
 eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
 eq(cons(T,L),nil) -> ffalse
 eq(lambda(X,T),apply(Tp,Sp)) -> ffalse
 eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
 eq(lambda(X,T),var(L)) -> ffalse
 eq(nil,cons(T,L)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(L),apply(T,S)) -> ffalse
 eq(var(L),lambda(X,T)) -> ffalse
 eq(var(L),var(Lp)) -> eq(L,Lp)
 if(ffalse,var(K),var(L)) -> var(L)
 if(ftrue,var(K),var(L)) -> var(K)
 ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
 ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
 ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)))
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 REN(X,Y,lambda(Z,T)) -> REN(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)
->->-> Rules:
 and(ffalse,ffalse) -> ffalse
 and(ffalse,ftrue) -> ffalse
 and(ftrue,ffalse) -> ffalse
 and(ftrue,ftrue) -> ftrue
 eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
 eq(apply(T,S),lambda(X,Tp)) -> ffalse
 eq(apply(T,S),var(L)) -> ffalse
 eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
 eq(cons(T,L),nil) -> ffalse
 eq(lambda(X,T),apply(Tp,Sp)) -> ffalse
 eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
 eq(lambda(X,T),var(L)) -> ffalse
 eq(nil,cons(T,L)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(L),apply(T,S)) -> ffalse
 eq(var(L),lambda(X,T)) -> ffalse
 eq(var(L),var(Lp)) -> eq(L,Lp)
 if(ffalse,var(K),var(L)) -> var(L)
 if(ftrue,var(K),var(L)) -> var(K)
 ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
 ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
 ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)))

Problem 1.2: 

Subterm Processor:
-> Pairs:
 REN(X,Y,lambda(Z,T)) -> REN(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)
-> Rules:
 and(ffalse,ffalse) -> ffalse
 and(ffalse,ftrue) -> ffalse
 and(ftrue,ffalse) -> ffalse
 and(ftrue,ftrue) -> ftrue
 eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
 eq(apply(T,S),lambda(X,Tp)) -> ffalse
 eq(apply(T,S),var(L)) -> ffalse
 eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
 eq(cons(T,L),nil) -> ffalse
 eq(lambda(X,T),apply(Tp,Sp)) -> ffalse
 eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
 eq(lambda(X,T),var(L)) -> ffalse
 eq(nil,cons(T,L)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(L),apply(T,S)) -> ffalse
 eq(var(L),lambda(X,T)) -> ffalse
 eq(var(L),var(Lp)) -> eq(L,Lp)
 if(ffalse,var(K),var(L)) -> var(L)
 if(ftrue,var(K),var(L)) -> var(K)
 ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
 ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
 ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)))
->Projection:
 pi(REN) = 3

Problem 1.2: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 and(ffalse,ffalse) -> ffalse
 and(ffalse,ftrue) -> ffalse
 and(ftrue,ffalse) -> ffalse
 and(ftrue,ftrue) -> ftrue
 eq(apply(T,S),apply(Tp,Sp)) -> and(eq(T,Tp),eq(S,Sp))
 eq(apply(T,S),lambda(X,Tp)) -> ffalse
 eq(apply(T,S),var(L)) -> ffalse
 eq(cons(T,L),cons(Tp,Lp)) -> and(eq(T,Tp),eq(L,Lp))
 eq(cons(T,L),nil) -> ffalse
 eq(lambda(X,T),apply(Tp,Sp)) -> ffalse
 eq(lambda(X,T),lambda(Xp,Tp)) -> and(eq(T,Tp),eq(X,Xp))
 eq(lambda(X,T),var(L)) -> ffalse
 eq(nil,cons(T,L)) -> ffalse
 eq(nil,nil) -> ftrue
 eq(var(L),apply(T,S)) -> ffalse
 eq(var(L),lambda(X,T)) -> ffalse
 eq(var(L),var(Lp)) -> eq(L,Lp)
 if(ffalse,var(K),var(L)) -> var(L)
 if(ftrue,var(K),var(L)) -> var(K)
 ren(var(L),var(K),var(Lp)) -> if(eq(L,Lp),var(K),var(Lp))
 ren(X,Y,apply(T,S)) -> apply(ren(X,Y,T),ren(X,Y,S))
 ren(X,Y,lambda(Z,T)) -> lambda(var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),ren(X,Y,ren(Z,var(cons(X,cons(Y,cons(lambda(Z,T),nil)))),T)))
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
