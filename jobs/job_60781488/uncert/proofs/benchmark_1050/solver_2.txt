YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/TFAHX.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) QTRSToCSRProof [EQUIVALENT, 0 ms]
(2) CSR
(3) CSRRRRProof [EQUIVALENT, 28 ms]
(4) CSR
(5) CSRRRRProof [EQUIVALENT, 0 ms]
(6) CSR
(7) CSDependencyPairsProof [EQUIVALENT, 0 ms]
(8) QCSDP
(9) QCSDependencyGraphProof [EQUIVALENT, 0 ms]
(10) AND
    (11) QCSDP
        (12) QCSUsableRulesProof [EQUIVALENT, 0 ms]
        (13) QCSDP
        (14) QCSDPMuMonotonicPoloProof [EQUIVALENT, 0 ms]
        (15) QCSDP
        (16) QCSDependencyGraphProof [EQUIVALENT, 0 ms]
        (17) AND
            (18) QCSDP
                (19) QCSDPMuMonotonicPoloProof [EQUIVALENT, 0 ms]
                (20) QCSDP
                (21) PIsEmptyProof [EQUIVALENT, 0 ms]
                (22) YES
            (23) QCSDP
                (24) QCSDPMuMonotonicPoloProof [EQUIVALENT, 0 ms]
                (25) QCSDP
                (26) PIsEmptyProof [EQUIVALENT, 0 ms]
                (27) YES
    (28) QCSDP
        (29) QCSDPSubtermProof [EQUIVALENT, 0 ms]
        (30) QCSDP
        (31) QCSDependencyGraphProof [EQUIVALENT, 0 ms]
        (32) TRUE
    (33) QCSDP
        (34) QCSDPReductionPairProof [EQUIVALENT, 45 ms]
        (35) QCSDP
        (36) QCSDependencyGraphProof [EQUIVALENT, 0 ms]
        (37) TRUE


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   active(and(tt, T)) -> mark(T)
   active(isNatIList(IL)) -> mark(isNatList(IL))
   active(isNat(0)) -> mark(tt)
   active(isNat(s(N))) -> mark(isNat(N))
   active(isNat(length(L))) -> mark(isNatList(L))
   active(isNatIList(zeros)) -> mark(tt)
   active(isNatIList(cons(N, IL))) -> mark(and(isNat(N), isNatIList(IL)))
   active(isNatList(nil)) -> mark(tt)
   active(isNatList(cons(N, L))) -> mark(and(isNat(N), isNatList(L)))
   active(isNatList(take(N, IL))) -> mark(and(isNat(N), isNatIList(IL)))
   active(zeros) -> mark(cons(0, zeros))
   active(take(0, IL)) -> mark(uTake1(isNatIList(IL)))
   active(uTake1(tt)) -> mark(nil)
   active(take(s(M), cons(N, IL))) -> mark(uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL))
   active(uTake2(tt, M, N, IL)) -> mark(cons(N, take(M, IL)))
   active(length(cons(N, L))) -> mark(uLength(and(isNat(N), isNatList(L)), L))
   active(uLength(tt, L)) -> mark(s(length(L)))
   active(and(X1, X2)) -> and(active(X1), X2)
   active(and(X1, X2)) -> and(X1, active(X2))
   active(s(X)) -> s(active(X))
   active(length(X)) -> length(active(X))
   active(cons(X1, X2)) -> cons(active(X1), X2)
   active(take(X1, X2)) -> take(active(X1), X2)
   active(take(X1, X2)) -> take(X1, active(X2))
   active(uTake1(X)) -> uTake1(active(X))
   active(uTake2(X1, X2, X3, X4)) -> uTake2(active(X1), X2, X3, X4)
   active(uLength(X1, X2)) -> uLength(active(X1), X2)
   and(mark(X1), X2) -> mark(and(X1, X2))
   and(X1, mark(X2)) -> mark(and(X1, X2))
   s(mark(X)) -> mark(s(X))
   length(mark(X)) -> mark(length(X))
   cons(mark(X1), X2) -> mark(cons(X1, X2))
   take(mark(X1), X2) -> mark(take(X1, X2))
   take(X1, mark(X2)) -> mark(take(X1, X2))
   uTake1(mark(X)) -> mark(uTake1(X))
   uTake2(mark(X1), X2, X3, X4) -> mark(uTake2(X1, X2, X3, X4))
   uLength(mark(X1), X2) -> mark(uLength(X1, X2))
   proper(and(X1, X2)) -> and(proper(X1), proper(X2))
   proper(tt) -> ok(tt)
   proper(isNatIList(X)) -> isNatIList(proper(X))
   proper(isNatList(X)) -> isNatList(proper(X))
   proper(isNat(X)) -> isNat(proper(X))
   proper(0) -> ok(0)
   proper(s(X)) -> s(proper(X))
   proper(length(X)) -> length(proper(X))
   proper(zeros) -> ok(zeros)
   proper(cons(X1, X2)) -> cons(proper(X1), proper(X2))
   proper(nil) -> ok(nil)
   proper(take(X1, X2)) -> take(proper(X1), proper(X2))
   proper(uTake1(X)) -> uTake1(proper(X))
   proper(uTake2(X1, X2, X3, X4)) -> uTake2(proper(X1), proper(X2), proper(X3), proper(X4))
   proper(uLength(X1, X2)) -> uLength(proper(X1), proper(X2))
   and(ok(X1), ok(X2)) -> ok(and(X1, X2))
   isNatIList(ok(X)) -> ok(isNatIList(X))
   isNatList(ok(X)) -> ok(isNatList(X))
   isNat(ok(X)) -> ok(isNat(X))
   s(ok(X)) -> ok(s(X))
   length(ok(X)) -> ok(length(X))
   cons(ok(X1), ok(X2)) -> ok(cons(X1, X2))
   take(ok(X1), ok(X2)) -> ok(take(X1, X2))
   uTake1(ok(X)) -> ok(uTake1(X))
   uTake2(ok(X1), ok(X2), ok(X3), ok(X4)) -> ok(uTake2(X1, X2, X3, X4))
   uLength(ok(X1), ok(X2)) -> ok(uLength(X1, X2))
   top(mark(X)) -> top(proper(X))
   top(ok(X)) -> top(active(X))

Q is empty.

----------------------------------------

(1) QTRSToCSRProof (EQUIVALENT)
The following Q TRS is given: Q restricted rewrite system:
The TRS R consists of the following rules:

   active(and(tt, T)) -> mark(T)
   active(isNatIList(IL)) -> mark(isNatList(IL))
   active(isNat(0)) -> mark(tt)
   active(isNat(s(N))) -> mark(isNat(N))
   active(isNat(length(L))) -> mark(isNatList(L))
   active(isNatIList(zeros)) -> mark(tt)
   active(isNatIList(cons(N, IL))) -> mark(and(isNat(N), isNatIList(IL)))
   active(isNatList(nil)) -> mark(tt)
   active(isNatList(cons(N, L))) -> mark(and(isNat(N), isNatList(L)))
   active(isNatList(take(N, IL))) -> mark(and(isNat(N), isNatIList(IL)))
   active(zeros) -> mark(cons(0, zeros))
   active(take(0, IL)) -> mark(uTake1(isNatIList(IL)))
   active(uTake1(tt)) -> mark(nil)
   active(take(s(M), cons(N, IL))) -> mark(uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL))
   active(uTake2(tt, M, N, IL)) -> mark(cons(N, take(M, IL)))
   active(length(cons(N, L))) -> mark(uLength(and(isNat(N), isNatList(L)), L))
   active(uLength(tt, L)) -> mark(s(length(L)))
   active(and(X1, X2)) -> and(active(X1), X2)
   active(and(X1, X2)) -> and(X1, active(X2))
   active(s(X)) -> s(active(X))
   active(length(X)) -> length(active(X))
   active(cons(X1, X2)) -> cons(active(X1), X2)
   active(take(X1, X2)) -> take(active(X1), X2)
   active(take(X1, X2)) -> take(X1, active(X2))
   active(uTake1(X)) -> uTake1(active(X))
   active(uTake2(X1, X2, X3, X4)) -> uTake2(active(X1), X2, X3, X4)
   active(uLength(X1, X2)) -> uLength(active(X1), X2)
   and(mark(X1), X2) -> mark(and(X1, X2))
   and(X1, mark(X2)) -> mark(and(X1, X2))
   s(mark(X)) -> mark(s(X))
   length(mark(X)) -> mark(length(X))
   cons(mark(X1), X2) -> mark(cons(X1, X2))
   take(mark(X1), X2) -> mark(take(X1, X2))
   take(X1, mark(X2)) -> mark(take(X1, X2))
   uTake1(mark(X)) -> mark(uTake1(X))
   uTake2(mark(X1), X2, X3, X4) -> mark(uTake2(X1, X2, X3, X4))
   uLength(mark(X1), X2) -> mark(uLength(X1, X2))
   proper(and(X1, X2)) -> and(proper(X1), proper(X2))
   proper(tt) -> ok(tt)
   proper(isNatIList(X)) -> isNatIList(proper(X))
   proper(isNatList(X)) -> isNatList(proper(X))
   proper(isNat(X)) -> isNat(proper(X))
   proper(0) -> ok(0)
   proper(s(X)) -> s(proper(X))
   proper(length(X)) -> length(proper(X))
   proper(zeros) -> ok(zeros)
   proper(cons(X1, X2)) -> cons(proper(X1), proper(X2))
   proper(nil) -> ok(nil)
   proper(take(X1, X2)) -> take(proper(X1), proper(X2))
   proper(uTake1(X)) -> uTake1(proper(X))
   proper(uTake2(X1, X2, X3, X4)) -> uTake2(proper(X1), proper(X2), proper(X3), proper(X4))
   proper(uLength(X1, X2)) -> uLength(proper(X1), proper(X2))
   and(ok(X1), ok(X2)) -> ok(and(X1, X2))
   isNatIList(ok(X)) -> ok(isNatIList(X))
   isNatList(ok(X)) -> ok(isNatList(X))
   isNat(ok(X)) -> ok(isNat(X))
   s(ok(X)) -> ok(s(X))
   length(ok(X)) -> ok(length(X))
   cons(ok(X1), ok(X2)) -> ok(cons(X1, X2))
   take(ok(X1), ok(X2)) -> ok(take(X1, X2))
   uTake1(ok(X)) -> ok(uTake1(X))
   uTake2(ok(X1), ok(X2), ok(X3), ok(X4)) -> ok(uTake2(X1, X2, X3, X4))
   uLength(ok(X1), ok(X2)) -> ok(uLength(X1, X2))
   top(mark(X)) -> top(proper(X))
   top(ok(X)) -> top(active(X))

Q is empty.
Special symbols used for the transformation (see [GM04]):
top: top_1, active: active_1, mark: mark_1, ok: ok_1, proper: proper_1
The replacement map contains the following entries:

and: {1, 2}
tt: empty set
isNatIList: empty set
isNatList: empty set
isNat: empty set
0: empty set
s: {1}
length: {1}
zeros: empty set
cons: {1}
nil: empty set
take: {1, 2}
uTake1: {1}
uTake2: {1}
uLength: {1}
The QTRS contained all rules created by the complete Giesl-Middeldorp transformation. Therefore, the inverse transformation is complete (and sound).
----------------------------------------

(2)
Obligation:
Context-sensitive rewrite system:
The TRS R consists of the following rules:

   and(tt, T) -> T
   isNatIList(IL) -> isNatList(IL)
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)
   take(0, IL) -> uTake1(isNatIList(IL))
   uTake1(tt) -> nil
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))

The replacement map contains the following entries:

and: {1, 2}
tt: empty set
isNatIList: empty set
isNatList: empty set
isNat: empty set
0: empty set
s: {1}
length: {1}
zeros: empty set
cons: {1}
nil: empty set
take: {1, 2}
uTake1: {1}
uTake2: {1}
uLength: {1}

----------------------------------------

(3) CSRRRRProof (EQUIVALENT)
The following CSR is given: Context-sensitive rewrite system:
The TRS R consists of the following rules:

   and(tt, T) -> T
   isNatIList(IL) -> isNatList(IL)
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)
   take(0, IL) -> uTake1(isNatIList(IL))
   uTake1(tt) -> nil
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))

The replacement map contains the following entries:

and: {1, 2}
tt: empty set
isNatIList: empty set
isNatList: empty set
isNat: empty set
0: empty set
s: {1}
length: {1}
zeros: empty set
cons: {1}
nil: empty set
take: {1, 2}
uTake1: {1}
uTake2: {1}
uLength: {1}
Used ordering:
Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(and(x_1, x_2)) = x_1 + x_2
   POL(cons(x_1, x_2)) = x_1 + x_2
   POL(isNat(x_1)) = 0
   POL(isNatIList(x_1)) = 0
   POL(isNatList(x_1)) = 0
   POL(length(x_1)) = 1 + x_1
   POL(nil) = 0
   POL(s(x_1)) = x_1
   POL(take(x_1, x_2)) = 1 + x_1 + x_2
   POL(tt) = 0
   POL(uLength(x_1, x_2)) = 1 + x_1 + x_2
   POL(uTake1(x_1)) = 1 + x_1
   POL(uTake2(x_1, x_2, x_3, x_4)) = 1 + x_1 + x_2 + x_3 + x_4
   POL(zeros) = 0
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   uTake1(tt) -> nil




----------------------------------------

(4)
Obligation:
Context-sensitive rewrite system:
The TRS R consists of the following rules:

   and(tt, T) -> T
   isNatIList(IL) -> isNatList(IL)
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)
   take(0, IL) -> uTake1(isNatIList(IL))
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))

The replacement map contains the following entries:

and: {1, 2}
tt: empty set
isNatIList: empty set
isNatList: empty set
isNat: empty set
0: empty set
s: {1}
length: {1}
zeros: empty set
cons: {1}
nil: empty set
take: {1, 2}
uTake1: {1}
uTake2: {1}
uLength: {1}

----------------------------------------

(5) CSRRRRProof (EQUIVALENT)
The following CSR is given: Context-sensitive rewrite system:
The TRS R consists of the following rules:

   and(tt, T) -> T
   isNatIList(IL) -> isNatList(IL)
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)
   take(0, IL) -> uTake1(isNatIList(IL))
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))

The replacement map contains the following entries:

and: {1, 2}
tt: empty set
isNatIList: empty set
isNatList: empty set
isNat: empty set
0: empty set
s: {1}
length: {1}
zeros: empty set
cons: {1}
nil: empty set
take: {1, 2}
uTake1: {1}
uTake2: {1}
uLength: {1}
Used ordering:
Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(and(x_1, x_2)) = x_1 + x_2
   POL(cons(x_1, x_2)) = x_1 + x_2
   POL(isNat(x_1)) = 0
   POL(isNatIList(x_1)) = 0
   POL(isNatList(x_1)) = 0
   POL(length(x_1)) = 1 + x_1
   POL(nil) = 0
   POL(s(x_1)) = x_1
   POL(take(x_1, x_2)) = 1 + x_1 + x_2
   POL(tt) = 0
   POL(uLength(x_1, x_2)) = 1 + x_1 + x_2
   POL(uTake1(x_1)) = x_1
   POL(uTake2(x_1, x_2, x_3, x_4)) = 1 + x_1 + x_2 + x_3 + x_4
   POL(zeros) = 0
With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   take(0, IL) -> uTake1(isNatIList(IL))




----------------------------------------

(6)
Obligation:
Context-sensitive rewrite system:
The TRS R consists of the following rules:

   and(tt, T) -> T
   isNatIList(IL) -> isNatList(IL)
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))

The replacement map contains the following entries:

and: {1, 2}
tt: empty set
isNatIList: empty set
isNatList: empty set
isNat: empty set
0: empty set
s: {1}
length: {1}
zeros: empty set
cons: {1}
nil: empty set
take: {1, 2}
uTake2: {1}
uLength: {1}

----------------------------------------

(7) CSDependencyPairsProof (EQUIVALENT)
Using Improved CS-DPs [LPAR08] we result in the following initial Q-CSDP problem.
----------------------------------------

(8)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {and_2, s_1, length_1, take_2, AND_2, TAKE_2, LENGTH_1} are replacing on all positions.
For all symbols f in {cons_2, uTake2_4, uLength_2, UTAKE2_4, ULENGTH_2} we have mu(f) = {1}.
The symbols in {isNatIList_1, isNatList_1, isNat_1, ISNATLIST_1, ISNATILIST_1, ISNAT_1, U_1} are not replacing on any position.

The ordinary context-sensitive dependency pairs DP_o are:
   ISNATILIST(IL) -> ISNATLIST(IL)
   ISNAT(s(N)) -> ISNAT(N)
   ISNAT(length(L)) -> ISNATLIST(L)
   ISNATILIST(cons(N, IL)) -> AND(isNat(N), isNatIList(IL))
   ISNATILIST(cons(N, IL)) -> ISNAT(N)
   ISNATILIST(cons(N, IL)) -> ISNATILIST(IL)
   ISNATLIST(cons(N, L)) -> AND(isNat(N), isNatList(L))
   ISNATLIST(cons(N, L)) -> ISNAT(N)
   ISNATLIST(cons(N, L)) -> ISNATLIST(L)
   ISNATLIST(take(N, IL)) -> AND(isNat(N), isNatIList(IL))
   ISNATLIST(take(N, IL)) -> ISNAT(N)
   ISNATLIST(take(N, IL)) -> ISNATILIST(IL)
   TAKE(s(M), cons(N, IL)) -> UTAKE2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   TAKE(s(M), cons(N, IL)) -> AND(isNat(M), and(isNat(N), isNatIList(IL)))
   TAKE(s(M), cons(N, IL)) -> ISNAT(M)
   TAKE(s(M), cons(N, IL)) -> AND(isNat(N), isNatIList(IL))
   TAKE(s(M), cons(N, IL)) -> ISNAT(N)
   TAKE(s(M), cons(N, IL)) -> ISNATILIST(IL)
   LENGTH(cons(N, L)) -> ULENGTH(and(isNat(N), isNatList(L)), L)
   LENGTH(cons(N, L)) -> AND(isNat(N), isNatList(L))
   LENGTH(cons(N, L)) -> ISNAT(N)
   LENGTH(cons(N, L)) -> ISNATLIST(L)
   ULENGTH(tt, L) -> LENGTH(L)

The collapsing dependency pairs are DP_c:
   UTAKE2(tt, M, N, IL) -> N
   ULENGTH(tt, L) -> L


The hidden terms of R are:

   zeros
   take(x0, x1)

Every hiding context is built from:
   aprove.DPFramework.CSDPProblem.QCSDPProblem$1@5c0c456a

Hence, the new unhiding pairs DP_u are :
   UTAKE2(tt, M, N, IL) -> U(N)
   ULENGTH(tt, L) -> U(L)
   U(take(x_0, x_1)) -> U(x_0)
   U(take(x_0, x_1)) -> U(x_1)
   U(zeros) -> ZEROS
   U(take(x0, x1)) -> TAKE(x0, x1)

The TRS R consists of the following rules:

   and(tt, T) -> T
   isNatIList(IL) -> isNatList(IL)
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))

Q is empty.

----------------------------------------

(9) QCSDependencyGraphProof (EQUIVALENT)
The approximation of the Context-Sensitive Dependency Graph [LPAR08] contains 3 SCCs with 13 less nodes.

----------------------------------------

(10)
Complex Obligation (AND)

----------------------------------------

(11)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {and_2, s_1, length_1, take_2} are replacing on all positions.
For all symbols f in {cons_2, uTake2_4, uLength_2} we have mu(f) = {1}.
The symbols in {isNatIList_1, isNatList_1, isNat_1, ISNAT_1, ISNATLIST_1, ISNATILIST_1} are not replacing on any position.

The TRS P consists of the following rules:

   ISNATLIST(cons(N, L)) -> ISNAT(N)
   ISNAT(s(N)) -> ISNAT(N)
   ISNAT(length(L)) -> ISNATLIST(L)
   ISNATLIST(cons(N, L)) -> ISNATLIST(L)
   ISNATLIST(take(N, IL)) -> ISNAT(N)
   ISNATLIST(take(N, IL)) -> ISNATILIST(IL)
   ISNATILIST(IL) -> ISNATLIST(IL)
   ISNATILIST(cons(N, IL)) -> ISNAT(N)
   ISNATILIST(cons(N, IL)) -> ISNATILIST(IL)

The TRS R consists of the following rules:

   and(tt, T) -> T
   isNatIList(IL) -> isNatList(IL)
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))

Q is empty.

----------------------------------------

(12) QCSUsableRulesProof (EQUIVALENT)
The following rules are not useable [DA_EMMES] and can be deleted:

   and(tt, x0) -> x0
   isNatIList(x0) -> isNatList(x0)
   isNat(0) -> tt
   isNat(s(x0)) -> isNat(x0)
   isNat(length(x0)) -> isNatList(x0)
   isNatIList(zeros) -> tt
   isNatIList(cons(x0, x1)) -> and(isNat(x0), isNatIList(x1))
   isNatList(nil) -> tt
   isNatList(cons(x0, x1)) -> and(isNat(x0), isNatList(x1))
   isNatList(take(x0, x1)) -> and(isNat(x0), isNatIList(x1))
   zeros -> cons(0, zeros)
   take(s(x0), cons(x1, x2)) -> uTake2(and(isNat(x0), and(isNat(x1), isNatIList(x2))), x0, x1, x2)
   uTake2(tt, x0, x1, x2) -> cons(x1, take(x0, x2))
   length(cons(x0, x1)) -> uLength(and(isNat(x0), isNatList(x1)), x1)
   uLength(tt, x0) -> s(length(x0))

----------------------------------------

(13)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {s_1, length_1, take_2} are replacing on all positions.
For all symbols f in {cons_2} we have mu(f) = {1}.
The symbols in {ISNAT_1, ISNATLIST_1, ISNATILIST_1} are not replacing on any position.

The TRS P consists of the following rules:

   ISNATLIST(cons(N, L)) -> ISNAT(N)
   ISNAT(s(N)) -> ISNAT(N)
   ISNAT(length(L)) -> ISNATLIST(L)
   ISNATLIST(cons(N, L)) -> ISNATLIST(L)
   ISNATLIST(take(N, IL)) -> ISNAT(N)
   ISNATLIST(take(N, IL)) -> ISNATILIST(IL)
   ISNATILIST(IL) -> ISNATLIST(IL)
   ISNATILIST(cons(N, IL)) -> ISNAT(N)
   ISNATILIST(cons(N, IL)) -> ISNATILIST(IL)

R is empty.
Q is empty.

----------------------------------------

(14) QCSDPMuMonotonicPoloProof (EQUIVALENT)
By using the following mu-monotonic polynomial ordering [POLO], at least one Dependency Pair or term rewrite system rule of this Q-CSDP problem can be strictly oriented and thus deleted.

Strictly oriented dependency pairs:

   ISNAT(s(N)) -> ISNAT(N)
   ISNAT(length(L)) -> ISNATLIST(L)
   ISNATLIST(take(N, IL)) -> ISNAT(N)
   ISNATLIST(take(N, IL)) -> ISNATILIST(IL)
   ISNATILIST(IL) -> ISNATLIST(IL)
   ISNATILIST(cons(N, IL)) -> ISNAT(N)


Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(ISNAT(x_1)) = 1 + x_1
   POL(ISNATILIST(x_1)) = 2 + 2*x_1
   POL(ISNATLIST(x_1)) = 1 + 2*x_1
   POL(cons(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(length(x_1)) = 1 + 2*x_1
   POL(s(x_1)) = 2 + 2*x_1
   POL(take(x_1, x_2)) = 2 + 2*x_1 + x_2


----------------------------------------

(15)
Obligation:
Q-restricted context-sensitive dependency pair problem:
For all symbols f in {cons_2} we have mu(f) = {1}.
The symbols in {ISNAT_1, ISNATLIST_1, ISNATILIST_1} are not replacing on any position.

The TRS P consists of the following rules:

   ISNATLIST(cons(N, L)) -> ISNAT(N)
   ISNATLIST(cons(N, L)) -> ISNATLIST(L)
   ISNATILIST(cons(N, IL)) -> ISNATILIST(IL)

R is empty.
Q is empty.

----------------------------------------

(16) QCSDependencyGraphProof (EQUIVALENT)
The approximation of the Context-Sensitive Dependency Graph [LPAR08] contains 2 SCCs with 1 less node.

----------------------------------------

(17)
Complex Obligation (AND)

----------------------------------------

(18)
Obligation:
Q-restricted context-sensitive dependency pair problem:
For all symbols f in {cons_2} we have mu(f) = {1}.
The symbols in {ISNATILIST_1} are not replacing on any position.

The TRS P consists of the following rules:

   ISNATILIST(cons(N, IL)) -> ISNATILIST(IL)

R is empty.
Q is empty.

----------------------------------------

(19) QCSDPMuMonotonicPoloProof (EQUIVALENT)
By using the following mu-monotonic polynomial ordering [POLO], at least one Dependency Pair or term rewrite system rule of this Q-CSDP problem can be strictly oriented and thus deleted.

Strictly oriented dependency pairs:

   ISNATILIST(cons(N, IL)) -> ISNATILIST(IL)


Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(ISNATILIST(x_1)) = 2*x_1
   POL(cons(x_1, x_2)) = 1 + x_1 + x_2


----------------------------------------

(20)
Obligation:
Q-restricted context-sensitive dependency pair problem:

The TRS P consists of the following rules:
none

R is empty.
Q is empty.

----------------------------------------

(21) PIsEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R,mu)-chain.
----------------------------------------

(22)
YES

----------------------------------------

(23)
Obligation:
Q-restricted context-sensitive dependency pair problem:
For all symbols f in {cons_2} we have mu(f) = {1}.
The symbols in {ISNATLIST_1} are not replacing on any position.

The TRS P consists of the following rules:

   ISNATLIST(cons(N, L)) -> ISNATLIST(L)

R is empty.
Q is empty.

----------------------------------------

(24) QCSDPMuMonotonicPoloProof (EQUIVALENT)
By using the following mu-monotonic polynomial ordering [POLO], at least one Dependency Pair or term rewrite system rule of this Q-CSDP problem can be strictly oriented and thus deleted.

Strictly oriented dependency pairs:

   ISNATLIST(cons(N, L)) -> ISNATLIST(L)


Used ordering: POLO with Polynomial interpretation [POLO]:

   POL(ISNATLIST(x_1)) = 2*x_1
   POL(cons(x_1, x_2)) = 1 + x_1 + x_2


----------------------------------------

(25)
Obligation:
Q-restricted context-sensitive dependency pair problem:

The TRS P consists of the following rules:
none

R is empty.
Q is empty.

----------------------------------------

(26) PIsEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R,mu)-chain.
----------------------------------------

(27)
YES

----------------------------------------

(28)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {and_2, s_1, length_1, take_2, TAKE_2} are replacing on all positions.
For all symbols f in {cons_2, uTake2_4, uLength_2, UTAKE2_4} we have mu(f) = {1}.
The symbols in {isNatIList_1, isNatList_1, isNat_1, U_1} are not replacing on any position.

The TRS P consists of the following rules:

   TAKE(s(M), cons(N, IL)) -> UTAKE2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   UTAKE2(tt, M, N, IL) -> U(N)
   U(take(x_0, x_1)) -> U(x_0)
   U(take(x_0, x_1)) -> U(x_1)
   U(take(x0, x1)) -> TAKE(x0, x1)

The TRS R consists of the following rules:

   and(tt, T) -> T
   isNatIList(IL) -> isNatList(IL)
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))

Q is empty.

----------------------------------------

(29) QCSDPSubtermProof (EQUIVALENT)
We use the subterm processor [DA_EMMES].


The following pairs can be oriented strictly and are deleted.

   TAKE(s(M), cons(N, IL)) -> UTAKE2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   U(take(x_0, x_1)) -> U(x_0)
   U(take(x_0, x_1)) -> U(x_1)
   U(take(x0, x1)) -> TAKE(x0, x1)
The remaining pairs can at least be oriented weakly.

   UTAKE2(tt, M, N, IL) -> U(N)
Used ordering:  Combined order from the following AFS and order.
UTAKE2(x1, x2, x3, x4)  =  x3

TAKE(x1, x2)  =  x2

U(x1)  =  x1


Subterm Order

----------------------------------------

(30)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {and_2, s_1, length_1, take_2} are replacing on all positions.
For all symbols f in {cons_2, uTake2_4, uLength_2, UTAKE2_4} we have mu(f) = {1}.
The symbols in {isNatIList_1, isNatList_1, isNat_1, U_1} are not replacing on any position.

The TRS P consists of the following rules:

   UTAKE2(tt, M, N, IL) -> U(N)

The TRS R consists of the following rules:

   and(tt, T) -> T
   isNatIList(IL) -> isNatList(IL)
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))

Q is empty.

----------------------------------------

(31) QCSDependencyGraphProof (EQUIVALENT)
The approximation of the Context-Sensitive Dependency Graph [LPAR08] contains 0 SCCs with 1 less node.

----------------------------------------

(32)
TRUE

----------------------------------------

(33)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {and_2, s_1, length_1, take_2, LENGTH_1} are replacing on all positions.
For all symbols f in {cons_2, uTake2_4, uLength_2, ULENGTH_2} we have mu(f) = {1}.
The symbols in {isNatIList_1, isNatList_1, isNat_1} are not replacing on any position.

The TRS P consists of the following rules:

   ULENGTH(tt, L) -> LENGTH(L)
   LENGTH(cons(N, L)) -> ULENGTH(and(isNat(N), isNatList(L)), L)

The TRS R consists of the following rules:

   and(tt, T) -> T
   isNatIList(IL) -> isNatList(IL)
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))

Q is empty.

----------------------------------------

(34) QCSDPReductionPairProof (EQUIVALENT)
Using the order

Matrix interpretation [MATRO]:

Non-tuple symbols: 
<<<
 M( isNat_1(x_1) ) =  	[[1], [1]] 	+ 	[[1, 0], [0, 0]] 	* 	x_1
>>>

<<<
 M( isNatIList_1(x_1) ) =  	[[1], [1]] 	+ 	[[1, 0], [0, 0]] 	* 	x_1
>>>

<<<
 M( and_2(x_1, x_2) ) =  	[[0], [0]] 	+ 	[[0, 0], [0, 0]] 	* 	x_1 	+ 	[[1, 0], [0, 1]] 	* 	x_2
>>>

<<<
 M( tt ) =  	[[1], [1]]
>>>

<<<
 M( uLength_2(x_1, x_2) ) =  	[[0], [0]] 	+ 	[[1, 0], [0, 0]] 	* 	x_1 	+ 	[[1, 1], [0, 0]] 	* 	x_2
>>>

<<<
 M( nil ) =  	[[1], [1]]
>>>

<<<
 M( s_1(x_1) ) =  	[[1], [0]] 	+ 	[[1, 0], [0, 0]] 	* 	x_1
>>>

<<<
 M( uTake2_4(x_1, ..., x_4) ) =  	[[0], [0]] 	+ 	[[0, 1], [0, 1]] 	* 	x_1 	+ 	[[0, 0], [1, 0]] 	* 	x_2 	+ 	[[0, 0], [0, 0]] 	* 	x_3 	+ 	[[1, 0], [1, 1]] 	* 	x_4
>>>

<<<
 M( length_1(x_1) ) =  	[[0], [0]] 	+ 	[[1, 1], [0, 0]] 	* 	x_1
>>>

<<<
 M( take_2(x_1, x_2) ) =  	[[1], [0]] 	+ 	[[0, 0], [1, 0]] 	* 	x_1 	+ 	[[1, 0], [0, 1]] 	* 	x_2
>>>

<<<
 M( zeros ) =  	[[0], [0]]
>>>

<<<
 M( 0 ) =  	[[0], [0]]
>>>

<<<
 M( cons_2(x_1, x_2) ) =  	[[0], [0]] 	+ 	[[0, 0], [0, 0]] 	* 	x_1 	+ 	[[1, 0], [1, 1]] 	* 	x_2
>>>

<<<
 M( isNatList_1(x_1) ) =  	[[0], [1]] 	+ 	[[1, 0], [0, 0]] 	* 	x_1
>>>

Tuple symbols: 
<<<
 M( LENGTH_1(x_1) ) =  	[[1]] 	+ 	[[0, 1]] 	* 	x_1
>>>

<<<
 M( ULENGTH_2(x_1, x_2) ) =  	[[0]] 	+ 	[[1, 0]] 	* 	x_1 	+ 	[[0, 1]] 	* 	x_2
>>>



Matrix type: 

We used a basic matrix type which is not further parametrizeable.





the following usable rules


   and(tt, T) -> T
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   isNatIList(IL) -> isNatList(IL)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)


could all be oriented weakly.

Furthermore, the pairs


   LENGTH(cons(N, L)) -> ULENGTH(and(isNat(N), isNatList(L)), L)


could be oriented strictly and thus removed by the CS-Reduction Pair Processor [LPAR08,DA_EMMES].


----------------------------------------

(35)
Obligation:
Q-restricted context-sensitive dependency pair problem:
The symbols in {and_2, s_1, length_1, take_2, LENGTH_1} are replacing on all positions.
For all symbols f in {cons_2, uTake2_4, uLength_2, ULENGTH_2} we have mu(f) = {1}.
The symbols in {isNatIList_1, isNatList_1, isNat_1} are not replacing on any position.

The TRS P consists of the following rules:

   ULENGTH(tt, L) -> LENGTH(L)

The TRS R consists of the following rules:

   and(tt, T) -> T
   isNatIList(IL) -> isNatList(IL)
   isNat(0) -> tt
   isNat(s(N)) -> isNat(N)
   isNat(length(L)) -> isNatList(L)
   isNatIList(zeros) -> tt
   isNatIList(cons(N, IL)) -> and(isNat(N), isNatIList(IL))
   isNatList(nil) -> tt
   isNatList(cons(N, L)) -> and(isNat(N), isNatList(L))
   isNatList(take(N, IL)) -> and(isNat(N), isNatIList(IL))
   zeros -> cons(0, zeros)
   take(s(M), cons(N, IL)) -> uTake2(and(isNat(M), and(isNat(N), isNatIList(IL))), M, N, IL)
   uTake2(tt, M, N, IL) -> cons(N, take(M, IL))
   length(cons(N, L)) -> uLength(and(isNat(N), isNatList(L)), L)
   uLength(tt, L) -> s(length(L))

Q is empty.

----------------------------------------

(36) QCSDependencyGraphProof (EQUIVALENT)
The approximation of the Context-Sensitive Dependency Graph [LPAR08] contains 0 SCCs with 1 less node.

----------------------------------------

(37)
TRUE
