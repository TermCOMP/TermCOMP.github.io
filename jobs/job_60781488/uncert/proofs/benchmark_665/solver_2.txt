NO
proof of /hpcwork/ff862203/termcomp25/benchmarks/cPI5U.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be disproven:

(0) QTRS
(1) DependencyPairsProof [EQUIVALENT, 0 ms]
(2) QDP
(3) QDPOrderProof [EQUIVALENT, 0 ms]
(4) QDP
(5) DependencyGraphProof [EQUIVALENT, 0 ms]
(6) QDP
(7) NonTerminationLoopProof [COMPLETE, 0 ms]
(8) NO


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   +(x, +(y, z)) -> +(+(x, y), z)
   *(x, +(y, z)) -> +(*(x, y), *(x, z))
   +(+(x, *(y, z)), *(y, u)) -> +(x, *(y, +(z, u)))

Q is empty.

----------------------------------------

(1) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(2)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   +^1(x, +(y, z)) -> +^1(+(x, y), z)
   +^1(x, +(y, z)) -> +^1(x, y)
   *^1(x, +(y, z)) -> +^1(*(x, y), *(x, z))
   *^1(x, +(y, z)) -> *^1(x, y)
   *^1(x, +(y, z)) -> *^1(x, z)
   +^1(+(x, *(y, z)), *(y, u)) -> +^1(x, *(y, +(z, u)))
   +^1(+(x, *(y, z)), *(y, u)) -> *^1(y, +(z, u))
   +^1(+(x, *(y, z)), *(y, u)) -> +^1(z, u)

The TRS R consists of the following rules:

   +(x, +(y, z)) -> +(+(x, y), z)
   *(x, +(y, z)) -> +(*(x, y), *(x, z))
   +(+(x, *(y, z)), *(y, u)) -> +(x, *(y, +(z, u)))

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(3) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   +^1(x, +(y, z)) -> +^1(x, y)
   *^1(x, +(y, z)) -> +^1(*(x, y), *(x, z))
   *^1(x, +(y, z)) -> *^1(x, y)
   *^1(x, +(y, z)) -> *^1(x, z)
   +^1(+(x, *(y, z)), *(y, u)) -> +^1(z, u)
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial interpretation [POLO]:

   POL(*(x_1, x_2)) = x_2
   POL(*^1(x_1, x_2)) = x_2
   POL(+(x_1, x_2)) = 1 + x_1 + x_2
   POL(+^1(x_1, x_2)) = x_1 + x_2

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   +(+(x, *(y, z)), *(y, u)) -> +(x, *(y, +(z, u)))
   +(x, +(y, z)) -> +(+(x, y), z)
   *(x, +(y, z)) -> +(*(x, y), *(x, z))


----------------------------------------

(4)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   +^1(x, +(y, z)) -> +^1(+(x, y), z)
   +^1(+(x, *(y, z)), *(y, u)) -> +^1(x, *(y, +(z, u)))
   +^1(+(x, *(y, z)), *(y, u)) -> *^1(y, +(z, u))

The TRS R consists of the following rules:

   +(x, +(y, z)) -> +(+(x, y), z)
   *(x, +(y, z)) -> +(*(x, y), *(x, z))
   +(+(x, *(y, z)), *(y, u)) -> +(x, *(y, +(z, u)))

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(5) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(6)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   +^1(+(x, *(y, z)), *(y, u)) -> +^1(x, *(y, +(z, u)))
   +^1(x, +(y, z)) -> +^1(+(x, y), z)

The TRS R consists of the following rules:

   +(x, +(y, z)) -> +(+(x, y), z)
   *(x, +(y, z)) -> +(*(x, y), *(x, z))
   +(+(x, *(y, z)), *(y, u)) -> +(x, *(y, +(z, u)))

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(7) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = +^1(x', *(x, +(y', z'))) evaluates to  t =+^1(x', *(x, +(y', z')))

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [ ]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

+^1(x', *(x, +(y', z'))) -> +^1(x', +(*(x, y'), *(x, z')))
with rule *(x'', +(y'', z'')) -> +(*(x'', y''), *(x'', z'')) at position [1] and matcher [x'' / x, y'' / y', z'' / z']

+^1(x', +(*(x, y'), *(x, z'))) -> +^1(+(x', *(x, y')), *(x, z'))
with rule +^1(x'', +(y'', z'')) -> +^1(+(x'', y''), z'') at position [] and matcher [x'' / x', y'' / *(x, y'), z'' / *(x, z')]

+^1(+(x', *(x, y')), *(x, z')) -> +^1(x', *(x, +(y', z')))
with rule +^1(+(x, *(y, z)), *(y, u)) -> +^1(x, *(y, +(z, u)))

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(8)
NO
