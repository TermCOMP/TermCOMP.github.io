YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/bdxL4.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) DependencyPairsProof [EQUIVALENT, 0 ms]
(2) QDP
(3) DependencyGraphProof [EQUIVALENT, 0 ms]
(4) QDP
(5) QDPOrderProof [EQUIVALENT, 39 ms]
(6) QDP
(7) QDPOrderProof [EQUIVALENT, 8 ms]
(8) QDP
(9) DependencyGraphProof [EQUIVALENT, 0 ms]
(10) TRUE


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   fst(0, Z) -> nil
   fst(s(X), cons(Y, Z)) -> cons(Y, n__fst(activate(X), activate(Z)))
   from(X) -> cons(X, n__from(n__s(X)))
   add(0, X) -> X
   add(s(X), Y) -> s(n__add(activate(X), Y))
   len(nil) -> 0
   len(cons(X, Z)) -> s(n__len(activate(Z)))
   fst(X1, X2) -> n__fst(X1, X2)
   from(X) -> n__from(X)
   s(X) -> n__s(X)
   add(X1, X2) -> n__add(X1, X2)
   len(X) -> n__len(X)
   activate(n__fst(X1, X2)) -> fst(activate(X1), activate(X2))
   activate(n__from(X)) -> from(activate(X))
   activate(n__s(X)) -> s(X)
   activate(n__add(X1, X2)) -> add(activate(X1), activate(X2))
   activate(n__len(X)) -> len(activate(X))
   activate(X) -> X

Q is empty.

----------------------------------------

(1) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(2)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   FST(s(X), cons(Y, Z)) -> ACTIVATE(X)
   FST(s(X), cons(Y, Z)) -> ACTIVATE(Z)
   ADD(s(X), Y) -> S(n__add(activate(X), Y))
   ADD(s(X), Y) -> ACTIVATE(X)
   LEN(cons(X, Z)) -> S(n__len(activate(Z)))
   LEN(cons(X, Z)) -> ACTIVATE(Z)
   ACTIVATE(n__fst(X1, X2)) -> FST(activate(X1), activate(X2))
   ACTIVATE(n__fst(X1, X2)) -> ACTIVATE(X1)
   ACTIVATE(n__fst(X1, X2)) -> ACTIVATE(X2)
   ACTIVATE(n__from(X)) -> FROM(activate(X))
   ACTIVATE(n__from(X)) -> ACTIVATE(X)
   ACTIVATE(n__s(X)) -> S(X)
   ACTIVATE(n__add(X1, X2)) -> ADD(activate(X1), activate(X2))
   ACTIVATE(n__add(X1, X2)) -> ACTIVATE(X1)
   ACTIVATE(n__add(X1, X2)) -> ACTIVATE(X2)
   ACTIVATE(n__len(X)) -> LEN(activate(X))
   ACTIVATE(n__len(X)) -> ACTIVATE(X)

The TRS R consists of the following rules:

   fst(0, Z) -> nil
   fst(s(X), cons(Y, Z)) -> cons(Y, n__fst(activate(X), activate(Z)))
   from(X) -> cons(X, n__from(n__s(X)))
   add(0, X) -> X
   add(s(X), Y) -> s(n__add(activate(X), Y))
   len(nil) -> 0
   len(cons(X, Z)) -> s(n__len(activate(Z)))
   fst(X1, X2) -> n__fst(X1, X2)
   from(X) -> n__from(X)
   s(X) -> n__s(X)
   add(X1, X2) -> n__add(X1, X2)
   len(X) -> n__len(X)
   activate(n__fst(X1, X2)) -> fst(activate(X1), activate(X2))
   activate(n__from(X)) -> from(activate(X))
   activate(n__s(X)) -> s(X)
   activate(n__add(X1, X2)) -> add(activate(X1), activate(X2))
   activate(n__len(X)) -> len(activate(X))
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(3) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 4 less nodes.
----------------------------------------

(4)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVATE(n__fst(X1, X2)) -> FST(activate(X1), activate(X2))
   FST(s(X), cons(Y, Z)) -> ACTIVATE(X)
   ACTIVATE(n__fst(X1, X2)) -> ACTIVATE(X1)
   ACTIVATE(n__fst(X1, X2)) -> ACTIVATE(X2)
   ACTIVATE(n__from(X)) -> ACTIVATE(X)
   ACTIVATE(n__add(X1, X2)) -> ADD(activate(X1), activate(X2))
   ADD(s(X), Y) -> ACTIVATE(X)
   ACTIVATE(n__add(X1, X2)) -> ACTIVATE(X1)
   ACTIVATE(n__add(X1, X2)) -> ACTIVATE(X2)
   ACTIVATE(n__len(X)) -> LEN(activate(X))
   LEN(cons(X, Z)) -> ACTIVATE(Z)
   ACTIVATE(n__len(X)) -> ACTIVATE(X)
   FST(s(X), cons(Y, Z)) -> ACTIVATE(Z)

The TRS R consists of the following rules:

   fst(0, Z) -> nil
   fst(s(X), cons(Y, Z)) -> cons(Y, n__fst(activate(X), activate(Z)))
   from(X) -> cons(X, n__from(n__s(X)))
   add(0, X) -> X
   add(s(X), Y) -> s(n__add(activate(X), Y))
   len(nil) -> 0
   len(cons(X, Z)) -> s(n__len(activate(Z)))
   fst(X1, X2) -> n__fst(X1, X2)
   from(X) -> n__from(X)
   s(X) -> n__s(X)
   add(X1, X2) -> n__add(X1, X2)
   len(X) -> n__len(X)
   activate(n__fst(X1, X2)) -> fst(activate(X1), activate(X2))
   activate(n__from(X)) -> from(activate(X))
   activate(n__s(X)) -> s(X)
   activate(n__add(X1, X2)) -> add(activate(X1), activate(X2))
   activate(n__len(X)) -> len(activate(X))
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(5) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ACTIVATE(n__from(X)) -> ACTIVATE(X)
   ACTIVATE(n__add(X1, X2)) -> ADD(activate(X1), activate(X2))
   ADD(s(X), Y) -> ACTIVATE(X)
   ACTIVATE(n__add(X1, X2)) -> ACTIVATE(X1)
   ACTIVATE(n__add(X1, X2)) -> ACTIVATE(X2)
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( ADD_2(x_1, x_2) ) = 2x_1 + 2
POL( FST_2(x_1, x_2) ) = 2x_1 + 2x_2
POL( LEN_1(x_1) ) = 2x_1
POL( activate_1(x_1) ) = x_1
POL( n__fst_2(x_1, x_2) ) = 2x_1 + x_2
POL( fst_2(x_1, x_2) ) = 2x_1 + x_2
POL( n__from_1(x_1) ) = 2x_1 + 2
POL( from_1(x_1) ) = 2x_1 + 2
POL( n__s_1(x_1) ) = x_1
POL( s_1(x_1) ) = x_1
POL( n__add_2(x_1, x_2) ) = x_1 + 2x_2 + 2
POL( add_2(x_1, x_2) ) = x_1 + 2x_2 + 2
POL( n__len_1(x_1) ) = x_1
POL( len_1(x_1) ) = x_1
POL( cons_2(x_1, x_2) ) = x_2
POL( 0 ) = 2
POL( nil ) = 2
POL( ACTIVATE_1(x_1) ) = 2x_1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   activate(n__fst(X1, X2)) -> fst(activate(X1), activate(X2))
   activate(n__from(X)) -> from(activate(X))
   activate(n__s(X)) -> s(X)
   activate(n__add(X1, X2)) -> add(activate(X1), activate(X2))
   activate(n__len(X)) -> len(activate(X))
   activate(X) -> X
   from(X) -> cons(X, n__from(n__s(X)))
   from(X) -> n__from(X)
   fst(0, Z) -> nil
   fst(X1, X2) -> n__fst(X1, X2)
   add(0, X) -> X
   add(X1, X2) -> n__add(X1, X2)
   len(nil) -> 0
   len(X) -> n__len(X)
   len(cons(X, Z)) -> s(n__len(activate(Z)))
   s(X) -> n__s(X)
   add(s(X), Y) -> s(n__add(activate(X), Y))
   fst(s(X), cons(Y, Z)) -> cons(Y, n__fst(activate(X), activate(Z)))


----------------------------------------

(6)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   ACTIVATE(n__fst(X1, X2)) -> FST(activate(X1), activate(X2))
   FST(s(X), cons(Y, Z)) -> ACTIVATE(X)
   ACTIVATE(n__fst(X1, X2)) -> ACTIVATE(X1)
   ACTIVATE(n__fst(X1, X2)) -> ACTIVATE(X2)
   ACTIVATE(n__len(X)) -> LEN(activate(X))
   LEN(cons(X, Z)) -> ACTIVATE(Z)
   ACTIVATE(n__len(X)) -> ACTIVATE(X)
   FST(s(X), cons(Y, Z)) -> ACTIVATE(Z)

The TRS R consists of the following rules:

   fst(0, Z) -> nil
   fst(s(X), cons(Y, Z)) -> cons(Y, n__fst(activate(X), activate(Z)))
   from(X) -> cons(X, n__from(n__s(X)))
   add(0, X) -> X
   add(s(X), Y) -> s(n__add(activate(X), Y))
   len(nil) -> 0
   len(cons(X, Z)) -> s(n__len(activate(Z)))
   fst(X1, X2) -> n__fst(X1, X2)
   from(X) -> n__from(X)
   s(X) -> n__s(X)
   add(X1, X2) -> n__add(X1, X2)
   len(X) -> n__len(X)
   activate(n__fst(X1, X2)) -> fst(activate(X1), activate(X2))
   activate(n__from(X)) -> from(activate(X))
   activate(n__s(X)) -> s(X)
   activate(n__add(X1, X2)) -> add(activate(X1), activate(X2))
   activate(n__len(X)) -> len(activate(X))
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(7) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   ACTIVATE(n__fst(X1, X2)) -> FST(activate(X1), activate(X2))
   ACTIVATE(n__fst(X1, X2)) -> ACTIVATE(X1)
   ACTIVATE(n__fst(X1, X2)) -> ACTIVATE(X2)
   LEN(cons(X, Z)) -> ACTIVATE(Z)
   ACTIVATE(n__len(X)) -> ACTIVATE(X)
The remaining pairs can at least be oriented weakly.
Used ordering:  Polynomial Order [NEGPOLO,POLO] with Interpretation:

POL( FST_2(x_1, x_2) ) = 2x_1 + 2x_2
POL( LEN_1(x_1) ) = x_1 + 2
POL( activate_1(x_1) ) = x_1
POL( n__fst_2(x_1, x_2) ) = 2x_1 + 2x_2 + 2
POL( fst_2(x_1, x_2) ) = 2x_1 + 2x_2 + 2
POL( n__from_1(x_1) ) = max{0, -2}
POL( from_1(x_1) ) = max{0, -2}
POL( n__s_1(x_1) ) = x_1
POL( s_1(x_1) ) = x_1
POL( n__add_2(x_1, x_2) ) = x_2
POL( add_2(x_1, x_2) ) = x_2
POL( n__len_1(x_1) ) = 2x_1 + 2
POL( len_1(x_1) ) = 2x_1 + 2
POL( cons_2(x_1, x_2) ) = x_2
POL( 0 ) = 2
POL( nil ) = 2
POL( ACTIVATE_1(x_1) ) = x_1

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   activate(n__fst(X1, X2)) -> fst(activate(X1), activate(X2))
   activate(n__from(X)) -> from(activate(X))
   activate(n__s(X)) -> s(X)
   activate(n__add(X1, X2)) -> add(activate(X1), activate(X2))
   activate(n__len(X)) -> len(activate(X))
   activate(X) -> X
   from(X) -> cons(X, n__from(n__s(X)))
   from(X) -> n__from(X)
   fst(0, Z) -> nil
   fst(X1, X2) -> n__fst(X1, X2)
   add(0, X) -> X
   add(X1, X2) -> n__add(X1, X2)
   len(nil) -> 0
   len(X) -> n__len(X)
   len(cons(X, Z)) -> s(n__len(activate(Z)))
   s(X) -> n__s(X)
   add(s(X), Y) -> s(n__add(activate(X), Y))
   fst(s(X), cons(Y, Z)) -> cons(Y, n__fst(activate(X), activate(Z)))


----------------------------------------

(8)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   FST(s(X), cons(Y, Z)) -> ACTIVATE(X)
   ACTIVATE(n__len(X)) -> LEN(activate(X))
   FST(s(X), cons(Y, Z)) -> ACTIVATE(Z)

The TRS R consists of the following rules:

   fst(0, Z) -> nil
   fst(s(X), cons(Y, Z)) -> cons(Y, n__fst(activate(X), activate(Z)))
   from(X) -> cons(X, n__from(n__s(X)))
   add(0, X) -> X
   add(s(X), Y) -> s(n__add(activate(X), Y))
   len(nil) -> 0
   len(cons(X, Z)) -> s(n__len(activate(Z)))
   fst(X1, X2) -> n__fst(X1, X2)
   from(X) -> n__from(X)
   s(X) -> n__s(X)
   add(X1, X2) -> n__add(X1, X2)
   len(X) -> n__len(X)
   activate(n__fst(X1, X2)) -> fst(activate(X1), activate(X2))
   activate(n__from(X)) -> from(activate(X))
   activate(n__s(X)) -> s(X)
   activate(n__add(X1, X2)) -> add(activate(X1), activate(X2))
   activate(n__len(X)) -> len(activate(X))
   activate(X) -> X

Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(9) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 3 less nodes.
----------------------------------------

(10)
TRUE
