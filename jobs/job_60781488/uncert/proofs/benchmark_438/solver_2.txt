YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/Ch5gx.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) Overlay + Local Confluence [EQUIVALENT, 0 ms]
(2) QTRS
(3) DependencyPairsProof [EQUIVALENT, 0 ms]
(4) QDP
(5) DependencyGraphProof [EQUIVALENT, 0 ms]
(6) AND
    (7) QDP
        (8) UsableRulesProof [EQUIVALENT, 0 ms]
        (9) QDP
        (10) QReductionProof [EQUIVALENT, 0 ms]
        (11) QDP
        (12) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (13) YES
    (14) QDP
        (15) UsableRulesProof [EQUIVALENT, 0 ms]
        (16) QDP
        (17) QReductionProof [EQUIVALENT, 0 ms]
        (18) QDP
        (19) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (20) YES
    (21) QDP
        (22) UsableRulesProof [EQUIVALENT, 0 ms]
        (23) QDP
        (24) QReductionProof [EQUIVALENT, 0 ms]
        (25) QDP
        (26) NonInfProof [EQUIVALENT, 508 ms]
        (27) QDP
        (28) DependencyGraphProof [EQUIVALENT, 0 ms]
        (29) TRUE


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   diff(x, y) -> cond1(equal(x, y), x, y)
   cond1(true, x, y) -> 0
   cond1(false, x, y) -> cond2(gt(x, y), x, y)
   cond2(true, x, y) -> s(diff(x, s(y)))
   cond2(false, x, y) -> s(diff(s(x), y))
   gt(0, v) -> false
   gt(s(u), 0) -> true
   gt(s(u), s(v)) -> gt(u, v)
   equal(0, 0) -> true
   equal(s(x), 0) -> false
   equal(0, s(y)) -> false
   equal(s(x), s(y)) -> equal(x, y)

Q is empty.

----------------------------------------

(1) Overlay + Local Confluence (EQUIVALENT)
The TRS is overlay and locally confluent. By [NOC] we can switch to innermost.
----------------------------------------

(2)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   diff(x, y) -> cond1(equal(x, y), x, y)
   cond1(true, x, y) -> 0
   cond1(false, x, y) -> cond2(gt(x, y), x, y)
   cond2(true, x, y) -> s(diff(x, s(y)))
   cond2(false, x, y) -> s(diff(s(x), y))
   gt(0, v) -> false
   gt(s(u), 0) -> true
   gt(s(u), s(v)) -> gt(u, v)
   equal(0, 0) -> true
   equal(s(x), 0) -> false
   equal(0, s(y)) -> false
   equal(s(x), s(y)) -> equal(x, y)

The set Q consists of the following terms:

   diff(x0, x1)
   cond1(true, x0, x1)
   cond1(false, x0, x1)
   cond2(true, x0, x1)
   cond2(false, x0, x1)
   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   equal(0, 0)
   equal(s(x0), 0)
   equal(0, s(x0))
   equal(s(x0), s(x1))


----------------------------------------

(3) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(4)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   DIFF(x, y) -> COND1(equal(x, y), x, y)
   DIFF(x, y) -> EQUAL(x, y)
   COND1(false, x, y) -> COND2(gt(x, y), x, y)
   COND1(false, x, y) -> GT(x, y)
   COND2(true, x, y) -> DIFF(x, s(y))
   COND2(false, x, y) -> DIFF(s(x), y)
   GT(s(u), s(v)) -> GT(u, v)
   EQUAL(s(x), s(y)) -> EQUAL(x, y)

The TRS R consists of the following rules:

   diff(x, y) -> cond1(equal(x, y), x, y)
   cond1(true, x, y) -> 0
   cond1(false, x, y) -> cond2(gt(x, y), x, y)
   cond2(true, x, y) -> s(diff(x, s(y)))
   cond2(false, x, y) -> s(diff(s(x), y))
   gt(0, v) -> false
   gt(s(u), 0) -> true
   gt(s(u), s(v)) -> gt(u, v)
   equal(0, 0) -> true
   equal(s(x), 0) -> false
   equal(0, s(y)) -> false
   equal(s(x), s(y)) -> equal(x, y)

The set Q consists of the following terms:

   diff(x0, x1)
   cond1(true, x0, x1)
   cond1(false, x0, x1)
   cond2(true, x0, x1)
   cond2(false, x0, x1)
   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   equal(0, 0)
   equal(s(x0), 0)
   equal(0, s(x0))
   equal(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(5) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 3 SCCs with 2 less nodes.
----------------------------------------

(6)
Complex Obligation (AND)

----------------------------------------

(7)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   EQUAL(s(x), s(y)) -> EQUAL(x, y)

The TRS R consists of the following rules:

   diff(x, y) -> cond1(equal(x, y), x, y)
   cond1(true, x, y) -> 0
   cond1(false, x, y) -> cond2(gt(x, y), x, y)
   cond2(true, x, y) -> s(diff(x, s(y)))
   cond2(false, x, y) -> s(diff(s(x), y))
   gt(0, v) -> false
   gt(s(u), 0) -> true
   gt(s(u), s(v)) -> gt(u, v)
   equal(0, 0) -> true
   equal(s(x), 0) -> false
   equal(0, s(y)) -> false
   equal(s(x), s(y)) -> equal(x, y)

The set Q consists of the following terms:

   diff(x0, x1)
   cond1(true, x0, x1)
   cond1(false, x0, x1)
   cond2(true, x0, x1)
   cond2(false, x0, x1)
   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   equal(0, 0)
   equal(s(x0), 0)
   equal(0, s(x0))
   equal(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(8) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(9)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   EQUAL(s(x), s(y)) -> EQUAL(x, y)

R is empty.
The set Q consists of the following terms:

   diff(x0, x1)
   cond1(true, x0, x1)
   cond1(false, x0, x1)
   cond2(true, x0, x1)
   cond2(false, x0, x1)
   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   equal(0, 0)
   equal(s(x0), 0)
   equal(0, s(x0))
   equal(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(10) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   diff(x0, x1)
   cond1(true, x0, x1)
   cond1(false, x0, x1)
   cond2(true, x0, x1)
   cond2(false, x0, x1)
   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   equal(0, 0)
   equal(s(x0), 0)
   equal(0, s(x0))
   equal(s(x0), s(x1))


----------------------------------------

(11)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   EQUAL(s(x), s(y)) -> EQUAL(x, y)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(12) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*EQUAL(s(x), s(y)) -> EQUAL(x, y)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(13)
YES

----------------------------------------

(14)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   GT(s(u), s(v)) -> GT(u, v)

The TRS R consists of the following rules:

   diff(x, y) -> cond1(equal(x, y), x, y)
   cond1(true, x, y) -> 0
   cond1(false, x, y) -> cond2(gt(x, y), x, y)
   cond2(true, x, y) -> s(diff(x, s(y)))
   cond2(false, x, y) -> s(diff(s(x), y))
   gt(0, v) -> false
   gt(s(u), 0) -> true
   gt(s(u), s(v)) -> gt(u, v)
   equal(0, 0) -> true
   equal(s(x), 0) -> false
   equal(0, s(y)) -> false
   equal(s(x), s(y)) -> equal(x, y)

The set Q consists of the following terms:

   diff(x0, x1)
   cond1(true, x0, x1)
   cond1(false, x0, x1)
   cond2(true, x0, x1)
   cond2(false, x0, x1)
   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   equal(0, 0)
   equal(s(x0), 0)
   equal(0, s(x0))
   equal(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(15) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(16)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   GT(s(u), s(v)) -> GT(u, v)

R is empty.
The set Q consists of the following terms:

   diff(x0, x1)
   cond1(true, x0, x1)
   cond1(false, x0, x1)
   cond2(true, x0, x1)
   cond2(false, x0, x1)
   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   equal(0, 0)
   equal(s(x0), 0)
   equal(0, s(x0))
   equal(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(17) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   diff(x0, x1)
   cond1(true, x0, x1)
   cond1(false, x0, x1)
   cond2(true, x0, x1)
   cond2(false, x0, x1)
   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   equal(0, 0)
   equal(s(x0), 0)
   equal(0, s(x0))
   equal(s(x0), s(x1))


----------------------------------------

(18)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   GT(s(u), s(v)) -> GT(u, v)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(19) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*GT(s(u), s(v)) -> GT(u, v)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(20)
YES

----------------------------------------

(21)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   COND1(false, x, y) -> COND2(gt(x, y), x, y)
   COND2(true, x, y) -> DIFF(x, s(y))
   DIFF(x, y) -> COND1(equal(x, y), x, y)
   COND2(false, x, y) -> DIFF(s(x), y)

The TRS R consists of the following rules:

   diff(x, y) -> cond1(equal(x, y), x, y)
   cond1(true, x, y) -> 0
   cond1(false, x, y) -> cond2(gt(x, y), x, y)
   cond2(true, x, y) -> s(diff(x, s(y)))
   cond2(false, x, y) -> s(diff(s(x), y))
   gt(0, v) -> false
   gt(s(u), 0) -> true
   gt(s(u), s(v)) -> gt(u, v)
   equal(0, 0) -> true
   equal(s(x), 0) -> false
   equal(0, s(y)) -> false
   equal(s(x), s(y)) -> equal(x, y)

The set Q consists of the following terms:

   diff(x0, x1)
   cond1(true, x0, x1)
   cond1(false, x0, x1)
   cond2(true, x0, x1)
   cond2(false, x0, x1)
   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   equal(0, 0)
   equal(s(x0), 0)
   equal(0, s(x0))
   equal(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(22) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(23)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   COND1(false, x, y) -> COND2(gt(x, y), x, y)
   COND2(true, x, y) -> DIFF(x, s(y))
   DIFF(x, y) -> COND1(equal(x, y), x, y)
   COND2(false, x, y) -> DIFF(s(x), y)

The TRS R consists of the following rules:

   equal(0, 0) -> true
   equal(s(x), 0) -> false
   equal(0, s(y)) -> false
   equal(s(x), s(y)) -> equal(x, y)
   gt(0, v) -> false
   gt(s(u), 0) -> true
   gt(s(u), s(v)) -> gt(u, v)

The set Q consists of the following terms:

   diff(x0, x1)
   cond1(true, x0, x1)
   cond1(false, x0, x1)
   cond2(true, x0, x1)
   cond2(false, x0, x1)
   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   equal(0, 0)
   equal(s(x0), 0)
   equal(0, s(x0))
   equal(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(24) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   diff(x0, x1)
   cond1(true, x0, x1)
   cond1(false, x0, x1)
   cond2(true, x0, x1)
   cond2(false, x0, x1)


----------------------------------------

(25)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   COND1(false, x, y) -> COND2(gt(x, y), x, y)
   COND2(true, x, y) -> DIFF(x, s(y))
   DIFF(x, y) -> COND1(equal(x, y), x, y)
   COND2(false, x, y) -> DIFF(s(x), y)

The TRS R consists of the following rules:

   equal(0, 0) -> true
   equal(s(x), 0) -> false
   equal(0, s(y)) -> false
   equal(s(x), s(y)) -> equal(x, y)
   gt(0, v) -> false
   gt(s(u), 0) -> true
   gt(s(u), s(v)) -> gt(u, v)

The set Q consists of the following terms:

   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   equal(0, 0)
   equal(s(x0), 0)
   equal(0, s(x0))
   equal(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(26) NonInfProof (EQUIVALENT)
The DP Problem is simplified using the Induction Calculus [NONINF] with the following steps:

Note that final constraints are written in bold face.



For Pair COND1(false, x, y) -> COND2(gt(x, y), x, y) the following chains were created:
*We consider the chain COND2(true, x22, x23) -> DIFF(x22, s(x23)), DIFF(x24, x25) -> COND1(equal(x24, x25), x24, x25), COND1(false, x26, x27) -> COND2(gt(x26, x27), x26, x27) which results in the following constraint:

(1)    (DIFF(x22, s(x23))=DIFF(x24, x25) & COND1(equal(x24, x25), x24, x25)=COND1(false, x26, x27)  ==>  COND1(false, x26, x27)_>=_COND2(gt(x26, x27), x26, x27))



We simplified constraint (1) using rules (I), (II), (III) which results in the following new constraint:

(2)    (s(x23)=x25 & equal(x24, x25)=false  ==>  COND1(false, x24, x25)_>=_COND2(gt(x24, x25), x24, x25))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on equal(x24, x25)=false which results in the following new constraints:

(3)    (false=false & s(x23)=0  ==>  COND1(false, s(x180), 0)_>=_COND2(gt(s(x180), 0), s(x180), 0))

(4)    (false=false & s(x23)=s(x181)  ==>  COND1(false, 0, s(x181))_>=_COND2(gt(0, s(x181)), 0, s(x181)))

(5)    (equal(x183, x182)=false & s(x23)=s(x182) & (\/x184:equal(x183, x182)=false & s(x184)=x182  ==>  COND1(false, x183, x182)_>=_COND2(gt(x183, x182), x183, x182))  ==>  COND1(false, s(x183), s(x182))_>=_COND2(gt(s(x183), s(x182)), s(x183), s(x182)))



We solved constraint (3) using rules (I), (II).We simplified constraint (4) using rules (I), (II), (III) which results in the following new constraint:

(6)    (COND1(false, 0, s(x23))_>=_COND2(gt(0, s(x23)), 0, s(x23)))



We simplified constraint (5) using rules (I), (II), (III), (IV) which results in the following new constraint:

(7)    (equal(x183, x182)=false  ==>  COND1(false, s(x183), s(x182))_>=_COND2(gt(s(x183), s(x182)), s(x183), s(x182)))



We simplified constraint (7) using rule (V) (with possible (I) afterwards) using induction on equal(x183, x182)=false which results in the following new constraints:

(8)    (false=false  ==>  COND1(false, s(s(x185)), s(0))_>=_COND2(gt(s(s(x185)), s(0)), s(s(x185)), s(0)))

(9)    (false=false  ==>  COND1(false, s(0), s(s(x186)))_>=_COND2(gt(s(0), s(s(x186))), s(0), s(s(x186))))

(10)    (equal(x188, x187)=false & (equal(x188, x187)=false  ==>  COND1(false, s(x188), s(x187))_>=_COND2(gt(s(x188), s(x187)), s(x188), s(x187)))  ==>  COND1(false, s(s(x188)), s(s(x187)))_>=_COND2(gt(s(s(x188)), s(s(x187))), s(s(x188)), s(s(x187))))



We simplified constraint (8) using rules (I), (II) which results in the following new constraint:

(11)    (COND1(false, s(s(x185)), s(0))_>=_COND2(gt(s(s(x185)), s(0)), s(s(x185)), s(0)))



We simplified constraint (9) using rules (I), (II) which results in the following new constraint:

(12)    (COND1(false, s(0), s(s(x186)))_>=_COND2(gt(s(0), s(s(x186))), s(0), s(s(x186))))



We simplified constraint (10) using rule (VI) where we applied the induction hypothesis (equal(x188, x187)=false  ==>  COND1(false, s(x188), s(x187))_>=_COND2(gt(s(x188), s(x187)), s(x188), s(x187))) with sigma = [ ] which results in the following new constraint:

(13)    (COND1(false, s(x188), s(x187))_>=_COND2(gt(s(x188), s(x187)), s(x188), s(x187))  ==>  COND1(false, s(s(x188)), s(s(x187)))_>=_COND2(gt(s(s(x188)), s(s(x187))), s(s(x188)), s(s(x187))))




*We consider the chain COND2(false, x30, x31) -> DIFF(s(x30), x31), DIFF(x32, x33) -> COND1(equal(x32, x33), x32, x33), COND1(false, x34, x35) -> COND2(gt(x34, x35), x34, x35) which results in the following constraint:

(1)    (DIFF(s(x30), x31)=DIFF(x32, x33) & COND1(equal(x32, x33), x32, x33)=COND1(false, x34, x35)  ==>  COND1(false, x34, x35)_>=_COND2(gt(x34, x35), x34, x35))



We simplified constraint (1) using rules (I), (II), (III) which results in the following new constraint:

(2)    (s(x30)=x32 & equal(x32, x33)=false  ==>  COND1(false, x32, x33)_>=_COND2(gt(x32, x33), x32, x33))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on equal(x32, x33)=false which results in the following new constraints:

(3)    (false=false & s(x30)=s(x189)  ==>  COND1(false, s(x189), 0)_>=_COND2(gt(s(x189), 0), s(x189), 0))

(4)    (false=false & s(x30)=0  ==>  COND1(false, 0, s(x190))_>=_COND2(gt(0, s(x190)), 0, s(x190)))

(5)    (equal(x192, x191)=false & s(x30)=s(x192) & (\/x193:equal(x192, x191)=false & s(x193)=x192  ==>  COND1(false, x192, x191)_>=_COND2(gt(x192, x191), x192, x191))  ==>  COND1(false, s(x192), s(x191))_>=_COND2(gt(s(x192), s(x191)), s(x192), s(x191)))



We simplified constraint (3) using rules (I), (II), (III) which results in the following new constraint:

(6)    (COND1(false, s(x30), 0)_>=_COND2(gt(s(x30), 0), s(x30), 0))



We solved constraint (4) using rules (I), (II).We simplified constraint (5) using rules (I), (II), (III), (IV) which results in the following new constraint:

(7)    (equal(x192, x191)=false  ==>  COND1(false, s(x192), s(x191))_>=_COND2(gt(s(x192), s(x191)), s(x192), s(x191)))



We simplified constraint (7) using rule (V) (with possible (I) afterwards) using induction on equal(x192, x191)=false which results in the following new constraints:

(8)    (false=false  ==>  COND1(false, s(s(x194)), s(0))_>=_COND2(gt(s(s(x194)), s(0)), s(s(x194)), s(0)))

(9)    (false=false  ==>  COND1(false, s(0), s(s(x195)))_>=_COND2(gt(s(0), s(s(x195))), s(0), s(s(x195))))

(10)    (equal(x197, x196)=false & (equal(x197, x196)=false  ==>  COND1(false, s(x197), s(x196))_>=_COND2(gt(s(x197), s(x196)), s(x197), s(x196)))  ==>  COND1(false, s(s(x197)), s(s(x196)))_>=_COND2(gt(s(s(x197)), s(s(x196))), s(s(x197)), s(s(x196))))



We simplified constraint (8) using rules (I), (II) which results in the following new constraint:

(11)    (COND1(false, s(s(x194)), s(0))_>=_COND2(gt(s(s(x194)), s(0)), s(s(x194)), s(0)))



We simplified constraint (9) using rules (I), (II) which results in the following new constraint:

(12)    (COND1(false, s(0), s(s(x195)))_>=_COND2(gt(s(0), s(s(x195))), s(0), s(s(x195))))



We simplified constraint (10) using rule (VI) where we applied the induction hypothesis (equal(x197, x196)=false  ==>  COND1(false, s(x197), s(x196))_>=_COND2(gt(s(x197), s(x196)), s(x197), s(x196))) with sigma = [ ] which results in the following new constraint:

(13)    (COND1(false, s(x197), s(x196))_>=_COND2(gt(s(x197), s(x196)), s(x197), s(x196))  ==>  COND1(false, s(s(x197)), s(s(x196)))_>=_COND2(gt(s(s(x197)), s(s(x196))), s(s(x197)), s(s(x196))))








For Pair COND2(true, x, y) -> DIFF(x, s(y)) the following chains were created:
*We consider the chain DIFF(x50, x51) -> COND1(equal(x50, x51), x50, x51), COND1(false, x52, x53) -> COND2(gt(x52, x53), x52, x53), COND2(true, x54, x55) -> DIFF(x54, s(x55)) which results in the following constraint:

(1)    (COND1(equal(x50, x51), x50, x51)=COND1(false, x52, x53) & COND2(gt(x52, x53), x52, x53)=COND2(true, x54, x55)  ==>  COND2(true, x54, x55)_>=_DIFF(x54, s(x55)))



We simplified constraint (1) using rules (I), (II), (III) which results in the following new constraint:

(2)    (equal(x50, x51)=false & x50=x52 & x51=x53 & gt(x52, x53)=true  ==>  COND2(true, x52, x53)_>=_DIFF(x52, s(x53)))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on equal(x50, x51)=false which results in the following new constraints:

(3)    (false=false & s(x198)=x52 & 0=x53 & gt(x52, x53)=true  ==>  COND2(true, x52, x53)_>=_DIFF(x52, s(x53)))

(4)    (false=false & 0=x52 & s(x199)=x53 & gt(x52, x53)=true  ==>  COND2(true, x52, x53)_>=_DIFF(x52, s(x53)))

(5)    (equal(x201, x200)=false & s(x201)=x52 & s(x200)=x53 & gt(x52, x53)=true & (\/x202,x203:equal(x201, x200)=false & x201=x202 & x200=x203 & gt(x202, x203)=true  ==>  COND2(true, x202, x203)_>=_DIFF(x202, s(x203)))  ==>  COND2(true, x52, x53)_>=_DIFF(x52, s(x53)))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(6)    (s(x198)=x52 & 0=x53 & gt(x52, x53)=true  ==>  COND2(true, x52, x53)_>=_DIFF(x52, s(x53)))



We simplified constraint (4) using rules (I), (II) which results in the following new constraint:

(7)    (0=x52 & s(x199)=x53 & gt(x52, x53)=true  ==>  COND2(true, x52, x53)_>=_DIFF(x52, s(x53)))



We simplified constraint (5) using rule (V) (with possible (I) afterwards) using induction on gt(x52, x53)=true which results in the following new constraints:

(8)    (true=true & equal(x201, x200)=false & s(x201)=s(x215) & s(x200)=0 & (\/x202,x203:equal(x201, x200)=false & x201=x202 & x200=x203 & gt(x202, x203)=true  ==>  COND2(true, x202, x203)_>=_DIFF(x202, s(x203)))  ==>  COND2(true, s(x215), 0)_>=_DIFF(s(x215), s(0)))

(9)    (gt(x217, x216)=true & equal(x201, x200)=false & s(x201)=s(x217) & s(x200)=s(x216) & (\/x202,x203:equal(x201, x200)=false & x201=x202 & x200=x203 & gt(x202, x203)=true  ==>  COND2(true, x202, x203)_>=_DIFF(x202, s(x203))) & (\/x218,x219,x220,x221:gt(x217, x216)=true & equal(x218, x219)=false & s(x218)=x217 & s(x219)=x216 & (\/x220,x221:equal(x218, x219)=false & x218=x220 & x219=x221 & gt(x220, x221)=true  ==>  COND2(true, x220, x221)_>=_DIFF(x220, s(x221)))  ==>  COND2(true, x217, x216)_>=_DIFF(x217, s(x216)))  ==>  COND2(true, s(x217), s(x216))_>=_DIFF(s(x217), s(s(x216))))



We simplified constraint (6) using rule (V) (with possible (I) afterwards) using induction on gt(x52, x53)=true which results in the following new constraints:

(10)    (true=true & s(x198)=s(x205) & 0=0  ==>  COND2(true, s(x205), 0)_>=_DIFF(s(x205), s(0)))

(11)    (gt(x207, x206)=true & s(x198)=s(x207) & 0=s(x206) & (\/x208:gt(x207, x206)=true & s(x208)=x207 & 0=x206  ==>  COND2(true, x207, x206)_>=_DIFF(x207, s(x206)))  ==>  COND2(true, s(x207), s(x206))_>=_DIFF(s(x207), s(s(x206))))



We simplified constraint (10) using rules (I), (II), (III) which results in the following new constraint:

(12)    (COND2(true, s(x198), 0)_>=_DIFF(s(x198), s(0)))



We solved constraint (11) using rules (I), (II).We simplified constraint (7) using rule (V) (with possible (I) afterwards) using induction on gt(x52, x53)=true which results in the following new constraints:

(13)    (true=true & 0=s(x210) & s(x199)=0  ==>  COND2(true, s(x210), 0)_>=_DIFF(s(x210), s(0)))

(14)    (gt(x212, x211)=true & 0=s(x212) & s(x199)=s(x211) & (\/x213:gt(x212, x211)=true & 0=x212 & s(x213)=x211  ==>  COND2(true, x212, x211)_>=_DIFF(x212, s(x211)))  ==>  COND2(true, s(x212), s(x211))_>=_DIFF(s(x212), s(s(x211))))



We solved constraint (13) using rules (I), (II).We solved constraint (14) using rules (I), (II).We solved constraint (8) using rules (I), (II).We simplified constraint (9) using rules (I), (II) which results in the following new constraint:

(15)    (gt(x217, x216)=true & equal(x201, x200)=false & x201=x217 & x200=x216 & (\/x202,x203:equal(x201, x200)=false & x201=x202 & x200=x203 & gt(x202, x203)=true  ==>  COND2(true, x202, x203)_>=_DIFF(x202, s(x203))) & (\/x218,x219,x220,x221:gt(x217, x216)=true & equal(x218, x219)=false & s(x218)=x217 & s(x219)=x216 & (\/x220,x221:equal(x218, x219)=false & x218=x220 & x219=x221 & gt(x220, x221)=true  ==>  COND2(true, x220, x221)_>=_DIFF(x220, s(x221)))  ==>  COND2(true, x217, x216)_>=_DIFF(x217, s(x216)))  ==>  COND2(true, s(x217), s(x216))_>=_DIFF(s(x217), s(s(x216))))



We simplified constraint (15) using rule (VI) where we applied the induction hypothesis (\/x202,x203:equal(x201, x200)=false & x201=x202 & x200=x203 & gt(x202, x203)=true  ==>  COND2(true, x202, x203)_>=_DIFF(x202, s(x203))) with sigma = [x202 / x217, x203 / x216] which results in the following new constraint:

(16)    (COND2(true, x217, x216)_>=_DIFF(x217, s(x216)) & (\/x218,x219,x220,x221:gt(x217, x216)=true & equal(x218, x219)=false & s(x218)=x217 & s(x219)=x216 & (\/x220,x221:equal(x218, x219)=false & x218=x220 & x219=x221 & gt(x220, x221)=true  ==>  COND2(true, x220, x221)_>=_DIFF(x220, s(x221)))  ==>  COND2(true, x217, x216)_>=_DIFF(x217, s(x216)))  ==>  COND2(true, s(x217), s(x216))_>=_DIFF(s(x217), s(s(x216))))



We simplified constraint (16) using rule (IV) which results in the following new constraint:

(17)    (COND2(true, x217, x216)_>=_DIFF(x217, s(x216))  ==>  COND2(true, s(x217), s(x216))_>=_DIFF(s(x217), s(s(x216))))








For Pair DIFF(x, y) -> COND1(equal(x, y), x, y) the following chains were created:
*We consider the chain COND1(false, x100, x101) -> COND2(gt(x100, x101), x100, x101), COND2(true, x102, x103) -> DIFF(x102, s(x103)), DIFF(x104, x105) -> COND1(equal(x104, x105), x104, x105) which results in the following constraint:

(1)    (COND2(gt(x100, x101), x100, x101)=COND2(true, x102, x103) & DIFF(x102, s(x103))=DIFF(x104, x105)  ==>  DIFF(x104, x105)_>=_COND1(equal(x104, x105), x104, x105))



We simplified constraint (1) using rules (I), (II), (III) which results in the following new constraint:

(2)    (gt(x100, x101)=true  ==>  DIFF(x100, s(x101))_>=_COND1(equal(x100, s(x101)), x100, s(x101)))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on gt(x100, x101)=true which results in the following new constraints:

(3)    (true=true  ==>  DIFF(s(x223), s(0))_>=_COND1(equal(s(x223), s(0)), s(x223), s(0)))

(4)    (gt(x225, x224)=true & (gt(x225, x224)=true  ==>  DIFF(x225, s(x224))_>=_COND1(equal(x225, s(x224)), x225, s(x224)))  ==>  DIFF(s(x225), s(s(x224)))_>=_COND1(equal(s(x225), s(s(x224))), s(x225), s(s(x224))))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(5)    (DIFF(s(x223), s(0))_>=_COND1(equal(s(x223), s(0)), s(x223), s(0)))



We simplified constraint (4) using rule (VI) where we applied the induction hypothesis (gt(x225, x224)=true  ==>  DIFF(x225, s(x224))_>=_COND1(equal(x225, s(x224)), x225, s(x224))) with sigma = [ ] which results in the following new constraint:

(6)    (DIFF(x225, s(x224))_>=_COND1(equal(x225, s(x224)), x225, s(x224))  ==>  DIFF(s(x225), s(s(x224)))_>=_COND1(equal(s(x225), s(s(x224))), s(x225), s(s(x224))))




*We consider the chain COND1(false, x124, x125) -> COND2(gt(x124, x125), x124, x125), COND2(false, x126, x127) -> DIFF(s(x126), x127), DIFF(x128, x129) -> COND1(equal(x128, x129), x128, x129) which results in the following constraint:

(1)    (COND2(gt(x124, x125), x124, x125)=COND2(false, x126, x127) & DIFF(s(x126), x127)=DIFF(x128, x129)  ==>  DIFF(x128, x129)_>=_COND1(equal(x128, x129), x128, x129))



We simplified constraint (1) using rules (I), (II), (III) which results in the following new constraint:

(2)    (gt(x124, x125)=false  ==>  DIFF(s(x124), x125)_>=_COND1(equal(s(x124), x125), s(x124), x125))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on gt(x124, x125)=false which results in the following new constraints:

(3)    (false=false  ==>  DIFF(s(0), x226)_>=_COND1(equal(s(0), x226), s(0), x226))

(4)    (gt(x229, x228)=false & (gt(x229, x228)=false  ==>  DIFF(s(x229), x228)_>=_COND1(equal(s(x229), x228), s(x229), x228))  ==>  DIFF(s(s(x229)), s(x228))_>=_COND1(equal(s(s(x229)), s(x228)), s(s(x229)), s(x228)))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(5)    (DIFF(s(0), x226)_>=_COND1(equal(s(0), x226), s(0), x226))



We simplified constraint (4) using rule (VI) where we applied the induction hypothesis (gt(x229, x228)=false  ==>  DIFF(s(x229), x228)_>=_COND1(equal(s(x229), x228), s(x229), x228)) with sigma = [ ] which results in the following new constraint:

(6)    (DIFF(s(x229), x228)_>=_COND1(equal(s(x229), x228), s(x229), x228)  ==>  DIFF(s(s(x229)), s(x228))_>=_COND1(equal(s(s(x229)), s(x228)), s(s(x229)), s(x228)))








For Pair COND2(false, x, y) -> DIFF(s(x), y) the following chains were created:
*We consider the chain DIFF(x140, x141) -> COND1(equal(x140, x141), x140, x141), COND1(false, x142, x143) -> COND2(gt(x142, x143), x142, x143), COND2(false, x144, x145) -> DIFF(s(x144), x145) which results in the following constraint:

(1)    (COND1(equal(x140, x141), x140, x141)=COND1(false, x142, x143) & COND2(gt(x142, x143), x142, x143)=COND2(false, x144, x145)  ==>  COND2(false, x144, x145)_>=_DIFF(s(x144), x145))



We simplified constraint (1) using rules (I), (II), (III) which results in the following new constraint:

(2)    (equal(x140, x141)=false & x140=x142 & x141=x143 & gt(x142, x143)=false  ==>  COND2(false, x142, x143)_>=_DIFF(s(x142), x143))



We simplified constraint (2) using rule (V) (with possible (I) afterwards) using induction on equal(x140, x141)=false which results in the following new constraints:

(3)    (false=false & s(x230)=x142 & 0=x143 & gt(x142, x143)=false  ==>  COND2(false, x142, x143)_>=_DIFF(s(x142), x143))

(4)    (false=false & 0=x142 & s(x231)=x143 & gt(x142, x143)=false  ==>  COND2(false, x142, x143)_>=_DIFF(s(x142), x143))

(5)    (equal(x233, x232)=false & s(x233)=x142 & s(x232)=x143 & gt(x142, x143)=false & (\/x234,x235:equal(x233, x232)=false & x233=x234 & x232=x235 & gt(x234, x235)=false  ==>  COND2(false, x234, x235)_>=_DIFF(s(x234), x235))  ==>  COND2(false, x142, x143)_>=_DIFF(s(x142), x143))



We simplified constraint (3) using rules (I), (II) which results in the following new constraint:

(6)    (s(x230)=x142 & 0=x143 & gt(x142, x143)=false  ==>  COND2(false, x142, x143)_>=_DIFF(s(x142), x143))



We simplified constraint (4) using rules (I), (II) which results in the following new constraint:

(7)    (0=x142 & s(x231)=x143 & gt(x142, x143)=false  ==>  COND2(false, x142, x143)_>=_DIFF(s(x142), x143))



We simplified constraint (5) using rule (V) (with possible (I) afterwards) using induction on gt(x142, x143)=false which results in the following new constraints:

(8)    (false=false & equal(x233, x232)=false & s(x233)=0 & s(x232)=x246 & (\/x234,x235:equal(x233, x232)=false & x233=x234 & x232=x235 & gt(x234, x235)=false  ==>  COND2(false, x234, x235)_>=_DIFF(s(x234), x235))  ==>  COND2(false, 0, x246)_>=_DIFF(s(0), x246))

(9)    (gt(x249, x248)=false & equal(x233, x232)=false & s(x233)=s(x249) & s(x232)=s(x248) & (\/x234,x235:equal(x233, x232)=false & x233=x234 & x232=x235 & gt(x234, x235)=false  ==>  COND2(false, x234, x235)_>=_DIFF(s(x234), x235)) & (\/x250,x251,x252,x253:gt(x249, x248)=false & equal(x250, x251)=false & s(x250)=x249 & s(x251)=x248 & (\/x252,x253:equal(x250, x251)=false & x250=x252 & x251=x253 & gt(x252, x253)=false  ==>  COND2(false, x252, x253)_>=_DIFF(s(x252), x253))  ==>  COND2(false, x249, x248)_>=_DIFF(s(x249), x248))  ==>  COND2(false, s(x249), s(x248))_>=_DIFF(s(s(x249)), s(x248)))



We simplified constraint (6) using rule (V) (with possible (I) afterwards) using induction on gt(x142, x143)=false which results in the following new constraints:

(10)    (false=false & s(x230)=0 & 0=x236  ==>  COND2(false, 0, x236)_>=_DIFF(s(0), x236))

(11)    (gt(x239, x238)=false & s(x230)=s(x239) & 0=s(x238) & (\/x240:gt(x239, x238)=false & s(x240)=x239 & 0=x238  ==>  COND2(false, x239, x238)_>=_DIFF(s(x239), x238))  ==>  COND2(false, s(x239), s(x238))_>=_DIFF(s(s(x239)), s(x238)))



We solved constraint (10) using rules (I), (II).We solved constraint (11) using rules (I), (II).We simplified constraint (7) using rule (V) (with possible (I) afterwards) using induction on gt(x142, x143)=false which results in the following new constraints:

(12)    (false=false & 0=0 & s(x231)=x241  ==>  COND2(false, 0, x241)_>=_DIFF(s(0), x241))

(13)    (gt(x244, x243)=false & 0=s(x244) & s(x231)=s(x243) & (\/x245:gt(x244, x243)=false & 0=x244 & s(x245)=x243  ==>  COND2(false, x244, x243)_>=_DIFF(s(x244), x243))  ==>  COND2(false, s(x244), s(x243))_>=_DIFF(s(s(x244)), s(x243)))



We simplified constraint (12) using rules (I), (II), (III) which results in the following new constraint:

(14)    (COND2(false, 0, s(x231))_>=_DIFF(s(0), s(x231)))



We solved constraint (13) using rules (I), (II).We solved constraint (8) using rules (I), (II).We simplified constraint (9) using rules (I), (II) which results in the following new constraint:

(15)    (gt(x249, x248)=false & equal(x233, x232)=false & x233=x249 & x232=x248 & (\/x234,x235:equal(x233, x232)=false & x233=x234 & x232=x235 & gt(x234, x235)=false  ==>  COND2(false, x234, x235)_>=_DIFF(s(x234), x235)) & (\/x250,x251,x252,x253:gt(x249, x248)=false & equal(x250, x251)=false & s(x250)=x249 & s(x251)=x248 & (\/x252,x253:equal(x250, x251)=false & x250=x252 & x251=x253 & gt(x252, x253)=false  ==>  COND2(false, x252, x253)_>=_DIFF(s(x252), x253))  ==>  COND2(false, x249, x248)_>=_DIFF(s(x249), x248))  ==>  COND2(false, s(x249), s(x248))_>=_DIFF(s(s(x249)), s(x248)))



We simplified constraint (15) using rule (VI) where we applied the induction hypothesis (\/x234,x235:equal(x233, x232)=false & x233=x234 & x232=x235 & gt(x234, x235)=false  ==>  COND2(false, x234, x235)_>=_DIFF(s(x234), x235)) with sigma = [x234 / x249, x235 / x248] which results in the following new constraint:

(16)    (COND2(false, x249, x248)_>=_DIFF(s(x249), x248) & (\/x250,x251,x252,x253:gt(x249, x248)=false & equal(x250, x251)=false & s(x250)=x249 & s(x251)=x248 & (\/x252,x253:equal(x250, x251)=false & x250=x252 & x251=x253 & gt(x252, x253)=false  ==>  COND2(false, x252, x253)_>=_DIFF(s(x252), x253))  ==>  COND2(false, x249, x248)_>=_DIFF(s(x249), x248))  ==>  COND2(false, s(x249), s(x248))_>=_DIFF(s(s(x249)), s(x248)))



We simplified constraint (16) using rule (IV) which results in the following new constraint:

(17)    (COND2(false, x249, x248)_>=_DIFF(s(x249), x248)  ==>  COND2(false, s(x249), s(x248))_>=_DIFF(s(s(x249)), s(x248)))








To summarize, we get the following constraints P__>=_ for the following pairs.

*COND1(false, x, y) -> COND2(gt(x, y), x, y)

*(COND1(false, 0, s(x23))_>=_COND2(gt(0, s(x23)), 0, s(x23)))


*(COND1(false, s(s(x185)), s(0))_>=_COND2(gt(s(s(x185)), s(0)), s(s(x185)), s(0)))


*(COND1(false, s(0), s(s(x186)))_>=_COND2(gt(s(0), s(s(x186))), s(0), s(s(x186))))


*(COND1(false, s(x188), s(x187))_>=_COND2(gt(s(x188), s(x187)), s(x188), s(x187))  ==>  COND1(false, s(s(x188)), s(s(x187)))_>=_COND2(gt(s(s(x188)), s(s(x187))), s(s(x188)), s(s(x187))))


*(COND1(false, s(x30), 0)_>=_COND2(gt(s(x30), 0), s(x30), 0))


*(COND1(false, s(s(x194)), s(0))_>=_COND2(gt(s(s(x194)), s(0)), s(s(x194)), s(0)))


*(COND1(false, s(0), s(s(x195)))_>=_COND2(gt(s(0), s(s(x195))), s(0), s(s(x195))))


*(COND1(false, s(x197), s(x196))_>=_COND2(gt(s(x197), s(x196)), s(x197), s(x196))  ==>  COND1(false, s(s(x197)), s(s(x196)))_>=_COND2(gt(s(s(x197)), s(s(x196))), s(s(x197)), s(s(x196))))




*COND2(true, x, y) -> DIFF(x, s(y))

*(COND2(true, s(x198), 0)_>=_DIFF(s(x198), s(0)))


*(COND2(true, x217, x216)_>=_DIFF(x217, s(x216))  ==>  COND2(true, s(x217), s(x216))_>=_DIFF(s(x217), s(s(x216))))




*DIFF(x, y) -> COND1(equal(x, y), x, y)

*(DIFF(s(x223), s(0))_>=_COND1(equal(s(x223), s(0)), s(x223), s(0)))


*(DIFF(x225, s(x224))_>=_COND1(equal(x225, s(x224)), x225, s(x224))  ==>  DIFF(s(x225), s(s(x224)))_>=_COND1(equal(s(x225), s(s(x224))), s(x225), s(s(x224))))


*(DIFF(s(0), x226)_>=_COND1(equal(s(0), x226), s(0), x226))


*(DIFF(s(x229), x228)_>=_COND1(equal(s(x229), x228), s(x229), x228)  ==>  DIFF(s(s(x229)), s(x228))_>=_COND1(equal(s(s(x229)), s(x228)), s(s(x229)), s(x228)))




*COND2(false, x, y) -> DIFF(s(x), y)

*(COND2(false, 0, s(x231))_>=_DIFF(s(0), s(x231)))


*(COND2(false, x249, x248)_>=_DIFF(s(x249), x248)  ==>  COND2(false, s(x249), s(x248))_>=_DIFF(s(s(x249)), s(x248)))








The constraints for P_> respective P_bound are constructed from P__>=_ where we just replace every occurence of "t _>=_ s" in P__>=_ by  "t > s" respective "t _>=_ c". Here c stands for the fresh constant used for P_bound. 

Using the following integer polynomial ordering the  resulting constraints can be solved 

Polynomial interpretation [NONINF]:

   POL(0) = 0
   POL(COND1(x_1, x_2, x_3)) = -1 + 2*x_1*x_2 - 2*x_1*x_3 + x_1^2 - 2*x_2*x_3 + x_2^2 + x_3^2
   POL(COND2(x_1, x_2, x_3)) = -1 - 2*x_1*x_2 + 2*x_1*x_3 + x_1^2 - 2*x_2*x_3 + x_2^2 + x_3^2
   POL(DIFF(x_1, x_2)) = -1 - 2*x_1*x_2 + x_1^2 + x_2^2
   POL(c) = -1
   POL(equal(x_1, x_2)) = 0
   POL(false) = 0
   POL(gt(x_1, x_2)) = 0
   POL(s(x_1)) = 1 + x_1
   POL(true) = 0


The following pairs  are in P_>:
   COND2(true, x, y) -> DIFF(x, s(y))
   COND2(false, x, y) -> DIFF(s(x), y)
The following pairs are in P_bound:
   COND1(false, x, y) -> COND2(gt(x, y), x, y)
   COND2(true, x, y) -> DIFF(x, s(y))
   DIFF(x, y) -> COND1(equal(x, y), x, y)
   COND2(false, x, y) -> DIFF(s(x), y)
The following rules are usable:
   gt(0, v) <-> false
   gt(s(u), 0) <-> true
   gt(s(u), s(v)) <-> gt(u, v)
   equal(0, 0) <-> true
   equal(s(x), 0) <-> false
   equal(0, s(y)) <-> false
   equal(s(x), s(y)) <-> equal(x, y)

----------------------------------------

(27)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   COND1(false, x, y) -> COND2(gt(x, y), x, y)
   DIFF(x, y) -> COND1(equal(x, y), x, y)

The TRS R consists of the following rules:

   equal(0, 0) -> true
   equal(s(x), 0) -> false
   equal(0, s(y)) -> false
   equal(s(x), s(y)) -> equal(x, y)
   gt(0, v) -> false
   gt(s(u), 0) -> true
   gt(s(u), s(v)) -> gt(u, v)

The set Q consists of the following terms:

   gt(0, x0)
   gt(s(x0), 0)
   gt(s(x0), s(x1))
   equal(0, 0)
   equal(s(x0), 0)
   equal(0, s(x0))
   equal(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(28) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 2 less nodes.
----------------------------------------

(29)
TRUE
