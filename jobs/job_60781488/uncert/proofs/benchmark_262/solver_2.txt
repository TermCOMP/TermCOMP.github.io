YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/HA4B3.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) Overlay + Local Confluence [EQUIVALENT, 0 ms]
(2) QTRS
(3) DependencyPairsProof [EQUIVALENT, 0 ms]
(4) QDP
(5) DependencyGraphProof [EQUIVALENT, 0 ms]
(6) AND
    (7) QDP
        (8) UsableRulesProof [EQUIVALENT, 0 ms]
        (9) QDP
        (10) QReductionProof [EQUIVALENT, 0 ms]
        (11) QDP
        (12) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (13) YES
    (14) QDP
        (15) UsableRulesProof [EQUIVALENT, 0 ms]
        (16) QDP
        (17) QReductionProof [EQUIVALENT, 0 ms]
        (18) QDP
        (19) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (20) YES
    (21) QDP
        (22) UsableRulesProof [EQUIVALENT, 0 ms]
        (23) QDP
        (24) QReductionProof [EQUIVALENT, 0 ms]
        (25) QDP
        (26) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (27) YES
    (28) QDP
        (29) UsableRulesProof [EQUIVALENT, 0 ms]
        (30) QDP
        (31) QReductionProof [EQUIVALENT, 0 ms]
        (32) QDP
        (33) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (34) YES
    (35) QDP
        (36) UsableRulesProof [EQUIVALENT, 0 ms]
        (37) QDP
        (38) QReductionProof [EQUIVALENT, 0 ms]
        (39) QDP
        (40) QDPOrderProof [EQUIVALENT, 0 ms]
        (41) QDP
        (42) PisEmptyProof [EQUIVALENT, 0 ms]
        (43) YES
    (44) QDP
        (45) UsableRulesProof [EQUIVALENT, 0 ms]
        (46) QDP
        (47) QReductionProof [EQUIVALENT, 0 ms]
        (48) QDP
        (49) Induction-Processor [SOUND, 24 ms]
        (50) AND
            (51) QDP
                (52) PisEmptyProof [EQUIVALENT, 0 ms]
                (53) YES
            (54) QTRS
                (55) Overlay + Local Confluence [EQUIVALENT, 0 ms]
                (56) QTRS
                (57) DependencyPairsProof [EQUIVALENT, 0 ms]
                (58) QDP
                (59) DependencyGraphProof [EQUIVALENT, 0 ms]
                (60) AND
                    (61) QDP
                        (62) UsableRulesProof [EQUIVALENT, 0 ms]
                        (63) QDP
                        (64) QReductionProof [EQUIVALENT, 0 ms]
                        (65) QDP
                        (66) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                        (67) YES
                    (68) QDP
                        (69) UsableRulesProof [EQUIVALENT, 0 ms]
                        (70) QDP
                        (71) QReductionProof [EQUIVALENT, 0 ms]
                        (72) QDP
                        (73) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                        (74) YES
                    (75) QDP
                        (76) UsableRulesProof [EQUIVALENT, 0 ms]
                        (77) QDP
                        (78) QReductionProof [EQUIVALENT, 0 ms]
                        (79) QDP
                        (80) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                        (81) YES
                    (82) QDP
                        (83) UsableRulesProof [EQUIVALENT, 0 ms]
                        (84) QDP
                        (85) QReductionProof [EQUIVALENT, 0 ms]
                        (86) QDP
                        (87) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                        (88) YES
                    (89) QDP
                        (90) UsableRulesProof [EQUIVALENT, 0 ms]
                        (91) QDP
                        (92) QReductionProof [EQUIVALENT, 0 ms]
                        (93) QDP
                        (94) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                        (95) YES
                    (96) QDP
                        (97) UsableRulesProof [EQUIVALENT, 0 ms]
                        (98) QDP
                        (99) QReductionProof [EQUIVALENT, 0 ms]
                        (100) QDP
                        (101) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                        (102) YES
                    (103) QDP
                        (104) UsableRulesProof [EQUIVALENT, 0 ms]
                        (105) QDP
                        (106) QReductionProof [EQUIVALENT, 0 ms]
                        (107) QDP
                        (108) QDPOrderProof [EQUIVALENT, 0 ms]
                        (109) QDP
                        (110) PisEmptyProof [EQUIVALENT, 0 ms]
                        (111) YES
                    (112) QDP
                        (113) UsableRulesProof [EQUIVALENT, 0 ms]
                        (114) QDP
                        (115) QReductionProof [EQUIVALENT, 0 ms]
                        (116) QDP
                        (117) QDPSizeChangeProof [EQUIVALENT, 0 ms]
                        (118) YES


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   max(nil) -> 0
   max(cons(x, nil)) -> x
   max(cons(x, cons(y, xs))) -> if1(ge(x, y), x, y, xs)
   if1(true, x, y, xs) -> max(cons(x, xs))
   if1(false, x, y, xs) -> max(cons(y, xs))
   del(x, nil) -> nil
   del(x, cons(y, xs)) -> if2(eq(x, y), x, y, xs)
   if2(true, x, y, xs) -> xs
   if2(false, x, y, xs) -> cons(y, del(x, xs))
   eq(0, 0) -> true
   eq(0, s(y)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   sort(nil) -> nil
   sort(cons(x, xs)) -> cons(max(cons(x, xs)), sort(h(del(max(cons(x, xs)), cons(x, xs)))))
   ge(0, 0) -> true
   ge(s(x), 0) -> true
   ge(0, s(x)) -> false
   ge(s(x), s(y)) -> ge(x, y)
   h(nil) -> nil
   h(cons(x, xs)) -> cons(x, h(xs))

Q is empty.

----------------------------------------

(1) Overlay + Local Confluence (EQUIVALENT)
The TRS is overlay and locally confluent. By [NOC] we can switch to innermost.
----------------------------------------

(2)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   max(nil) -> 0
   max(cons(x, nil)) -> x
   max(cons(x, cons(y, xs))) -> if1(ge(x, y), x, y, xs)
   if1(true, x, y, xs) -> max(cons(x, xs))
   if1(false, x, y, xs) -> max(cons(y, xs))
   del(x, nil) -> nil
   del(x, cons(y, xs)) -> if2(eq(x, y), x, y, xs)
   if2(true, x, y, xs) -> xs
   if2(false, x, y, xs) -> cons(y, del(x, xs))
   eq(0, 0) -> true
   eq(0, s(y)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   sort(nil) -> nil
   sort(cons(x, xs)) -> cons(max(cons(x, xs)), sort(h(del(max(cons(x, xs)), cons(x, xs)))))
   ge(0, 0) -> true
   ge(s(x), 0) -> true
   ge(0, s(x)) -> false
   ge(s(x), s(y)) -> ge(x, y)
   h(nil) -> nil
   h(cons(x, xs)) -> cons(x, h(xs))

The set Q consists of the following terms:

   max(nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true, x0, x1, x2)
   if1(false, x0, x1, x2)
   del(x0, nil)
   del(x0, cons(x1, x2))
   if2(true, x0, x1, x2)
   if2(false, x0, x1, x2)
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   sort(nil)
   sort(cons(x0, x1))
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   h(nil)
   h(cons(x0, x1))


----------------------------------------

(3) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(4)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MAX(cons(x, cons(y, xs))) -> IF1(ge(x, y), x, y, xs)
   MAX(cons(x, cons(y, xs))) -> GE(x, y)
   IF1(true, x, y, xs) -> MAX(cons(x, xs))
   IF1(false, x, y, xs) -> MAX(cons(y, xs))
   DEL(x, cons(y, xs)) -> IF2(eq(x, y), x, y, xs)
   DEL(x, cons(y, xs)) -> EQ(x, y)
   IF2(false, x, y, xs) -> DEL(x, xs)
   EQ(s(x), s(y)) -> EQ(x, y)
   SORT(cons(x, xs)) -> MAX(cons(x, xs))
   SORT(cons(x, xs)) -> SORT(h(del(max(cons(x, xs)), cons(x, xs))))
   SORT(cons(x, xs)) -> H(del(max(cons(x, xs)), cons(x, xs)))
   SORT(cons(x, xs)) -> DEL(max(cons(x, xs)), cons(x, xs))
   GE(s(x), s(y)) -> GE(x, y)
   H(cons(x, xs)) -> H(xs)

The TRS R consists of the following rules:

   max(nil) -> 0
   max(cons(x, nil)) -> x
   max(cons(x, cons(y, xs))) -> if1(ge(x, y), x, y, xs)
   if1(true, x, y, xs) -> max(cons(x, xs))
   if1(false, x, y, xs) -> max(cons(y, xs))
   del(x, nil) -> nil
   del(x, cons(y, xs)) -> if2(eq(x, y), x, y, xs)
   if2(true, x, y, xs) -> xs
   if2(false, x, y, xs) -> cons(y, del(x, xs))
   eq(0, 0) -> true
   eq(0, s(y)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   sort(nil) -> nil
   sort(cons(x, xs)) -> cons(max(cons(x, xs)), sort(h(del(max(cons(x, xs)), cons(x, xs)))))
   ge(0, 0) -> true
   ge(s(x), 0) -> true
   ge(0, s(x)) -> false
   ge(s(x), s(y)) -> ge(x, y)
   h(nil) -> nil
   h(cons(x, xs)) -> cons(x, h(xs))

The set Q consists of the following terms:

   max(nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true, x0, x1, x2)
   if1(false, x0, x1, x2)
   del(x0, nil)
   del(x0, cons(x1, x2))
   if2(true, x0, x1, x2)
   if2(false, x0, x1, x2)
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   sort(nil)
   sort(cons(x0, x1))
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   h(nil)
   h(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(5) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 6 SCCs with 5 less nodes.
----------------------------------------

(6)
Complex Obligation (AND)

----------------------------------------

(7)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(cons(x, xs)) -> H(xs)

The TRS R consists of the following rules:

   max(nil) -> 0
   max(cons(x, nil)) -> x
   max(cons(x, cons(y, xs))) -> if1(ge(x, y), x, y, xs)
   if1(true, x, y, xs) -> max(cons(x, xs))
   if1(false, x, y, xs) -> max(cons(y, xs))
   del(x, nil) -> nil
   del(x, cons(y, xs)) -> if2(eq(x, y), x, y, xs)
   if2(true, x, y, xs) -> xs
   if2(false, x, y, xs) -> cons(y, del(x, xs))
   eq(0, 0) -> true
   eq(0, s(y)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   sort(nil) -> nil
   sort(cons(x, xs)) -> cons(max(cons(x, xs)), sort(h(del(max(cons(x, xs)), cons(x, xs)))))
   ge(0, 0) -> true
   ge(s(x), 0) -> true
   ge(0, s(x)) -> false
   ge(s(x), s(y)) -> ge(x, y)
   h(nil) -> nil
   h(cons(x, xs)) -> cons(x, h(xs))

The set Q consists of the following terms:

   max(nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true, x0, x1, x2)
   if1(false, x0, x1, x2)
   del(x0, nil)
   del(x0, cons(x1, x2))
   if2(true, x0, x1, x2)
   if2(false, x0, x1, x2)
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   sort(nil)
   sort(cons(x0, x1))
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   h(nil)
   h(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(8) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(9)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(cons(x, xs)) -> H(xs)

R is empty.
The set Q consists of the following terms:

   max(nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true, x0, x1, x2)
   if1(false, x0, x1, x2)
   del(x0, nil)
   del(x0, cons(x1, x2))
   if2(true, x0, x1, x2)
   if2(false, x0, x1, x2)
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   sort(nil)
   sort(cons(x0, x1))
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   h(nil)
   h(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(10) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   max(nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true, x0, x1, x2)
   if1(false, x0, x1, x2)
   del(x0, nil)
   del(x0, cons(x1, x2))
   if2(true, x0, x1, x2)
   if2(false, x0, x1, x2)
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   sort(nil)
   sort(cons(x0, x1))
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   h(nil)
   h(cons(x0, x1))


----------------------------------------

(11)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(cons(x, xs)) -> H(xs)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(12) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*H(cons(x, xs)) -> H(xs)
The graph contains the following edges 1 > 1


----------------------------------------

(13)
YES

----------------------------------------

(14)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   GE(s(x), s(y)) -> GE(x, y)

The TRS R consists of the following rules:

   max(nil) -> 0
   max(cons(x, nil)) -> x
   max(cons(x, cons(y, xs))) -> if1(ge(x, y), x, y, xs)
   if1(true, x, y, xs) -> max(cons(x, xs))
   if1(false, x, y, xs) -> max(cons(y, xs))
   del(x, nil) -> nil
   del(x, cons(y, xs)) -> if2(eq(x, y), x, y, xs)
   if2(true, x, y, xs) -> xs
   if2(false, x, y, xs) -> cons(y, del(x, xs))
   eq(0, 0) -> true
   eq(0, s(y)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   sort(nil) -> nil
   sort(cons(x, xs)) -> cons(max(cons(x, xs)), sort(h(del(max(cons(x, xs)), cons(x, xs)))))
   ge(0, 0) -> true
   ge(s(x), 0) -> true
   ge(0, s(x)) -> false
   ge(s(x), s(y)) -> ge(x, y)
   h(nil) -> nil
   h(cons(x, xs)) -> cons(x, h(xs))

The set Q consists of the following terms:

   max(nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true, x0, x1, x2)
   if1(false, x0, x1, x2)
   del(x0, nil)
   del(x0, cons(x1, x2))
   if2(true, x0, x1, x2)
   if2(false, x0, x1, x2)
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   sort(nil)
   sort(cons(x0, x1))
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   h(nil)
   h(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(15) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(16)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   GE(s(x), s(y)) -> GE(x, y)

R is empty.
The set Q consists of the following terms:

   max(nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true, x0, x1, x2)
   if1(false, x0, x1, x2)
   del(x0, nil)
   del(x0, cons(x1, x2))
   if2(true, x0, x1, x2)
   if2(false, x0, x1, x2)
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   sort(nil)
   sort(cons(x0, x1))
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   h(nil)
   h(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(17) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   max(nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true, x0, x1, x2)
   if1(false, x0, x1, x2)
   del(x0, nil)
   del(x0, cons(x1, x2))
   if2(true, x0, x1, x2)
   if2(false, x0, x1, x2)
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   sort(nil)
   sort(cons(x0, x1))
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   h(nil)
   h(cons(x0, x1))


----------------------------------------

(18)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   GE(s(x), s(y)) -> GE(x, y)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(19) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*GE(s(x), s(y)) -> GE(x, y)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(20)
YES

----------------------------------------

(21)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   EQ(s(x), s(y)) -> EQ(x, y)

The TRS R consists of the following rules:

   max(nil) -> 0
   max(cons(x, nil)) -> x
   max(cons(x, cons(y, xs))) -> if1(ge(x, y), x, y, xs)
   if1(true, x, y, xs) -> max(cons(x, xs))
   if1(false, x, y, xs) -> max(cons(y, xs))
   del(x, nil) -> nil
   del(x, cons(y, xs)) -> if2(eq(x, y), x, y, xs)
   if2(true, x, y, xs) -> xs
   if2(false, x, y, xs) -> cons(y, del(x, xs))
   eq(0, 0) -> true
   eq(0, s(y)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   sort(nil) -> nil
   sort(cons(x, xs)) -> cons(max(cons(x, xs)), sort(h(del(max(cons(x, xs)), cons(x, xs)))))
   ge(0, 0) -> true
   ge(s(x), 0) -> true
   ge(0, s(x)) -> false
   ge(s(x), s(y)) -> ge(x, y)
   h(nil) -> nil
   h(cons(x, xs)) -> cons(x, h(xs))

The set Q consists of the following terms:

   max(nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true, x0, x1, x2)
   if1(false, x0, x1, x2)
   del(x0, nil)
   del(x0, cons(x1, x2))
   if2(true, x0, x1, x2)
   if2(false, x0, x1, x2)
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   sort(nil)
   sort(cons(x0, x1))
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   h(nil)
   h(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(22) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(23)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   EQ(s(x), s(y)) -> EQ(x, y)

R is empty.
The set Q consists of the following terms:

   max(nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true, x0, x1, x2)
   if1(false, x0, x1, x2)
   del(x0, nil)
   del(x0, cons(x1, x2))
   if2(true, x0, x1, x2)
   if2(false, x0, x1, x2)
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   sort(nil)
   sort(cons(x0, x1))
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   h(nil)
   h(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(24) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   max(nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true, x0, x1, x2)
   if1(false, x0, x1, x2)
   del(x0, nil)
   del(x0, cons(x1, x2))
   if2(true, x0, x1, x2)
   if2(false, x0, x1, x2)
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   sort(nil)
   sort(cons(x0, x1))
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   h(nil)
   h(cons(x0, x1))


----------------------------------------

(25)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   EQ(s(x), s(y)) -> EQ(x, y)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(26) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*EQ(s(x), s(y)) -> EQ(x, y)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(27)
YES

----------------------------------------

(28)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false, x, y, xs) -> DEL(x, xs)
   DEL(x, cons(y, xs)) -> IF2(eq(x, y), x, y, xs)

The TRS R consists of the following rules:

   max(nil) -> 0
   max(cons(x, nil)) -> x
   max(cons(x, cons(y, xs))) -> if1(ge(x, y), x, y, xs)
   if1(true, x, y, xs) -> max(cons(x, xs))
   if1(false, x, y, xs) -> max(cons(y, xs))
   del(x, nil) -> nil
   del(x, cons(y, xs)) -> if2(eq(x, y), x, y, xs)
   if2(true, x, y, xs) -> xs
   if2(false, x, y, xs) -> cons(y, del(x, xs))
   eq(0, 0) -> true
   eq(0, s(y)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   sort(nil) -> nil
   sort(cons(x, xs)) -> cons(max(cons(x, xs)), sort(h(del(max(cons(x, xs)), cons(x, xs)))))
   ge(0, 0) -> true
   ge(s(x), 0) -> true
   ge(0, s(x)) -> false
   ge(s(x), s(y)) -> ge(x, y)
   h(nil) -> nil
   h(cons(x, xs)) -> cons(x, h(xs))

The set Q consists of the following terms:

   max(nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true, x0, x1, x2)
   if1(false, x0, x1, x2)
   del(x0, nil)
   del(x0, cons(x1, x2))
   if2(true, x0, x1, x2)
   if2(false, x0, x1, x2)
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   sort(nil)
   sort(cons(x0, x1))
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   h(nil)
   h(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(29) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(30)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false, x, y, xs) -> DEL(x, xs)
   DEL(x, cons(y, xs)) -> IF2(eq(x, y), x, y, xs)

The TRS R consists of the following rules:

   eq(0, 0) -> true
   eq(0, s(y)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   max(nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true, x0, x1, x2)
   if1(false, x0, x1, x2)
   del(x0, nil)
   del(x0, cons(x1, x2))
   if2(true, x0, x1, x2)
   if2(false, x0, x1, x2)
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   sort(nil)
   sort(cons(x0, x1))
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   h(nil)
   h(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(31) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   max(nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true, x0, x1, x2)
   if1(false, x0, x1, x2)
   del(x0, nil)
   del(x0, cons(x1, x2))
   if2(true, x0, x1, x2)
   if2(false, x0, x1, x2)
   sort(nil)
   sort(cons(x0, x1))
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   h(nil)
   h(cons(x0, x1))


----------------------------------------

(32)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false, x, y, xs) -> DEL(x, xs)
   DEL(x, cons(y, xs)) -> IF2(eq(x, y), x, y, xs)

The TRS R consists of the following rules:

   eq(0, 0) -> true
   eq(0, s(y)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(33) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*DEL(x, cons(y, xs)) -> IF2(eq(x, y), x, y, xs)
The graph contains the following edges 1 >= 2, 2 > 3, 2 > 4


*IF2(false, x, y, xs) -> DEL(x, xs)
The graph contains the following edges 2 >= 1, 4 >= 2


----------------------------------------

(34)
YES

----------------------------------------

(35)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF1(true, x, y, xs) -> MAX(cons(x, xs))
   MAX(cons(x, cons(y, xs))) -> IF1(ge(x, y), x, y, xs)
   IF1(false, x, y, xs) -> MAX(cons(y, xs))

The TRS R consists of the following rules:

   max(nil) -> 0
   max(cons(x, nil)) -> x
   max(cons(x, cons(y, xs))) -> if1(ge(x, y), x, y, xs)
   if1(true, x, y, xs) -> max(cons(x, xs))
   if1(false, x, y, xs) -> max(cons(y, xs))
   del(x, nil) -> nil
   del(x, cons(y, xs)) -> if2(eq(x, y), x, y, xs)
   if2(true, x, y, xs) -> xs
   if2(false, x, y, xs) -> cons(y, del(x, xs))
   eq(0, 0) -> true
   eq(0, s(y)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   sort(nil) -> nil
   sort(cons(x, xs)) -> cons(max(cons(x, xs)), sort(h(del(max(cons(x, xs)), cons(x, xs)))))
   ge(0, 0) -> true
   ge(s(x), 0) -> true
   ge(0, s(x)) -> false
   ge(s(x), s(y)) -> ge(x, y)
   h(nil) -> nil
   h(cons(x, xs)) -> cons(x, h(xs))

The set Q consists of the following terms:

   max(nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true, x0, x1, x2)
   if1(false, x0, x1, x2)
   del(x0, nil)
   del(x0, cons(x1, x2))
   if2(true, x0, x1, x2)
   if2(false, x0, x1, x2)
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   sort(nil)
   sort(cons(x0, x1))
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   h(nil)
   h(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(36) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(37)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF1(true, x, y, xs) -> MAX(cons(x, xs))
   MAX(cons(x, cons(y, xs))) -> IF1(ge(x, y), x, y, xs)
   IF1(false, x, y, xs) -> MAX(cons(y, xs))

The TRS R consists of the following rules:

   ge(0, 0) -> true
   ge(s(x), 0) -> true
   ge(0, s(x)) -> false
   ge(s(x), s(y)) -> ge(x, y)

The set Q consists of the following terms:

   max(nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true, x0, x1, x2)
   if1(false, x0, x1, x2)
   del(x0, nil)
   del(x0, cons(x1, x2))
   if2(true, x0, x1, x2)
   if2(false, x0, x1, x2)
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   sort(nil)
   sort(cons(x0, x1))
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   h(nil)
   h(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(38) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   max(nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true, x0, x1, x2)
   if1(false, x0, x1, x2)
   del(x0, nil)
   del(x0, cons(x1, x2))
   if2(true, x0, x1, x2)
   if2(false, x0, x1, x2)
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   sort(nil)
   sort(cons(x0, x1))
   h(nil)
   h(cons(x0, x1))


----------------------------------------

(39)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF1(true, x, y, xs) -> MAX(cons(x, xs))
   MAX(cons(x, cons(y, xs))) -> IF1(ge(x, y), x, y, xs)
   IF1(false, x, y, xs) -> MAX(cons(y, xs))

The TRS R consists of the following rules:

   ge(0, 0) -> true
   ge(s(x), 0) -> true
   ge(0, s(x)) -> false
   ge(s(x), s(y)) -> ge(x, y)

The set Q consists of the following terms:

   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(40) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   IF1(true, x, y, xs) -> MAX(cons(x, xs))
   MAX(cons(x, cons(y, xs))) -> IF1(ge(x, y), x, y, xs)
   IF1(false, x, y, xs) -> MAX(cons(y, xs))
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
IF1(x1, x2, x3, x4)  =  IF1(x4)

MAX(x1)  =  x1

cons(x1, x2)  =  cons(x2)


Knuth-Bendix order [KBO] with precedence:trivial

and weight map:

   dummyConstant=1
   IF1_1=3
   cons_1=2

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:
none


----------------------------------------

(41)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   ge(0, 0) -> true
   ge(s(x), 0) -> true
   ge(0, s(x)) -> false
   ge(s(x), s(y)) -> ge(x, y)

The set Q consists of the following terms:

   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(42) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(43)
YES

----------------------------------------

(44)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   SORT(cons(x, xs)) -> SORT(h(del(max(cons(x, xs)), cons(x, xs))))

The TRS R consists of the following rules:

   max(nil) -> 0
   max(cons(x, nil)) -> x
   max(cons(x, cons(y, xs))) -> if1(ge(x, y), x, y, xs)
   if1(true, x, y, xs) -> max(cons(x, xs))
   if1(false, x, y, xs) -> max(cons(y, xs))
   del(x, nil) -> nil
   del(x, cons(y, xs)) -> if2(eq(x, y), x, y, xs)
   if2(true, x, y, xs) -> xs
   if2(false, x, y, xs) -> cons(y, del(x, xs))
   eq(0, 0) -> true
   eq(0, s(y)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   sort(nil) -> nil
   sort(cons(x, xs)) -> cons(max(cons(x, xs)), sort(h(del(max(cons(x, xs)), cons(x, xs)))))
   ge(0, 0) -> true
   ge(s(x), 0) -> true
   ge(0, s(x)) -> false
   ge(s(x), s(y)) -> ge(x, y)
   h(nil) -> nil
   h(cons(x, xs)) -> cons(x, h(xs))

The set Q consists of the following terms:

   max(nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true, x0, x1, x2)
   if1(false, x0, x1, x2)
   del(x0, nil)
   del(x0, cons(x1, x2))
   if2(true, x0, x1, x2)
   if2(false, x0, x1, x2)
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   sort(nil)
   sort(cons(x0, x1))
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   h(nil)
   h(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(45) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(46)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   SORT(cons(x, xs)) -> SORT(h(del(max(cons(x, xs)), cons(x, xs))))

The TRS R consists of the following rules:

   max(cons(x, nil)) -> x
   max(cons(x, cons(y, xs))) -> if1(ge(x, y), x, y, xs)
   if1(true, x, y, xs) -> max(cons(x, xs))
   if1(false, x, y, xs) -> max(cons(y, xs))
   del(x, cons(y, xs)) -> if2(eq(x, y), x, y, xs)
   h(nil) -> nil
   h(cons(x, xs)) -> cons(x, h(xs))
   eq(0, 0) -> true
   eq(0, s(y)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   if2(true, x, y, xs) -> xs
   if2(false, x, y, xs) -> cons(y, del(x, xs))
   del(x, nil) -> nil
   ge(0, 0) -> true
   ge(s(x), 0) -> true
   ge(0, s(x)) -> false
   ge(s(x), s(y)) -> ge(x, y)

The set Q consists of the following terms:

   max(nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true, x0, x1, x2)
   if1(false, x0, x1, x2)
   del(x0, nil)
   del(x0, cons(x1, x2))
   if2(true, x0, x1, x2)
   if2(false, x0, x1, x2)
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   sort(nil)
   sort(cons(x0, x1))
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   h(nil)
   h(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(47) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   sort(nil)
   sort(cons(x0, x1))


----------------------------------------

(48)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   SORT(cons(x, xs)) -> SORT(h(del(max(cons(x, xs)), cons(x, xs))))

The TRS R consists of the following rules:

   max(cons(x, nil)) -> x
   max(cons(x, cons(y, xs))) -> if1(ge(x, y), x, y, xs)
   if1(true, x, y, xs) -> max(cons(x, xs))
   if1(false, x, y, xs) -> max(cons(y, xs))
   del(x, cons(y, xs)) -> if2(eq(x, y), x, y, xs)
   h(nil) -> nil
   h(cons(x, xs)) -> cons(x, h(xs))
   eq(0, 0) -> true
   eq(0, s(y)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   if2(true, x, y, xs) -> xs
   if2(false, x, y, xs) -> cons(y, del(x, xs))
   del(x, nil) -> nil
   ge(0, 0) -> true
   ge(s(x), 0) -> true
   ge(0, s(x)) -> false
   ge(s(x), s(y)) -> ge(x, y)

The set Q consists of the following terms:

   max(nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true, x0, x1, x2)
   if1(false, x0, x1, x2)
   del(x0, nil)
   del(x0, cons(x1, x2))
   if2(true, x0, x1, x2)
   if2(false, x0, x1, x2)
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   h(nil)
   h(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(49) Induction-Processor (SOUND)

This DP could be deleted by the Induction-Processor:
SORT(cons(x, xs)) -> SORT(h(del(max(cons(x, xs)), cons(x, xs))))


This order was computed:
Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(SORT(x_1)) = 2*x_1
   POL(cons(x_1, x_2)) = 2 + x_1 + x_2
   POL(del(x_1, x_2)) = x_2
   POL(eq(x_1, x_2)) = 1
   POL(false_renamed) = 1
   POL(ge(x_1, x_2)) = 1
   POL(h(x_1)) = x_1
   POL(if1(x_1, x_2, x_3, x_4)) = 2 + 2*x_1 + 2*x_2 + 2*x_3 + 2*x_4
   POL(if2(x_1, x_2, x_3, x_4)) = 2*x_1 + x_3 + x_4
   POL(max(x_1)) = 2*x_1
   POL(nil) = 0
   POL(s(x_1)) = 3*x_1
   POL(true_renamed) = 1

At least one of these decreasing rules is always used after the deleted DP:
if2(true_renamed, x7, y4, xs4) -> xs4


The following formula is valid:
z0:sort[a37].(~(z0=nil)->del'(max(z0), z0)=true)


The transformed set:
del'(x3, cons(y1, xs2)) -> if2'(eq(x3, y1), x3, y1, xs2)
if2'(true_renamed, x7, y4, xs4) -> true
if2'(false_renamed, x8, y5, xs5) -> del'(x8, xs5)
del'(x9, nil) -> false
max(cons(x', nil)) -> x'
max(cons(x'', cons(y, xs'))) -> if1(ge(x'', y), x'', y, xs')
if1(true_renamed, x1, y', xs'') -> max(cons(x1, xs''))
if1(false_renamed, x2, y'', xs1) -> max(cons(y'', xs1))
del(x3, cons(y1, xs2)) -> if2(eq(x3, y1), x3, y1, xs2)
h(nil) -> nil
h(cons(x4, xs3)) -> cons(x4, h(xs3))
eq(0, 0) -> true_renamed
eq(0, s(y2)) -> false_renamed
eq(s(x5), 0) -> false_renamed
eq(s(x6), s(y3)) -> eq(x6, y3)
if2(true_renamed, x7, y4, xs4) -> xs4
if2(false_renamed, x8, y5, xs5) -> cons(y5, del(x8, xs5))
del(x9, nil) -> nil
ge(0, 0) -> true_renamed
ge(s(x10), 0) -> true_renamed
ge(0, s(x11)) -> false_renamed
ge(s(x12), s(y6)) -> ge(x12, y6)
max(nil) -> 0
equal_bool(true, false) -> false
equal_bool(false, true) -> false
equal_bool(true, true) -> true
equal_bool(false, false) -> true
and(true, x) -> x
and(false, x) -> false
or(true, x) -> true
or(false, x) -> x
not(false) -> true
not(true) -> false
isa_true(true) -> true
isa_true(false) -> false
isa_false(true) -> false
isa_false(false) -> true
equal_sort[a0](0, 0) -> true
equal_sort[a0](0, s(v30)) -> false
equal_sort[a0](s(v31), 0) -> false
equal_sort[a0](s(v31), s(v32)) -> equal_sort[a0](v31, v32)
equal_sort[a37](cons(v33, v34), cons(v35, v36)) -> and(equal_sort[a0](v33, v35), equal_sort[a37](v34, v36))
equal_sort[a37](cons(v33, v34), nil) -> false
equal_sort[a37](nil, cons(v37, v38)) -> false
equal_sort[a37](nil, nil) -> true
equal_sort[a45](true_renamed, true_renamed) -> true
equal_sort[a45](true_renamed, false_renamed) -> false
equal_sort[a45](false_renamed, true_renamed) -> false
equal_sort[a45](false_renamed, false_renamed) -> true
equal_sort[a65](witness_sort[a65], witness_sort[a65]) -> true


The proof given by the theorem prover:
The following output was given by the internal theorem prover:proof of internal
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Partial correctness of the following Program

   [x, v30, v31, v32, v33, v34, v35, v36, v37, v38, x7, y4, xs4, x8, y5, y1, xs2, x9, x3, x', x'', y, xs', x4, xs3, y2, x5, x6, y3, x10, x11, x12, y6, x1, y', x2, y'', xs'', xs1]
   equal_bool(true, false) -> false
   equal_bool(false, true) -> false
   equal_bool(true, true) -> true
   equal_bool(false, false) -> true
   true and x -> x
   false and x -> false
   true or x -> true
   false or x -> x
   not(false) -> true
   not(true) -> false
   isa_true(true) -> true
   isa_true(false) -> false
   isa_false(true) -> false
   isa_false(false) -> true
   equal_sort[a0](0, 0) -> true
   equal_sort[a0](0, s(v30)) -> false
   equal_sort[a0](s(v31), 0) -> false
   equal_sort[a0](s(v31), s(v32)) -> equal_sort[a0](v31, v32)
   equal_sort[a37](cons(v33, v34), cons(v35, v36)) -> equal_sort[a0](v33, v35) and equal_sort[a37](v34, v36)
   equal_sort[a37](cons(v33, v34), nil) -> false
   equal_sort[a37](nil, cons(v37, v38)) -> false
   equal_sort[a37](nil, nil) -> true
   equal_sort[a45](true_renamed, true_renamed) -> true
   equal_sort[a45](true_renamed, false_renamed) -> false
   equal_sort[a45](false_renamed, true_renamed) -> false
   equal_sort[a45](false_renamed, false_renamed) -> true
   equal_sort[a65](witness_sort[a65], witness_sort[a65]) -> true
   if2'(true_renamed, x7, y4, xs4) -> true
   if2'(false_renamed, x8, y5, cons(y1, xs2)) -> if2'(eq(x8, y1), x8, y1, xs2)
   if2'(false_renamed, x8, y5, nil) -> false
   del'(x9, nil) -> false
   equal_sort[a45](eq(x3, y1), true_renamed) -> true | del'(x3, cons(y1, xs2)) -> true
   equal_sort[a45](eq(x3, y1), true_renamed) -> false | del'(x3, cons(y1, xs2)) -> del'(x3, xs2)
   max(cons(x', nil)) -> x'
   max(nil) -> 0
   equal_sort[a45](ge(x'', y), true_renamed) -> true | max(cons(x'', cons(y, xs'))) -> max(cons(x'', xs'))
   equal_sort[a45](ge(x'', y), true_renamed) -> false | max(cons(x'', cons(y, xs'))) -> max(cons(y, xs'))
   h(nil) -> nil
   h(cons(x4, xs3)) -> cons(x4, h(xs3))
   eq(0, 0) -> true_renamed
   eq(0, s(y2)) -> false_renamed
   eq(s(x5), 0) -> false_renamed
   eq(s(x6), s(y3)) -> eq(x6, y3)
   if2(true_renamed, x7, y4, xs4) -> xs4
   if2(false_renamed, x8, y5, cons(y1, xs2)) -> cons(y5, if2(eq(x8, y1), x8, y1, xs2))
   if2(false_renamed, x8, y5, nil) -> cons(y5, nil)
   del(x9, nil) -> nil
   equal_sort[a45](eq(x3, y1), true_renamed) -> true | del(x3, cons(y1, xs2)) -> xs2
   equal_sort[a45](eq(x3, y1), true_renamed) -> false | del(x3, cons(y1, xs2)) -> cons(y1, del(x3, xs2))
   ge(0, 0) -> true_renamed
   ge(s(x10), 0) -> true_renamed
   ge(0, s(x11)) -> false_renamed
   ge(s(x12), s(y6)) -> ge(x12, y6)
   if1(true_renamed, x1, y', nil) -> x1
   if1(true_renamed, x1, y', cons(y, xs')) -> if1(ge(x1, y), x1, y, xs')
   if1(false_renamed, x2, y'', nil) -> y''
   if1(false_renamed, x2, y'', cons(y, xs')) -> if1(ge(y'', y), y'', y, xs')
   if1(true_renamed, x1, y', xs'') -> 0
   if1(false_renamed, x2, y'', xs1) -> 0

using the following formula:
z0:sort[a37].(~(z0=nil)->del'(max(z0), z0)=true)

could be successfully shown:
(0) Formula
(1) Induction by algorithm [EQUIVALENT, 0 ms]
(2) AND
    (3) Formula
        (4) Symbolic evaluation [EQUIVALENT, 0 ms]
        (5) Formula
        (6) Induction by data structure [EQUIVALENT, 0 ms]
        (7) AND
            (8) Formula
                (9) Symbolic evaluation [EQUIVALENT, 0 ms]
                (10) YES
            (11) Formula
                (12) Conditional Evaluation [EQUIVALENT, 0 ms]
                (13) AND
                    (14) Formula
                        (15) Symbolic evaluation [EQUIVALENT, 0 ms]
                        (16) YES
                    (17) Formula
                        (18) Symbolic evaluation [EQUIVALENT, 0 ms]
                        (19) Formula
                        (20) Hypothesis Lifting [EQUIVALENT, 0 ms]
                        (21) Formula
                        (22) Symbolic evaluation under hypothesis [SOUND, 0 ms]
                        (23) Formula
                        (24) Hypothesis Lifting [EQUIVALENT, 0 ms]
                        (25) Formula
                        (26) Hypothesis Lifting [EQUIVALENT, 0 ms]
                        (27) Formula
                        (28) Conditional Evaluation [EQUIVALENT, 0 ms]
                        (29) AND
                            (30) Formula
                                (31) Symbolic evaluation under hypothesis [EQUIVALENT, 0 ms]
                                (32) YES
                            (33) Formula
                                (34) Symbolic evaluation [EQUIVALENT, 0 ms]
                                (35) YES
    (36) Formula
        (37) Symbolic evaluation [EQUIVALENT, 0 ms]
        (38) YES
    (39) Formula
        (40) Symbolic evaluation [EQUIVALENT, 0 ms]
        (41) Formula
        (42) Conditional Evaluation [EQUIVALENT, 0 ms]
        (43) Formula
        (44) Conditional Evaluation [EQUIVALENT, 0 ms]
        (45) AND
            (46) Formula
                (47) Symbolic evaluation [EQUIVALENT, 0 ms]
                (48) YES
            (49) Formula
                (50) Conditional Evaluation [EQUIVALENT, 0 ms]
                (51) AND
                    (52) Formula
                        (53) Symbolic evaluation [EQUIVALENT, 0 ms]
                        (54) YES
                    (55) Formula
                        (56) Hypothesis Lifting [EQUIVALENT, 0 ms]
                        (57) Formula
                        (58) Conditional Evaluation [EQUIVALENT, 0 ms]
                        (59) Formula
                        (60) Symbolic evaluation [EQUIVALENT, 0 ms]
                        (61) YES
    (62) Formula
        (63) Symbolic evaluation [EQUIVALENT, 0 ms]
        (64) Formula
        (65) Conditional Evaluation [EQUIVALENT, 0 ms]
        (66) Formula
        (67) Conditional Evaluation [EQUIVALENT, 0 ms]
        (68) AND
            (69) Formula
                (70) Symbolic evaluation [EQUIVALENT, 0 ms]
                (71) YES
            (72) Formula
                (73) Symbolic evaluation under hypothesis [EQUIVALENT, 0 ms]
                (74) YES


----------------------------------------

(0)
Obligation:
Formula:
z0:sort[a37].(~(z0=nil)->del'(max(z0), z0)=true)

There are no hypotheses.




----------------------------------------

(1) Induction by algorithm (EQUIVALENT)
Induction by algorithm max(z0) generates the following cases:

1. Base Case:
Formula:
x':sort[a0].(~(cons(x', nil)=nil)->del'(max(cons(x', nil)), cons(x', nil))=true)

There are no hypotheses.





2. Base Case:
Formula:
(~(nil=nil)->del'(max(nil), nil)=true)

There are no hypotheses.





1. Step Case:
Formula:
x'':sort[a0],y:sort[a0],xs':sort[a37].(~(cons(x'', cons(y, xs'))=nil)->del'(max(cons(x'', cons(y, xs'))), cons(x'', cons(y, xs')))=true)

Hypotheses:
x'':sort[a0],xs':sort[a37].del'(max(cons(x'', xs')), cons(x'', xs'))=true
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=true





2. Step Case:
Formula:
x'':sort[a0],y:sort[a0],xs':sort[a37].(~(cons(x'', cons(y, xs'))=nil)->del'(max(cons(x'', cons(y, xs'))), cons(x'', cons(y, xs')))=true)

Hypotheses:
y:sort[a0],xs':sort[a37].del'(max(cons(y, xs')), cons(y, xs'))=true
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=false






----------------------------------------

(2)
Complex Obligation (AND)

----------------------------------------

(3)
Obligation:
Formula:
x':sort[a0].(~(cons(x', nil)=nil)->del'(max(cons(x', nil)), cons(x', nil))=true)

There are no hypotheses.




----------------------------------------

(4) Symbolic evaluation (EQUIVALENT)
Could be shown by simple symbolic evaluation.
----------------------------------------

(5)
Obligation:
Formula:
x':sort[a0].del'(x', cons(x', nil))=true

There are no hypotheses.




----------------------------------------

(6) Induction by data structure (EQUIVALENT)
Induction by data structure sort[a0] generates the following cases:



1. Base Case:
Formula:
del'(0, cons(0, nil))=true

There are no hypotheses.





1. Step Case:
Formula:
n:sort[a0].del'(s(n), cons(s(n), nil))=true

Hypotheses:
n:sort[a0].del'(n, cons(n, nil))=true






----------------------------------------

(7)
Complex Obligation (AND)

----------------------------------------

(8)
Obligation:
Formula:
del'(0, cons(0, nil))=true

There are no hypotheses.




----------------------------------------

(9) Symbolic evaluation (EQUIVALENT)
Could be reduced to the following new obligation by simple symbolic evaluation:
True
----------------------------------------

(10)
YES

----------------------------------------

(11)
Obligation:
Formula:
n:sort[a0].del'(s(n), cons(s(n), nil))=true

Hypotheses:
n:sort[a0].del'(n, cons(n, nil))=true




----------------------------------------

(12) Conditional Evaluation (EQUIVALENT)
The formula could be reduced to the following new obligations by conditional evaluation:
Formula:
true=true

Hypotheses:
n:sort[a0].del'(n, cons(n, nil))=true
n:sort[a0].equal_sort[a45](eq(s(n), s(n)), true_renamed)=true





Formula:
n:sort[a0].del'(s(n), nil)=true

Hypotheses:
n:sort[a0].del'(n, cons(n, nil))=true
n:sort[a0].equal_sort[a45](eq(s(n), s(n)), true_renamed)=false






----------------------------------------

(13)
Complex Obligation (AND)

----------------------------------------

(14)
Obligation:
Formula:
true=true

Hypotheses:
n:sort[a0].del'(n, cons(n, nil))=true
n:sort[a0].equal_sort[a45](eq(s(n), s(n)), true_renamed)=true




----------------------------------------

(15) Symbolic evaluation (EQUIVALENT)
Could be reduced to the following new obligation by simple symbolic evaluation:
True
----------------------------------------

(16)
YES

----------------------------------------

(17)
Obligation:
Formula:
n:sort[a0].del'(s(n), nil)=true

Hypotheses:
n:sort[a0].del'(n, cons(n, nil))=true
n:sort[a0].equal_sort[a45](eq(s(n), s(n)), true_renamed)=false




----------------------------------------

(18) Symbolic evaluation (EQUIVALENT)
Could be shown by simple symbolic evaluation.
----------------------------------------

(19)
Obligation:
Formula:
False

Hypotheses:
n:sort[a0].del'(n, cons(n, nil))=true
n:sort[a0].equal_sort[a45](eq(s(n), s(n)), true_renamed)=false




----------------------------------------

(20) Hypothesis Lifting (EQUIVALENT)
Formula could be generalised by hypothesis lifting to the following new obligation:
Formula:
n:sort[a0].((del'(n, cons(n, nil))=true/\equal_sort[a45](eq(s(n), s(n)), true_renamed)=false)->False)

Hypotheses:
n:sort[a0].del'(n, cons(n, nil))=true
n:sort[a0].equal_sort[a45](eq(s(n), s(n)), true_renamed)=false




----------------------------------------

(21)
Obligation:
Formula:
n:sort[a0].((del'(n, cons(n, nil))=true/\equal_sort[a45](eq(s(n), s(n)), true_renamed)=false)->False)

Hypotheses:
n:sort[a0].del'(n, cons(n, nil))=true
n:sort[a0].equal_sort[a45](eq(s(n), s(n)), true_renamed)=false




----------------------------------------

(22) Symbolic evaluation under hypothesis (SOUND)
Could be reduced by symbolic evaluation under hypothesis to:
n:sort[a0].~(equal_sort[a45](eq(n, n), true_renamed)=false)

By using the following hypotheses:
n:sort[a0].del'(n, cons(n, nil))=true

----------------------------------------

(23)
Obligation:
Formula:
n:sort[a0].~(equal_sort[a45](eq(n, n), true_renamed)=false)

Hypotheses:
n:sort[a0].del'(n, cons(n, nil))=true
n:sort[a0].equal_sort[a45](eq(s(n), s(n)), true_renamed)=false




----------------------------------------

(24) Hypothesis Lifting (EQUIVALENT)
Formula could be generalised by hypothesis lifting to the following new obligation:
Formula:
n:sort[a0].(equal_sort[a45](eq(n, n), true_renamed)=false->~(equal_sort[a45](eq(n, n), true_renamed)=false))

Hypotheses:
n:sort[a0].del'(n, cons(n, nil))=true




----------------------------------------

(25)
Obligation:
Formula:
n:sort[a0].(equal_sort[a45](eq(n, n), true_renamed)=false->~(equal_sort[a45](eq(n, n), true_renamed)=false))

Hypotheses:
n:sort[a0].del'(n, cons(n, nil))=true




----------------------------------------

(26) Hypothesis Lifting (EQUIVALENT)
Formula could be generalised by hypothesis lifting to the following new obligation:
Formula:
n:sort[a0].(del'(n, cons(n, nil))=true->(equal_sort[a45](eq(n, n), true_renamed)=false->~(equal_sort[a45](eq(n, n), true_renamed)=false)))

There are no hypotheses.




----------------------------------------

(27)
Obligation:
Formula:
n:sort[a0].(del'(n, cons(n, nil))=true->(equal_sort[a45](eq(n, n), true_renamed)=false->~(equal_sort[a45](eq(n, n), true_renamed)=false)))

There are no hypotheses.




----------------------------------------

(28) Conditional Evaluation (EQUIVALENT)
The formula could be reduced to the following new obligations by conditional evaluation:
Formula:
n:sort[a0].(true=true->(equal_sort[a45](eq(n, n), true_renamed)=false->~(equal_sort[a45](eq(n, n), true_renamed)=false)))

Hypotheses:
n:sort[a0].equal_sort[a45](eq(n, n), true_renamed)=true





Formula:
n:sort[a0].(del'(n, nil)=true->(equal_sort[a45](eq(n, n), true_renamed)=false->~(equal_sort[a45](eq(n, n), true_renamed)=false)))

Hypotheses:
n:sort[a0].equal_sort[a45](eq(n, n), true_renamed)=false






----------------------------------------

(29)
Complex Obligation (AND)

----------------------------------------

(30)
Obligation:
Formula:
n:sort[a0].(true=true->(equal_sort[a45](eq(n, n), true_renamed)=false->~(equal_sort[a45](eq(n, n), true_renamed)=false)))

Hypotheses:
n:sort[a0].equal_sort[a45](eq(n, n), true_renamed)=true




----------------------------------------

(31) Symbolic evaluation under hypothesis (EQUIVALENT)
Could be shown using symbolic evaluation under hypothesis, by using the following hypotheses:

n:sort[a0].equal_sort[a45](eq(n, n), true_renamed)=true

----------------------------------------

(32)
YES

----------------------------------------

(33)
Obligation:
Formula:
n:sort[a0].(del'(n, nil)=true->(equal_sort[a45](eq(n, n), true_renamed)=false->~(equal_sort[a45](eq(n, n), true_renamed)=false)))

Hypotheses:
n:sort[a0].equal_sort[a45](eq(n, n), true_renamed)=false




----------------------------------------

(34) Symbolic evaluation (EQUIVALENT)
Could be reduced to the following new obligation by simple symbolic evaluation:
True
----------------------------------------

(35)
YES

----------------------------------------

(36)
Obligation:
Formula:
(~(nil=nil)->del'(max(nil), nil)=true)

There are no hypotheses.




----------------------------------------

(37) Symbolic evaluation (EQUIVALENT)
Could be reduced to the following new obligation by simple symbolic evaluation:
True
----------------------------------------

(38)
YES

----------------------------------------

(39)
Obligation:
Formula:
x'':sort[a0],y:sort[a0],xs':sort[a37].(~(cons(x'', cons(y, xs'))=nil)->del'(max(cons(x'', cons(y, xs'))), cons(x'', cons(y, xs')))=true)

Hypotheses:
x'':sort[a0],xs':sort[a37].del'(max(cons(x'', xs')), cons(x'', xs'))=true
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=true




----------------------------------------

(40) Symbolic evaluation (EQUIVALENT)
Could be shown by simple symbolic evaluation.
----------------------------------------

(41)
Obligation:
Formula:
x'':sort[a0],y:sort[a0],xs':sort[a37].del'(max(cons(x'', cons(y, xs'))), cons(x'', cons(y, xs')))=true

Hypotheses:
x'':sort[a0],xs':sort[a37].del'(max(cons(x'', xs')), cons(x'', xs'))=true
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=true




----------------------------------------

(42) Conditional Evaluation (EQUIVALENT)
The formula could be reduced to the following new obligations by conditional evaluation:
Formula:
x'':sort[a0],xs':sort[a37],y:sort[a0].del'(max(cons(x'', xs')), cons(x'', cons(y, xs')))=true

Hypotheses:
x'':sort[a0],xs':sort[a37].del'(max(cons(x'', xs')), cons(x'', xs'))=true
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=true






----------------------------------------

(43)
Obligation:
Formula:
x'':sort[a0],xs':sort[a37],y:sort[a0].del'(max(cons(x'', xs')), cons(x'', cons(y, xs')))=true

Hypotheses:
x'':sort[a0],xs':sort[a37].del'(max(cons(x'', xs')), cons(x'', xs'))=true
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=true




----------------------------------------

(44) Conditional Evaluation (EQUIVALENT)
The formula could be reduced to the following new obligations by conditional evaluation:
Formula:
true=true

Hypotheses:
x'':sort[a0],xs':sort[a37].del'(max(cons(x'', xs')), cons(x'', xs'))=true
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=true
x'':sort[a0],xs':sort[a37].equal_sort[a45](eq(max(cons(x'', xs')), x''), true_renamed)=true





Formula:
x'':sort[a0],xs':sort[a37],y:sort[a0].del'(max(cons(x'', xs')), cons(y, xs'))=true

Hypotheses:
x'':sort[a0],xs':sort[a37].del'(max(cons(x'', xs')), cons(x'', xs'))=true
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=true
x'':sort[a0],xs':sort[a37].equal_sort[a45](eq(max(cons(x'', xs')), x''), true_renamed)=false






----------------------------------------

(45)
Complex Obligation (AND)

----------------------------------------

(46)
Obligation:
Formula:
true=true

Hypotheses:
x'':sort[a0],xs':sort[a37].del'(max(cons(x'', xs')), cons(x'', xs'))=true
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=true
x'':sort[a0],xs':sort[a37].equal_sort[a45](eq(max(cons(x'', xs')), x''), true_renamed)=true




----------------------------------------

(47) Symbolic evaluation (EQUIVALENT)
Could be reduced to the following new obligation by simple symbolic evaluation:
True
----------------------------------------

(48)
YES

----------------------------------------

(49)
Obligation:
Formula:
x'':sort[a0],xs':sort[a37],y:sort[a0].del'(max(cons(x'', xs')), cons(y, xs'))=true

Hypotheses:
x'':sort[a0],xs':sort[a37].del'(max(cons(x'', xs')), cons(x'', xs'))=true
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=true
x'':sort[a0],xs':sort[a37].equal_sort[a45](eq(max(cons(x'', xs')), x''), true_renamed)=false




----------------------------------------

(50) Conditional Evaluation (EQUIVALENT)
The formula could be reduced to the following new obligations by conditional evaluation:
Formula:
true=true

Hypotheses:
x'':sort[a0],xs':sort[a37].del'(max(cons(x'', xs')), cons(x'', xs'))=true
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=true
x'':sort[a0],xs':sort[a37].equal_sort[a45](eq(max(cons(x'', xs')), x''), true_renamed)=false
x'':sort[a0],xs':sort[a37],y:sort[a0].equal_sort[a45](eq(max(cons(x'', xs')), y), true_renamed)=true





Formula:
x'':sort[a0],xs':sort[a37].del'(max(cons(x'', xs')), xs')=true

Hypotheses:
x'':sort[a0],xs':sort[a37].del'(max(cons(x'', xs')), cons(x'', xs'))=true
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=true
x'':sort[a0],xs':sort[a37].equal_sort[a45](eq(max(cons(x'', xs')), x''), true_renamed)=false
x'':sort[a0],xs':sort[a37],y:sort[a0].equal_sort[a45](eq(max(cons(x'', xs')), y), true_renamed)=false






----------------------------------------

(51)
Complex Obligation (AND)

----------------------------------------

(52)
Obligation:
Formula:
true=true

Hypotheses:
x'':sort[a0],xs':sort[a37].del'(max(cons(x'', xs')), cons(x'', xs'))=true
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=true
x'':sort[a0],xs':sort[a37].equal_sort[a45](eq(max(cons(x'', xs')), x''), true_renamed)=false
x'':sort[a0],xs':sort[a37],y:sort[a0].equal_sort[a45](eq(max(cons(x'', xs')), y), true_renamed)=true




----------------------------------------

(53) Symbolic evaluation (EQUIVALENT)
Could be reduced to the following new obligation by simple symbolic evaluation:
True
----------------------------------------

(54)
YES

----------------------------------------

(55)
Obligation:
Formula:
x'':sort[a0],xs':sort[a37].del'(max(cons(x'', xs')), xs')=true

Hypotheses:
x'':sort[a0],xs':sort[a37].del'(max(cons(x'', xs')), cons(x'', xs'))=true
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=true
x'':sort[a0],xs':sort[a37].equal_sort[a45](eq(max(cons(x'', xs')), x''), true_renamed)=false
x'':sort[a0],xs':sort[a37],y:sort[a0].equal_sort[a45](eq(max(cons(x'', xs')), y), true_renamed)=false




----------------------------------------

(56) Hypothesis Lifting (EQUIVALENT)
Formula could be generalised by hypothesis lifting to the following new obligation:
Formula:
x'':sort[a0],xs':sort[a37].(del'(max(cons(x'', xs')), cons(x'', xs'))=true->del'(max(cons(x'', xs')), xs')=true)

Hypotheses:
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=true
x'':sort[a0],xs':sort[a37].equal_sort[a45](eq(max(cons(x'', xs')), x''), true_renamed)=false
x'':sort[a0],xs':sort[a37],y:sort[a0].equal_sort[a45](eq(max(cons(x'', xs')), y), true_renamed)=false




----------------------------------------

(57)
Obligation:
Formula:
x'':sort[a0],xs':sort[a37].(del'(max(cons(x'', xs')), cons(x'', xs'))=true->del'(max(cons(x'', xs')), xs')=true)

Hypotheses:
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=true
x'':sort[a0],xs':sort[a37].equal_sort[a45](eq(max(cons(x'', xs')), x''), true_renamed)=false
x'':sort[a0],xs':sort[a37],y:sort[a0].equal_sort[a45](eq(max(cons(x'', xs')), y), true_renamed)=false




----------------------------------------

(58) Conditional Evaluation (EQUIVALENT)
The formula could be reduced to the following new obligations by conditional evaluation:
Formula:
x'':sort[a0],xs':sort[a37].(del'(max(cons(x'', xs')), xs')=true->del'(max(cons(x'', xs')), xs')=true)

Hypotheses:
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=true
x'':sort[a0],xs':sort[a37].equal_sort[a45](eq(max(cons(x'', xs')), x''), true_renamed)=false
x'':sort[a0],xs':sort[a37],y:sort[a0].equal_sort[a45](eq(max(cons(x'', xs')), y), true_renamed)=false






----------------------------------------

(59)
Obligation:
Formula:
x'':sort[a0],xs':sort[a37].(del'(max(cons(x'', xs')), xs')=true->del'(max(cons(x'', xs')), xs')=true)

Hypotheses:
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=true
x'':sort[a0],xs':sort[a37].equal_sort[a45](eq(max(cons(x'', xs')), x''), true_renamed)=false
x'':sort[a0],xs':sort[a37],y:sort[a0].equal_sort[a45](eq(max(cons(x'', xs')), y), true_renamed)=false




----------------------------------------

(60) Symbolic evaluation (EQUIVALENT)
Could be reduced to the following new obligation by simple symbolic evaluation:
True
----------------------------------------

(61)
YES

----------------------------------------

(62)
Obligation:
Formula:
x'':sort[a0],y:sort[a0],xs':sort[a37].(~(cons(x'', cons(y, xs'))=nil)->del'(max(cons(x'', cons(y, xs'))), cons(x'', cons(y, xs')))=true)

Hypotheses:
y:sort[a0],xs':sort[a37].del'(max(cons(y, xs')), cons(y, xs'))=true
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=false




----------------------------------------

(63) Symbolic evaluation (EQUIVALENT)
Could be shown by simple symbolic evaluation.
----------------------------------------

(64)
Obligation:
Formula:
x'':sort[a0],y:sort[a0],xs':sort[a37].del'(max(cons(x'', cons(y, xs'))), cons(x'', cons(y, xs')))=true

Hypotheses:
y:sort[a0],xs':sort[a37].del'(max(cons(y, xs')), cons(y, xs'))=true
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=false




----------------------------------------

(65) Conditional Evaluation (EQUIVALENT)
The formula could be reduced to the following new obligations by conditional evaluation:
Formula:
y:sort[a0],xs':sort[a37],x'':sort[a0].del'(max(cons(y, xs')), cons(x'', cons(y, xs')))=true

Hypotheses:
y:sort[a0],xs':sort[a37].del'(max(cons(y, xs')), cons(y, xs'))=true
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=false






----------------------------------------

(66)
Obligation:
Formula:
y:sort[a0],xs':sort[a37],x'':sort[a0].del'(max(cons(y, xs')), cons(x'', cons(y, xs')))=true

Hypotheses:
y:sort[a0],xs':sort[a37].del'(max(cons(y, xs')), cons(y, xs'))=true
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=false




----------------------------------------

(67) Conditional Evaluation (EQUIVALENT)
The formula could be reduced to the following new obligations by conditional evaluation:
Formula:
true=true

Hypotheses:
y:sort[a0],xs':sort[a37].del'(max(cons(y, xs')), cons(y, xs'))=true
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=false
y:sort[a0],xs':sort[a37],x'':sort[a0].equal_sort[a45](eq(max(cons(y, xs')), x''), true_renamed)=true





Formula:
y:sort[a0],xs':sort[a37].del'(max(cons(y, xs')), cons(y, xs'))=true

Hypotheses:
y:sort[a0],xs':sort[a37].del'(max(cons(y, xs')), cons(y, xs'))=true
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=false
y:sort[a0],xs':sort[a37],x'':sort[a0].equal_sort[a45](eq(max(cons(y, xs')), x''), true_renamed)=false






----------------------------------------

(68)
Complex Obligation (AND)

----------------------------------------

(69)
Obligation:
Formula:
true=true

Hypotheses:
y:sort[a0],xs':sort[a37].del'(max(cons(y, xs')), cons(y, xs'))=true
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=false
y:sort[a0],xs':sort[a37],x'':sort[a0].equal_sort[a45](eq(max(cons(y, xs')), x''), true_renamed)=true




----------------------------------------

(70) Symbolic evaluation (EQUIVALENT)
Could be reduced to the following new obligation by simple symbolic evaluation:
True
----------------------------------------

(71)
YES

----------------------------------------

(72)
Obligation:
Formula:
y:sort[a0],xs':sort[a37].del'(max(cons(y, xs')), cons(y, xs'))=true

Hypotheses:
y:sort[a0],xs':sort[a37].del'(max(cons(y, xs')), cons(y, xs'))=true
x'':sort[a0],y:sort[a0].equal_sort[a45](ge(x'', y), true_renamed)=false
y:sort[a0],xs':sort[a37],x'':sort[a0].equal_sort[a45](eq(max(cons(y, xs')), x''), true_renamed)=false




----------------------------------------

(73) Symbolic evaluation under hypothesis (EQUIVALENT)
Could be shown using symbolic evaluation under hypothesis, by using the following hypotheses:

y:sort[a0],xs':sort[a37].del'(max(cons(y, xs')), cons(y, xs'))=true

----------------------------------------

(74)
YES

----------------------------------------

(50)
Complex Obligation (AND)

----------------------------------------

(51)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   max(cons(x, nil)) -> x
   max(cons(x, cons(y, xs))) -> if1(ge(x, y), x, y, xs)
   if1(true, x, y, xs) -> max(cons(x, xs))
   if1(false, x, y, xs) -> max(cons(y, xs))
   del(x, cons(y, xs)) -> if2(eq(x, y), x, y, xs)
   h(nil) -> nil
   h(cons(x, xs)) -> cons(x, h(xs))
   eq(0, 0) -> true
   eq(0, s(y)) -> false
   eq(s(x), 0) -> false
   eq(s(x), s(y)) -> eq(x, y)
   if2(true, x, y, xs) -> xs
   if2(false, x, y, xs) -> cons(y, del(x, xs))
   del(x, nil) -> nil
   ge(0, 0) -> true
   ge(s(x), 0) -> true
   ge(0, s(x)) -> false
   ge(s(x), s(y)) -> ge(x, y)

The set Q consists of the following terms:

   max(nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true, x0, x1, x2)
   if1(false, x0, x1, x2)
   del(x0, nil)
   del(x0, cons(x1, x2))
   if2(true, x0, x1, x2)
   if2(false, x0, x1, x2)
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   h(nil)
   h(cons(x0, x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(52) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(53)
YES

----------------------------------------

(54)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   del'(x3, cons(y1, xs2)) -> if2'(eq(x3, y1), x3, y1, xs2)
   if2'(true_renamed, x7, y4, xs4) -> true
   if2'(false_renamed, x8, y5, xs5) -> del'(x8, xs5)
   del'(x9, nil) -> false
   max(cons(x', nil)) -> x'
   max(cons(x'', cons(y, xs'))) -> if1(ge(x'', y), x'', y, xs')
   if1(true_renamed, x1, y', xs'') -> max(cons(x1, xs''))
   if1(false_renamed, x2, y'', xs1) -> max(cons(y'', xs1))
   del(x3, cons(y1, xs2)) -> if2(eq(x3, y1), x3, y1, xs2)
   h(nil) -> nil
   h(cons(x4, xs3)) -> cons(x4, h(xs3))
   eq(0, 0) -> true_renamed
   eq(0, s(y2)) -> false_renamed
   eq(s(x5), 0) -> false_renamed
   eq(s(x6), s(y3)) -> eq(x6, y3)
   if2(true_renamed, x7, y4, xs4) -> xs4
   if2(false_renamed, x8, y5, xs5) -> cons(y5, del(x8, xs5))
   del(x9, nil) -> nil
   ge(0, 0) -> true_renamed
   ge(s(x10), 0) -> true_renamed
   ge(0, s(x11)) -> false_renamed
   ge(s(x12), s(y6)) -> ge(x12, y6)
   max(nil) -> 0
   equal_bool(true, false) -> false
   equal_bool(false, true) -> false
   equal_bool(true, true) -> true
   equal_bool(false, false) -> true
   and(true, x) -> x
   and(false, x) -> false
   or(true, x) -> true
   or(false, x) -> x
   not(false) -> true
   not(true) -> false
   isa_true(true) -> true
   isa_true(false) -> false
   isa_false(true) -> false
   isa_false(false) -> true
   equal_sort[a0](0, 0) -> true
   equal_sort[a0](0, s(v30)) -> false
   equal_sort[a0](s(v31), 0) -> false
   equal_sort[a0](s(v31), s(v32)) -> equal_sort[a0](v31, v32)
   equal_sort[a37](cons(v33, v34), cons(v35, v36)) -> and(equal_sort[a0](v33, v35), equal_sort[a37](v34, v36))
   equal_sort[a37](cons(v33, v34), nil) -> false
   equal_sort[a37](nil, cons(v37, v38)) -> false
   equal_sort[a37](nil, nil) -> true
   equal_sort[a45](true_renamed, true_renamed) -> true
   equal_sort[a45](true_renamed, false_renamed) -> false
   equal_sort[a45](false_renamed, true_renamed) -> false
   equal_sort[a45](false_renamed, false_renamed) -> true
   equal_sort[a65](witness_sort[a65], witness_sort[a65]) -> true

Q is empty.

----------------------------------------

(55) Overlay + Local Confluence (EQUIVALENT)
The TRS is overlay and locally confluent. By [NOC] we can switch to innermost.
----------------------------------------

(56)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   del'(x3, cons(y1, xs2)) -> if2'(eq(x3, y1), x3, y1, xs2)
   if2'(true_renamed, x7, y4, xs4) -> true
   if2'(false_renamed, x8, y5, xs5) -> del'(x8, xs5)
   del'(x9, nil) -> false
   max(cons(x', nil)) -> x'
   max(cons(x'', cons(y, xs'))) -> if1(ge(x'', y), x'', y, xs')
   if1(true_renamed, x1, y', xs'') -> max(cons(x1, xs''))
   if1(false_renamed, x2, y'', xs1) -> max(cons(y'', xs1))
   del(x3, cons(y1, xs2)) -> if2(eq(x3, y1), x3, y1, xs2)
   h(nil) -> nil
   h(cons(x4, xs3)) -> cons(x4, h(xs3))
   eq(0, 0) -> true_renamed
   eq(0, s(y2)) -> false_renamed
   eq(s(x5), 0) -> false_renamed
   eq(s(x6), s(y3)) -> eq(x6, y3)
   if2(true_renamed, x7, y4, xs4) -> xs4
   if2(false_renamed, x8, y5, xs5) -> cons(y5, del(x8, xs5))
   del(x9, nil) -> nil
   ge(0, 0) -> true_renamed
   ge(s(x10), 0) -> true_renamed
   ge(0, s(x11)) -> false_renamed
   ge(s(x12), s(y6)) -> ge(x12, y6)
   max(nil) -> 0
   equal_bool(true, false) -> false
   equal_bool(false, true) -> false
   equal_bool(true, true) -> true
   equal_bool(false, false) -> true
   and(true, x) -> x
   and(false, x) -> false
   or(true, x) -> true
   or(false, x) -> x
   not(false) -> true
   not(true) -> false
   isa_true(true) -> true
   isa_true(false) -> false
   isa_false(true) -> false
   isa_false(false) -> true
   equal_sort[a0](0, 0) -> true
   equal_sort[a0](0, s(v30)) -> false
   equal_sort[a0](s(v31), 0) -> false
   equal_sort[a0](s(v31), s(v32)) -> equal_sort[a0](v31, v32)
   equal_sort[a37](cons(v33, v34), cons(v35, v36)) -> and(equal_sort[a0](v33, v35), equal_sort[a37](v34, v36))
   equal_sort[a37](cons(v33, v34), nil) -> false
   equal_sort[a37](nil, cons(v37, v38)) -> false
   equal_sort[a37](nil, nil) -> true
   equal_sort[a45](true_renamed, true_renamed) -> true
   equal_sort[a45](true_renamed, false_renamed) -> false
   equal_sort[a45](false_renamed, true_renamed) -> false
   equal_sort[a45](false_renamed, false_renamed) -> true
   equal_sort[a65](witness_sort[a65], witness_sort[a65]) -> true

The set Q consists of the following terms:

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])


----------------------------------------

(57) DependencyPairsProof (EQUIVALENT)
Using Dependency Pairs [AG00,LPAR04] we result in the following initial DP problem.
----------------------------------------

(58)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   DEL'(x3, cons(y1, xs2)) -> IF2'(eq(x3, y1), x3, y1, xs2)
   DEL'(x3, cons(y1, xs2)) -> EQ(x3, y1)
   IF2'(false_renamed, x8, y5, xs5) -> DEL'(x8, xs5)
   MAX(cons(x'', cons(y, xs'))) -> IF1(ge(x'', y), x'', y, xs')
   MAX(cons(x'', cons(y, xs'))) -> GE(x'', y)
   IF1(true_renamed, x1, y', xs'') -> MAX(cons(x1, xs''))
   IF1(false_renamed, x2, y'', xs1) -> MAX(cons(y'', xs1))
   DEL(x3, cons(y1, xs2)) -> IF2(eq(x3, y1), x3, y1, xs2)
   DEL(x3, cons(y1, xs2)) -> EQ(x3, y1)
   H(cons(x4, xs3)) -> H(xs3)
   EQ(s(x6), s(y3)) -> EQ(x6, y3)
   IF2(false_renamed, x8, y5, xs5) -> DEL(x8, xs5)
   GE(s(x12), s(y6)) -> GE(x12, y6)
   EQUAL_SORT[A0](s(v31), s(v32)) -> EQUAL_SORT[A0](v31, v32)
   EQUAL_SORT[A37](cons(v33, v34), cons(v35, v36)) -> AND(equal_sort[a0](v33, v35), equal_sort[a37](v34, v36))
   EQUAL_SORT[A37](cons(v33, v34), cons(v35, v36)) -> EQUAL_SORT[A0](v33, v35)
   EQUAL_SORT[A37](cons(v33, v34), cons(v35, v36)) -> EQUAL_SORT[A37](v34, v36)

The TRS R consists of the following rules:

   del'(x3, cons(y1, xs2)) -> if2'(eq(x3, y1), x3, y1, xs2)
   if2'(true_renamed, x7, y4, xs4) -> true
   if2'(false_renamed, x8, y5, xs5) -> del'(x8, xs5)
   del'(x9, nil) -> false
   max(cons(x', nil)) -> x'
   max(cons(x'', cons(y, xs'))) -> if1(ge(x'', y), x'', y, xs')
   if1(true_renamed, x1, y', xs'') -> max(cons(x1, xs''))
   if1(false_renamed, x2, y'', xs1) -> max(cons(y'', xs1))
   del(x3, cons(y1, xs2)) -> if2(eq(x3, y1), x3, y1, xs2)
   h(nil) -> nil
   h(cons(x4, xs3)) -> cons(x4, h(xs3))
   eq(0, 0) -> true_renamed
   eq(0, s(y2)) -> false_renamed
   eq(s(x5), 0) -> false_renamed
   eq(s(x6), s(y3)) -> eq(x6, y3)
   if2(true_renamed, x7, y4, xs4) -> xs4
   if2(false_renamed, x8, y5, xs5) -> cons(y5, del(x8, xs5))
   del(x9, nil) -> nil
   ge(0, 0) -> true_renamed
   ge(s(x10), 0) -> true_renamed
   ge(0, s(x11)) -> false_renamed
   ge(s(x12), s(y6)) -> ge(x12, y6)
   max(nil) -> 0
   equal_bool(true, false) -> false
   equal_bool(false, true) -> false
   equal_bool(true, true) -> true
   equal_bool(false, false) -> true
   and(true, x) -> x
   and(false, x) -> false
   or(true, x) -> true
   or(false, x) -> x
   not(false) -> true
   not(true) -> false
   isa_true(true) -> true
   isa_true(false) -> false
   isa_false(true) -> false
   isa_false(false) -> true
   equal_sort[a0](0, 0) -> true
   equal_sort[a0](0, s(v30)) -> false
   equal_sort[a0](s(v31), 0) -> false
   equal_sort[a0](s(v31), s(v32)) -> equal_sort[a0](v31, v32)
   equal_sort[a37](cons(v33, v34), cons(v35, v36)) -> and(equal_sort[a0](v33, v35), equal_sort[a37](v34, v36))
   equal_sort[a37](cons(v33, v34), nil) -> false
   equal_sort[a37](nil, cons(v37, v38)) -> false
   equal_sort[a37](nil, nil) -> true
   equal_sort[a45](true_renamed, true_renamed) -> true
   equal_sort[a45](true_renamed, false_renamed) -> false
   equal_sort[a45](false_renamed, true_renamed) -> false
   equal_sort[a45](false_renamed, false_renamed) -> true
   equal_sort[a65](witness_sort[a65], witness_sort[a65]) -> true

The set Q consists of the following terms:

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(59) DependencyGraphProof (EQUIVALENT)
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 8 SCCs with 5 less nodes.
----------------------------------------

(60)
Complex Obligation (AND)

----------------------------------------

(61)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   EQUAL_SORT[A0](s(v31), s(v32)) -> EQUAL_SORT[A0](v31, v32)

The TRS R consists of the following rules:

   del'(x3, cons(y1, xs2)) -> if2'(eq(x3, y1), x3, y1, xs2)
   if2'(true_renamed, x7, y4, xs4) -> true
   if2'(false_renamed, x8, y5, xs5) -> del'(x8, xs5)
   del'(x9, nil) -> false
   max(cons(x', nil)) -> x'
   max(cons(x'', cons(y, xs'))) -> if1(ge(x'', y), x'', y, xs')
   if1(true_renamed, x1, y', xs'') -> max(cons(x1, xs''))
   if1(false_renamed, x2, y'', xs1) -> max(cons(y'', xs1))
   del(x3, cons(y1, xs2)) -> if2(eq(x3, y1), x3, y1, xs2)
   h(nil) -> nil
   h(cons(x4, xs3)) -> cons(x4, h(xs3))
   eq(0, 0) -> true_renamed
   eq(0, s(y2)) -> false_renamed
   eq(s(x5), 0) -> false_renamed
   eq(s(x6), s(y3)) -> eq(x6, y3)
   if2(true_renamed, x7, y4, xs4) -> xs4
   if2(false_renamed, x8, y5, xs5) -> cons(y5, del(x8, xs5))
   del(x9, nil) -> nil
   ge(0, 0) -> true_renamed
   ge(s(x10), 0) -> true_renamed
   ge(0, s(x11)) -> false_renamed
   ge(s(x12), s(y6)) -> ge(x12, y6)
   max(nil) -> 0
   equal_bool(true, false) -> false
   equal_bool(false, true) -> false
   equal_bool(true, true) -> true
   equal_bool(false, false) -> true
   and(true, x) -> x
   and(false, x) -> false
   or(true, x) -> true
   or(false, x) -> x
   not(false) -> true
   not(true) -> false
   isa_true(true) -> true
   isa_true(false) -> false
   isa_false(true) -> false
   isa_false(false) -> true
   equal_sort[a0](0, 0) -> true
   equal_sort[a0](0, s(v30)) -> false
   equal_sort[a0](s(v31), 0) -> false
   equal_sort[a0](s(v31), s(v32)) -> equal_sort[a0](v31, v32)
   equal_sort[a37](cons(v33, v34), cons(v35, v36)) -> and(equal_sort[a0](v33, v35), equal_sort[a37](v34, v36))
   equal_sort[a37](cons(v33, v34), nil) -> false
   equal_sort[a37](nil, cons(v37, v38)) -> false
   equal_sort[a37](nil, nil) -> true
   equal_sort[a45](true_renamed, true_renamed) -> true
   equal_sort[a45](true_renamed, false_renamed) -> false
   equal_sort[a45](false_renamed, true_renamed) -> false
   equal_sort[a45](false_renamed, false_renamed) -> true
   equal_sort[a65](witness_sort[a65], witness_sort[a65]) -> true

The set Q consists of the following terms:

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(62) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(63)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   EQUAL_SORT[A0](s(v31), s(v32)) -> EQUAL_SORT[A0](v31, v32)

R is empty.
The set Q consists of the following terms:

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(64) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])


----------------------------------------

(65)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   EQUAL_SORT[A0](s(v31), s(v32)) -> EQUAL_SORT[A0](v31, v32)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(66) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*EQUAL_SORT[A0](s(v31), s(v32)) -> EQUAL_SORT[A0](v31, v32)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(67)
YES

----------------------------------------

(68)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   EQUAL_SORT[A37](cons(v33, v34), cons(v35, v36)) -> EQUAL_SORT[A37](v34, v36)

The TRS R consists of the following rules:

   del'(x3, cons(y1, xs2)) -> if2'(eq(x3, y1), x3, y1, xs2)
   if2'(true_renamed, x7, y4, xs4) -> true
   if2'(false_renamed, x8, y5, xs5) -> del'(x8, xs5)
   del'(x9, nil) -> false
   max(cons(x', nil)) -> x'
   max(cons(x'', cons(y, xs'))) -> if1(ge(x'', y), x'', y, xs')
   if1(true_renamed, x1, y', xs'') -> max(cons(x1, xs''))
   if1(false_renamed, x2, y'', xs1) -> max(cons(y'', xs1))
   del(x3, cons(y1, xs2)) -> if2(eq(x3, y1), x3, y1, xs2)
   h(nil) -> nil
   h(cons(x4, xs3)) -> cons(x4, h(xs3))
   eq(0, 0) -> true_renamed
   eq(0, s(y2)) -> false_renamed
   eq(s(x5), 0) -> false_renamed
   eq(s(x6), s(y3)) -> eq(x6, y3)
   if2(true_renamed, x7, y4, xs4) -> xs4
   if2(false_renamed, x8, y5, xs5) -> cons(y5, del(x8, xs5))
   del(x9, nil) -> nil
   ge(0, 0) -> true_renamed
   ge(s(x10), 0) -> true_renamed
   ge(0, s(x11)) -> false_renamed
   ge(s(x12), s(y6)) -> ge(x12, y6)
   max(nil) -> 0
   equal_bool(true, false) -> false
   equal_bool(false, true) -> false
   equal_bool(true, true) -> true
   equal_bool(false, false) -> true
   and(true, x) -> x
   and(false, x) -> false
   or(true, x) -> true
   or(false, x) -> x
   not(false) -> true
   not(true) -> false
   isa_true(true) -> true
   isa_true(false) -> false
   isa_false(true) -> false
   isa_false(false) -> true
   equal_sort[a0](0, 0) -> true
   equal_sort[a0](0, s(v30)) -> false
   equal_sort[a0](s(v31), 0) -> false
   equal_sort[a0](s(v31), s(v32)) -> equal_sort[a0](v31, v32)
   equal_sort[a37](cons(v33, v34), cons(v35, v36)) -> and(equal_sort[a0](v33, v35), equal_sort[a37](v34, v36))
   equal_sort[a37](cons(v33, v34), nil) -> false
   equal_sort[a37](nil, cons(v37, v38)) -> false
   equal_sort[a37](nil, nil) -> true
   equal_sort[a45](true_renamed, true_renamed) -> true
   equal_sort[a45](true_renamed, false_renamed) -> false
   equal_sort[a45](false_renamed, true_renamed) -> false
   equal_sort[a45](false_renamed, false_renamed) -> true
   equal_sort[a65](witness_sort[a65], witness_sort[a65]) -> true

The set Q consists of the following terms:

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(69) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(70)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   EQUAL_SORT[A37](cons(v33, v34), cons(v35, v36)) -> EQUAL_SORT[A37](v34, v36)

R is empty.
The set Q consists of the following terms:

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(71) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])


----------------------------------------

(72)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   EQUAL_SORT[A37](cons(v33, v34), cons(v35, v36)) -> EQUAL_SORT[A37](v34, v36)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(73) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*EQUAL_SORT[A37](cons(v33, v34), cons(v35, v36)) -> EQUAL_SORT[A37](v34, v36)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(74)
YES

----------------------------------------

(75)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   GE(s(x12), s(y6)) -> GE(x12, y6)

The TRS R consists of the following rules:

   del'(x3, cons(y1, xs2)) -> if2'(eq(x3, y1), x3, y1, xs2)
   if2'(true_renamed, x7, y4, xs4) -> true
   if2'(false_renamed, x8, y5, xs5) -> del'(x8, xs5)
   del'(x9, nil) -> false
   max(cons(x', nil)) -> x'
   max(cons(x'', cons(y, xs'))) -> if1(ge(x'', y), x'', y, xs')
   if1(true_renamed, x1, y', xs'') -> max(cons(x1, xs''))
   if1(false_renamed, x2, y'', xs1) -> max(cons(y'', xs1))
   del(x3, cons(y1, xs2)) -> if2(eq(x3, y1), x3, y1, xs2)
   h(nil) -> nil
   h(cons(x4, xs3)) -> cons(x4, h(xs3))
   eq(0, 0) -> true_renamed
   eq(0, s(y2)) -> false_renamed
   eq(s(x5), 0) -> false_renamed
   eq(s(x6), s(y3)) -> eq(x6, y3)
   if2(true_renamed, x7, y4, xs4) -> xs4
   if2(false_renamed, x8, y5, xs5) -> cons(y5, del(x8, xs5))
   del(x9, nil) -> nil
   ge(0, 0) -> true_renamed
   ge(s(x10), 0) -> true_renamed
   ge(0, s(x11)) -> false_renamed
   ge(s(x12), s(y6)) -> ge(x12, y6)
   max(nil) -> 0
   equal_bool(true, false) -> false
   equal_bool(false, true) -> false
   equal_bool(true, true) -> true
   equal_bool(false, false) -> true
   and(true, x) -> x
   and(false, x) -> false
   or(true, x) -> true
   or(false, x) -> x
   not(false) -> true
   not(true) -> false
   isa_true(true) -> true
   isa_true(false) -> false
   isa_false(true) -> false
   isa_false(false) -> true
   equal_sort[a0](0, 0) -> true
   equal_sort[a0](0, s(v30)) -> false
   equal_sort[a0](s(v31), 0) -> false
   equal_sort[a0](s(v31), s(v32)) -> equal_sort[a0](v31, v32)
   equal_sort[a37](cons(v33, v34), cons(v35, v36)) -> and(equal_sort[a0](v33, v35), equal_sort[a37](v34, v36))
   equal_sort[a37](cons(v33, v34), nil) -> false
   equal_sort[a37](nil, cons(v37, v38)) -> false
   equal_sort[a37](nil, nil) -> true
   equal_sort[a45](true_renamed, true_renamed) -> true
   equal_sort[a45](true_renamed, false_renamed) -> false
   equal_sort[a45](false_renamed, true_renamed) -> false
   equal_sort[a45](false_renamed, false_renamed) -> true
   equal_sort[a65](witness_sort[a65], witness_sort[a65]) -> true

The set Q consists of the following terms:

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(76) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(77)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   GE(s(x12), s(y6)) -> GE(x12, y6)

R is empty.
The set Q consists of the following terms:

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(78) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])


----------------------------------------

(79)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   GE(s(x12), s(y6)) -> GE(x12, y6)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(80) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*GE(s(x12), s(y6)) -> GE(x12, y6)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(81)
YES

----------------------------------------

(82)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   EQ(s(x6), s(y3)) -> EQ(x6, y3)

The TRS R consists of the following rules:

   del'(x3, cons(y1, xs2)) -> if2'(eq(x3, y1), x3, y1, xs2)
   if2'(true_renamed, x7, y4, xs4) -> true
   if2'(false_renamed, x8, y5, xs5) -> del'(x8, xs5)
   del'(x9, nil) -> false
   max(cons(x', nil)) -> x'
   max(cons(x'', cons(y, xs'))) -> if1(ge(x'', y), x'', y, xs')
   if1(true_renamed, x1, y', xs'') -> max(cons(x1, xs''))
   if1(false_renamed, x2, y'', xs1) -> max(cons(y'', xs1))
   del(x3, cons(y1, xs2)) -> if2(eq(x3, y1), x3, y1, xs2)
   h(nil) -> nil
   h(cons(x4, xs3)) -> cons(x4, h(xs3))
   eq(0, 0) -> true_renamed
   eq(0, s(y2)) -> false_renamed
   eq(s(x5), 0) -> false_renamed
   eq(s(x6), s(y3)) -> eq(x6, y3)
   if2(true_renamed, x7, y4, xs4) -> xs4
   if2(false_renamed, x8, y5, xs5) -> cons(y5, del(x8, xs5))
   del(x9, nil) -> nil
   ge(0, 0) -> true_renamed
   ge(s(x10), 0) -> true_renamed
   ge(0, s(x11)) -> false_renamed
   ge(s(x12), s(y6)) -> ge(x12, y6)
   max(nil) -> 0
   equal_bool(true, false) -> false
   equal_bool(false, true) -> false
   equal_bool(true, true) -> true
   equal_bool(false, false) -> true
   and(true, x) -> x
   and(false, x) -> false
   or(true, x) -> true
   or(false, x) -> x
   not(false) -> true
   not(true) -> false
   isa_true(true) -> true
   isa_true(false) -> false
   isa_false(true) -> false
   isa_false(false) -> true
   equal_sort[a0](0, 0) -> true
   equal_sort[a0](0, s(v30)) -> false
   equal_sort[a0](s(v31), 0) -> false
   equal_sort[a0](s(v31), s(v32)) -> equal_sort[a0](v31, v32)
   equal_sort[a37](cons(v33, v34), cons(v35, v36)) -> and(equal_sort[a0](v33, v35), equal_sort[a37](v34, v36))
   equal_sort[a37](cons(v33, v34), nil) -> false
   equal_sort[a37](nil, cons(v37, v38)) -> false
   equal_sort[a37](nil, nil) -> true
   equal_sort[a45](true_renamed, true_renamed) -> true
   equal_sort[a45](true_renamed, false_renamed) -> false
   equal_sort[a45](false_renamed, true_renamed) -> false
   equal_sort[a45](false_renamed, false_renamed) -> true
   equal_sort[a65](witness_sort[a65], witness_sort[a65]) -> true

The set Q consists of the following terms:

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(83) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(84)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   EQ(s(x6), s(y3)) -> EQ(x6, y3)

R is empty.
The set Q consists of the following terms:

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(85) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])


----------------------------------------

(86)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   EQ(s(x6), s(y3)) -> EQ(x6, y3)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(87) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*EQ(s(x6), s(y3)) -> EQ(x6, y3)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(88)
YES

----------------------------------------

(89)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(cons(x4, xs3)) -> H(xs3)

The TRS R consists of the following rules:

   del'(x3, cons(y1, xs2)) -> if2'(eq(x3, y1), x3, y1, xs2)
   if2'(true_renamed, x7, y4, xs4) -> true
   if2'(false_renamed, x8, y5, xs5) -> del'(x8, xs5)
   del'(x9, nil) -> false
   max(cons(x', nil)) -> x'
   max(cons(x'', cons(y, xs'))) -> if1(ge(x'', y), x'', y, xs')
   if1(true_renamed, x1, y', xs'') -> max(cons(x1, xs''))
   if1(false_renamed, x2, y'', xs1) -> max(cons(y'', xs1))
   del(x3, cons(y1, xs2)) -> if2(eq(x3, y1), x3, y1, xs2)
   h(nil) -> nil
   h(cons(x4, xs3)) -> cons(x4, h(xs3))
   eq(0, 0) -> true_renamed
   eq(0, s(y2)) -> false_renamed
   eq(s(x5), 0) -> false_renamed
   eq(s(x6), s(y3)) -> eq(x6, y3)
   if2(true_renamed, x7, y4, xs4) -> xs4
   if2(false_renamed, x8, y5, xs5) -> cons(y5, del(x8, xs5))
   del(x9, nil) -> nil
   ge(0, 0) -> true_renamed
   ge(s(x10), 0) -> true_renamed
   ge(0, s(x11)) -> false_renamed
   ge(s(x12), s(y6)) -> ge(x12, y6)
   max(nil) -> 0
   equal_bool(true, false) -> false
   equal_bool(false, true) -> false
   equal_bool(true, true) -> true
   equal_bool(false, false) -> true
   and(true, x) -> x
   and(false, x) -> false
   or(true, x) -> true
   or(false, x) -> x
   not(false) -> true
   not(true) -> false
   isa_true(true) -> true
   isa_true(false) -> false
   isa_false(true) -> false
   isa_false(false) -> true
   equal_sort[a0](0, 0) -> true
   equal_sort[a0](0, s(v30)) -> false
   equal_sort[a0](s(v31), 0) -> false
   equal_sort[a0](s(v31), s(v32)) -> equal_sort[a0](v31, v32)
   equal_sort[a37](cons(v33, v34), cons(v35, v36)) -> and(equal_sort[a0](v33, v35), equal_sort[a37](v34, v36))
   equal_sort[a37](cons(v33, v34), nil) -> false
   equal_sort[a37](nil, cons(v37, v38)) -> false
   equal_sort[a37](nil, nil) -> true
   equal_sort[a45](true_renamed, true_renamed) -> true
   equal_sort[a45](true_renamed, false_renamed) -> false
   equal_sort[a45](false_renamed, true_renamed) -> false
   equal_sort[a45](false_renamed, false_renamed) -> true
   equal_sort[a65](witness_sort[a65], witness_sort[a65]) -> true

The set Q consists of the following terms:

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(90) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(91)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(cons(x4, xs3)) -> H(xs3)

R is empty.
The set Q consists of the following terms:

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(92) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])


----------------------------------------

(93)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   H(cons(x4, xs3)) -> H(xs3)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(94) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*H(cons(x4, xs3)) -> H(xs3)
The graph contains the following edges 1 > 1


----------------------------------------

(95)
YES

----------------------------------------

(96)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false_renamed, x8, y5, xs5) -> DEL(x8, xs5)
   DEL(x3, cons(y1, xs2)) -> IF2(eq(x3, y1), x3, y1, xs2)

The TRS R consists of the following rules:

   del'(x3, cons(y1, xs2)) -> if2'(eq(x3, y1), x3, y1, xs2)
   if2'(true_renamed, x7, y4, xs4) -> true
   if2'(false_renamed, x8, y5, xs5) -> del'(x8, xs5)
   del'(x9, nil) -> false
   max(cons(x', nil)) -> x'
   max(cons(x'', cons(y, xs'))) -> if1(ge(x'', y), x'', y, xs')
   if1(true_renamed, x1, y', xs'') -> max(cons(x1, xs''))
   if1(false_renamed, x2, y'', xs1) -> max(cons(y'', xs1))
   del(x3, cons(y1, xs2)) -> if2(eq(x3, y1), x3, y1, xs2)
   h(nil) -> nil
   h(cons(x4, xs3)) -> cons(x4, h(xs3))
   eq(0, 0) -> true_renamed
   eq(0, s(y2)) -> false_renamed
   eq(s(x5), 0) -> false_renamed
   eq(s(x6), s(y3)) -> eq(x6, y3)
   if2(true_renamed, x7, y4, xs4) -> xs4
   if2(false_renamed, x8, y5, xs5) -> cons(y5, del(x8, xs5))
   del(x9, nil) -> nil
   ge(0, 0) -> true_renamed
   ge(s(x10), 0) -> true_renamed
   ge(0, s(x11)) -> false_renamed
   ge(s(x12), s(y6)) -> ge(x12, y6)
   max(nil) -> 0
   equal_bool(true, false) -> false
   equal_bool(false, true) -> false
   equal_bool(true, true) -> true
   equal_bool(false, false) -> true
   and(true, x) -> x
   and(false, x) -> false
   or(true, x) -> true
   or(false, x) -> x
   not(false) -> true
   not(true) -> false
   isa_true(true) -> true
   isa_true(false) -> false
   isa_false(true) -> false
   isa_false(false) -> true
   equal_sort[a0](0, 0) -> true
   equal_sort[a0](0, s(v30)) -> false
   equal_sort[a0](s(v31), 0) -> false
   equal_sort[a0](s(v31), s(v32)) -> equal_sort[a0](v31, v32)
   equal_sort[a37](cons(v33, v34), cons(v35, v36)) -> and(equal_sort[a0](v33, v35), equal_sort[a37](v34, v36))
   equal_sort[a37](cons(v33, v34), nil) -> false
   equal_sort[a37](nil, cons(v37, v38)) -> false
   equal_sort[a37](nil, nil) -> true
   equal_sort[a45](true_renamed, true_renamed) -> true
   equal_sort[a45](true_renamed, false_renamed) -> false
   equal_sort[a45](false_renamed, true_renamed) -> false
   equal_sort[a45](false_renamed, false_renamed) -> true
   equal_sort[a65](witness_sort[a65], witness_sort[a65]) -> true

The set Q consists of the following terms:

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(97) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(98)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false_renamed, x8, y5, xs5) -> DEL(x8, xs5)
   DEL(x3, cons(y1, xs2)) -> IF2(eq(x3, y1), x3, y1, xs2)

The TRS R consists of the following rules:

   eq(0, 0) -> true_renamed
   eq(0, s(y2)) -> false_renamed
   eq(s(x5), 0) -> false_renamed
   eq(s(x6), s(y3)) -> eq(x6, y3)

The set Q consists of the following terms:

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(99) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])


----------------------------------------

(100)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2(false_renamed, x8, y5, xs5) -> DEL(x8, xs5)
   DEL(x3, cons(y1, xs2)) -> IF2(eq(x3, y1), x3, y1, xs2)

The TRS R consists of the following rules:

   eq(0, 0) -> true_renamed
   eq(0, s(y2)) -> false_renamed
   eq(s(x5), 0) -> false_renamed
   eq(s(x6), s(y3)) -> eq(x6, y3)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(101) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*DEL(x3, cons(y1, xs2)) -> IF2(eq(x3, y1), x3, y1, xs2)
The graph contains the following edges 1 >= 2, 2 > 3, 2 > 4


*IF2(false_renamed, x8, y5, xs5) -> DEL(x8, xs5)
The graph contains the following edges 2 >= 1, 4 >= 2


----------------------------------------

(102)
YES

----------------------------------------

(103)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF1(true_renamed, x1, y', xs'') -> MAX(cons(x1, xs''))
   MAX(cons(x'', cons(y, xs'))) -> IF1(ge(x'', y), x'', y, xs')
   IF1(false_renamed, x2, y'', xs1) -> MAX(cons(y'', xs1))

The TRS R consists of the following rules:

   del'(x3, cons(y1, xs2)) -> if2'(eq(x3, y1), x3, y1, xs2)
   if2'(true_renamed, x7, y4, xs4) -> true
   if2'(false_renamed, x8, y5, xs5) -> del'(x8, xs5)
   del'(x9, nil) -> false
   max(cons(x', nil)) -> x'
   max(cons(x'', cons(y, xs'))) -> if1(ge(x'', y), x'', y, xs')
   if1(true_renamed, x1, y', xs'') -> max(cons(x1, xs''))
   if1(false_renamed, x2, y'', xs1) -> max(cons(y'', xs1))
   del(x3, cons(y1, xs2)) -> if2(eq(x3, y1), x3, y1, xs2)
   h(nil) -> nil
   h(cons(x4, xs3)) -> cons(x4, h(xs3))
   eq(0, 0) -> true_renamed
   eq(0, s(y2)) -> false_renamed
   eq(s(x5), 0) -> false_renamed
   eq(s(x6), s(y3)) -> eq(x6, y3)
   if2(true_renamed, x7, y4, xs4) -> xs4
   if2(false_renamed, x8, y5, xs5) -> cons(y5, del(x8, xs5))
   del(x9, nil) -> nil
   ge(0, 0) -> true_renamed
   ge(s(x10), 0) -> true_renamed
   ge(0, s(x11)) -> false_renamed
   ge(s(x12), s(y6)) -> ge(x12, y6)
   max(nil) -> 0
   equal_bool(true, false) -> false
   equal_bool(false, true) -> false
   equal_bool(true, true) -> true
   equal_bool(false, false) -> true
   and(true, x) -> x
   and(false, x) -> false
   or(true, x) -> true
   or(false, x) -> x
   not(false) -> true
   not(true) -> false
   isa_true(true) -> true
   isa_true(false) -> false
   isa_false(true) -> false
   isa_false(false) -> true
   equal_sort[a0](0, 0) -> true
   equal_sort[a0](0, s(v30)) -> false
   equal_sort[a0](s(v31), 0) -> false
   equal_sort[a0](s(v31), s(v32)) -> equal_sort[a0](v31, v32)
   equal_sort[a37](cons(v33, v34), cons(v35, v36)) -> and(equal_sort[a0](v33, v35), equal_sort[a37](v34, v36))
   equal_sort[a37](cons(v33, v34), nil) -> false
   equal_sort[a37](nil, cons(v37, v38)) -> false
   equal_sort[a37](nil, nil) -> true
   equal_sort[a45](true_renamed, true_renamed) -> true
   equal_sort[a45](true_renamed, false_renamed) -> false
   equal_sort[a45](false_renamed, true_renamed) -> false
   equal_sort[a45](false_renamed, false_renamed) -> true
   equal_sort[a65](witness_sort[a65], witness_sort[a65]) -> true

The set Q consists of the following terms:

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(104) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(105)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF1(true_renamed, x1, y', xs'') -> MAX(cons(x1, xs''))
   MAX(cons(x'', cons(y, xs'))) -> IF1(ge(x'', y), x'', y, xs')
   IF1(false_renamed, x2, y'', xs1) -> MAX(cons(y'', xs1))

The TRS R consists of the following rules:

   ge(0, 0) -> true_renamed
   ge(s(x10), 0) -> true_renamed
   ge(0, s(x11)) -> false_renamed
   ge(s(x12), s(y6)) -> ge(x12, y6)

The set Q consists of the following terms:

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(106) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])


----------------------------------------

(107)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF1(true_renamed, x1, y', xs'') -> MAX(cons(x1, xs''))
   MAX(cons(x'', cons(y, xs'))) -> IF1(ge(x'', y), x'', y, xs')
   IF1(false_renamed, x2, y'', xs1) -> MAX(cons(y'', xs1))

The TRS R consists of the following rules:

   ge(0, 0) -> true_renamed
   ge(s(x10), 0) -> true_renamed
   ge(0, s(x11)) -> false_renamed
   ge(s(x12), s(y6)) -> ge(x12, y6)

The set Q consists of the following terms:

   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(108) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   IF1(true_renamed, x1, y', xs'') -> MAX(cons(x1, xs''))
   MAX(cons(x'', cons(y, xs'))) -> IF1(ge(x'', y), x'', y, xs')
   IF1(false_renamed, x2, y'', xs1) -> MAX(cons(y'', xs1))
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
IF1(x1, x2, x3, x4)  =  IF1(x4)

MAX(x1)  =  x1

cons(x1, x2)  =  cons(x2)


Knuth-Bendix order [KBO] with precedence:trivial

and weight map:

   dummyConstant=1
   IF1_1=3
   cons_1=2

The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:
none


----------------------------------------

(109)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   ge(0, 0) -> true_renamed
   ge(s(x10), 0) -> true_renamed
   ge(0, s(x11)) -> false_renamed
   ge(s(x12), s(y6)) -> ge(x12, y6)

The set Q consists of the following terms:

   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(110) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(111)
YES

----------------------------------------

(112)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2'(false_renamed, x8, y5, xs5) -> DEL'(x8, xs5)
   DEL'(x3, cons(y1, xs2)) -> IF2'(eq(x3, y1), x3, y1, xs2)

The TRS R consists of the following rules:

   del'(x3, cons(y1, xs2)) -> if2'(eq(x3, y1), x3, y1, xs2)
   if2'(true_renamed, x7, y4, xs4) -> true
   if2'(false_renamed, x8, y5, xs5) -> del'(x8, xs5)
   del'(x9, nil) -> false
   max(cons(x', nil)) -> x'
   max(cons(x'', cons(y, xs'))) -> if1(ge(x'', y), x'', y, xs')
   if1(true_renamed, x1, y', xs'') -> max(cons(x1, xs''))
   if1(false_renamed, x2, y'', xs1) -> max(cons(y'', xs1))
   del(x3, cons(y1, xs2)) -> if2(eq(x3, y1), x3, y1, xs2)
   h(nil) -> nil
   h(cons(x4, xs3)) -> cons(x4, h(xs3))
   eq(0, 0) -> true_renamed
   eq(0, s(y2)) -> false_renamed
   eq(s(x5), 0) -> false_renamed
   eq(s(x6), s(y3)) -> eq(x6, y3)
   if2(true_renamed, x7, y4, xs4) -> xs4
   if2(false_renamed, x8, y5, xs5) -> cons(y5, del(x8, xs5))
   del(x9, nil) -> nil
   ge(0, 0) -> true_renamed
   ge(s(x10), 0) -> true_renamed
   ge(0, s(x11)) -> false_renamed
   ge(s(x12), s(y6)) -> ge(x12, y6)
   max(nil) -> 0
   equal_bool(true, false) -> false
   equal_bool(false, true) -> false
   equal_bool(true, true) -> true
   equal_bool(false, false) -> true
   and(true, x) -> x
   and(false, x) -> false
   or(true, x) -> true
   or(false, x) -> x
   not(false) -> true
   not(true) -> false
   isa_true(true) -> true
   isa_true(false) -> false
   isa_false(true) -> false
   isa_false(false) -> true
   equal_sort[a0](0, 0) -> true
   equal_sort[a0](0, s(v30)) -> false
   equal_sort[a0](s(v31), 0) -> false
   equal_sort[a0](s(v31), s(v32)) -> equal_sort[a0](v31, v32)
   equal_sort[a37](cons(v33, v34), cons(v35, v36)) -> and(equal_sort[a0](v33, v35), equal_sort[a37](v34, v36))
   equal_sort[a37](cons(v33, v34), nil) -> false
   equal_sort[a37](nil, cons(v37, v38)) -> false
   equal_sort[a37](nil, nil) -> true
   equal_sort[a45](true_renamed, true_renamed) -> true
   equal_sort[a45](true_renamed, false_renamed) -> false
   equal_sort[a45](false_renamed, true_renamed) -> false
   equal_sort[a45](false_renamed, false_renamed) -> true
   equal_sort[a65](witness_sort[a65], witness_sort[a65]) -> true

The set Q consists of the following terms:

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(113) UsableRulesProof (EQUIVALENT)
As all Q-normal forms are R-normal forms we are in the innermost case. Hence, by the usable rules processor [LPAR04] we can delete all non-usable rules [FROCOS05] from R.
----------------------------------------

(114)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2'(false_renamed, x8, y5, xs5) -> DEL'(x8, xs5)
   DEL'(x3, cons(y1, xs2)) -> IF2'(eq(x3, y1), x3, y1, xs2)

The TRS R consists of the following rules:

   eq(0, 0) -> true_renamed
   eq(0, s(y2)) -> false_renamed
   eq(s(x5), 0) -> false_renamed
   eq(s(x6), s(y3)) -> eq(x6, y3)

The set Q consists of the following terms:

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(115) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   del'(x0, cons(x1, x2))
   if2'(true_renamed, x0, x1, x2)
   if2'(false_renamed, x0, x1, x2)
   del'(x0, nil)
   max(cons(x0, nil))
   max(cons(x0, cons(x1, x2)))
   if1(true_renamed, x0, x1, x2)
   if1(false_renamed, x0, x1, x2)
   del(x0, cons(x1, x2))
   h(nil)
   h(cons(x0, x1))
   if2(true_renamed, x0, x1, x2)
   if2(false_renamed, x0, x1, x2)
   del(x0, nil)
   ge(0, 0)
   ge(s(x0), 0)
   ge(0, s(x0))
   ge(s(x0), s(x1))
   max(nil)
   equal_bool(true, false)
   equal_bool(false, true)
   equal_bool(true, true)
   equal_bool(false, false)
   and(true, x0)
   and(false, x0)
   or(true, x0)
   or(false, x0)
   not(false)
   not(true)
   isa_true(true)
   isa_true(false)
   isa_false(true)
   isa_false(false)
   equal_sort[a0](0, 0)
   equal_sort[a0](0, s(x0))
   equal_sort[a0](s(x0), 0)
   equal_sort[a0](s(x0), s(x1))
   equal_sort[a37](cons(x0, x1), cons(x2, x3))
   equal_sort[a37](cons(x0, x1), nil)
   equal_sort[a37](nil, cons(x0, x1))
   equal_sort[a37](nil, nil)
   equal_sort[a45](true_renamed, true_renamed)
   equal_sort[a45](true_renamed, false_renamed)
   equal_sort[a45](false_renamed, true_renamed)
   equal_sort[a45](false_renamed, false_renamed)
   equal_sort[a65](witness_sort[a65], witness_sort[a65])


----------------------------------------

(116)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IF2'(false_renamed, x8, y5, xs5) -> DEL'(x8, xs5)
   DEL'(x3, cons(y1, xs2)) -> IF2'(eq(x3, y1), x3, y1, xs2)

The TRS R consists of the following rules:

   eq(0, 0) -> true_renamed
   eq(0, s(y2)) -> false_renamed
   eq(s(x5), 0) -> false_renamed
   eq(s(x6), s(y3)) -> eq(x6, y3)

The set Q consists of the following terms:

   eq(0, 0)
   eq(0, s(x0))
   eq(s(x0), 0)
   eq(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(117) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*DEL'(x3, cons(y1, xs2)) -> IF2'(eq(x3, y1), x3, y1, xs2)
The graph contains the following edges 1 >= 2, 2 > 3, 2 > 4


*IF2'(false_renamed, x8, y5, xs5) -> DEL'(x8, xs5)
The graph contains the following edges 2 >= 1, 4 >= 2


----------------------------------------

(118)
YES
