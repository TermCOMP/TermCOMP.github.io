YES

Problem 1: 

(VAR vu95NonEmpty assign clause cnf e l ls t x xs y ys)
(RULES
choice(cons(x,xs)) -> choice(xs)
choice(cons(x,xs)) -> x
eq(num0(x),num1(y)) -> ffalse
eq(num1(x),num0(y)) -> ffalse
eq(num1(x),num1(y)) -> eq(x,y)
eq(O(x),num0(y)) -> eq(x,y)
eq(nil,nil) -> ftrue
guess(cons(clause,cnf)) -> cons(choice(clause),guess(cnf))
guess(nil) -> nil
if(ffalse,t,e) -> e
if(ftrue,t,e) -> t
member(x,cons(y,ys)) -> if(eq(x,y),ftrue,member(x,ys))
member(x,nil) -> ffalse
negate(num0(x)) -> num1(x)
negate(num1(x)) -> num0(x)
sat(cnf) -> satck(cnf,guess(cnf))
satck(cnf,assign) -> if(verify(assign),assign,unsat)
verify(cons(l,ls)) -> if(member(negate(l),ls),ffalse,verify(ls))
verify(nil) -> ftrue
)


Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 CHOICE(cons(x,xs)) -> CHOICE(xs)
 EQ(num1(x),num1(y)) -> EQ(x,y)
 EQ(O(x),num0(y)) -> EQ(x,y)
 GUESS(cons(clause,cnf)) -> CHOICE(clause)
 GUESS(cons(clause,cnf)) -> GUESS(cnf)
 MEMBER(x,cons(y,ys)) -> EQ(x,y)
 MEMBER(x,cons(y,ys)) -> IF(eq(x,y),ftrue,member(x,ys))
 MEMBER(x,cons(y,ys)) -> MEMBER(x,ys)
 SAT(cnf) -> GUESS(cnf)
 SAT(cnf) -> SATCK(cnf,guess(cnf))
 SATCK(cnf,assign) -> IF(verify(assign),assign,unsat)
 SATCK(cnf,assign) -> VERIFY(assign)
 VERIFY(cons(l,ls)) -> IF(member(negate(l),ls),ffalse,verify(ls))
 VERIFY(cons(l,ls)) -> MEMBER(negate(l),ls)
 VERIFY(cons(l,ls)) -> NEGATE(l)
 VERIFY(cons(l,ls)) -> VERIFY(ls)
-> Rules:
 choice(cons(x,xs)) -> choice(xs)
 choice(cons(x,xs)) -> x
 eq(num0(x),num1(y)) -> ffalse
 eq(num1(x),num0(y)) -> ffalse
 eq(num1(x),num1(y)) -> eq(x,y)
 eq(O(x),num0(y)) -> eq(x,y)
 eq(nil,nil) -> ftrue
 guess(cons(clause,cnf)) -> cons(choice(clause),guess(cnf))
 guess(nil) -> nil
 if(ffalse,t,e) -> e
 if(ftrue,t,e) -> t
 member(x,cons(y,ys)) -> if(eq(x,y),ftrue,member(x,ys))
 member(x,nil) -> ffalse
 negate(num0(x)) -> num1(x)
 negate(num1(x)) -> num0(x)
 sat(cnf) -> satck(cnf,guess(cnf))
 satck(cnf,assign) -> if(verify(assign),assign,unsat)
 verify(cons(l,ls)) -> if(member(negate(l),ls),ffalse,verify(ls))
 verify(nil) -> ftrue

Problem 1: 

SCC Processor:
-> Pairs:
 CHOICE(cons(x,xs)) -> CHOICE(xs)
 EQ(num1(x),num1(y)) -> EQ(x,y)
 EQ(O(x),num0(y)) -> EQ(x,y)
 GUESS(cons(clause,cnf)) -> CHOICE(clause)
 GUESS(cons(clause,cnf)) -> GUESS(cnf)
 MEMBER(x,cons(y,ys)) -> EQ(x,y)
 MEMBER(x,cons(y,ys)) -> IF(eq(x,y),ftrue,member(x,ys))
 MEMBER(x,cons(y,ys)) -> MEMBER(x,ys)
 SAT(cnf) -> GUESS(cnf)
 SAT(cnf) -> SATCK(cnf,guess(cnf))
 SATCK(cnf,assign) -> IF(verify(assign),assign,unsat)
 SATCK(cnf,assign) -> VERIFY(assign)
 VERIFY(cons(l,ls)) -> IF(member(negate(l),ls),ffalse,verify(ls))
 VERIFY(cons(l,ls)) -> MEMBER(negate(l),ls)
 VERIFY(cons(l,ls)) -> NEGATE(l)
 VERIFY(cons(l,ls)) -> VERIFY(ls)
-> Rules:
 choice(cons(x,xs)) -> choice(xs)
 choice(cons(x,xs)) -> x
 eq(num0(x),num1(y)) -> ffalse
 eq(num1(x),num0(y)) -> ffalse
 eq(num1(x),num1(y)) -> eq(x,y)
 eq(O(x),num0(y)) -> eq(x,y)
 eq(nil,nil) -> ftrue
 guess(cons(clause,cnf)) -> cons(choice(clause),guess(cnf))
 guess(nil) -> nil
 if(ffalse,t,e) -> e
 if(ftrue,t,e) -> t
 member(x,cons(y,ys)) -> if(eq(x,y),ftrue,member(x,ys))
 member(x,nil) -> ffalse
 negate(num0(x)) -> num1(x)
 negate(num1(x)) -> num0(x)
 sat(cnf) -> satck(cnf,guess(cnf))
 satck(cnf,assign) -> if(verify(assign),assign,unsat)
 verify(cons(l,ls)) -> if(member(negate(l),ls),ffalse,verify(ls))
 verify(nil) -> ftrue
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 EQ(num1(x),num1(y)) -> EQ(x,y)
 EQ(O(x),num0(y)) -> EQ(x,y)
->->-> Rules:
 choice(cons(x,xs)) -> choice(xs)
 choice(cons(x,xs)) -> x
 eq(num0(x),num1(y)) -> ffalse
 eq(num1(x),num0(y)) -> ffalse
 eq(num1(x),num1(y)) -> eq(x,y)
 eq(O(x),num0(y)) -> eq(x,y)
 eq(nil,nil) -> ftrue
 guess(cons(clause,cnf)) -> cons(choice(clause),guess(cnf))
 guess(nil) -> nil
 if(ffalse,t,e) -> e
 if(ftrue,t,e) -> t
 member(x,cons(y,ys)) -> if(eq(x,y),ftrue,member(x,ys))
 member(x,nil) -> ffalse
 negate(num0(x)) -> num1(x)
 negate(num1(x)) -> num0(x)
 sat(cnf) -> satck(cnf,guess(cnf))
 satck(cnf,assign) -> if(verify(assign),assign,unsat)
 verify(cons(l,ls)) -> if(member(negate(l),ls),ffalse,verify(ls))
 verify(nil) -> ftrue
->->Cycle:
->->-> Pairs:
 MEMBER(x,cons(y,ys)) -> MEMBER(x,ys)
->->-> Rules:
 choice(cons(x,xs)) -> choice(xs)
 choice(cons(x,xs)) -> x
 eq(num0(x),num1(y)) -> ffalse
 eq(num1(x),num0(y)) -> ffalse
 eq(num1(x),num1(y)) -> eq(x,y)
 eq(O(x),num0(y)) -> eq(x,y)
 eq(nil,nil) -> ftrue
 guess(cons(clause,cnf)) -> cons(choice(clause),guess(cnf))
 guess(nil) -> nil
 if(ffalse,t,e) -> e
 if(ftrue,t,e) -> t
 member(x,cons(y,ys)) -> if(eq(x,y),ftrue,member(x,ys))
 member(x,nil) -> ffalse
 negate(num0(x)) -> num1(x)
 negate(num1(x)) -> num0(x)
 sat(cnf) -> satck(cnf,guess(cnf))
 satck(cnf,assign) -> if(verify(assign),assign,unsat)
 verify(cons(l,ls)) -> if(member(negate(l),ls),ffalse,verify(ls))
 verify(nil) -> ftrue
->->Cycle:
->->-> Pairs:
 VERIFY(cons(l,ls)) -> VERIFY(ls)
->->-> Rules:
 choice(cons(x,xs)) -> choice(xs)
 choice(cons(x,xs)) -> x
 eq(num0(x),num1(y)) -> ffalse
 eq(num1(x),num0(y)) -> ffalse
 eq(num1(x),num1(y)) -> eq(x,y)
 eq(O(x),num0(y)) -> eq(x,y)
 eq(nil,nil) -> ftrue
 guess(cons(clause,cnf)) -> cons(choice(clause),guess(cnf))
 guess(nil) -> nil
 if(ffalse,t,e) -> e
 if(ftrue,t,e) -> t
 member(x,cons(y,ys)) -> if(eq(x,y),ftrue,member(x,ys))
 member(x,nil) -> ffalse
 negate(num0(x)) -> num1(x)
 negate(num1(x)) -> num0(x)
 sat(cnf) -> satck(cnf,guess(cnf))
 satck(cnf,assign) -> if(verify(assign),assign,unsat)
 verify(cons(l,ls)) -> if(member(negate(l),ls),ffalse,verify(ls))
 verify(nil) -> ftrue
->->Cycle:
->->-> Pairs:
 CHOICE(cons(x,xs)) -> CHOICE(xs)
->->-> Rules:
 choice(cons(x,xs)) -> choice(xs)
 choice(cons(x,xs)) -> x
 eq(num0(x),num1(y)) -> ffalse
 eq(num1(x),num0(y)) -> ffalse
 eq(num1(x),num1(y)) -> eq(x,y)
 eq(O(x),num0(y)) -> eq(x,y)
 eq(nil,nil) -> ftrue
 guess(cons(clause,cnf)) -> cons(choice(clause),guess(cnf))
 guess(nil) -> nil
 if(ffalse,t,e) -> e
 if(ftrue,t,e) -> t
 member(x,cons(y,ys)) -> if(eq(x,y),ftrue,member(x,ys))
 member(x,nil) -> ffalse
 negate(num0(x)) -> num1(x)
 negate(num1(x)) -> num0(x)
 sat(cnf) -> satck(cnf,guess(cnf))
 satck(cnf,assign) -> if(verify(assign),assign,unsat)
 verify(cons(l,ls)) -> if(member(negate(l),ls),ffalse,verify(ls))
 verify(nil) -> ftrue
->->Cycle:
->->-> Pairs:
 GUESS(cons(clause,cnf)) -> GUESS(cnf)
->->-> Rules:
 choice(cons(x,xs)) -> choice(xs)
 choice(cons(x,xs)) -> x
 eq(num0(x),num1(y)) -> ffalse
 eq(num1(x),num0(y)) -> ffalse
 eq(num1(x),num1(y)) -> eq(x,y)
 eq(O(x),num0(y)) -> eq(x,y)
 eq(nil,nil) -> ftrue
 guess(cons(clause,cnf)) -> cons(choice(clause),guess(cnf))
 guess(nil) -> nil
 if(ffalse,t,e) -> e
 if(ftrue,t,e) -> t
 member(x,cons(y,ys)) -> if(eq(x,y),ftrue,member(x,ys))
 member(x,nil) -> ffalse
 negate(num0(x)) -> num1(x)
 negate(num1(x)) -> num0(x)
 sat(cnf) -> satck(cnf,guess(cnf))
 satck(cnf,assign) -> if(verify(assign),assign,unsat)
 verify(cons(l,ls)) -> if(member(negate(l),ls),ffalse,verify(ls))
 verify(nil) -> ftrue


The problem is decomposed in 5 subproblems.

Problem 1.1: 

Subterm Processor:
-> Pairs:
 EQ(num1(x),num1(y)) -> EQ(x,y)
 EQ(O(x),num0(y)) -> EQ(x,y)
-> Rules:
 choice(cons(x,xs)) -> choice(xs)
 choice(cons(x,xs)) -> x
 eq(num0(x),num1(y)) -> ffalse
 eq(num1(x),num0(y)) -> ffalse
 eq(num1(x),num1(y)) -> eq(x,y)
 eq(O(x),num0(y)) -> eq(x,y)
 eq(nil,nil) -> ftrue
 guess(cons(clause,cnf)) -> cons(choice(clause),guess(cnf))
 guess(nil) -> nil
 if(ffalse,t,e) -> e
 if(ftrue,t,e) -> t
 member(x,cons(y,ys)) -> if(eq(x,y),ftrue,member(x,ys))
 member(x,nil) -> ffalse
 negate(num0(x)) -> num1(x)
 negate(num1(x)) -> num0(x)
 sat(cnf) -> satck(cnf,guess(cnf))
 satck(cnf,assign) -> if(verify(assign),assign,unsat)
 verify(cons(l,ls)) -> if(member(negate(l),ls),ffalse,verify(ls))
 verify(nil) -> ftrue
->Projection:
 pi(EQ) = 1

Problem 1.1: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 choice(cons(x,xs)) -> choice(xs)
 choice(cons(x,xs)) -> x
 eq(num0(x),num1(y)) -> ffalse
 eq(num1(x),num0(y)) -> ffalse
 eq(num1(x),num1(y)) -> eq(x,y)
 eq(O(x),num0(y)) -> eq(x,y)
 eq(nil,nil) -> ftrue
 guess(cons(clause,cnf)) -> cons(choice(clause),guess(cnf))
 guess(nil) -> nil
 if(ffalse,t,e) -> e
 if(ftrue,t,e) -> t
 member(x,cons(y,ys)) -> if(eq(x,y),ftrue,member(x,ys))
 member(x,nil) -> ffalse
 negate(num0(x)) -> num1(x)
 negate(num1(x)) -> num0(x)
 sat(cnf) -> satck(cnf,guess(cnf))
 satck(cnf,assign) -> if(verify(assign),assign,unsat)
 verify(cons(l,ls)) -> if(member(negate(l),ls),ffalse,verify(ls))
 verify(nil) -> ftrue
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2: 

Subterm Processor:
-> Pairs:
 MEMBER(x,cons(y,ys)) -> MEMBER(x,ys)
-> Rules:
 choice(cons(x,xs)) -> choice(xs)
 choice(cons(x,xs)) -> x
 eq(num0(x),num1(y)) -> ffalse
 eq(num1(x),num0(y)) -> ffalse
 eq(num1(x),num1(y)) -> eq(x,y)
 eq(O(x),num0(y)) -> eq(x,y)
 eq(nil,nil) -> ftrue
 guess(cons(clause,cnf)) -> cons(choice(clause),guess(cnf))
 guess(nil) -> nil
 if(ffalse,t,e) -> e
 if(ftrue,t,e) -> t
 member(x,cons(y,ys)) -> if(eq(x,y),ftrue,member(x,ys))
 member(x,nil) -> ffalse
 negate(num0(x)) -> num1(x)
 negate(num1(x)) -> num0(x)
 sat(cnf) -> satck(cnf,guess(cnf))
 satck(cnf,assign) -> if(verify(assign),assign,unsat)
 verify(cons(l,ls)) -> if(member(negate(l),ls),ffalse,verify(ls))
 verify(nil) -> ftrue
->Projection:
 pi(MEMBER) = 2

Problem 1.2: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 choice(cons(x,xs)) -> choice(xs)
 choice(cons(x,xs)) -> x
 eq(num0(x),num1(y)) -> ffalse
 eq(num1(x),num0(y)) -> ffalse
 eq(num1(x),num1(y)) -> eq(x,y)
 eq(O(x),num0(y)) -> eq(x,y)
 eq(nil,nil) -> ftrue
 guess(cons(clause,cnf)) -> cons(choice(clause),guess(cnf))
 guess(nil) -> nil
 if(ffalse,t,e) -> e
 if(ftrue,t,e) -> t
 member(x,cons(y,ys)) -> if(eq(x,y),ftrue,member(x,ys))
 member(x,nil) -> ffalse
 negate(num0(x)) -> num1(x)
 negate(num1(x)) -> num0(x)
 sat(cnf) -> satck(cnf,guess(cnf))
 satck(cnf,assign) -> if(verify(assign),assign,unsat)
 verify(cons(l,ls)) -> if(member(negate(l),ls),ffalse,verify(ls))
 verify(nil) -> ftrue
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.3: 

Subterm Processor:
-> Pairs:
 VERIFY(cons(l,ls)) -> VERIFY(ls)
-> Rules:
 choice(cons(x,xs)) -> choice(xs)
 choice(cons(x,xs)) -> x
 eq(num0(x),num1(y)) -> ffalse
 eq(num1(x),num0(y)) -> ffalse
 eq(num1(x),num1(y)) -> eq(x,y)
 eq(O(x),num0(y)) -> eq(x,y)
 eq(nil,nil) -> ftrue
 guess(cons(clause,cnf)) -> cons(choice(clause),guess(cnf))
 guess(nil) -> nil
 if(ffalse,t,e) -> e
 if(ftrue,t,e) -> t
 member(x,cons(y,ys)) -> if(eq(x,y),ftrue,member(x,ys))
 member(x,nil) -> ffalse
 negate(num0(x)) -> num1(x)
 negate(num1(x)) -> num0(x)
 sat(cnf) -> satck(cnf,guess(cnf))
 satck(cnf,assign) -> if(verify(assign),assign,unsat)
 verify(cons(l,ls)) -> if(member(negate(l),ls),ffalse,verify(ls))
 verify(nil) -> ftrue
->Projection:
 pi(VERIFY) = 1

Problem 1.3: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 choice(cons(x,xs)) -> choice(xs)
 choice(cons(x,xs)) -> x
 eq(num0(x),num1(y)) -> ffalse
 eq(num1(x),num0(y)) -> ffalse
 eq(num1(x),num1(y)) -> eq(x,y)
 eq(O(x),num0(y)) -> eq(x,y)
 eq(nil,nil) -> ftrue
 guess(cons(clause,cnf)) -> cons(choice(clause),guess(cnf))
 guess(nil) -> nil
 if(ffalse,t,e) -> e
 if(ftrue,t,e) -> t
 member(x,cons(y,ys)) -> if(eq(x,y),ftrue,member(x,ys))
 member(x,nil) -> ffalse
 negate(num0(x)) -> num1(x)
 negate(num1(x)) -> num0(x)
 sat(cnf) -> satck(cnf,guess(cnf))
 satck(cnf,assign) -> if(verify(assign),assign,unsat)
 verify(cons(l,ls)) -> if(member(negate(l),ls),ffalse,verify(ls))
 verify(nil) -> ftrue
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.4: 

Subterm Processor:
-> Pairs:
 CHOICE(cons(x,xs)) -> CHOICE(xs)
-> Rules:
 choice(cons(x,xs)) -> choice(xs)
 choice(cons(x,xs)) -> x
 eq(num0(x),num1(y)) -> ffalse
 eq(num1(x),num0(y)) -> ffalse
 eq(num1(x),num1(y)) -> eq(x,y)
 eq(O(x),num0(y)) -> eq(x,y)
 eq(nil,nil) -> ftrue
 guess(cons(clause,cnf)) -> cons(choice(clause),guess(cnf))
 guess(nil) -> nil
 if(ffalse,t,e) -> e
 if(ftrue,t,e) -> t
 member(x,cons(y,ys)) -> if(eq(x,y),ftrue,member(x,ys))
 member(x,nil) -> ffalse
 negate(num0(x)) -> num1(x)
 negate(num1(x)) -> num0(x)
 sat(cnf) -> satck(cnf,guess(cnf))
 satck(cnf,assign) -> if(verify(assign),assign,unsat)
 verify(cons(l,ls)) -> if(member(negate(l),ls),ffalse,verify(ls))
 verify(nil) -> ftrue
->Projection:
 pi(CHOICE) = 1

Problem 1.4: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 choice(cons(x,xs)) -> choice(xs)
 choice(cons(x,xs)) -> x
 eq(num0(x),num1(y)) -> ffalse
 eq(num1(x),num0(y)) -> ffalse
 eq(num1(x),num1(y)) -> eq(x,y)
 eq(O(x),num0(y)) -> eq(x,y)
 eq(nil,nil) -> ftrue
 guess(cons(clause,cnf)) -> cons(choice(clause),guess(cnf))
 guess(nil) -> nil
 if(ffalse,t,e) -> e
 if(ftrue,t,e) -> t
 member(x,cons(y,ys)) -> if(eq(x,y),ftrue,member(x,ys))
 member(x,nil) -> ffalse
 negate(num0(x)) -> num1(x)
 negate(num1(x)) -> num0(x)
 sat(cnf) -> satck(cnf,guess(cnf))
 satck(cnf,assign) -> if(verify(assign),assign,unsat)
 verify(cons(l,ls)) -> if(member(negate(l),ls),ffalse,verify(ls))
 verify(nil) -> ftrue
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.5: 

Subterm Processor:
-> Pairs:
 GUESS(cons(clause,cnf)) -> GUESS(cnf)
-> Rules:
 choice(cons(x,xs)) -> choice(xs)
 choice(cons(x,xs)) -> x
 eq(num0(x),num1(y)) -> ffalse
 eq(num1(x),num0(y)) -> ffalse
 eq(num1(x),num1(y)) -> eq(x,y)
 eq(O(x),num0(y)) -> eq(x,y)
 eq(nil,nil) -> ftrue
 guess(cons(clause,cnf)) -> cons(choice(clause),guess(cnf))
 guess(nil) -> nil
 if(ffalse,t,e) -> e
 if(ftrue,t,e) -> t
 member(x,cons(y,ys)) -> if(eq(x,y),ftrue,member(x,ys))
 member(x,nil) -> ffalse
 negate(num0(x)) -> num1(x)
 negate(num1(x)) -> num0(x)
 sat(cnf) -> satck(cnf,guess(cnf))
 satck(cnf,assign) -> if(verify(assign),assign,unsat)
 verify(cons(l,ls)) -> if(member(negate(l),ls),ffalse,verify(ls))
 verify(nil) -> ftrue
->Projection:
 pi(GUESS) = 1

Problem 1.5: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 choice(cons(x,xs)) -> choice(xs)
 choice(cons(x,xs)) -> x
 eq(num0(x),num1(y)) -> ffalse
 eq(num1(x),num0(y)) -> ffalse
 eq(num1(x),num1(y)) -> eq(x,y)
 eq(O(x),num0(y)) -> eq(x,y)
 eq(nil,nil) -> ftrue
 guess(cons(clause,cnf)) -> cons(choice(clause),guess(cnf))
 guess(nil) -> nil
 if(ffalse,t,e) -> e
 if(ftrue,t,e) -> t
 member(x,cons(y,ys)) -> if(eq(x,y),ftrue,member(x,ys))
 member(x,nil) -> ffalse
 negate(num0(x)) -> num1(x)
 negate(num1(x)) -> num0(x)
 sat(cnf) -> satck(cnf,guess(cnf))
 satck(cnf,assign) -> if(verify(assign),assign,unsat)
 verify(cons(l,ls)) -> if(member(negate(l),ls),ffalse,verify(ls))
 verify(nil) -> ftrue
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
