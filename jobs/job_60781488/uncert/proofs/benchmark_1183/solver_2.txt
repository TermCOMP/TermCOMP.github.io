YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/QYvP1.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination w.r.t. Q of the given QTRS could be proven:

(0) QTRS
(1) QTRSRRRProof [EQUIVALENT, 13 ms]
(2) QTRS
(3) QTRSRRRProof [EQUIVALENT, 1 ms]
(4) QTRS
(5) RisEmptyProof [EQUIVALENT, 0 ms]
(6) YES


----------------------------------------

(0)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   natsFrom(N) -> cons(N, n__natsFrom(s(N)))
   fst(pair(XS, YS)) -> XS
   snd(pair(XS, YS)) -> YS
   splitAt(0, XS) -> pair(nil, XS)
   splitAt(s(N), cons(X, XS)) -> u(splitAt(N, activate(XS)), N, X, activate(XS))
   u(pair(YS, ZS), N, X, XS) -> pair(cons(activate(X), YS), ZS)
   head(cons(N, XS)) -> N
   tail(cons(N, XS)) -> activate(XS)
   sel(N, XS) -> head(afterNth(N, XS))
   take(N, XS) -> fst(splitAt(N, XS))
   afterNth(N, XS) -> snd(splitAt(N, XS))
   natsFrom(X) -> n__natsFrom(X)
   activate(n__natsFrom(X)) -> natsFrom(X)
   activate(X) -> X

Q is empty.

----------------------------------------

(1) QTRSRRRProof (EQUIVALENT)
Used ordering:
natsFrom/1(YES)
cons/2(YES,YES)
n__natsFrom/1(YES)
s/1(YES)
fst/1(YES)
pair/2(YES,YES)
snd/1(YES)
splitAt/2(YES,YES)
0/0)
nil/0)
u/4(YES,YES,YES,YES)
activate/1(YES)
head/1)YES(
tail/1(YES)
sel/2(YES,YES)
afterNth/2(YES,YES)
take/2(YES,YES)

Quasi precedence:
[sel_2, afterNth_2] > snd_1
[sel_2, afterNth_2] > [splitAt_2, 0, nil] > [natsFrom_1, u_4, activate_1, tail_1] > n__natsFrom_1
[sel_2, afterNth_2] > [splitAt_2, 0, nil] > [natsFrom_1, u_4, activate_1, tail_1] > s_1
[sel_2, afterNth_2] > [splitAt_2, 0, nil] > [natsFrom_1, u_4, activate_1, tail_1] > pair_2 > cons_2
take_2 > fst_1
take_2 > [splitAt_2, 0, nil] > [natsFrom_1, u_4, activate_1, tail_1] > n__natsFrom_1
take_2 > [splitAt_2, 0, nil] > [natsFrom_1, u_4, activate_1, tail_1] > s_1
take_2 > [splitAt_2, 0, nil] > [natsFrom_1, u_4, activate_1, tail_1] > pair_2 > cons_2


Status:
natsFrom_1: multiset status
cons_2: multiset status
n__natsFrom_1: multiset status
s_1: multiset status
fst_1: multiset status
pair_2: multiset status
snd_1: multiset status
splitAt_2: [1,2]
0: multiset status
nil: multiset status
u_4: multiset status
activate_1: multiset status
tail_1: multiset status
sel_2: multiset status
afterNth_2: multiset status
take_2: multiset status

With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   natsFrom(N) -> cons(N, n__natsFrom(s(N)))
   fst(pair(XS, YS)) -> XS
   snd(pair(XS, YS)) -> YS
   splitAt(0, XS) -> pair(nil, XS)
   splitAt(s(N), cons(X, XS)) -> u(splitAt(N, activate(XS)), N, X, activate(XS))
   u(pair(YS, ZS), N, X, XS) -> pair(cons(activate(X), YS), ZS)
   head(cons(N, XS)) -> N
   tail(cons(N, XS)) -> activate(XS)
   take(N, XS) -> fst(splitAt(N, XS))
   afterNth(N, XS) -> snd(splitAt(N, XS))
   natsFrom(X) -> n__natsFrom(X)
   activate(n__natsFrom(X)) -> natsFrom(X)
   activate(X) -> X




----------------------------------------

(2)
Obligation:
Q restricted rewrite system:
The TRS R consists of the following rules:

   sel(N, XS) -> head(afterNth(N, XS))

Q is empty.

----------------------------------------

(3) QTRSRRRProof (EQUIVALENT)
Used ordering:
Knuth-Bendix order [KBO] with precedence:afterNth_2 > sel_2 > head_1

and weight map:

   head_1=1
   sel_2=1
   afterNth_2=0

The variable weight is 1With this ordering the following rules can be removed by the rule removal processor [LPAR04] because they are oriented strictly:

   sel(N, XS) -> head(afterNth(N, XS))




----------------------------------------

(4)
Obligation:
Q restricted rewrite system:
R is empty.
Q is empty.

----------------------------------------

(5) RisEmptyProof (EQUIVALENT)
The TRS R is empty. Hence, termination is trivially proven.
----------------------------------------

(6)
YES
