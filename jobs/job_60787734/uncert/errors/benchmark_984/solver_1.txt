[Info] pool sizes (success) 197 seen 90 todo
 @(pure-matchbox-1.1-76efd0ca7ed81445e0700c76a09ee684727edfd56408cc0b27b65ea5a40ad6b4:Matchbox.Closure.Simple src/Matchbox/Closure/Simple.hs:236:10)
last 487 length 1996
last 545 length 2248
last 426 length 1709
last 504 length 2077
CNF 487 vars 1996 clauses
CNF 545 vars 2248 clauses
CNF 426 vars 1709 clauses
CNF 504 vars 2077 clauses
**************************************************Matrix {monotone = Weak, domain = Arctic, method = QPI, shape = Full, bits = 3, compress = True, remove = Any, constraint = And [], minimize = Nothing, encoding = Ersatz_Binary, dim = 3, solver = Stats (Kissatapi [Option "quiet" 1,Configuration "sat"]), verbose = False, tracing = False, briefing = False, log_level = 1, draw = False} vars: 1996, clauses: 7129
Matrix {monotone = Weak, domain = Arctic, method = QPI, shape = Full, bits = 3, compress = True, remove = Any, constraint = And [], minimize = Nothing, encoding = Ersatz_Binary, dim = 3, solver = Stats (Kissatapi [Option "quiet" 1,Configuration "sat"]), verbose = False, tracing = False, briefing = False, log_level = 1, draw = False} vars: 1800, clauses: 6410

Matrix {monotone = Weak, domain = ArcticBZ, method = Direct, shape = Cornered, bits = 4, compress = True, remove = Any, constraint = And [], minimize = Nothing, encoding = Ersatz_Unary, dim = 3, solver = Stats (Kissatapi [Option "quiet" 1,Configuration "sat"]), verbose = False, tracing = False, briefing = False, log_level = 1, draw = False} vars: 5422, clauses: 22373
Matrix {monotone = Weak, domain = ArcticBZ, method = Direct, shape = Cornered, bits = 4, compress = True, remove = Any, constraint = And [], minimize = Nothing, encoding = Ersatz_Unary, dim = 3, solver = Stats (Kissatapi [Option "quiet" 1,Configuration "sat"]), verbose = False, tracing = False, briefing = False, log_level = 1, draw = False} vars: 5747, clauses: 23683
last 5593 length 24238
last 6902 length 29696
last 1996 length 7129
last 1800 length 6410
last 5422 length 22373
last 5747 length 23683
summaryCNF 5593 vars 24238 clauses

CNF 1996 vars 7129 clauses
CNF 1800 vars 6410 clauses
CNF 6902 vars 29696 clauses
CNF 5422 vars 22373 clauses
last 5542 length 22867
CNF 5747 vars 23683 clauses
last 7105 length 30079
**************************************************
SRS with 2 rules on 3 letters       mirror
SRS with 2 rules on 3 letters       admits a non-terminating transport system
with pivot [a]
alphabet [[a], [b, a], [c, b, a]]
pivot represented as [[a]]
derivations for transport system
  [a]
    [a] pivot ->^0 pivot [[a]]
    because of derivation
      [a, a] ->^0 [a, a]
      via steps 
      contains strict step False
  [b, a]
    [b, a] pivot ->^1 pivot [[a], [c, b, a]]
    because of derivation
      [b, a, a] ->^1 [a, a, c, b, a]
      via steps Step   { rule = 0, position = 0, s_strict = True}
      contains strict step True
  [c, b, a]
    [c, b, a] pivot ->^2 pivot [[b, a], [c, b, a]]
    because of derivation
      [c, b, a, a] ->^2 [a, b, a, c, b, a]
      via steps Step   { rule = 0, position = 1, s_strict = True}
      Step   { rule = 1, position = 0, s_strict = True}
      contains strict step True
infinite derivation starts at
  [[c, b, a]] pivot ^ 5

**************************************************
proof
**************************************************
property Termination
has value Just False
for SRS
  [a, a, b] -> [a, b, c, a, a] {- Input 0 -}
  [a, c] -> [b, a] {- Input 1 -}
reason
  mirror
   property Termination
has value Just False
for SRS
  [b, a, a] -> [a, a, c, b, a] {- Mirror (Input 0) -}
  [c, a] -> [a, b] {- Mirror (Input 1) -}
reason
  admits a non-terminating transport system
  with pivot [a]
  alphabet [[a], [b, a], [c, b, a]]
  pivot represented as [[a]]
  derivations for transport system
    [a]
      [a] pivot ->^0 pivot [[a]]
      because of derivation
        [a, a] ->^0 [a, a]
        via steps 
        contains strict step False
    [b, a]
      [b, a] pivot ->^1 pivot [[a], [c, b, a]]
      because of derivation
        [b, a, a] ->^1 [a, a, c, b, a]
        via steps Step   { rule = 0, position = 0, s_strict = True}
        contains strict step True
    [c, b, a]
      [c, b, a] pivot ->^2 pivot [[b, a], [c, b, a]]
      because of derivation
        [c, b, a, a] ->^2 [a, b, a, c, b, a]
        via steps Step   { rule = 0, position = 1, s_strict = True}
        Step   { rule = 1, position = 0, s_strict = True}
        contains strict step True
  infinite derivation starts at
    [[c, b, a]] pivot ^ 5

**************************************************
skeleton: \Mirror(2,3)\Transport{}[]
**************************************************
let {slowdown = 1.0}
in let {verb ?= False;trac ?= False;cpf ?= False;slowdown = 3;uncertified = \ p -> Apply (Guard_Not cpf) p;uncertified_T = \ t -> And_Then (Guard_Not cpf) t;do = \ x -> x;dont = \ x -> Fail;done = Worker No_Strict_Rules;when_small = \ m -> And_Then (Worker (SizeAtmost 10000)) m;solver = Stats (Kissatapi [ Option "quiet" 1, Configuration "sat"]);mo = Pre (Or_Else Count GLPK);weight = Worker (Weight {modus = mo});wop = Or_Else weight Pass;weighted = \ m -> And_Then m wop;mirror = Worker Mirror;mirrored = \ m -> And_Then mirror m;cleaner = Or_Else (Worker (Cleaner {tracing = trac})) Pass;tiling = \ m w u -> weighted (Worker (Tiling {method = m,width = w,state_type = Best,map_type = Enum,unlabel = u,max_num_tiles = Just 10000,max_num_rules = Just 100000,cpf = cpf}));kbo = \ b -> weighted (Worker (KBO {direction = LR,bits = b,encoding = Ersatz_Bits,solver = solver}));okb = \ b -> weighted (Worker (KBO {direction = RL,bits = b,encoding = Ersatz_Bits,solver = solver}));kbom = \ b -> First_Of [ kbo b, okb b];qpi = \ dim bits -> weighted (Worker (QPI {tracing = trac,dim = dim,bits = bits,solver = solver,encoding = Ersatz_Binary}));matrix = \ mon dom dim bits enc -> weighted (Worker (Matrix {monotone = mon,domain = dom,dim = dim,bits = bits,shape = Cornered,encoding = enc,tracing = trac,verbose = verb,solver = solver}));ctx = Worker (Context {when = When_Empty,side = Right,close = Empty});simple = Seq [ weight, Timeout slowdown (when_small (kbom 1))];unlab = Worker (Unlabel {accept_null_strict = True,produce_null_strict = False});tileun = \ w -> And_Then (tiling All w Never) (Or_Else unlab (And_Then simple (Or_Else unlab (And_Then simple (Or_Else unlab (And_Then simple unlab))))));tileuns = Seq ([2..2] >>= (\ w -> [ tileun w]));preprocess = While_Fail_T (Worker No_Strict_Rules_T) tileuns;bin = Ersatz_Binary;una = Ersatz_Unary;tp = Worker (Transport {max_derivation_length = Just 2,max_tiers = Just 33,direction = Forward_Backward,tracing = False,cpf = cpf});nohs = let {noh = \ c w m -> Worker (Simple (Config {closure = c,max_closure_width = w,max_seen_size = m,max_inner_children = Just 8,max_outer_children = Just 2,intermediates = All,priority = Linear [ ( -7, Width_lhs), ( -1, Width_rhs), ( 7, Log2 Steps)],start_strict_only = True,print_sizes_finally = True}));f1w = 15;f1s = 1000000;nohs = [ tp, Seq [ noh Forward (Just f1w) (Just f1s), noh Forward Nothing Nothing], Seq [ noh Backward (Just f1w) (Just f1s), noh Backward Nothing Nothing]]}in nohs;relative = let {matrices = First_Of_Pool (Config {workers = 2,advice = Nothing,tracing = trac}) let {s = slowdown;matrix_strict_timeout = \ dom dim bits enc -> TimeoutSlowdown s dim (matrix Strict dom dim bits enc);kbobits = 1}in [ ] <> ([ Timeout s (kbo kbobits), Timeout s (okb kbobits)] <> ([ matrix_strict_timeout ArcticBZ 3 4 una, matrix_strict_timeout Natural 3 3 bin, matrix_strict_timeout ArcticBZ 4 4 una, matrix_strict_timeout Natural 4 3 bin] <> ([5..10] >>= (\ dim -> [ matrix_strict_timeout Arctic dim 3 una, matrix_strict_timeout Natural dim 2 bin]))));barr = \ h -> Worker (Matchbound {method = ROC,implementation = Approximate {at_bound = Merge},max_height = Just h});remove = Seq [ weight, First_Of [ when_small (weighted matrices), tileuns]];yeah = While_Fail done remove}in First_Of ([ ] <> ([ Apply ctx yeah, Apply preprocess (Apply ctx yeah)] <> (nohs <> [ do (Apply (tiling All 2 Never) yeah), dont (Apply (tiling All 3 Never) yeah), dont (Apply (tiling All 4 Never) yeah)])));standard = let {matrices = First_Of_Pool (Config {workers = 2,advice = Nothing,tracing = trac}) let {s = slowdown;matrix_weak_timeout = \ dom dim bits enc -> TimeoutSlowdown s dim (matrix Weak dom dim bits enc);kbobits = 1}in [ ] <> ([ Timeout s (kbo kbobits), Timeout s (okb kbobits)] <> ([ TimeoutSlowdown s 3 (qpi 3 3), matrix_weak_timeout ArcticBZ 3 4 una, matrix_weak_timeout Natural 3 3 bin, TimeoutSlowdown s 4 (qpi 4 3), matrix_weak_timeout Natural 4 3 bin] <> ([5..10] >>= (\ dim -> [ do (TimeoutSlowdown s dim (qpi dim 4)), do (matrix_weak_timeout Arctic dim 3 una), do (matrix_weak_timeout Natural dim 2 bin)]))));remove = Seq [ weight, when_small (weighted matrices)];dp = Apply ctx (Apply (Worker (DP {tracing = False})) (Apply wop (Branch (Worker (EDG {usable = True,tcap_inverse = True})) remove)));mbe = \ ms -> uncertified_T (Worker (Matchbound {method = RFC,implementation = Exact,max_size = ms}));mbeh = Apply (mbe (Just 100000)) done;mba = \ h -> uncertified_T (Worker (Matchbound {method = RFC,implementation = Approximate {at_bound = Merge},max_height = Just h}));mb_trans = Worker (Matchbound {method = RFC,max_size = Just 10000,max_height = Just 5});mb_proof = Apply mb_trans done;when_onerule = \ m -> Apply (Worker (Assert (Atmost 1 Rules))) m;dropped = \ y -> Or_Else (when_onerule (Dropped_Par (First_Of (nohs <> [ y])))) y;simple_yeah = Seq [ done, uncertified (Worker KKST01), uncertified (dropped (First_Of [ mb_proof, Apply (Worker Mirror) mb_proof]))];yeah = Seq [ done, simple_yeah, First_Of [ dp, Apply (Worker Mirror) dp]];preprocess = While_Fail_T (Worker No_Strict_Rules_T) (First_Of [ tileuns, Seq ([2..6] >>= (\ h -> [ mba h, And_Then (Worker Mirror) (mba h)]))])}in Apply wop (Or_Else done (First_Of ([ Apply preprocess yeah, yeah] <> (nohs <> [ do (Apply (tiling All 2 Never) yeah), dont (Apply (tiling All 3 Never) yeah), dont (Apply (tiling All 4 Never) yeah)]))));strictify = Worker (Strictify {});dropstrict = Worker (Dropstrict {})}
  in Apply cleaner (Or_Else done (Apply wop (Or_Else done (Or_Else (Apply (When_True (Apply dropstrict (Apply strictify standard))) (Apply strictify standard)) relative))))Matrix {monotone = Weak, domain = Arctic, method = QPI, shape = Full, bits = 3, compress = True, remove = Any, constraint = And [], minimize = Nothing, encoding = Ersatz_Binary, dim = 3, solver = Stats (Kissatapi [Option "quiet" 1,Configuration "sat"]), verbose = False, tracing = False, briefing = False, log_level = 1, draw = False} vars: 1996, clauses: 7129, status: Unsatisfied, time: 0.124040198s
**************************************************
statistics on proof search (nodes types that (together) took more than 1.000000000000)
**************************************************CNF 5542 vars 22867 clauses
CNF 7105 vars 30079 clauses


**************************************************
   
