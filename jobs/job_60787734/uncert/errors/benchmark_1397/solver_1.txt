last 2468 length 10450
CNF 2468 vars 10450 clauses
last 512 length 1983
CNF 512 vars 1983 clauses
last 557 length 2163
CNF 557 vars 2163 clauses
last 2728 length 12070
CNF 2728 vars 12070 clauses
Matrix {monotone = Weak, domain = Arctic, method = QPI, shape = Full, bits = 3, compress = True, remove = Any, constraint = And [], minimize = Nothing, encoding = Ersatz_Binary, dim = 3, solver = Stats (Kissatapi [Option "quiet" 1,Configuration "sat"]), verbose = False, tracing = False, briefing = False, log_level = 1, draw = False} vars: 2407, clauses: 8563
last 429 length 1676
last 472 length 1851
last 2407 length 8563
Matrix {monotone = Weak, domain = Arctic, method = QPI, shape = Full, bits = 3, compress = True, remove = Any, constraint = And [], minimize = Nothing, encoding = Ersatz_Binary, dim = 3, solver = Stats (Kissatapi [Option "quiet" 1,Configuration "sat"]), verbose = False, tracing = False, briefing = False, log_level = 1, draw = False} vars: 2606, clauses: 9342
CNF 429 vars 1676 clauses
CNF 472 vars 1851 clauses
last 2606 length 9342
CNF 2407 vars 8563 clauses
CNF 2606 vars 9342 clauses
last 3460 length 14029
Matrix {monotone = Weak, domain = Arctic, method = QPI, shape = Full, bits = 3, compress = True, remove = Any, constraint = And [], minimize = Nothing, encoding = Ersatz_Binary, dim = 3, solver = Stats (Kissatapi [Option "quiet" 1,Configuration "sat"]), verbose = False, tracing = False, briefing = False, log_level = 1, draw = False} vars: 2606, clauses: 9342, status: Satisfied, time: 0.158923852s
Matrix {monotone = Weak, domain = Arctic, method = QPI, shape = Full, bits = 3, compress = True, remove = Any, constraint = And [], minimize = Nothing, encoding = Ersatz_Binary, dim = 3, solver = Stats (Kissatapi [Option "quiet" 1,Configuration "sat"]), verbose = False, tracing = False, briefing = False, log_level = 1, draw = False} vars: 2407, clauses: 8563, status: Unsatisfied, time: 0.176421591s
CNF 3460 vars 14029 clauses
Matrix {monotone = Weak, domain = ArcticBZ, method = Direct, shape = Cornered, bits = 4, compress = True, remove = Any, constraint = And [], minimize = Nothing, encoding = Ersatz_Unary, dim = 3, solver = Stats (Kissatapi [Option "quiet" 1,Configuration "sat"]), verbose = False, tracing = False, briefing = False, log_level = 1, draw = False} vars: 6581, clauses: 27093
last 4353 length 17899
last 2894 length 12362
Matrix {monotone = Weak, domain = Natural, method = Direct, shape = Cornered, bits = 3, compress = True, remove = Any, constraint = And [], minimize = Nothing, encoding = Ersatz_Binary, dim = 3, solver = Stats (Kissatapi [Option "quiet" 1,Configuration "sat"]), verbose = False, tracing = False, briefing = False, log_level = 1, draw = False} vars: 4227, clauses: 16411
last 400 length 1581
last 415 length 1629
last 3418 length 15540
last 6581 length 27093
CNF 4353 vars 17899 clauses
last 4227 length 16411
CNF 400 vars 1581 clauses
CNF 2894 vars 12362 clauses
CNF 3418 vars 15540 clauses
CNF 415 vars 1629 clauses
CNF 6581 vars 27093 clauses
[Info] AsyncCancelled @(pure-matchbox-1.1-76efd0ca7ed81445e0700c76a09ee684727edfd56408cc0b27b65ea5a40ad6b4:Matchbox.QPI.Top src/Matchbox/QPI/Top.hs:136:6)
**************************************************
summary
**************************************************
SRS with 4 rules on 3 letters       split
2 sub-proofs
  1 SRS with 1 strict rules and 3 weak rules on 3 letters       CNF 4227 vars 16411 clauses
tile all, by Config   { method = All,width = 2,unlabel = Never}
  SRS with 9 strict rules and 27 weak rules on 9 letters       weights
  SRS with 4 strict rules and 16 weak rules on 9 letters       Matrix   { monotone = Strict, domain = Natural, method = KBO, shape = Full, bits = 1, compress = True, remove = Any, constraint = And [], minimize = Nothing, encoding = Ersatz_Binary, dim = 2, solver = Stats (Kissatapi [Option "quiet" 1, Configuration "sat"]), verbose = False, tracing = False, briefing = False, log_level = 1, draw = False}
  SRS with 2 strict rules and 13 weak rules on 9 letters       weights
  SRS with 0 strict rules and 13 weak rules on 9 letters       no strict rules

  2 SRS with 3 rules on 3 letters       mirror
  SRS with 3 rules on 3 letters       relatively RFC-matchbounded for method RFC at bound  Merge with height bound 3 and actual height 3 and with 54 epsilon transitions
  SRS with 1 rules on 1 letters       relatively RFC-matchbounded for method RFC at bound  Merge with height bound 2 and actual height -1 and with 0 epsilon transitions
  SRS with 0 rules on 0 letters       no strict rules

**************************************************
proof
**************************************************
property Termination
has value Just True
for SRS
  [a] -> [] {- Input 0 -}
  [a, a] -> [a, b, c] {- Input 1 -}
  [b] -> [] {- Input 2 -}
  [c, b] -> [b, a, c] {- Input 3 -}
reason
  split
   property Termination
has value Just True
for SRS
  [a] -> [] {- Input 0 -}
  [a, a] ->= [a, b, c] {- Input 1 -}
  [b] ->= [] {- Input 2 -}
  [c, b] ->= [b, a, c] {- Input 3 -}
reason
  Tiling   { method = All, width = 2, state_type = Bit64, map_type = Enum, unlabel = Never, print_completion_steps = False, print_tiles = False, max_num_tiles = Just 10000, max_num_rules = Just 100000, verbose = False, tracing = False, draw = False, cpf = False}
  steps 2
  using all tiles
  tile all rules
  steps: 2

   property Termination
has value Just True
for SRS
  [[a, a], [a, a]] -> [[a, a]] {- Semlab 0 (Concon 0 (Input 0)) -}
  [[a, a], [a, b]] -> [[a, b]] {- Semlab 0 (Concon 1 (Input 0)) -}
  [[a, a], [a, c]] -> [[a, c]] {- Semlab 0 (Concon 2 (Input 0)) -}
  [[b, a], [a, a]] -> [[b, a]] {- Semlab 1 (Concon 0 (Input 0)) -}
  [[b, a], [a, b]] -> [[b, b]] {- Semlab 1 (Concon 1 (Input 0)) -}
  [[b, a], [a, c]] -> [[b, c]] {- Semlab 1 (Concon 2 (Input 0)) -}
  [[c, a], [a, a]] -> [[c, a]] {- Semlab 2 (Concon 0 (Input 0)) -}
  [[c, a], [a, b]] -> [[c, b]] {- Semlab 2 (Concon 1 (Input 0)) -}
  [[c, a], [a, c]] -> [[c, c]] {- Semlab 2 (Concon 2 (Input 0)) -}
  [[a, a], [a, a], [a, a]] ->= [ [a, a] , [a, b] , [b, c] , [c, a] ] {- Semlab 0 (Concon 0 (Input 1)) -}
  [[a, a], [a, a], [a, b]] ->= [ [a, a] , [a, b] , [b, c] , [c, b] ] {- Semlab 0 (Concon 1 (Input 1)) -}
  [[a, a], [a, a], [a, c]] ->= [ [a, a] , [a, b] , [b, c] , [c, c] ] {- Semlab 0 (Concon 2 (Input 1)) -}
  [[b, a], [a, a], [a, a]] ->= [ [b, a] , [a, b] , [b, c] , [c, a] ] {- Semlab 1 (Concon 0 (Input 1)) -}
  [[b, a], [a, a], [a, b]] ->= [ [b, a] , [a, b] , [b, c] , [c, b] ] {- Semlab 1 (Concon 1 (Input 1)) -}
  [[b, a], [a, a], [a, c]] ->= [ [b, a] , [a, b] , [b, c] , [c, c] ] {- Semlab 1 (Concon 2 (Input 1)) -}
  [[c, a], [a, a], [a, a]] ->= [ [c, a] , [a, b] , [b, c] , [c, a] ] {- Semlab 2 (Concon 0 (Input 1)) -}
  [[c, a], [a, a], [a, b]] ->= [ [c, a] , [a, b] , [b, c] , [c, b] ] {- Semlab 2 (Concon 1 (Input 1)) -}
  [[c, a], [a, a], [a, c]] ->= [ [c, a] , [a, b] , [b, c] , [c, c] ] {- Semlab 2 (Concon 2 (Input 1)) -}
  [[a, b], [b, a]] ->= [[a, a]] {- Semlab 0 (Concon 0 (Input 2)) -}
  [[a, b], [b, b]] ->= [[a, b]] {- Semlab 0 (Concon 1 (Input 2)) -}
  [[a, b], [b, c]] ->= [[a, c]] {- Semlab 0 (Concon 2 (Input 2)) -}
  [[b, b], [b, a]] ->= [[b, a]] {- Semlab 1 (Concon 0 (Input 2)) -}
  [[b, b], [b, b]] ->= [[b, b]] {- Semlab 1 (Concon 1 (Input 2)) -}
  [[b, b], [b, c]] ->= [[b, c]] {- Semlab 1 (Concon 2 (Input 2)) -}
  [[c, b], [b, a]] ->= [[c, a]] {- Semlab 2 (Concon 0 (Input 2)) -}
  [[c, b], [b, b]] ->= [[c, b]] {- Semlab 2 (Concon 1 (Input 2)) -}
  [[c, b], [b, c]] ->= [[c, c]] {- Semlab 2 (Concon 2 (Input 2)) -}
  [[a, c], [c, b], [b, a]] ->= [ [a, b] , [b, a] , [a, c] , [c, a] ] {- Semlab 0 (Concon 0 (Input 3)) -}
  [[a, c], [c, b], [b, b]] ->= [ [a, b] , [b, a] , [a, c] , [c, b] ] {- Semlab 0 (Concon 1 (Input 3)) -}
  [[a, c], [c, b], [b, c]] ->= [ [a, b] , [b, a] , [a, c] , [c, c] ] {- Semlab 0 (Concon 2 (Input 3)) -}
  [[b, c], [c, b], [b, a]] ->= [ [b, b] , [b, a] , [a, c] , [c, a] ] {- Semlab 1 (Concon 0 (Input 3)) -}
  [[b, c], [c, b], [b, b]] ->= [ [b, b] , [b, a] , [a, c] , [c, b] ] {- Semlab 1 (Concon 1 (Input 3)) -}
  [[b, c], [c, b], [b, c]] ->= [ [b, b] , [b, a] , [a, c] , [c, c] ] {- Semlab 1 (Concon 2 (Input 3)) -}
  [[c, c], [c, b], [b, a]] ->= [ [c, b] , [b, a] , [a, c] , [c, a] ] {- Semlab 2 (Concon 0 (Input 3)) -}
  [[c, c], [c, b], [b, b]] ->= [ [c, b] , [b, a] , [a, c] , [c, b] ] {- Semlab 2 (Concon 1 (Input 3)) -}
  [[c, c], [c, b], [b, c]] ->= [ [c, b] , [b, a] , [a, c] , [c, c] ] {- Semlab 2 (Concon 2 (Input 3)) -}
reason
  ([a, a], 1/1)
  ([a, b], 0/1)
  ([a, c], 0/1)
  ([b, a], 1/1)
  ([b, b], 1/1)
  ([b, c], 1/1)
  ([c, a], 0/1)
  ([c, b], 0/1)
  ([c, c], 0/1)
   property Termination
has value Just True
for SRS
  [[b, a], [a, b]] -> [[b, b]] {- Semlab 1 (Concon 1 (Input 0)) -}
  [[b, a], [a, c]] -> [[b, c]] {- Semlab 1 (Concon 2 (Input 0)) -}
  [[c, a], [a, b]] -> [[c, b]] {- Semlab 2 (Concon 1 (Input 0)) -}
  [[c, a], [a, c]] -> [[c, c]] {- Semlab 2 (Concon 2 (Input 0)) -}
  [[a, a], [a, a], [a, b]] ->= [ [a, a] , [a, b] , [b, c] , [c, b] ] {- Semlab 0 (Concon 1 (Input 1)) -}
  [[a, a], [a, a], [a, c]] ->= [ [a, a] , [a, b] , [b, c] , [c, c] ] {- Semlab 0 (Concon 2 (Input 1)) -}
  [[b, a], [a, a], [a, b]] ->= [ [b, a] , [a, b] , [b, c] , [c, b] ] {- Semlab 1 (Concon 1 (Input 1)) -}
  [[b, a], [a, a], [a, c]] ->= [ [b, a] , [a, b] , [b, c] , [c, c] ] {- Semlab 1 (Concon 2 (Input 1)) -}
  [[c, a], [a, a], [a, b]] ->= [ [c, a] , [a, b] , [b, c] , [c, b] ] {- Semlab 2 (Concon 1 (Input 1)) -}
  [[c, a], [a, a], [a, c]] ->= [ [c, a] , [a, b] , [b, c] , [c, c] ] {- Semlab 2 (Concon 2 (Input 1)) -}
  [[a, b], [b, a]] ->= [[a, a]] {- Semlab 0 (Concon 0 (Input 2)) -}
  [[a, c], [c, b], [b, a]] ->= [ [a, b] , [b, a] , [a, c] , [c, a] ] {- Semlab 0 (Concon 0 (Input 3)) -}
  [[a, c], [c, b], [b, b]] ->= [ [a, b] , [b, a] , [a, c] , [c, b] ] {- Semlab 0 (Concon 1 (Input 3)) -}
  [[a, c], [c, b], [b, c]] ->= [ [a, b] , [b, a] , [a, c] , [c, c] ] {- Semlab 0 (Concon 2 (Input 3)) -}
  [[b, c], [c, b], [b, a]] ->= [ [b, b] , [b, a] , [a, c] , [c, a] ] {- Semlab 1 (Concon 0 (Input 3)) -}
  [[b, c], [c, b], [b, b]] ->= [ [b, b] , [b, a] , [a, c] , [c, b] ] {- Semlab 1 (Concon 1 (Input 3)) -}
  [[b, c], [c, b], [b, c]] ->= [ [b, b] , [b, a] , [a, c] , [c, c] ] {- Semlab 1 (Concon 2 (Input 3)) -}
  [[c, c], [c, b], [b, a]] ->= [ [c, b] , [b, a] , [a, c] , [c, a] ] {- Semlab 2 (Concon 0 (Input 3)) -}
  [[c, c], [c, b], [b, b]] ->= [ [c, b] , [b, a] , [a, c] , [c, b] ] {- Semlab 2 (Concon 1 (Input 3)) -}
  [[c, c], [c, b], [b, c]] ->= [ [c, b] , [b, a] , [a, c] , [c, c] ] {- Semlab 2 (Concon 2 (Input 3)) -}
reason
  ( [a, a]
  , Ek 2  / 1 1 \
          \ 0 2 / )
  ( [a, b]
  , Ek 2  / 1 0 \
          \ 0 2 / )
  ( [a, c]
  , Ek 2  / 1 1 \
          \ 0 1 / )
  ( [b, a]
  , Ek 2  / 1 1 \
          \ 0 1 / )
  ( [b, b]
  , Ek 2  / 1 0 \
          \ 0 2 / )
  ( [b, c]
  , Ek 2  / 1 1 \
          \ 0 1 / )
  ( [c, a]
  , Ek 2  / 1 0 \
          \ 0 1 / )
  ( [c, b]
  , Ek 2  / 1 0 \
          \ 0 2 / )
  ( [c, c]
  , Ek 2  / 1 1 \
          \ 0 1 / )
   property Termination
has value Just True
for SRS
  [[c, a], [a, b]] -> [[c, b]] {- Semlab 2 (Concon 1 (Input 0)) -}
  [[c, a], [a, c]] -> [[c, c]] {- Semlab 2 (Concon 2 (Input 0)) -}
  [[a, a], [a, a], [a, b]] ->= [ [a, a] , [a, b] , [b, c] , [c, b] ] {- Semlab 0 (Concon 1 (Input 1)) -}
  [[a, a], [a, a], [a, c]] ->= [ [a, a] , [a, b] , [b, c] , [c, c] ] {- Semlab 0 (Concon 2 (Input 1)) -}
  [[b, a], [a, a], [a, b]] ->= [ [b, a] , [a, b] , [b, c] , [c, b] ] {- Semlab 1 (Concon 1 (Input 1)) -}
  [[b, a], [a, a], [a, c]] ->= [ [b, a] , [a, b] , [b, c] , [c, c] ] {- Semlab 1 (Concon 2 (Input 1)) -}
  [[c, a], [a, a], [a, b]] ->= [ [c, a] , [a, b] , [b, c] , [c, b] ] {- Semlab 2 (Concon 1 (Input 1)) -}
  [[c, a], [a, a], [a, c]] ->= [ [c, a] , [a, b] , [b, c] , [c, c] ] {- Semlab 2 (Concon 2 (Input 1)) -}
  [[a, b], [b, a]] ->= [[a, a]] {- Semlab 0 (Concon 0 (Input 2)) -}
  [[a, c], [c, b], [b, b]] ->= [ [a, b] , [b, a] , [a, c] , [c, b] ] {- Semlab 0 (Concon 1 (Input 3)) -}
  [[a, c], [c, b], [b, c]] ->= [ [a, b] , [b, a] , [a, c] , [c, c] ] {- Semlab 0 (Concon 2 (Input 3)) -}
  [[b, c], [c, b], [b, b]] ->= [ [b, b] , [b, a] , [a, c] , [c, b] ] {- Semlab 1 (Concon 1 (Input 3)) -}
  [[b, c], [c, b], [b, c]] ->= [ [b, b] , [b, a] , [a, c] , [c, c] ] {- Semlab 1 (Concon 2 (Input 3)) -}
  [[c, c], [c, b], [b, b]] ->= [ [c, b] , [b, a] , [a, c] , [c, b] ] {- Semlab 2 (Concon 1 (Input 3)) -}
  [[c, c], [c, b], [b, c]] ->= [ [c, b] , [b, a] , [a, c] , [c, c] ] {- Semlab 2 (Concon 2 (Input 3)) -}
reason
  ([a, a], 0/1)
  ([a, b], 0/1)
  ([a, c], 0/1)
  ([b, a], 0/1)
  ([b, b], 0/1)
  ([b, c], 0/1)
  ([c, a], 1/1)
  ([c, b], 0/1)
  ([c, c], 0/1)
   property Termination
has value Just True
for SRS
  [[a, a], [a, a], [a, b]] ->= [ [a, a] , [a, b] , [b, c] , [c, b] ] {- Semlab 0 (Concon 1 (Input 1)) -}
  [[a, a], [a, a], [a, c]] ->= [ [a, a] , [a, b] , [b, c] , [c, c] ] {- Semlab 0 (Concon 2 (Input 1)) -}
  [[b, a], [a, a], [a, b]] ->= [ [b, a] , [a, b] , [b, c] , [c, b] ] {- Semlab 1 (Concon 1 (Input 1)) -}
  [[b, a], [a, a], [a, c]] ->= [ [b, a] , [a, b] , [b, c] , [c, c] ] {- Semlab 1 (Concon 2 (Input 1)) -}
  [[c, a], [a, a], [a, b]] ->= [ [c, a] , [a, b] , [b, c] , [c, b] ] {- Semlab 2 (Concon 1 (Input 1)) -}
  [[c, a], [a, a], [a, c]] ->= [ [c, a] , [a, b] , [b, c] , [c, c] ] {- Semlab 2 (Concon 2 (Input 1)) -}
  [[a, b], [b, a]] ->= [[a, a]] {- Semlab 0 (Concon 0 (Input 2)) -}
  [[a, c], [c, b], [b, b]] ->= [ [a, b] , [b, a] , [a, c] , [c, b] ] {- Semlab 0 (Concon 1 (Input 3)) -}
  [[a, c], [c, b], [b, c]] ->= [ [a, b] , [b, a] , [a, c] , [c, c] ] {- Semlab 0 (Concon 2 (Input 3)) -}
  [[b, c], [c, b], [b, b]] ->= [ [b, b] , [b, a] , [a, c] , [c, b] ] {- Semlab 1 (Concon 1 (Input 3)) -}
  [[b, c], [c, b], [b, c]] ->= [ [b, b] , [b, a] , [a, c] , [c, c] ] {- Semlab 1 (Concon 2 (Input 3)) -}
  [[c, c], [c, b], [b, b]] ->= [ [c, b] , [b, a] , [a, c] , [c, b] ] {- Semlab 2 (Concon 1 (Input 3)) -}
  [[c, c], [c, b], [b, c]] ->= [ [c, b] , [b, a] , [a, c] , [c, c] ] {- Semlab 2 (Concon 2 (Input 3)) -}
reason
  no strict rules

property Termination
has value Just True
for SRS
  [a, a] -> [a, b, c] {- Input 1 -}
  [b] -> [] {- Input 2 -}
  [c, b] -> [b, a, c] {- Input 3 -}
reason
  mirror
   property Termination
has value Just True
for SRS
  [a, a] -> [c, b, a] {- Mirror (Input 1) -}
  [b] -> [] {- Mirror (Input 2) -}
  [b, c] -> [c, a, b] {- Mirror (Input 3) -}
reason
  right-barren
    Barren   { method_ = RFC, bound = 3, at_bound = Merge, rule_height = [(0, 2), (1, 3), (2, 2)], epsilons = [((0, 0, 1), (0, 0, 0)), ((0, 0, 1), (1, 2, 0)), ((0, 0, 1), (0, 0, 2)), ((1, 0, 1), (0, 0, 0)), ((1, 0, 1), (1, 2, 0)), ((1, 0, 1), (1, 0, 2)), ((2, 0, 1), (0, 0, 0)), ((2, 0, 1), (1, 0, 0)), ((2, 0, 1), (1, 2, 0)), ((2, 0, 1), (2, 2, 0)), ((2, 0, 1), (2, 0, 2)), ((0, 2, 1), (0, 0, 0)), ((1, 2, 1), (1, 0, 0)), ((2, 2, 1), (2, 0, 0)), ((0, 0, 2), (0, 0, 0)), ((1, 0, 2), (0, 0, 0)), ((2, 0, 2), (0, 0, 0)), ((2, 0, 2), (1, 0, 0)), ((0, 2, 2), (0, 2, 0)), ((0, 2, 2), (0, 2, 3)), ((1, 2, 2), (0, 0, 0)), ((1, 2, 2), (1, 2, 0)), ((1, 2, 2), (2, 2, 0)), ((1, 2, 2), (0, 0, 1)), ((1, 2, 2), (0, 0, 2)), ((1, 2, 2), (1, 2, 3)), ((2, 2, 2), (0, 0, 0)), ((2, 2, 2), (1, 0, 0)), ((2, 2, 2), (1, 2, 0)), ((2, 2, 2), (2, 2, 0)), ((2, 2, 2), (1, 0, 1)), ((2, 2, 2), (1, 2, 1)), ((2, 2, 2), (1, 0, 2)), ((2, 2, 2), (2, 2, 3)), ((1, 0, 3), (0, 0, 3)), ((2, 0, 3), (0, 0, 0)), ((2, 0, 3), (1, 2, 0)), ((2, 0, 3), (2, 2, 0)), ((2, 0, 3), (0, 0, 1)), ((2, 0, 3), (0, 0, 2)), ((2, 0, 3), (1, 2, 2)), ((2, 0, 3), (0, 0, 3)), ((2, 0, 3), (1, 0, 3)), ((2, 0, 3), (1, 2, 3)), ((1, 2, 3), (0, 0, 0)), ((1, 2, 3), (1, 2, 0)), ((1, 2, 3), (0, 0, 1)), ((1, 2, 3), (0, 0, 2)), ((2, 2, 3), (0, 0, 0)), ((2, 2, 3), (1, 0, 0)), ((2, 2, 3), (1, 2, 0)), ((2, 2, 3), (1, 0, 1)), ((2, 2, 3), (1, 2, 1)), ((2, 2, 3), (1, 0, 2))]}
   property Termination
has value Just True
for SRS
  [b] -> [] {- Mirror (Input 2) -}
reason
  right-barren
    Barren   { method_ = RFC, bound = 2, at_bound = Merge, rule_height = [(0, -1)], epsilons = []}
   property Termination
has value Just True
for SRS
  
reason
  no strict rules

**************************************************
skeleton: (4,3)\Split[(1/3,3)\TileAllAll{2}(9/27,9)\Weight(4/16,9)\Matrix{\Natural}{2}(2/13,9)\Weight(0/13,9)[],\Mirror(3,3)\RelRFCmb{3}(1,1)\RelRFCmb{-1}(0,0)[]]
**************************************************
let {slowdown = 1.0}
in let {verb ?= False;trac ?= False;cpf ?= False;slowdown = 3;uncertified = \ p -> Apply (Guard_Not cpf) p;uncertified_T = \ t -> And_Then (Guard_Not cpf) t;do = \ x -> x;dont = \ x -> Fail;done = Worker No_Strict_Rules;when_small = \ m -> And_Then (Worker (SizeAtmost 10000)) m;solver = Stats (Kissatapi [ Option "quiet" 1, Configuration "sat"]);mo = Pre (Or_Else Count GLPK);weight = Worker (Weight {modus = mo});wop = Or_Else weight Pass;weighted = \ m -> And_Then m wop;mirror = Worker Mirror;mirrored = \ m -> And_Then mirror m;cleaner = Or_Else (Worker (Cleaner {tracing = trac})) Pass;tiling = \ m w u -> weighted (Worker (Tiling {method = m,width = w,state_type = Best,map_type = Enum,unlabel = u,max_num_tiles = Just 10000,max_num_rules = Just 100000,cpf = cpf}));kbo = \ b -> weighted (Worker (KBO {direction = LR,bits = b,encoding = Ersatz_Bits,solver = solver}));okb = \ b -> weighted (Worker (KBO {direction = RL,bits = b,encoding = Ersatz_Bits,solver = solver}));kbom = \ b -> First_Of [ kbo b, okb b];qpi = \ dim bits -> weighted (Worker (QPI {tracing = trac,dim = dim,bits = bits,solver = solver,encoding = Ersatz_Binary}));matrix = \ mon dom dim bits enc -> weighted (Worker (Matrix {monotone = mon,domain = dom,dim = dim,bits = bits,shape = Cornered,encoding = enc,tracing = trac,verbose = verb,solver = solver}));ctx = Worker (Context {when = When_Empty,side = Right,close = Empty});simple = Seq [ weight, Timeout slowdown (when_small (kbom 1))];unlab = Worker (Unlabel {accept_null_strict = True,produce_null_strict = False});tileun = \ w -> And_Then (tiling All w Never) (Or_Else unlab (And_Then simple (Or_Else unlab (And_Then simple (Or_Else unlab (And_Then simple unlab))))));tileuns = Seq ([2..2] >>= (\ w -> [ tileun w]));preprocess = While_Fail_T (Worker No_Strict_Rules_T) tileuns;bin = Ersatz_Binary;una = Ersatz_Unary;tp = Worker (Transport {max_derivation_length = Just 2,max_tiers = Just 33,direction = Forward_Backward,tracing = False,cpf = cpf});nohs = let {noh = \ c w m -> Worker (Simple (Config {closure = c,max_closure_width = w,max_seen_size = m,max_inner_children = Just 8,max_outer_children = Just 2,intermediates = All,priority = Linear [ ( -7, Width_lhs), ( -1, Width_rhs), ( 7, Log2 Steps)],start_strict_only = True,print_sizes_finally = True}));f1w = 15;f1s = 1000000;nohs = [ tp, Seq [ noh Forward (Just f1w) (Just f1s), noh Forward Nothing Nothing], Seq [ noh Backward (Just f1w) (Just f1s), noh Backward Nothing Nothing]]}in nohs;relative = let {matrices = First_Of_Pool (Config {workers = 2,advice = Nothing,tracing = trac}) let {s = slowdown;matrix_strict_timeout = \ dom dim bits enc -> TimeoutSlowdown s dim (matrix Strict dom dim bits enc);kbobits = 1}in [ ] <> ([ Timeout s (kbo kbobits), Timeout s (okb kbobits)] <> ([ matrix_strict_timeout ArcticBZ 3 4 una, matrix_strict_timeout Natural 3 3 bin, matrix_strict_timeout ArcticBZ 4 4 una, matrix_strict_timeout Natural 4 3 bin] <> ([5..10] >>= (\ dim -> [ matrix_strict_timeout Arctic dim 3 una, matrix_strict_timeout Natural dim 2 bin]))));barr = \ h -> Worker (Matchbound {method = ROC,implementation = Approximate {at_bound = Merge},max_height = Just h});remove = Seq [ weight, First_Of [ when_small (weighted matrices), tileuns]];yeah = While_Fail done remove}in First_Of ([ ] <> ([ Apply ctx yeah, Apply preprocess (Apply ctx yeah)] <> (nohs <> [ do (Apply (tiling All 2 Never) yeah), dont (Apply (tiling All 3 Never) yeah), dont (Apply (tiling All 4 Never) yeah)])));standard = let {matrices = First_Of_Pool (Config {workers = 2,advice = Nothing,tracing = trac}) let {s = slowdown;matrix_weak_timeout = \ dom dim bits enc -> TimeoutSlowdown s dim (matrix Weak dom dim bits enc);kbobits = 1}in [ ] <> ([ Timeout s (kbo kbobits), Timeout s (okb kbobits)] <> ([ TimeoutSlowdown s 3 (qpi 3 3), matrix_weak_timeout ArcticBZ 3 4 una, matrix_weak_timeout Natural 3 3 bin, TimeoutSlowdown s 4 (qpi 4 3), matrix_weak_timeout Natural 4 3 bin] <> ([5..10] >>= (\ dim -> [ do (TimeoutSlowdown s dim (qpi dim 4)), do (matrix_weak_timeout Arctic dim 3 una), do (matrix_weak_timeout Natural dim 2 bin)]))));remove = Seq [ weight, when_small (weighted matrices)];dp = Apply ctx (Apply (Worker (DP {tracing = False})) (Apply wop (Branch (Worker (EDG {usable = True,tcap_inverse = True})) remove)));mbe = \ ms -> uncertified_T (Worker (Matchbound {method = RFC,implementation = Exact,max_size = ms}));mbeh = Apply (mbe (Just 100000)) done;mba = \ h -> uncertified_T (Worker (Matchbound {method = RFC,implementation = Approximate {at_bound = Merge},max_height = Just h}));mb_trans = Worker (Matchbound {method = RFC,max_size = Just 10000,max_height = Just 5});mb_proof = Apply mb_trans done;when_onerule = \ m -> Apply (Worker (Assert (Atmost 1 Rules))) m;dropped = \ y -> Or_Else (when_onerule (Dropped_Par (First_Of (nohs <> [ y])))) y;simple_yeah = Seq [ done, uncertified (Worker KKST01), uncertified (dropped (First_Of [ mb_proof, Apply (Worker Mirror) mb_proof]))];yeah = Seq [ done, simple_yeah, First_Of [ dp, Apply (Worker Mirror) dp]];preprocess = While_Fail_T (Worker No_Strict_Rules_T) (First_Of [ tileuns, Seq ([2..6] >>= (\ h -> [ mba h, And_Then (Worker Mirror) (mba h)]))])}in Apply wop (Or_Else done (First_Of ([ Apply preprocess yeah, yeah] <> (nohs <> [ do (Apply (tiling All 2 Never) yeah), dont (Apply (tiling All 3 Never) yeah), dont (Apply (tiling All 4 Never) yeah)]))));strictify = Worker (Strictify {});dropstrict = Worker (Dropstrict {})}
  in Apply cleaner (Or_Else done (Apply wop (Or_Else done (Or_Else (Apply (When_True (Apply dropstrict (Apply strictify standard))) (Apply strictify standard)) relative))))**************************************************
statistics on proof search (nodes types that (together) took more than 1.000000000000)
**************************************************

**************************************************
S          Info { what = "KBO\n { direction = RL\n , bits = 1\n , solver = Stats (Kissatapi
S          [Option \"quiet\" 1, Configuration \"sat\"])\n , compress = True\n , tracing
S          = False\n , verbose = False}" , input_size = Size { num_rules = 20 , num_strict_rules
S          = 20 , num_top_rules = 0 , num_weak_rules = 0 , alphabet_size = 9 , total_length
S          = 120} , self = 64 , parent = Nothing , duration = 0.116373570000 , status
S          = Success , start = 2025-09-03 11:44:11.36629053 UTC , finish = 2025-09-03
S          11:44:11.4826641 UTC , thread_cap_info = ("ThreadId 64", 2, False)}
S          
| F        Info { what = "Matchbound\n { method = RFC\n , implementation = Exact\n
| F        , cpf_state_encoding = Encoding { base = 10, order = MSB_First}\n , max_size
| F        = Just 10000\n , max_height = Just 5\n , initial = Paths\n , verbose =
| F        False\n , tracing = False\n , draw = False\n , cpf = False}" , input_size
| F        = Size { num_rules = 20 , num_strict_rules = 20 , num_top_rules = 0 , num_weak_rules
| F        = 0 , alphabet_size = 9 , total_length = 120} , self = 69 , parent = Nothing
| F        , duration = 0.130206512000 , status = Fail , start = 2025-09-03 11:44:11.401722608
| F        UTC , finish = 2025-09-03 11:44:11.53192912 UTC , thread_cap_info = ("ThreadId
| F        69", 2, False)}
| F        
| | F      Info { what = "QPI\n { dim = 3\n , bits = 3\n , solver = Stats (Kissatapi
| | F      [Option \"quiet\" 1, Configuration \"sat\"])\n , encoding = Ersatz_Binary\n
| | F      , tracing = False\n , verbose = False}" , input_size = Size { num_rules
| | F      = 11 , num_strict_rules = 3 , num_top_rules = 3 , num_weak_rules = 8 ,
| | F      alphabet_size = 5 , total_length = 39} , self = 95 , parent = Nothing ,
| | F      duration = 0.247930518000 , status = Fail , start = 2025-09-03 11:44:11.460012224
| | F      UTC , finish = 2025-09-03 11:44:11.707942742 UTC , thread_cap_info = ("ThreadId
| | F      100", 3, False)}
| | F      
| | | S    Info { what = "QPI\n { dim = 3\n , bits = 3\n , solver = Stats (Kissatapi
| | | S    [Option \"quiet\" 1, Configuration \"sat\"])\n , encoding = Ersatz_Binary\n
| | | S    , tracing = False\n , verbose = False}" , input_size = Size { num_rules
| | | S    = 12 , num_strict_rules = 4 , num_top_rules = 4 , num_weak_rules = 8 ,
| | | S    alphabet_size = 5 , total_length = 43} , self = 94 , parent = Nothing ,
| | | S    duration = 0.223478206000 , status = Success , start = 2025-09-03 11:44:11.476474248
| | | S    UTC , finish = 2025-09-03 11:44:11.699952454 UTC , thread_cap_info = ("ThreadId
| | | S    102", 3, False)}
| | | S    
S | | |    
  F | |    
F   | |    Info { what = "KBO\n { direction = RL\n , bits = 1\n , solver = Stats (Kissatapi
F   | |    [Option \"quiet\" 1, Configuration \"sat\"])\n , compress = True\n , tracing
F   | |    = False\n , verbose = False}" , input_size = Size { num_rules = 36 , num_strict_rules
F   | |    = 16 , num_top_rules = 16 , num_weak_rules = 20 , alphabet_size = 12 ,
F   | |    total_length = 207} , self = 103 , parent = Nothing , duration = 0.206005706000
F   | |    , status = Fail , start = 2025-09-03 11:44:11.559634977 UTC , finish =
F   | |    2025-09-03 11:44:11.765640683 UTC , thread_cap_info = ("ThreadId 122",
F   | |    2, False)}
F   | |    
| E | |    Info { what = "Matrix\n { monotone = Weak\n , domain = ArcticBZ\n , method
| E | |    = Direct\n , shape = Cornered\n , bits = 4\n , compress = True\n , remove
| E | |    = Any\n , constraint = And []\n , minimize = Nothing\n , encoding = Ersatz_Unary\n
| E | |    , dim = 3\n , solver = Stats (Kissatapi [Option \"quiet\" 1, Configuration
| E | |    \"sat\"])\n , verbose = False\n , tracing = False\n , briefing = False\n
| E | |    , log_level = 1\n , draw = False}" , input_size = Size { num_rules = 12
| E | |    , num_strict_rules = 4 , num_top_rules = 4 , num_weak_rules = 8 , alphabet_size
| E | |    = 5 , total_length = 43} , self = 97 , parent = Nothing , duration = 0.157412621000
| E | |    , status = Except "AsyncCancelled" , start = 2025-09-03 11:44:11.582201545
| E | |    UTC , finish = 2025-09-03 11:44:11.739614166 UTC , thread_cap_info = ("ThreadId
| E | |    125", 3, False)}
| E | |    
| | | | E  Info { what = "KBO\n { direction = LR\n , bits = 1\n , solver = Stats (Kissatapi
| | | | E  [Option \"quiet\" 1, Configuration \"sat\"])\n , compress = True\n , tracing
| | | | E  = False\n , verbose = False}" , input_size = Size { num_rules = 16 , num_strict_rules
| | | | E  = 16 , num_top_rules = 0 , num_weak_rules = 0 , alphabet_size = 9 , total_length
| | | | E  = 108} , self = 111 , parent = Nothing , duration = 0.107055027000 , status
| | | | E  = Except "AsyncCancelled" , start = 2025-09-03 11:44:11.699612203 UTC ,
| | | | E  finish = 2025-09-03 11:44:11.80666723 UTC , thread_cap_info = ("ThreadId
| | | | E  144", 1, False)}
| | | | E  
| | | S |  
| | F   |  
| E     |  
F       |  
        E  
