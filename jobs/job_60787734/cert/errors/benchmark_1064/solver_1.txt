last 3293 length 14872
CNF 3293 vars 14872 clauses
last 3813 length 19293
CNF 3813 vars 19293 clauses
last 591 length 2353
CNF 591 vars 2353 clauses
last 580 length 2335
CNF 580 vars 2335 clauses
last 637 length 2551
last 628 length 2584
Matrix {monotone = Weak, domain = Arctic, method = QPI, shape = Full, bits = 3, compress = True, remove = Any, constraint = And [], minimize = Nothing, encoding = Ersatz_Binary, dim = 3, solver = Stats (Kissatapi [Option "quiet" 1,Configuration "sat"]), verbose = False, tracing = False, briefing = False, log_level = 1, draw = False} vars: 2546, clauses: 9084
CNF 637 vars 2551 clauses
CNF 628 vars 2584 clauses
Matrix {monotone = Weak, domain = ArcticBZ, method = Direct, shape = Cornered, bits = 4, compress = True, remove = Any, constraint = And [], minimize = Nothing, encoding = Ersatz_Unary, dim = 3, solver = Stats (Kissatapi [Option "quiet" 1,Configuration "sat"]), verbose = False, tracing = False, briefing = False, log_level = 1, draw = False} vars: 8344, clauses: 34683
last 2546 length 9084
last 8344 length 34683
CNF 2546 vars 9084 clauses
Matrix {monotone = Weak, domain = Arctic, method = QPI, shape = Full, bits = 3, compress = True, remove = Any, constraint = And [], minimize = Nothing, encoding = Ersatz_Binary, dim = 3, solver = Stats (Kissatapi [Option "quiet" 1,Configuration "sat"]), verbose = False, tracing = False, briefing = False, log_level = 1, draw = False} vars: 2639, clauses: 9477
last 2639 length 9477
CNF 2639 vars 9477 clauses
CNF 8344 vars 34683 clauses
Matrix {monotone = Weak, domain = Arctic, method = QPI, shape = Full, bits = 3, compress = True, remove = Any, constraint = And [], minimize = Nothing, encoding = Ersatz_Binary, dim = 3, solver = Stats (Kissatapi [Option "quiet" 1,Configuration "sat"]), verbose = False, tracing = False, briefing = False, log_level = 1, draw = False} vars: 2546, clauses: 9084, status: Unsatisfied, time: 0.074297982s
Matrix {monotone = Weak, domain = Arctic, method = QPI, shape = Full, bits = 3, compress = True, remove = Any, constraint = And [], minimize = Nothing, encoding = Ersatz_Binary, dim = 3, solver = Stats (Kissatapi [Option "quiet" 1,Configuration "sat"]), verbose = False, tracing = False, briefing = False, log_level = 1, draw = False} vars: 2639, clauses: 9477, status: Unsatisfied, time: 0.072301135s
Matrix {monotone = Weak, domain = ArcticBZ, method = Direct, shape = Cornered, bits = 4, compress = True, remove = Any, constraint = And [], minimize = Nothing, encoding = Ersatz_Unary, dim = 3, solver = Stats (Kissatapi [Option "quiet" 1,Configuration "sat"]), verbose = False, tracing = False, briefing = False, log_level = 1, draw = False} vars: 8344, clauses: 34683, status: Satisfied, time: 0.17356897s
Matrix {monotone = Weak, domain = ArcticBZ, method = Direct, shape = Cornered, bits = 4, compress = True, remove = Any, constraint = And [], minimize = Nothing, encoding = Ersatz_Unary, dim = 3, solver = Stats (Kissatapi [Option "quiet" 1,Configuration "sat"]), verbose = False, tracing = False, briefing = False, log_level = 1, draw = False} vars: 8636, clauses: 35933
Matrix {monotone = Weak, domain = Natural, method = Direct, shape = Cornered, bits = 3, compress = True, remove = Any, constraint = And [], minimize = Nothing, encoding = Ersatz_Binary, dim = 3, solver = Stats (Kissatapi [Option "quiet" 1,Configuration "sat"]), verbose = False, tracing = False, briefing = False, log_level = 1, draw = False} vars: 5315, clauses: 21052
Matrix {monotone = Weak, domain = Natural, method = Direct, shape = Cornered, bits = 3, compress = True, remove = Any, constraint = And [], minimize = Nothing, encoding = Ersatz_Binary, dim = 3, solver = Stats (Kissatapi [Option "quiet" 1,Configuration "sat"]), verbose = False, tracing = False, briefing = False, log_level = 1, draw = False} vars: 5485, clauses: 21796
last 8636 length 35933
last 5485 length 21796
**************************************************
summary
CNF 5485 vars 21796 clauses
CNF 8636 vars 35933 clauses
**************************************************
SRS with 4 rules on 3 letters       context
SRS with 10 rules on 3 letters       mirror
SRS with 10 rules on 3 letters       DP
SRS with 5 strict rules and 10 weak rules on 6 letters       weights
SRS with 2 strict rules and 10 weak rules on 4 letters       EDG
SRS with 2 strict rules and 10 weak rules on 4 letters       Matrix   { monotone = Weak, domain = ArcticBZ, method = Direct, shape = Cornered, bits = 4, compress = True, remove = Any, constraint = And [], minimize = Nothing, encoding = Ersatz_Unary, dim = 3, solver = Stats (Kissatapi [Option "quiet" 1, Configuration "sat"]), verbose = False, tracing = False, briefing = False, log_level = 1, draw = False}
SRS with 0 strict rules and 10 weak rules on 3 letters       EDG

**************************************************
proof
**************************************************
property Termination
has value Just True
for SRS
  [a] -> [] {- Input 0 -}
  [a, b] -> [b, b, a, a, c] {- Input 1 -}
  [b] -> [] {- Input 2 -}
  [c, c] -> [] {- Input 3 -}
reason
  context
   property Termination
has value Just True
for SRS
  [a, a] -> [a] {- Input 0 -}
  [b, a] -> [b] {- Input 0 -}
  [c, a] -> [c] {- Input 0 -}
  [a, b] -> [b, b, a, a, c] {- Input 1 -}
  [a, b] -> [a] {- Input 2 -}
  [b, b] -> [b] {- Input 2 -}
  [c, b] -> [c] {- Input 2 -}
  [a, c, c] -> [a] {- Input 3 -}
  [b, c, c] -> [b] {- Input 3 -}
  [c, c, c] -> [c] {- Input 3 -}
reason
  mirror
   property Termination
has value Just True
for SRS
  [a, a] -> [a] {- Mirror (Input 0) -}
  [a, b] -> [b] {- Mirror (Input 0) -}
  [a, c] -> [c] {- Mirror (Input 0) -}
  [b, a] -> [c, a, a, b, b] {- Mirror (Input 1) -}
  [b, a] -> [a] {- Mirror (Input 2) -}
  [b, b] -> [b] {- Mirror (Input 2) -}
  [b, c] -> [c] {- Mirror (Input 2) -}
  [c, c, a] -> [a] {- Mirror (Input 3) -}
  [c, c, b] -> [b] {- Mirror (Input 3) -}
  [c, c, c] -> [c] {- Mirror (Input 3) -}
reason
  DP
   property Termination
has value Just True
for SRS
  [a, a] ->= [a] {- DP Nontop (Mirror (Input 0)) -}
  [a, b] ->= [b] {- DP Nontop (Mirror (Input 0)) -}
  [a, c] ->= [c] {- DP Nontop (Mirror (Input 0)) -}
  [b, a] ->= [c, a, a, b, b] {- DP Nontop (Mirror (Input 1)) -}
  [b, a] ->= [a] {- DP Nontop (Mirror (Input 2)) -}
  [b, b] ->= [b] {- DP Nontop (Mirror (Input 2)) -}
  [b, c] ->= [c] {- DP Nontop (Mirror (Input 2)) -}
  [c, c, a] ->= [a] {- DP Nontop (Mirror (Input 3)) -}
  [c, c, b] ->= [b] {- DP Nontop (Mirror (Input 3)) -}
  [c, c, c] ->= [c] {- DP Nontop (Mirror (Input 3)) -}
  [b#, a] |-> [a#, a, b, b] {- DP (Top 1) (Mirror (Input 1)) -}
  [b#, a] |-> [a#, b, b] {- DP (Top 2) (Mirror (Input 1)) -}
  [b#, a] |-> [b#] {- DP (Top 4) (Mirror (Input 1)) -}
  [b#, a] |-> [b#, b] {- DP (Top 3) (Mirror (Input 1)) -}
  [b#, a] |-> [c#, a, a, b, b] {- DP (Top 0) (Mirror (Input 1)) -}
reason
  (a, 0/1)
  (b, 0/1)
  (c, 0/1)
  (a#, 0/1)
  (b#, 1/1)
  (c#, 0/1)
   property Termination
has value Just True
for SRS
  [a, a] ->= [a] {- DP Nontop (Mirror (Input 0)) -}
  [a, b] ->= [b] {- DP Nontop (Mirror (Input 0)) -}
  [a, c] ->= [c] {- DP Nontop (Mirror (Input 0)) -}
  [b, a] ->= [c, a, a, b, b] {- DP Nontop (Mirror (Input 1)) -}
  [b, a] ->= [a] {- DP Nontop (Mirror (Input 2)) -}
  [b, b] ->= [b] {- DP Nontop (Mirror (Input 2)) -}
  [b, c] ->= [c] {- DP Nontop (Mirror (Input 2)) -}
  [c, c, a] ->= [a] {- DP Nontop (Mirror (Input 3)) -}
  [c, c, b] ->= [b] {- DP Nontop (Mirror (Input 3)) -}
  [c, c, c] ->= [c] {- DP Nontop (Mirror (Input 3)) -}
  [b#, a] |-> [b#] {- DP (Top 4) (Mirror (Input 1)) -}
  [b#, a] |-> [b#, b] {- DP (Top 3) (Mirror (Input 1)) -}
reason
  EDG
   property Termination
has value Just True
for SRS
  [b#, a] |-> [b#] {- DP (Top 4) (Mirror (Input 1)) -}
  [b#, a] |-> [b#, b] {- DP (Top 3) (Mirror (Input 1)) -}
  [a, a] ->= [a] {- DP Nontop (Mirror (Input 0)) -}
  [a, b] ->= [b] {- DP Nontop (Mirror (Input 0)) -}
  [a, c] ->= [c] {- DP Nontop (Mirror (Input 0)) -}
  [b, a] ->= [c, a, a, b, b] {- DP Nontop (Mirror (Input 1)) -}
  [b, a] ->= [a] {- DP Nontop (Mirror (Input 2)) -}
  [b, b] ->= [b] {- DP Nontop (Mirror (Input 2)) -}
  [b, c] ->= [c] {- DP Nontop (Mirror (Input 2)) -}
  [c, c, a] ->= [a] {- DP Nontop (Mirror (Input 3)) -}
  [c, c, b] ->= [b] {- DP Nontop (Mirror (Input 3)) -}
  [c, c, c] ->= [c] {- DP Nontop (Mirror (Input 3)) -}
reason
  ( a
  , Wk  / 1A  1A 1A  \
        | -1A 0A -2A |
        \ -   -  0A  / )
  ( b
  , Wk  / 0A 0A -   \
        | 0A 0A -2A |
        \ -  -  0A  / )
  ( c
  , Wk  / -   1A 1A \
        | -1A -  -  |
        \ -   -  0A / )
  ( b#
  , Wk  / 1A -1A -  \
        | -  -   -  |
        \ -  -   0A / )
   property Termination
has value Just True
for SRS
  [a, a] ->= [a] {- DP Nontop (Mirror (Input 0)) -}
  [a, b] ->= [b] {- DP Nontop (Mirror (Input 0)) -}
  [a, c] ->= [c] {- DP Nontop (Mirror (Input 0)) -}
  [b, a] ->= [c, a, a, b, b] {- DP Nontop (Mirror (Input 1)) -}
  [b, a] ->= [a] {- DP Nontop (Mirror (Input 2)) -}
  [b, b] ->= [b] {- DP Nontop (Mirror (Input 2)) -}
  [b, c] ->= [c] {- DP Nontop (Mirror (Input 2)) -}
  [c, c, a] ->= [a] {- DP Nontop (Mirror (Input 3)) -}
  [c, c, b] ->= [b] {- DP Nontop (Mirror (Input 3)) -}
  [c, c, c] ->= [c] {- DP Nontop (Mirror (Input 3)) -}
reason
  EDG

**************************************************
skeleton: (4,3)\Context\Mirror(10,3)\Deepee(5/10,6)\Weight\EDG(2/10,4)\Matrix{\ArcticBZ}{3}(0/10,3)\EDG[]
**************************************************
let {cpf = True;slowdown = 1.0}
in let {verb ?= False;trac ?= False;cpf ?= False;slowdown = 3;uncertified = \ p -> Apply (Guard_Not cpf) p;uncertified_T = \ t -> And_Then (Guard_Not cpf) t;do = \ x -> x;dont = \ x -> Fail;done = Worker No_Strict_Rules;when_small = \ m -> And_Then (Worker (SizeAtmost 10000)) m;solver = Stats (Kissatapi [ Option "quiet" 1, Configuration "sat"]);mo = Pre (Or_Else Count GLPK);weight = Worker (Weight {modus = mo});wop = Or_Else weight Pass;weighted = \ m -> And_Then m wop;mirror = Worker Mirror;mirrored = \ m -> And_Then mirror m;cleaner = Or_Else (Worker (Cleaner {tracing = trac})) Pass;tiling = \ m w u -> weighted (Worker (Tiling {method = m,width = w,state_type = Best,map_type = Enum,unlabel = u,max_num_tiles = Just 10000,max_num_rules = Just 100000,cpf = cpf}));kbo = \ b -> weighted (Worker (KBO {direction = LR,bits = b,encoding = Ersatz_Bits,solver = solver}));okb = \ b -> weighted (Worker (KBO {direction = RL,bits = b,encoding = Ersatz_Bits,solver = solver}));kbom = \ b -> First_Of [ kbo b, okb b];qpi = \ dim bits -> weighted (Worker (QPI {tracing = trac,dim = dim,bits = bits,solver = solver,encoding = Ersatz_Binary}));matrix = \ mon dom dim bits enc -> weighted (Worker (Matrix {monotone = mon,domain = dom,dim = dim,bits = bits,shape = Cornered,encoding = enc,tracing = trac,verbose = verb,solver = solver}));ctx = Worker (Context {when = When_Empty,side = Right,close = Empty});simple = Seq [ weight, Timeout slowdown (when_small (kbom 1))];unlab = Worker (Unlabel {accept_null_strict = True,produce_null_strict = False});tileun = \ w -> And_Then (tiling All w Never) (Or_Else unlab (And_Then simple (Or_Else unlab (And_Then simple (Or_Else unlab (And_Then simple unlab))))));tileuns = Seq ([2..2] >>= (\ w -> [ tileun w]));preprocess = While_Fail_T (Worker No_Strict_Rules_T) tileuns;bin = Ersatz_Binary;una = Ersatz_Unary;tp = Worker (Transport {max_derivation_length = Just 2,max_tiers = Just 33,direction = Forward_Backward,tracing = False,cpf = cpf});nohs = let {noh = \ c w m -> Worker (Simple (Config {closure = c,max_closure_width = w,max_seen_size = m,max_inner_children = Just 8,max_outer_children = Just 2,intermediates = All,priority = Linear [ ( -7, Width_lhs), ( -1, Width_rhs), ( 7, Log2 Steps)],start_strict_only = True,print_sizes_finally = True}));f1w = 15;f1s = 1000000;nohs = [ tp, Seq [ noh Forward (Just f1w) (Just f1s), noh Forward Nothing Nothing], Seq [ noh Backward (Just f1w) (Just f1s), noh Backward Nothing Nothing]]}in nohs;relative = let {matrices = First_Of_Pool (Config {workers = 2,advice = Nothing,tracing = trac}) let {s = slowdown;matrix_strict_timeout = \ dom dim bits enc -> TimeoutSlowdown s dim (matrix Strict dom dim bits enc);kbobits = 1}in [ ] <> ([ Timeout s (kbo kbobits), Timeout s (okb kbobits)] <> ([ matrix_strict_timeout ArcticBZ 3 4 una, matrix_strict_timeout Natural 3 3 bin, matrix_strict_timeout ArcticBZ 4 4 una, matrix_strict_timeout Natural 4 3 bin] <> ([5..10] >>= (\ dim -> [ matrix_strict_timeout Arctic dim 3 una, matrix_strict_timeout Natural dim 2 bin]))));barr = \ h -> Worker (Matchbound {method = ROC,implementation = Approximate {at_bound = Merge},max_height = Just h});remove = Seq [ weight, First_Of [ when_small (weighted matrices), tileuns]];yeah = While_Fail done remove}in First_Of ([ ] <> ([ Apply ctx yeah, Apply preprocess (Apply ctx yeah)] <> (nohs <> [ do (Apply (tiling All 2 Never) yeah), dont (Apply (tiling All 3 Never) yeah), dont (Apply (tiling All 4 Never) yeah)])));standard = let {matrices = First_Of_Pool (Config {workers = 2,advice = Nothing,tracing = trac}) let {s = slowdown;matrix_weak_timeout = \ dom dim bits enc -> TimeoutSlowdown s dim (matrix Weak dom dim bits enc);kbobits = 1}in [ ] <> ([ Timeout s (kbo kbobits), Timeout s (okb kbobits)] <> ([ TimeoutSlowdown s 3 (qpi 3 3), matrix_weak_timeout ArcticBZ 3 4 una, matrix_weak_timeout Natural 3 3 bin, TimeoutSlowdown s 4 (qpi 4 3), matrix_weak_timeout Natural 4 3 bin] <> ([5..10] >>= (\ dim -> [ do (TimeoutSlowdown s dim (qpi dim 4)), do (matrix_weak_timeout Arctic dim 3 una), do (matrix_weak_timeout Natural dim 2 bin)]))));remove = Seq [ weight, when_small (weighted matrices)];dp = Apply ctx (Apply (Worker (DP {tracing = False})) (Apply wop (Branch (Worker (EDG {usable = True,tcap_inverse = True})) remove)));mbe = \ ms -> uncertified_T (Worker (Matchbound {method = RFC,implementation = Exact,max_size = ms}));mbeh = Apply (mbe (Just 100000)) done;mba = \ h -> uncertified_T (Worker (Matchbound {method = RFC,implementation = Approximate {at_bound = Merge},max_height = Just h}));mb_trans = Worker (Matchbound {method = RFC,max_size = Just 10000,max_height = Just 5});mb_proof = Apply mb_trans done;when_onerule = \ m -> Apply (Worker (Assert (Atmost 1 Rules))) m;dropped = \ y -> Or_Else (when_onerule (Dropped_Par (First_Of (nohs <> [ y])))) y;simple_yeah = Seq [ done, uncertified (Worker KKST01), uncertified (dropped (First_Of [ mb_proof, Apply (Worker Mirror) mb_proof]))];yeah = Seq [ done, simple_yeah, First_Of [ dp, Apply (Worker Mirror) dp]];preprocess = While_Fail_T (Worker No_Strict_Rules_T) (First_Of [ tileuns, Seq ([2..6] >>= (\ h -> [ mba h, And_Then (Worker Mirror) (mba h)]))])}in Apply wop (Or_Else done (First_Of ([ Apply preprocess yeah, yeah] <> (nohs <> [ do (Apply (tiling All 2 Never) yeah), dont (Apply (tiling All 3 Never) yeah), dont (Apply (tiling All 4 Never) yeah)]))));strictify = Worker (Strictify {});dropstrict = Worker (Dropstrict {})}
  in Apply cleaner (Or_Else done (Apply wop (Or_Else done (Or_Else (Apply (When_True (Apply dropstrict (Apply strictify standard))) (Apply strictify standard)) relative))))**************************************************
statistics on proof search (nodes types that (together) took more than 1.000000000000)
**************************************************

**************************************************
F        Info { what = "KBO\n { direction = RL\n , bits = 1\n , solver = Stats (Kissatapi
F        [Option \"quiet\" 1, Configuration \"sat\"])\n , compress = True\n , tracing
F        = False\n , verbose = False}" , input_size = Size { num_rules = 36 , num_strict_rules
F        = 36 , num_top_rules = 0 , num_weak_rules = 0 , alphabet_size = 9 , total_length
F        = 171} , self = 54 , parent = Nothing , duration = 0.113244091000 , status
F        = Fail , start = 2025-09-03 10:53:57.996931266 UTC , finish = 2025-09-03
F        10:53:58.110175357 UTC , thread_cap_info = ("ThreadId 53", 1, False)}
F        
F        
F        Info { what = "KBO\n { direction = LR\n , bits = 1\n , solver = Stats (Kissatapi
F        [Option \"quiet\" 1, Configuration \"sat\"])\n , compress = True\n , tracing
F        = False\n , verbose = False}" , input_size = Size { num_rules = 12 , num_strict_rules
F        = 2 , num_top_rules = 2 , num_weak_rules = 10 , alphabet_size = 4 , total_length
F        = 46} , self = 60 , parent = Nothing , duration = 0.183575400000 , status
F        = Fail , start = 2025-09-03 10:53:58.120309853 UTC , finish = 2025-09-03
F        10:53:58.303885253 UTC , thread_cap_info = ("ThreadId 103", 0, False)}
F        
| F      Info { what = "KBO\n { direction = RL\n , bits = 1\n , solver = Stats (Kissatapi
| F      [Option \"quiet\" 1, Configuration \"sat\"])\n , compress = True\n , tracing
| F      = False\n , verbose = False}" , input_size = Size { num_rules = 12 , num_strict_rules
| F      = 2 , num_top_rules = 2 , num_weak_rules = 10 , alphabet_size = 4 , total_length
| F      = 46} , self = 59 , parent = Nothing , duration = 0.155114113000 , status
| F      = Fail , start = 2025-09-03 10:53:58.120313932 UTC , finish = 2025-09-03
| F      10:53:58.275428045 UTC , thread_cap_info = ("ThreadId 104", 0, False)}
| F      
| | F    Info { what = "QPI\n { dim = 3\n , bits = 3\n , solver = Stats (Kissatapi
| | F    [Option \"quiet\" 1, Configuration \"sat\"])\n , encoding = Ersatz_Binary\n
| | F    , tracing = False\n , verbose = False}" , input_size = Size { num_rules
| | F    = 12 , num_strict_rules = 2 , num_top_rules = 2 , num_weak_rules = 10 ,
| | F    alphabet_size = 4 , total_length = 44} , self = 61 , parent = Nothing ,
| | F    duration = 0.336226558000 , status = Fail , start = 2025-09-03 10:53:58.127608267
| | F    UTC , finish = 2025-09-03 10:53:58.463834825 UTC , thread_cap_info = ("ThreadId
| | F    105", 0, False)}
| | F    
| | | S  Info { what = "Matrix\n { monotone = Weak\n , domain = ArcticBZ\n , method
| | | S  = Direct\n , shape = Cornered\n , bits = 4\n , compress = True\n , remove
| | | S  = Any\n , constraint = And []\n , minimize = Nothing\n , encoding = Ersatz_Unary\n
| | | S  , dim = 3\n , solver = Stats (Kissatapi [Option \"quiet\" 1, Configuration
| | | S  \"sat\"])\n , verbose = False\n , tracing = False\n , briefing = False\n
| | | S  , log_level = 1\n , draw = False}" , input_size = Size { num_rules = 12
| | | S  , num_strict_rules = 2 , num_top_rules = 2 , num_weak_rules = 10 , alphabet_size
| | | S  = 4 , total_length = 44} , self = 63 , parent = Nothing , duration = 0.396764591000
| | | S  , status = Success , start = 2025-09-03 10:53:58.167233581 UTC , finish
| | | S  = 2025-09-03 10:53:58.563998172 UTC , thread_cap_info = ("ThreadId 108",
| | | S  0, False)}
| | | S  
| F | |  
| F | |  Info { what = "QPI\n { dim = 3\n , bits = 3\n , solver = Stats (Kissatapi
| F | |  [Option \"quiet\" 1, Configuration \"sat\"])\n , encoding = Ersatz_Binary\n
| F | |  , tracing = False\n , verbose = False}" , input_size = Size { num_rules
| F | |  = 12 , num_strict_rules = 2 , num_top_rules = 2 , num_weak_rules = 10 ,
| F | |  alphabet_size = 4 , total_length = 46} , self = 62 , parent = Nothing ,
| F | |  duration = 0.231817056000 , status = Fail , start = 2025-09-03 10:53:58.2754559
| F | |  UTC , finish = 2025-09-03 10:53:58.507272956 UTC , thread_cap_info = ("ThreadId
| F | |  111", 0, False)}
| F | |  
F | | |  
  | F |  
E |   |  Info { what = "Matrix\n { monotone = Weak\n , domain = Natural\n , method
E |   |  = Direct\n , shape = Cornered\n , bits = 3\n , compress = True\n , remove
E |   |  = Any\n , constraint = And []\n , minimize = Nothing\n , encoding = Ersatz_Binary\n
E |   |  , dim = 3\n , solver = Stats (Kissatapi [Option \"quiet\" 1, Configuration
E |   |  \"sat\"])\n , verbose = False\n , tracing = False\n , briefing = False\n
E |   |  , log_level = 1\n , draw = False}" , input_size = Size { num_rules = 12
E |   |  , num_strict_rules = 2 , num_top_rules = 2 , num_weak_rules = 10 , alphabet_size
E |   |  = 4 , total_length = 44} , self = 65 , parent = Nothing , duration = 0.100231433000
E |   |  , status = Except "AsyncCancelled" , start = 2025-09-03 10:53:58.463886654
E |   |  UTC , finish = 2025-09-03 10:53:58.564118087 UTC , thread_cap_info = ("ThreadId
E |   |  116", 0, False)}
E |   |  
| F   |  
|     S  
E        
