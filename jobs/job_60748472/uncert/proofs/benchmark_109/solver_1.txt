SAST
proof of /home/ff862203/input_Rn7uADavA8.ari
# AProVE Commit ID: 1c9e2a6453f9f0dca490585733f1cff3767d3e54 jan-christoph 20250828 unpublished


Complexity of the given CpxPTRS could be proven:

(0) CpxPTRS
(1) CpxPTRS_DerivationToRuntimeComplexityProof [UNSOUND LOWER BOUND(ID)SOUND UPPER BOUND(ID), 0 ms]
(2) CpxPTRS
(3) CpxPTRS_ToPQTRSProof [BOTH BOUNDS(ID, ID), 0 ms]
(4) PQTRS
(5) CpxPQTRS_ToADPProblemProof [BOTH BOUNDS(ID, ID), 57 ms]
(6) ADP
(7) CpxADP_SCCSplitProof [UPPER BOUND(ID), 0 ms]
(8) ADP
(9) CpxADP_UsableTermsProof [UPPER BOUND(ID), 2 ms]
(10) ADP
(11) CpxADP_UsableRulesProof [BOTH BOUNDS(ID, ID), 0 ms]
(12) ADP
(13) CpxADP_ProbabilityRemovalProof [UPPER BOUND(ID), 0 ms]
(14) CdtProblem
(15) CdtLeafRemovalProof [ComplexityIfPolyImplication, 0 ms]
(16) CdtProblem
(17) CdtToCpxRelTrsProof [BOTH BOUNDS(ID, ID), 0 ms]
(18) CpxTRS
(19) RelTrsToTrsProof [UPPER BOUND(ID), 0 ms]
(20) CpxTRS
(21) CpxTrsMatchBoundsTAProof [FINISHED, 26 ms]
(22) BOUNDS(1, n^1)


----------------------------------------

(0)
Obligation:
Probabilistic term rewrite system:
The TRS has the following probabilistic rules:

   g(b, c) -> 1 : d(f(a, a), f(a, a), f(a, a))
   g(c, b) -> 1 : d(f(a, a), f(a, a), f(a, a))
   f(x, x) -> 1 : g(x, x)
   a -> 1 / 2 : b || 1 / 2 : c

and uses the innermost rewrite strategy.

----------------------------------------

(1) CpxPTRS_DerivationToRuntimeComplexityProof (UNSOUND LOWER BOUND(ID)SOUND UPPER BOUND(ID))
The following rules have been added to R to convert the given derivational complexity problem to a runtime complexity problem:

   encArg(c) -> 1 : c
   encArg(b) -> 1 : b
   encArg(d(x_1, x_2, x_3)) -> 1 : d(encArg(x_1), encArg(x_2), encArg(x_3))
   encArg(cons_a) -> 1 : a
   encArg(cons_g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   encArg(cons_f(x_1, x_2)) -> 1 : f(encArg(x_1), encArg(x_2))
   encode_a -> 1 : a
   encode_c -> 1 : c
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   encode_b -> 1 : b
   encode_d(x_1, x_2, x_3) -> 1 : d(encArg(x_1), encArg(x_2), encArg(x_3))
   encode_f(x_1, x_2) -> 1 : f(encArg(x_1), encArg(x_2))


----------------------------------------

(2)
Obligation:
Probabilistic term rewrite system:
The TRS has the following probabilistic rules:

   encArg(c) -> 1 : c
   encArg(b) -> 1 : b
   encArg(d(x_1, x_2, x_3)) -> 1 : d(encArg(x_1), encArg(x_2), encArg(x_3))
   encArg(cons_a) -> 1 : a
   encArg(cons_g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   encArg(cons_f(x_1, x_2)) -> 1 : f(encArg(x_1), encArg(x_2))
   encode_a -> 1 : a
   encode_c -> 1 : c
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   encode_b -> 1 : b
   encode_d(x_1, x_2, x_3) -> 1 : d(encArg(x_1), encArg(x_2), encArg(x_3))
   encode_f(x_1, x_2) -> 1 : f(encArg(x_1), encArg(x_2))
   g(b, c) -> 1 : d(f(a, a), f(a, a), f(a, a))
   g(c, b) -> 1 : d(f(a, a), f(a, a), f(a, a))
   f(x, x) -> 1 : g(x, x)
   a -> 1 / 2 : b || 1 / 2 : c

and uses the innermost rewrite strategy.

----------------------------------------

(3) CpxPTRS_ToPQTRSProof (BOTH BOUNDS(ID, ID))
Transformed PTRS into PQTRS. Q is:
   encArg(c), encArg(b), encArg(d(x_1, x_2, x_3)), encArg(cons_a), encArg(cons_g(x_1, x_2)), encArg(cons_f(x_1, x_2)), encode_a, encode_c, encode_g(x_1, x_2), encode_b, encode_d(x_1, x_2, x_3), encode_f(x_1, x_2), g(b, c), g(c, b), f(x, x), a
----------------------------------------

(4)
Obligation:
Probabilistic Q term rewrite system:
The PQTRS has the following probabilistic rules:

   encArg(c) -> 1 : c
   encArg(b) -> 1 : b
   encArg(d(x_1, x_2, x_3)) -> 1 : d(encArg(x_1), encArg(x_2), encArg(x_3))
   encArg(cons_a) -> 1 : a
   encArg(cons_g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   encArg(cons_f(x_1, x_2)) -> 1 : f(encArg(x_1), encArg(x_2))
   encode_a -> 1 : a
   encode_c -> 1 : c
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   encode_b -> 1 : b
   encode_d(x_1, x_2, x_3) -> 1 : d(encArg(x_1), encArg(x_2), encArg(x_3))
   encode_f(x_1, x_2) -> 1 : f(encArg(x_1), encArg(x_2))
   g(b, c) -> 1 : d(f(a, a), f(a, a), f(a, a))
   g(c, b) -> 1 : d(f(a, a), f(a, a), f(a, a))
   f(x, x) -> 1 : g(x, x)
   a -> 1 / 2 : b || 1 / 2 : c

And Q contains the following terms:
   encArg(c), encArg(b), encArg(d(x0, x1, x2)), encArg(cons_a), encArg(cons_g(x0, x1)), encArg(cons_f(x0, x1)), encode_a, encode_c, encode_g(x0, x1), encode_b, encode_d(x0, x1, x2), encode_f(x0, x1), g(b, c), g(c, b), f(x0, x0), a

----------------------------------------

(5) CpxPQTRS_ToADPProblemProof (BOTH BOUNDS(ID, ID))


The complexity of a PQTRS (R,Q) is equivalent to the complexity of the ADP Problem A(R) (Chain-Criterion) (Leon's master's thesis).
The ADPs are:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(c) -> 1 : c
   encArg(b) -> 1 : b
   encArg(d(x_1, x_2, x_3)) -> 1 : d(encArg(x_1), encArg(x_2), encArg(x_3))
   encArg(cons_a) -> 1 : a
   encArg(cons_g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   encArg(cons_f(x_1, x_2)) -> 1 : f(encArg(x_1), encArg(x_2))
   encode_a -> 1 : a
   encode_c -> 1 : c
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   encode_b -> 1 : b
   encode_d(x_1, x_2, x_3) -> 1 : d(encArg(x_1), encArg(x_2), encArg(x_3))
   encode_f(x_1, x_2) -> 1 : f(encArg(x_1), encArg(x_2))
   g(b, c) -> 1 : d(f(a, a), f(a, a), f(a, a))
   g(c, b) -> 1 : d(f(a, a), f(a, a), f(a, a))
   f(x, x) -> 1 : g(x, x)
   a -> 1 / 2 : b || 1 / 2 : c

Rules with annotation in P:

   ENCARG(c) -> 1 : c
   ENCARG(b) -> 1 : b
   ENCARG(d(x_1, x_2, x_3)) -> 1 : d(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(cons_a) -> 1 : A
   ENCARG(cons_g(x_1, x_2)) -> 1 : G(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_f(x_1, x_2)) -> 1 : F(ENCARG(x_1), ENCARG(x_2))
   ENCODE_A -> 1 : A
   ENCODE_C -> 1 : c
   ENCODE_G(x_1, x_2) -> 1 : G(ENCARG(x_1), ENCARG(x_2))
   ENCODE_B -> 1 : b
   ENCODE_D(x_1, x_2, x_3) -> 1 : d(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCODE_F(x_1, x_2) -> 1 : F(ENCARG(x_1), ENCARG(x_2))
   G(b, c) -> 1 : d(F(A, A), F(A, A), F(A, A))
   G(c, b) -> 1 : d(F(A, A), F(A, A), F(A, A))
   F(x, x) -> 1 : G(x, x)
   A -> 1 / 2 : b || 1 / 2 : c

Rules with annotation in S:

   ENCARG(c) -> 1 : c
   ENCARG(b) -> 1 : b
   ENCARG(d(x_1, x_2, x_3)) -> 1 : d(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(cons_a) -> 1 : A
   ENCARG(cons_g(x_1, x_2)) -> 1 : G(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_f(x_1, x_2)) -> 1 : F(ENCARG(x_1), ENCARG(x_2))
   ENCODE_A -> 1 : A
   ENCODE_C -> 1 : c
   ENCODE_G(x_1, x_2) -> 1 : G(ENCARG(x_1), ENCARG(x_2))
   ENCODE_B -> 1 : b
   ENCODE_D(x_1, x_2, x_3) -> 1 : d(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCODE_F(x_1, x_2) -> 1 : F(ENCARG(x_1), ENCARG(x_2))
   G(b, c) -> 1 : d(F(A, A), F(A, A), F(A, A))
   G(c, b) -> 1 : d(F(A, A), F(A, A), F(A, A))
   F(x, x) -> 1 : G(x, x)
   A -> 1 / 2 : b || 1 / 2 : c

Rules with annotation and a known complexity:

   none

----------------------------------------

(6)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(c) -> 1 : c
   encArg(b) -> 1 : b
   encArg(d(x_1, x_2, x_3)) -> 1 : d(encArg(x_1), encArg(x_2), encArg(x_3))
   encArg(cons_a) -> 1 : a
   encArg(cons_g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   encArg(cons_f(x_1, x_2)) -> 1 : f(encArg(x_1), encArg(x_2))
   encode_a -> 1 : a
   encode_c -> 1 : c
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   encode_b -> 1 : b
   encode_d(x_1, x_2, x_3) -> 1 : d(encArg(x_1), encArg(x_2), encArg(x_3))
   encode_f(x_1, x_2) -> 1 : f(encArg(x_1), encArg(x_2))
   g(b, c) -> 1 : d(f(a, a), f(a, a), f(a, a))
   g(c, b) -> 1 : d(f(a, a), f(a, a), f(a, a))
   f(x, x) -> 1 : g(x, x)
   a -> 1 / 2 : b || 1 / 2 : c

Rules with annotation in P:

   ENCARG(c) -> 1 : c
   ENCARG(b) -> 1 : b
   ENCARG(d(x_1, x_2, x_3)) -> 1 : d(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(cons_a) -> 1 : A
   ENCARG(cons_g(x_1, x_2)) -> 1 : G(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_f(x_1, x_2)) -> 1 : F(ENCARG(x_1), ENCARG(x_2))
   ENCODE_A -> 1 : A
   ENCODE_C -> 1 : c
   ENCODE_G(x_1, x_2) -> 1 : G(ENCARG(x_1), ENCARG(x_2))
   ENCODE_B -> 1 : b
   ENCODE_D(x_1, x_2, x_3) -> 1 : d(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCODE_F(x_1, x_2) -> 1 : F(ENCARG(x_1), ENCARG(x_2))
   G(b, c) -> 1 : d(F(A, A), F(A, A), F(A, A))
   G(c, b) -> 1 : d(F(A, A), F(A, A), F(A, A))
   F(x, x) -> 1 : G(x, x)
   A -> 1 / 2 : b || 1 / 2 : c

Rules with annotation in S:

   ENCARG(c) -> 1 : c
   ENCARG(b) -> 1 : b
   ENCARG(d(x_1, x_2, x_3)) -> 1 : d(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(cons_a) -> 1 : A
   ENCARG(cons_g(x_1, x_2)) -> 1 : G(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_f(x_1, x_2)) -> 1 : F(ENCARG(x_1), ENCARG(x_2))
   ENCODE_A -> 1 : A
   ENCODE_C -> 1 : c
   ENCODE_G(x_1, x_2) -> 1 : G(ENCARG(x_1), ENCARG(x_2))
   ENCODE_B -> 1 : b
   ENCODE_D(x_1, x_2, x_3) -> 1 : d(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCODE_F(x_1, x_2) -> 1 : F(ENCARG(x_1), ENCARG(x_2))
   G(b, c) -> 1 : d(F(A, A), F(A, A), F(A, A))
   G(c, b) -> 1 : d(F(A, A), F(A, A), F(A, A))
   F(x, x) -> 1 : G(x, x)
   A -> 1 / 2 : b || 1 / 2 : c

Rules with annotation and a known complexity:

   none

----------------------------------------

(7) CpxADP_SCCSplitProof (UPPER BOUND(ID))
As part of the dependency graph processor, we can split problem in 1 new components.
----------------------------------------

(8)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(c) -> 1 : c
   encArg(b) -> 1 : b
   encArg(d(x_1, x_2, x_3)) -> 1 : d(encArg(x_1), encArg(x_2), encArg(x_3))
   encArg(cons_a) -> 1 : a
   encArg(cons_g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   encArg(cons_f(x_1, x_2)) -> 1 : f(encArg(x_1), encArg(x_2))
   encode_a -> 1 : a
   encode_c -> 1 : c
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   encode_b -> 1 : b
   encode_d(x_1, x_2, x_3) -> 1 : d(encArg(x_1), encArg(x_2), encArg(x_3))
   encode_f(x_1, x_2) -> 1 : f(encArg(x_1), encArg(x_2))
   g(b, c) -> 1 : d(f(a, a), f(a, a), f(a, a))
   g(c, b) -> 1 : d(f(a, a), f(a, a), f(a, a))
   f(x, x) -> 1 : g(x, x)
   a -> 1 / 2 : b || 1 / 2 : c

Rules with annotation in P:

   ENCODE_G(x_1, x_2) -> 1 : G(ENCARG(x_1), ENCARG(x_2))
   ENCODE_D(x_1, x_2, x_3) -> 1 : d(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCODE_F(x_1, x_2) -> 1 : F(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_g(x_1, x_2)) -> 1 : G(ENCARG(x_1), ENCARG(x_2))
   ENCARG(d(x_1, x_2, x_3)) -> 1 : d(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(cons_f(x_1, x_2)) -> 1 : F(ENCARG(x_1), ENCARG(x_2))

Rules with annotation in S:

   ENCARG(cons_g(x_1, x_2)) -> 1 : G(ENCARG(x_1), ENCARG(x_2))
   ENCARG(d(x_1, x_2, x_3)) -> 1 : d(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(cons_f(x_1, x_2)) -> 1 : F(ENCARG(x_1), ENCARG(x_2))

Rules with annotation and a known complexity:

   ENCODE_G(x_1, x_2) -> 1 : G(ENCARG(x_1), ENCARG(x_2))
   ENCODE_D(x_1, x_2, x_3) -> 1 : d(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCODE_F(x_1, x_2) -> 1 : F(ENCARG(x_1), ENCARG(x_2))


----------------------------------------

(9) CpxADP_UsableTermsProof (UPPER BOUND(ID))


The approximation of the Dependency Graph  gives us the following unusable Terms: 
   G(encArg(x_1), encArg(x_2)), F(encArg(x_1), encArg(x_2))
Hence, as part of the dependency graph processor, we can remove the annotations from these terms from every RHS of every ADP in P and S.

----------------------------------------

(10)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(c) -> 1 : c
   encArg(b) -> 1 : b
   encArg(d(x_1, x_2, x_3)) -> 1 : d(encArg(x_1), encArg(x_2), encArg(x_3))
   encArg(cons_a) -> 1 : a
   encArg(cons_g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   encArg(cons_f(x_1, x_2)) -> 1 : f(encArg(x_1), encArg(x_2))
   encode_a -> 1 : a
   encode_c -> 1 : c
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   encode_b -> 1 : b
   encode_d(x_1, x_2, x_3) -> 1 : d(encArg(x_1), encArg(x_2), encArg(x_3))
   encode_f(x_1, x_2) -> 1 : f(encArg(x_1), encArg(x_2))
   g(b, c) -> 1 : d(f(a, a), f(a, a), f(a, a))
   g(c, b) -> 1 : d(f(a, a), f(a, a), f(a, a))
   f(x, x) -> 1 : g(x, x)
   a -> 1 / 2 : b || 1 / 2 : c

Rules with annotation in P:

   ENCARG(cons_g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_f(x_1, x_2)) -> 1 : f(ENCARG(x_1), ENCARG(x_2))
   ENCODE_D(x_1, x_2, x_3) -> 1 : d(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(d(x_1, x_2, x_3)) -> 1 : d(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCODE_F(x_1, x_2) -> 1 : f(ENCARG(x_1), ENCARG(x_2))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))

Rules with annotation in S:

   ENCARG(cons_g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_f(x_1, x_2)) -> 1 : f(ENCARG(x_1), ENCARG(x_2))
   ENCARG(d(x_1, x_2, x_3)) -> 1 : d(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))

Rules with annotation and a known complexity:

   ENCODE_D(x_1, x_2, x_3) -> 1 : d(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCODE_F(x_1, x_2) -> 1 : f(ENCARG(x_1), ENCARG(x_2))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))


----------------------------------------

(11) CpxADP_UsableRulesProof (BOTH BOUNDS(ID, ID))


We use the usable rules processor.
We can deactivate the flags for all non-usable rules [FROCOS05]

Rules which have been flagged as non usable in this step:

   encArg(cons_a) -> 1 : a
   encode_b -> 1 : b
   encArg(c) -> 1 : c
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   encode_a -> 1 : a
   encode_f(x_1, x_2) -> 1 : f(encArg(x_1), encArg(x_2))
   a -> 1 / 2 : b || 1 / 2 : c
   encArg(b) -> 1 : b
   g(b, c) -> 1 : d(f(a, a), f(a, a), f(a, a))
   g(c, b) -> 1 : d(f(a, a), f(a, a), f(a, a))
   encode_d(x_1, x_2, x_3) -> 1 : d(encArg(x_1), encArg(x_2), encArg(x_3))
   encode_c -> 1 : c
   f(x, x) -> 1 : g(x, x)
   encArg(cons_f(x_1, x_2)) -> 1 : f(encArg(x_1), encArg(x_2))
   encArg(d(x_1, x_2, x_3)) -> 1 : d(encArg(x_1), encArg(x_2), encArg(x_3))
   encArg(cons_g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))

----------------------------------------

(12)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:
   none
Rules with annotation in P:

   ENCARG(cons_g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_f(x_1, x_2)) -> 1 : f(ENCARG(x_1), ENCARG(x_2))
   ENCODE_D(x_1, x_2, x_3) -> 1 : d(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(d(x_1, x_2, x_3)) -> 1 : d(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCODE_F(x_1, x_2) -> 1 : f(ENCARG(x_1), ENCARG(x_2))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))

Rules with annotation in S:

   ENCARG(cons_g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_f(x_1, x_2)) -> 1 : f(ENCARG(x_1), ENCARG(x_2))
   ENCARG(d(x_1, x_2, x_3)) -> 1 : d(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))

Rules with annotation and a known complexity:

   ENCODE_D(x_1, x_2, x_3) -> 1 : d(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCODE_F(x_1, x_2) -> 1 : f(ENCARG(x_1), ENCARG(x_2))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))


----------------------------------------

(13) CpxADP_ProbabilityRemovalProof (UPPER BOUND(ID))


We use the probability removal processor to move to dependecy tuples without probabilities.
As all rules have a trivial probability (1:r), we can transform it into a non-probabilistic DT problem

----------------------------------------

(14)
Obligation:
Complexity Dependency Tuples Problem

Rules:none
Tuples:
   ENCARG(cons_g(x_1, x_2)) -> c(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_g(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_f(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_f(x_1, x_2)) -> c3(ENCARG(x_2), ENCARG(x_1))
   ENCODE_D(x_1, x_2, x_3) -> c4(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCODE_D(x_1, x_2, x_3) -> c5(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCODE_D(x_1, x_2, x_3) -> c6(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(d(x_1, x_2, x_3)) -> c7(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(d(x_1, x_2, x_3)) -> c8(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(d(x_1, x_2, x_3)) -> c9(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCODE_F(x_1, x_2) -> c10(ENCARG(x_2), ENCARG(x_1))
   ENCODE_F(x_1, x_2) -> c11(ENCARG(x_2), ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> c12(ENCARG(x_2), ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> c13(ENCARG(x_2), ENCARG(x_1))
S tuples:
   ENCARG(cons_g(x_1, x_2)) -> c(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_g(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_f(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_f(x_1, x_2)) -> c3(ENCARG(x_2), ENCARG(x_1))
   ENCODE_D(x_1, x_2, x_3) -> c4(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCODE_D(x_1, x_2, x_3) -> c5(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCODE_D(x_1, x_2, x_3) -> c6(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(d(x_1, x_2, x_3)) -> c7(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(d(x_1, x_2, x_3)) -> c8(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(d(x_1, x_2, x_3)) -> c9(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCODE_F(x_1, x_2) -> c10(ENCARG(x_2), ENCARG(x_1))
   ENCODE_F(x_1, x_2) -> c11(ENCARG(x_2), ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> c12(ENCARG(x_2), ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> c13(ENCARG(x_2), ENCARG(x_1))
K tuples:none
Defined Rule Symbols:   encArg_1, encode_a, encode_c, encode_g_2, encode_b, encode_d_3, encode_f_2, g_2, f_2, a

Defined Pair Symbols:none

Compound Symbols:   c_2, c1_2, c2_2, c3_2, c4_3, c5_3, c6_3, c7_3, c8_3, c9_3, c10_2, c11_2, c12_2, c13_2


----------------------------------------

(15) CdtLeafRemovalProof (ComplexityIfPolyImplication)
Removed 7 leading nodes:
   ENCODE_D(x_1, x_2, x_3) -> c4(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCODE_D(x_1, x_2, x_3) -> c5(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCODE_D(x_1, x_2, x_3) -> c6(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCODE_F(x_1, x_2) -> c10(ENCARG(x_2), ENCARG(x_1))
   ENCODE_F(x_1, x_2) -> c11(ENCARG(x_2), ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> c12(ENCARG(x_2), ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> c13(ENCARG(x_2), ENCARG(x_1))

----------------------------------------

(16)
Obligation:
Complexity Dependency Tuples Problem

Rules:none
Tuples:
   ENCARG(cons_g(x_1, x_2)) -> c(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_g(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_f(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_f(x_1, x_2)) -> c3(ENCARG(x_2), ENCARG(x_1))
   ENCARG(d(x_1, x_2, x_3)) -> c7(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(d(x_1, x_2, x_3)) -> c8(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(d(x_1, x_2, x_3)) -> c9(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
S tuples:
   ENCARG(cons_g(x_1, x_2)) -> c(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_g(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_f(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_f(x_1, x_2)) -> c3(ENCARG(x_2), ENCARG(x_1))
   ENCARG(d(x_1, x_2, x_3)) -> c7(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(d(x_1, x_2, x_3)) -> c8(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(d(x_1, x_2, x_3)) -> c9(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
K tuples:none
Defined Rule Symbols:   encArg_1, encode_a, encode_c, encode_g_2, encode_b, encode_d_3, encode_f_2, g_2, f_2, a

Defined Pair Symbols:   ENCARG_1

Compound Symbols:   c_2, c1_2, c2_2, c3_2, c7_3, c8_3, c9_3


----------------------------------------

(17) CdtToCpxRelTrsProof (BOTH BOUNDS(ID, ID))
Converted S to standard rules, and D \ S as well as R to relative rules.
----------------------------------------

(18)
Obligation:
The Runtime Complexity (innermost) of the given CpxTRS could be proven to be BOUNDS(1, n^1).


The TRS R consists of the following rules:

   ENCARG(cons_g(x_1, x_2)) -> c(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_g(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_f(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_f(x_1, x_2)) -> c3(ENCARG(x_2), ENCARG(x_1))
   ENCARG(d(x_1, x_2, x_3)) -> c7(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(d(x_1, x_2, x_3)) -> c8(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(d(x_1, x_2, x_3)) -> c9(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))

S is empty.
Rewrite Strategy: INNERMOST
----------------------------------------

(19) RelTrsToTrsProof (UPPER BOUND(ID))
transformed relative TRS to TRS
----------------------------------------

(20)
Obligation:
The Runtime Complexity (innermost) of the given CpxTRS could be proven to be BOUNDS(1, n^1).


The TRS R consists of the following rules:

   ENCARG(cons_g(x_1, x_2)) -> c(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_g(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_f(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_f(x_1, x_2)) -> c3(ENCARG(x_2), ENCARG(x_1))
   ENCARG(d(x_1, x_2, x_3)) -> c7(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(d(x_1, x_2, x_3)) -> c8(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(d(x_1, x_2, x_3)) -> c9(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))

S is empty.
Rewrite Strategy: INNERMOST
----------------------------------------

(21) CpxTrsMatchBoundsTAProof (FINISHED)
A linear upper bound on the runtime complexity of the TRS R could be shown with a Match-Bound[TAB_LEFTLINEAR,TAB_NONLEFTLINEAR] (for contructor-based start-terms) of 1. 

The compatible tree automaton used to show the Match-Boundedness (for constructor-based start-terms) is represented by: 
final states : [1]
transitions: 
cons_g0(0, 0) -> 0
c0(0, 0) -> 0
c10(0, 0) -> 0
cons_f0(0, 0) -> 0
c20(0, 0) -> 0
c30(0, 0) -> 0
d0(0, 0, 0) -> 0
c70(0, 0, 0) -> 0
c80(0, 0, 0) -> 0
c90(0, 0, 0) -> 0
ENCARG0(0) -> 1
ENCARG1(0) -> 2
ENCARG1(0) -> 3
c1(2, 3) -> 1
ENCARG1(0) -> 4
ENCARG1(0) -> 5
c11(4, 5) -> 1
ENCARG1(0) -> 6
ENCARG1(0) -> 7
c21(6, 7) -> 1
ENCARG1(0) -> 8
ENCARG1(0) -> 9
c31(8, 9) -> 1
ENCARG1(0) -> 10
ENCARG1(0) -> 11
ENCARG1(0) -> 12
c71(10, 11, 12) -> 1
ENCARG1(0) -> 13
ENCARG1(0) -> 14
ENCARG1(0) -> 15
c81(13, 14, 15) -> 1
ENCARG1(0) -> 16
ENCARG1(0) -> 17
ENCARG1(0) -> 18
c91(16, 17, 18) -> 1
c1(2, 3) -> 2
c1(2, 3) -> 3
c1(2, 3) -> 4
c1(2, 3) -> 5
c1(2, 3) -> 6
c1(2, 3) -> 7
c1(2, 3) -> 8
c1(2, 3) -> 9
c1(2, 3) -> 10
c1(2, 3) -> 11
c1(2, 3) -> 12
c1(2, 3) -> 13
c1(2, 3) -> 14
c1(2, 3) -> 15
c1(2, 3) -> 16
c1(2, 3) -> 17
c1(2, 3) -> 18
c11(4, 5) -> 2
c11(4, 5) -> 3
c11(4, 5) -> 4
c11(4, 5) -> 5
c11(4, 5) -> 6
c11(4, 5) -> 7
c11(4, 5) -> 8
c11(4, 5) -> 9
c11(4, 5) -> 10
c11(4, 5) -> 11
c11(4, 5) -> 12
c11(4, 5) -> 13
c11(4, 5) -> 14
c11(4, 5) -> 15
c11(4, 5) -> 16
c11(4, 5) -> 17
c11(4, 5) -> 18
c21(6, 7) -> 2
c21(6, 7) -> 3
c21(6, 7) -> 4
c21(6, 7) -> 5
c21(6, 7) -> 6
c21(6, 7) -> 7
c21(6, 7) -> 8
c21(6, 7) -> 9
c21(6, 7) -> 10
c21(6, 7) -> 11
c21(6, 7) -> 12
c21(6, 7) -> 13
c21(6, 7) -> 14
c21(6, 7) -> 15
c21(6, 7) -> 16
c21(6, 7) -> 17
c21(6, 7) -> 18
c31(8, 9) -> 2
c31(8, 9) -> 3
c31(8, 9) -> 4
c31(8, 9) -> 5
c31(8, 9) -> 6
c31(8, 9) -> 7
c31(8, 9) -> 8
c31(8, 9) -> 9
c31(8, 9) -> 10
c31(8, 9) -> 11
c31(8, 9) -> 12
c31(8, 9) -> 13
c31(8, 9) -> 14
c31(8, 9) -> 15
c31(8, 9) -> 16
c31(8, 9) -> 17
c31(8, 9) -> 18
c71(10, 11, 12) -> 2
c71(10, 11, 12) -> 3
c71(10, 11, 12) -> 4
c71(10, 11, 12) -> 5
c71(10, 11, 12) -> 6
c71(10, 11, 12) -> 7
c71(10, 11, 12) -> 8
c71(10, 11, 12) -> 9
c71(10, 11, 12) -> 10
c71(10, 11, 12) -> 11
c71(10, 11, 12) -> 12
c71(10, 11, 12) -> 13
c71(10, 11, 12) -> 14
c71(10, 11, 12) -> 15
c71(10, 11, 12) -> 16
c71(10, 11, 12) -> 17
c71(10, 11, 12) -> 18
c81(13, 14, 15) -> 2
c81(13, 14, 15) -> 3
c81(13, 14, 15) -> 4
c81(13, 14, 15) -> 5
c81(13, 14, 15) -> 6
c81(13, 14, 15) -> 7
c81(13, 14, 15) -> 8
c81(13, 14, 15) -> 9
c81(13, 14, 15) -> 10
c81(13, 14, 15) -> 11
c81(13, 14, 15) -> 12
c81(13, 14, 15) -> 13
c81(13, 14, 15) -> 14
c81(13, 14, 15) -> 15
c81(13, 14, 15) -> 16
c81(13, 14, 15) -> 17
c81(13, 14, 15) -> 18
c91(16, 17, 18) -> 2
c91(16, 17, 18) -> 3
c91(16, 17, 18) -> 4
c91(16, 17, 18) -> 5
c91(16, 17, 18) -> 6
c91(16, 17, 18) -> 7
c91(16, 17, 18) -> 8
c91(16, 17, 18) -> 9
c91(16, 17, 18) -> 10
c91(16, 17, 18) -> 11
c91(16, 17, 18) -> 12
c91(16, 17, 18) -> 13
c91(16, 17, 18) -> 14
c91(16, 17, 18) -> 15
c91(16, 17, 18) -> 16
c91(16, 17, 18) -> 17
c91(16, 17, 18) -> 18

----------------------------------------

(22)
BOUNDS(1, n^1)
