AST
proof of /home/ff862203/input_gwe61PbQBT.ari
# AProVE Commit ID: 1c9e2a6453f9f0dca490585733f1cff3767d3e54 jan-christoph 20250828 unpublished


Innermost AST of the given PTRS could be proven:

(0) PTRS
(1) PTRStoPQTRSProof [EQUIVALENT, 0 ms]
(2) PQTRS
(3) PQTRStoADPProblemProof [EQUIVALENT, 0 ms]
(4) ADP
(5) AST_ADPDependencyGraphProof [EQUIVALENT, 0 ms]
(6) ADP
(7) AST_ADPUsableTermsProof [EQUIVALENT, 0 ms]
(8) ADP
(9) AST_ADPUsableRulesProof [EQUIVALENT, 0 ms]
(10) ADP
(11) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(12) ADP
(13) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(14) ADP
(15) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(16) ADP
(17) AST_ADPUsableRulesProof [EQUIVALENT, 0 ms]
(18) ADP
(19) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(20) ADP
(21) AST_ADPDependencyGraphProof [EQUIVALENT, 0 ms]
(22) ADP
(23) AST_ADPUsableRulesProof [EQUIVALENT, 0 ms]
(24) ADP
(25) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(26) ADP
(27) AST_ADPUsableRulesProof [EQUIVALENT, 0 ms]
(28) ADP
(29) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(30) ADP
(31) AST_ADPDependencyGraphProof [EQUIVALENT, 0 ms]
(32) ADP
(33) AST_ADPReductionPairProof [EQUIVALENT, 0 ms]
(34) ADP
(35) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(36) ADP
(37) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(38) ADP
(39) AST_ADPReductionPairProof [EQUIVALENT, 0 ms]
(40) ADP
(41) AST_ADPDependencyGraphProof [EQUIVALENT, 0 ms]
(42) TRUE


----------------------------------------

(0)
Obligation:
Probabilistic term rewrite system:
The TRS has the following probabilistic rules:

   p(s(x)) -> 1 : x
   rand_inc_dec(x) -> 1 / 2 : p(x) || 1 / 2 : s(x)
   if(true, x, y) -> 1 : rand(rand_inc_dec(x), rand_inc_dec(y))
   random(x) -> 1 : rand(x, 0)
   p(0) -> 1 : 0
   nonZero(0) -> 1 : false
   nonZero(s(x)) -> 1 : true
   rand(x, y) -> 1 : if(nonZero(x), x, y)
   if(false, x, y) -> 1 : y

and uses the innermost rewrite strategy.

----------------------------------------

(1) PTRStoPQTRSProof (EQUIVALENT)
Transformed PTRS into PQTRS. Q is:
   p(s(x)), rand_inc_dec(x), if(true, x, y), random(x), p(0), nonZero(0), nonZero(s(x)), rand(x, y), if(false, x, y)
----------------------------------------

(2)
Obligation:
Probabilistic Q term rewrite system:
The PQTRS has the following probabilistic rules:

   p(s(x)) -> 1 : x
   rand_inc_dec(x) -> 1 / 2 : p(x) || 1 / 2 : s(x)
   if(true, x, y) -> 1 : rand(rand_inc_dec(x), rand_inc_dec(y))
   random(x) -> 1 : rand(x, 0)
   p(0) -> 1 : 0
   nonZero(0) -> 1 : false
   nonZero(s(x)) -> 1 : true
   rand(x, y) -> 1 : if(nonZero(x), x, y)
   if(false, x, y) -> 1 : y

And Q contains the following terms:
   p(s(x0)), rand_inc_dec(x0), if(true, x0, x1), random(x0), p(0), nonZero(0), nonZero(s(x0)), rand(x0, x1), if(false, x0, x1)

----------------------------------------

(3) PQTRStoADPProblemProof (EQUIVALENT)


A PQTRS (R,Q) is innermost AST iff ADP(R) is innermost AST (Chain-Criterion)[FLOPS24].
----------------------------------------

(4)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   p(s(x)) -> 1 : x
   rand_inc_dec(x) -> 1 / 2 : p(x) || 1 / 2 : s(x)
   if(true, x, y) -> 1 : rand(rand_inc_dec(x), rand_inc_dec(y))
   random(x) -> 1 : rand(x, 0)
   p(0) -> 1 : 0
   nonZero(0) -> 1 : false
   nonZero(s(x)) -> 1 : true
   rand(x, y) -> 1 : if(nonZero(x), x, y)
   if(false, x, y) -> 1 : y

The ADP Problem has the following rules with annotations:

   P(s(x)) -> 1 : x
   RAND_INC_DEC(x) -> 1 / 2 : P(x) || 1 / 2 : s(x)
   IF(true, x, y) -> 1 : RAND(RAND_INC_DEC(x), RAND_INC_DEC(y))
   RANDOM(x) -> 1 : RAND(x, 0)
   P(0) -> 1 : 0
   NONZERO(0) -> 1 : false
   NONZERO(s(x)) -> 1 : true
   RAND(x, y) -> 1 : IF(NONZERO(x), x, y)
   IF(false, x, y) -> 1 : y


----------------------------------------

(5) AST_ADPDependencyGraphProof (EQUIVALENT)


We use the dependency graph processor [FLOPS24].
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 7 less nodes.
----------------------------------------

(6)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   p(s(x)) -> 1 : x
   rand_inc_dec(x) -> 1 / 2 : p(x) || 1 / 2 : s(x)
   if(true, x, y) -> 1 : rand(rand_inc_dec(x), rand_inc_dec(y))
   random(x) -> 1 : rand(x, 0)
   p(0) -> 1 : 0
   nonZero(0) -> 1 : false
   nonZero(s(x)) -> 1 : true
   rand(x, y) -> 1 : if(nonZero(x), x, y)
   if(false, x, y) -> 1 : y

The ADP Problem has the following rules with annotations:

   RAND(x, y) -> 1 : IF(NONZERO(x), x, y)
   IF(true, x, y) -> 1 : RAND(RAND_INC_DEC(x), RAND_INC_DEC(y))


----------------------------------------

(7) AST_ADPUsableTermsProof (EQUIVALENT)


We use the usable terms processor [FLOPS24].
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] gives us the following unusable Terms: 
[NONZERO(x), RAND_INC_DEC(y), RAND_INC_DEC(x)]
Hence, we can remove the annotations from these terms from every RHS of every ADP
----------------------------------------

(8)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   p(s(x)) -> 1 : x
   rand_inc_dec(x) -> 1 / 2 : p(x) || 1 / 2 : s(x)
   if(true, x, y) -> 1 : rand(rand_inc_dec(x), rand_inc_dec(y))
   random(x) -> 1 : rand(x, 0)
   p(0) -> 1 : 0
   nonZero(0) -> 1 : false
   nonZero(s(x)) -> 1 : true
   rand(x, y) -> 1 : if(nonZero(x), x, y)
   if(false, x, y) -> 1 : y

The ADP Problem has the following rules with annotations:

   RAND(x, y) -> 1 : IF(nonZero(x), x, y)
   IF(true, x, y) -> 1 : RAND(rand_inc_dec(x), rand_inc_dec(y))


----------------------------------------

(9) AST_ADPUsableRulesProof (EQUIVALENT)


We use the usable rules processor [FLOPS24].
Hence, by the usable rules processor [FLOPS24] we can deactivate the flags for all non-usable rules [FROCOS05]
----------------------------------------

(10)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   rand_inc_dec(x) -> 1 / 2 : p(x) || 1 / 2 : s(x)
   p(s(x)) -> 1 : x
   p(0) -> 1 : 0
   nonZero(0) -> 1 : false
   nonZero(s(x)) -> 1 : true

The ADP Problem has the following rules with annotations:

   RAND(x, y) -> 1 : IF(nonZero(x), x, y)
   IF(true, x, y) -> 1 : RAND(rand_inc_dec(x), rand_inc_dec(y))


----------------------------------------

(11) AST_ADPTransformationProof (EQUIVALENT)
By rewriting [FLOPS24] for the rule IF(true, x, y) -> 1 : RAND(rand_inc_dec(x), rand_inc_dec(y)) at position [0] we obtained the following new ADPs :

   IF(true, x, y) -> 1 / 2 : RAND(p(x), rand_inc_dec(y)) || 1 / 2 : RAND(s(x), rand_inc_dec(y))

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(12)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   p(s(x)) -> 1 : x
   rand_inc_dec(x) -> 1 / 2 : p(x) || 1 / 2 : s(x)
   p(0) -> 1 : 0
   nonZero(0) -> 1 : false
   nonZero(s(x)) -> 1 : true

The ADP Problem has the following rules with annotations:

   RAND(x, y) -> 1 : IF(nonZero(x), x, y)
   IF(true, x, y) -> 1 / 2 : RAND(p(x), rand_inc_dec(y)) || 1 / 2 : RAND(s(x), rand_inc_dec(y))


----------------------------------------

(13) AST_ADPTransformationProof (EQUIVALENT)
By rewriting [FLOPS24] for the rule IF(true, x, y) -> 1 / 2 : RAND(p(x), rand_inc_dec(y)) || 1 / 2 : RAND(s(x), rand_inc_dec(y)) at position [1] we obtained the following new ADPs :

   IF(true, x, y) -> 1 / 2 : RAND(s(x), rand_inc_dec(y)) || 1 / 4 : RAND(p(x), p(y)) || 1 / 4 : RAND(p(x), s(y))

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(14)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   p(s(x)) -> 1 : x
   rand_inc_dec(x) -> 1 / 2 : p(x) || 1 / 2 : s(x)
   p(0) -> 1 : 0
   nonZero(0) -> 1 : false
   nonZero(s(x)) -> 1 : true

The ADP Problem has the following rules with annotations:

   RAND(x, y) -> 1 : IF(nonZero(x), x, y)
   IF(true, x, y) -> 1 / 2 : RAND(s(x), rand_inc_dec(y)) || 1 / 4 : RAND(p(x), p(y)) || 1 / 4 : RAND(p(x), s(y))


----------------------------------------

(15) AST_ADPTransformationProof (EQUIVALENT)
By rewriting [FLOPS24] for the rule IF(true, x, y) -> 1 / 2 : RAND(s(x), rand_inc_dec(y)) || 1 / 4 : RAND(p(x), p(y)) || 1 / 4 : RAND(p(x), s(y)) at position [1] we obtained the following new ADPs :

   IF(true, x, y) -> 1 / 4 : RAND(p(x), p(y)) || 1 / 4 : RAND(p(x), s(y)) || 1 / 4 : RAND(s(x), p(y)) || 1 / 4 : RAND(s(x), s(y))

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(16)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   p(s(x)) -> 1 : x
   rand_inc_dec(x) -> 1 / 2 : p(x) || 1 / 2 : s(x)
   p(0) -> 1 : 0
   nonZero(0) -> 1 : false
   nonZero(s(x)) -> 1 : true

The ADP Problem has the following rules with annotations:

   RAND(x, y) -> 1 : IF(nonZero(x), x, y)
   IF(true, x, y) -> 1 / 4 : RAND(p(x), p(y)) || 1 / 4 : RAND(p(x), s(y)) || 1 / 4 : RAND(s(x), p(y)) || 1 / 4 : RAND(s(x), s(y))


----------------------------------------

(17) AST_ADPUsableRulesProof (EQUIVALENT)


We use the usable rules processor [FLOPS24].
Hence, by the usable rules processor [FLOPS24] we can deactivate the flags for all non-usable rules [FROCOS05]
----------------------------------------

(18)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   p(s(x)) -> 1 : x
   p(0) -> 1 : 0
   nonZero(0) -> 1 : false
   nonZero(s(x)) -> 1 : true

The ADP Problem has the following rules with annotations:

   RAND(x, y) -> 1 : IF(nonZero(x), x, y)
   IF(true, x, y) -> 1 / 4 : RAND(p(x), p(y)) || 1 / 4 : RAND(p(x), s(y)) || 1 / 4 : RAND(s(x), p(y)) || 1 / 4 : RAND(s(x), s(y))


----------------------------------------

(19) AST_ADPTransformationProof (EQUIVALENT)
By rule overlap instantiation [FLOPS24] for the rule RAND(x, y) -> 1 : IF(nonZero(x), x, y) we obtained the following new ADPs :

   RAND(0, x1) -> 1 : IF(nonZero(0), 0, x1)
   RAND(s(y0), x1) -> 1 : IF(nonZero(s(y0)), s(y0), x1)

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(20)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   p(s(x)) -> 1 : x
   p(0) -> 1 : 0
   nonZero(0) -> 1 : false
   nonZero(s(x)) -> 1 : true

The ADP Problem has the following rules with annotations:

   IF(true, x, y) -> 1 / 4 : RAND(p(x), p(y)) || 1 / 4 : RAND(p(x), s(y)) || 1 / 4 : RAND(s(x), p(y)) || 1 / 4 : RAND(s(x), s(y))
   RAND(0, x1) -> 1 : IF(nonZero(0), 0, x1)
   RAND(s(y0), x1) -> 1 : IF(nonZero(s(y0)), s(y0), x1)


----------------------------------------

(21) AST_ADPDependencyGraphProof (EQUIVALENT)


We use the dependency graph processor [FLOPS24].
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(22)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   p(s(x)) -> 1 : x
   p(0) -> 1 : 0
   nonZero(0) -> 1 : false
   nonZero(s(x)) -> 1 : true

The ADP Problem has the following rules with annotations:

   RAND(s(y0), x1) -> 1 : IF(nonZero(s(y0)), s(y0), x1)
   IF(true, x, y) -> 1 / 4 : RAND(p(x), p(y)) || 1 / 4 : RAND(p(x), s(y)) || 1 / 4 : RAND(s(x), p(y)) || 1 / 4 : RAND(s(x), s(y))


----------------------------------------

(23) AST_ADPUsableRulesProof (EQUIVALENT)


We use the usable rules processor [FLOPS24].
Hence, by the usable rules processor [FLOPS24] we can deactivate the flags for all non-usable rules [FROCOS05]
----------------------------------------

(24)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   p(s(x)) -> 1 : x
   p(0) -> 1 : 0
   nonZero(s(x)) -> 1 : true

The ADP Problem has the following rules with annotations:

   RAND(s(y0), x1) -> 1 : IF(nonZero(s(y0)), s(y0), x1)
   IF(true, x, y) -> 1 / 4 : RAND(p(x), p(y)) || 1 / 4 : RAND(p(x), s(y)) || 1 / 4 : RAND(s(x), p(y)) || 1 / 4 : RAND(s(x), s(y))


----------------------------------------

(25) AST_ADPTransformationProof (EQUIVALENT)
By rewriting [FLOPS24] for the rule RAND(s(y0), x1) -> 1 : IF(nonZero(s(y0)), s(y0), x1) at position [0] we obtained the following new ADPs :

   RAND(s(y0), x1) -> 1 : IF(true, s(y0), x1)

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(26)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   p(s(x)) -> 1 : x
   p(0) -> 1 : 0
   nonZero(s(x)) -> 1 : true

The ADP Problem has the following rules with annotations:

   IF(true, x, y) -> 1 / 4 : RAND(p(x), p(y)) || 1 / 4 : RAND(p(x), s(y)) || 1 / 4 : RAND(s(x), p(y)) || 1 / 4 : RAND(s(x), s(y))
   RAND(s(y0), x1) -> 1 : IF(true, s(y0), x1)


----------------------------------------

(27) AST_ADPUsableRulesProof (EQUIVALENT)


We use the usable rules processor [FLOPS24].
Hence, by the usable rules processor [FLOPS24] we can deactivate the flags for all non-usable rules [FROCOS05]
----------------------------------------

(28)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   p(s(x)) -> 1 : x
   p(0) -> 1 : 0

The ADP Problem has the following rules with annotations:

   IF(true, x, y) -> 1 / 4 : RAND(p(x), p(y)) || 1 / 4 : RAND(p(x), s(y)) || 1 / 4 : RAND(s(x), p(y)) || 1 / 4 : RAND(s(x), s(y))
   RAND(s(y0), x1) -> 1 : IF(true, s(y0), x1)


----------------------------------------

(29) AST_ADPTransformationProof (EQUIVALENT)
By rule overlap instantiation [FLOPS24] for the rule IF(true, x, y) -> 1 / 4 : RAND(p(x), p(y)) || 1 / 4 : RAND(p(x), s(y)) || 1 / 4 : RAND(s(x), p(y)) || 1 / 4 : RAND(s(x), s(y)) we obtained the following new ADPs :

   IF(true, s(y0), x1) -> 1 / 4 : RAND(p(s(y0)), p(x1)) || 1 / 4 : RAND(p(s(y0)), s(x1)) || 1 / 4 : RAND(s(s(y0)), p(x1)) || 1 / 4 : RAND(s(s(y0)), s(x1))
   IF(true, 0, x1) -> 1 / 4 : RAND(p(0), p(x1)) || 1 / 4 : RAND(p(0), s(x1)) || 1 / 4 : RAND(s(0), p(x1)) || 1 / 4 : RAND(s(0), s(x1))
   IF(true, x0, x1) -> 1 / 4 : RAND(p(x0), p(x1)) || 1 / 4 : rand(p(x0), s(x1)) || 1 / 4 : RAND(s(x0), p(x1)) || 1 / 4 : RAND(s(x0), s(x1))

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(30)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   p(s(x)) -> 1 : x
   p(0) -> 1 : 0

The ADP Problem has the following rules with annotations:

   RAND(s(y0), x1) -> 1 : IF(true, s(y0), x1)
   IF(true, s(y0), x1) -> 1 / 4 : RAND(p(s(y0)), p(x1)) || 1 / 4 : RAND(p(s(y0)), s(x1)) || 1 / 4 : RAND(s(s(y0)), p(x1)) || 1 / 4 : RAND(s(s(y0)), s(x1))
   IF(true, 0, x1) -> 1 / 4 : RAND(p(0), p(x1)) || 1 / 4 : RAND(p(0), s(x1)) || 1 / 4 : RAND(s(0), p(x1)) || 1 / 4 : RAND(s(0), s(x1))
   IF(true, x0, x1) -> 1 / 4 : RAND(p(x0), p(x1)) || 1 / 4 : rand(p(x0), s(x1)) || 1 / 4 : RAND(s(x0), p(x1)) || 1 / 4 : RAND(s(x0), s(x1))


----------------------------------------

(31) AST_ADPDependencyGraphProof (EQUIVALENT)


We use the dependency graph processor [FLOPS24].
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 1 less node.
----------------------------------------

(32)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   p(s(x)) -> 1 : x
   p(0) -> 1 : 0

The ADP Problem has the following rules with annotations:

   IF(true, s(y0), x1) -> 1 / 4 : RAND(p(s(y0)), p(x1)) || 1 / 4 : RAND(p(s(y0)), s(x1)) || 1 / 4 : RAND(s(s(y0)), p(x1)) || 1 / 4 : RAND(s(s(y0)), s(x1))
   RAND(s(y0), x1) -> 1 : IF(true, s(y0), x1)
   IF(true, x0, x1) -> 1 / 4 : RAND(p(x0), p(x1)) || 1 / 4 : rand(p(x0), s(x1)) || 1 / 4 : RAND(s(x0), p(x1)) || 1 / 4 : RAND(s(x0), s(x1))


----------------------------------------

(33) AST_ADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [FLOPS24].
The following pairs can be oriented strictly and we delete all annotations:

   IF(true, x0, x1) -> 1 / 4 : RAND(p(x0), p(x1)) || 1 / 4 : rand(p(x0), s(x1)) || 1 / 4 : RAND(s(x0), p(x1)) || 1 / 4 : RAND(s(x0), s(x1))

The remaining pairs can at least be oriented weakly:

   IF(true, s(y0), x1) -> 1 / 4 : RAND(p(s(y0)), p(x1)) || 1 / 4 : RAND(p(s(y0)), s(x1)) || 1 / 4 : RAND(s(s(y0)), p(x1)) || 1 / 4 : RAND(s(s(y0)), s(x1))
   RAND(s(y0), x1) -> 1 : IF(true, s(y0), x1)

Used ordering:  Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(IF(x_1, x_2, x_3)) = 1 + 2*x_1 + 2*x_1*x_3
   POL(RAND(x_1, x_2)) = 1
   POL(p(x_1)) = x_1
   POL(rand(x_1, x_2)) = 0
   POL(s(x_1)) = 2*x_1
   POL(true) = 0

----------------------------------------

(34)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   p(s(x)) -> 1 : x
   p(0) -> 1 : 0

The ADP Problem has the following rules with annotations:

   IF(true, s(y0), x1) -> 1 / 4 : RAND(p(s(y0)), p(x1)) || 1 / 4 : RAND(p(s(y0)), s(x1)) || 1 / 4 : RAND(s(s(y0)), p(x1)) || 1 / 4 : RAND(s(s(y0)), s(x1))
   RAND(s(y0), x1) -> 1 : IF(true, s(y0), x1)


----------------------------------------

(35) AST_ADPTransformationProof (EQUIVALENT)
By rewriting [FLOPS24] for the rule IF(true, s(y0), x1) -> 1 / 4 : RAND(p(s(y0)), p(x1)) || 1 / 4 : RAND(p(s(y0)), s(x1)) || 1 / 4 : RAND(s(s(y0)), p(x1)) || 1 / 4 : RAND(s(s(y0)), s(x1)) at position [0] we obtained the following new ADPs :

   IF(true, s(y0), x1) -> 1 / 4 : RAND(p(s(y0)), s(x1)) || 1 / 4 : RAND(s(s(y0)), p(x1)) || 1 / 4 : RAND(s(s(y0)), s(x1)) || 1 / 4 : RAND(y0, p(x1))

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(36)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   p(s(x)) -> 1 : x
   p(0) -> 1 : 0

The ADP Problem has the following rules with annotations:

   RAND(s(y0), x1) -> 1 : IF(true, s(y0), x1)
   IF(true, s(y0), x1) -> 1 / 4 : RAND(p(s(y0)), s(x1)) || 1 / 4 : RAND(s(s(y0)), p(x1)) || 1 / 4 : RAND(s(s(y0)), s(x1)) || 1 / 4 : RAND(y0, p(x1))


----------------------------------------

(37) AST_ADPTransformationProof (EQUIVALENT)
By rewriting [FLOPS24] for the rule IF(true, s(y0), x1) -> 1 / 4 : RAND(p(s(y0)), s(x1)) || 1 / 4 : RAND(s(s(y0)), p(x1)) || 1 / 4 : RAND(s(s(y0)), s(x1)) || 1 / 4 : RAND(y0, p(x1)) at position [0] we obtained the following new ADPs :

   IF(true, s(y0), x1) -> 1 / 4 : RAND(s(s(y0)), p(x1)) || 1 / 4 : RAND(s(s(y0)), s(x1)) || 1 / 4 : RAND(y0, p(x1)) || 1 / 4 : RAND(y0, s(x1))

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(38)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   p(s(x)) -> 1 : x
   p(0) -> 1 : 0

The ADP Problem has the following rules with annotations:

   RAND(s(y0), x1) -> 1 : IF(true, s(y0), x1)
   IF(true, s(y0), x1) -> 1 / 4 : RAND(s(s(y0)), p(x1)) || 1 / 4 : RAND(s(s(y0)), s(x1)) || 1 / 4 : RAND(y0, p(x1)) || 1 / 4 : RAND(y0, s(x1))


----------------------------------------

(39) AST_ADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [FLOPS24].
The following pairs can be oriented strictly and we delete all annotations:

   IF(true, s(y0), x1) -> 1 / 4 : RAND(s(s(y0)), p(x1)) || 1 / 4 : RAND(s(s(y0)), s(x1)) || 1 / 4 : RAND(y0, p(x1)) || 1 / 4 : RAND(y0, s(x1))

The remaining pairs can at least be oriented weakly:

   RAND(s(y0), x1) -> 1 : IF(true, s(y0), x1)

Used ordering:  Polynomial interpretation [POLO]:

   POL(0) = 1
   POL(IF(x_1, x_2, x_3)) = 2*x_1 + 2*x_1*x_2 + 2*x_1*x_2*x_3 + 2*x_1*x_3 + 2*x_2
   POL(RAND(x_1, x_2)) = 2*x_1
   POL(p(x_1)) = 2*x_1
   POL(s(x_1)) = 2 + x_1
   POL(true) = 0

----------------------------------------

(40)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   p(s(x)) -> 1 : x
   p(0) -> 1 : 0

The ADP Problem has the following rules with annotations:

   RAND(s(y0), x1) -> 1 : IF(true, s(y0), x1)


----------------------------------------

(41) AST_ADPDependencyGraphProof (EQUIVALENT)


We use the dependency graph processor [FLOPS24].
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 1 less node.
----------------------------------------

(42)
TRUE
