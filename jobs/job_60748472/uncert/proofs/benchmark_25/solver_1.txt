AST
proof of /home/ff862203/input_My2DVEKsST.ari
# AProVE Commit ID: 1c9e2a6453f9f0dca490585733f1cff3767d3e54 jan-christoph 20250828 unpublished


Innermost AST of the given PTRS could be proven:

(0) PTRS
(1) PTRStoPQTRSProof [EQUIVALENT, 0 ms]
(2) PQTRS
(3) PQTRStoADPProblemProof [EQUIVALENT, 0 ms]
(4) ADP
(5) AST_ADPDependencyGraphProof [EQUIVALENT, 0 ms]
(6) AND
    (7) ADP
        (8) AST_ADPUsableRulesProof [EQUIVALENT, 0 ms]
        (9) ADP
        (10) AST_ADPProbabilityRemovalProof [EQUIVALENT, 0 ms]
        (11) QDP
        (12) QReductionProof [EQUIVALENT, 0 ms]
        (13) QDP
        (14) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (15) YES
    (16) ADP
        (17) AST_ADPUsableRulesProof [EQUIVALENT, 0 ms]
        (18) ADP
        (19) AST_ADPProbabilityRemovalProof [EQUIVALENT, 0 ms]
        (20) QDP
        (21) QReductionProof [EQUIVALENT, 0 ms]
        (22) QDP
        (23) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (24) YES
    (25) ADP
        (26) AST_ADPUsableTermsProof [EQUIVALENT, 1 ms]
        (27) ADP
        (28) AST_ADPUsableRulesProof [EQUIVALENT, 0 ms]
        (29) ADP
        (30) AST_ADPProbabilityRemovalProof [EQUIVALENT, 0 ms]
        (31) QDP
        (32) QReductionProof [EQUIVALENT, 0 ms]
        (33) QDP
        (34) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (35) YES
    (36) ADP
        (37) AST_ADPUsableTermsProof [EQUIVALENT, 0 ms]
        (38) ADP
        (39) AST_ADPUsableRulesProof [EQUIVALENT, 0 ms]
        (40) ADP
        (41) AST_ADPProbabilityRemovalProof [EQUIVALENT, 0 ms]
        (42) QDP
        (43) QReductionProof [EQUIVALENT, 0 ms]
        (44) QDP
        (45) QDPSizeChangeProof [EQUIVALENT, 0 ms]
        (46) YES
    (47) ADP
        (48) AST_ADPUsableTermsProof [EQUIVALENT, 0 ms]
        (49) ADP
        (50) AST_ADPUsableRulesProof [EQUIVALENT, 0 ms]
        (51) ADP
        (52) AST_ADPReductionPairProof [EQUIVALENT, 3 ms]
        (53) ADP
        (54) PisEmptyProof [EQUIVALENT, 0 ms]
        (55) YES
    (56) ADP
        (57) AST_ADPUsableTermsProof [EQUIVALENT, 0 ms]
        (58) ADP
        (59) AST_ADPUsableRulesProof [EQUIVALENT, 0 ms]
        (60) ADP
        (61) AST_ADPReductionPairProof [EQUIVALENT, 0 ms]
        (62) ADP
        (63) AST_ADPDependencyGraphProof [EQUIVALENT, 0 ms]
        (64) TRUE


----------------------------------------

(0)
Obligation:
Probabilistic term rewrite system:
The TRS has the following probabilistic rules:

   rotate(cons(x, xs)) -> 1 / 2 : cons(x, xs) || 1 / 2 : rotate(app(rotate(xs), cons(x, nil)))
   leq(0, x) -> 1 : true
   low(x, nil) -> 1 : nil
   ifLow(true, x, cons(y, ys)) -> 1 : low(x, ys)
   high(x, nil) -> 1 : nil
   leq(s(x), 0) -> 1 : false
   app(nil, ys) -> 1 : ys
   app(cons(x, xs), ys) -> 1 : cons(x, app(xs, ys))
   rotate(nil) -> 1 : nil
   qsHelp(cons(x, xs)) -> 1 : app(qs(low(x, xs)), cons(x, qs(high(x, xs))))
   low(x, cons(y, ys)) -> 1 : ifLow(leq(x, y), x, cons(y, ys))
   leq(s(x), s(y)) -> 1 : leq(x, y)
   qs(nil) -> 1 : nil
   qs(cons(x, xs)) -> 1 : qsHelp(rotate(cons(x, xs)))
   high(x, cons(y, ys)) -> 1 : ifHigh(leq(x, y), x, cons(y, ys))
   ifLow(false, x, cons(y, ys)) -> 1 : cons(y, low(x, ys))
   ifHigh(false, x, cons(y, ys)) -> 1 : high(x, ys)
   ifHigh(true, x, cons(y, ys)) -> 1 : cons(y, high(x, ys))

and uses the innermost rewrite strategy.

----------------------------------------

(1) PTRStoPQTRSProof (EQUIVALENT)
Transformed PTRS into PQTRS. Q is:
   rotate(cons(x, xs)), leq(0, x), low(x, nil), ifLow(true, x, cons(y, ys)), high(x, nil), leq(s(x), 0), app(nil, ys), app(cons(x, xs), ys), rotate(nil), qsHelp(cons(x, xs)), low(x, cons(y, ys)), leq(s(x), s(y)), qs(nil), qs(cons(x, xs)), high(x, cons(y, ys)), ifLow(false, x, cons(y, ys)), ifHigh(false, x, cons(y, ys)), ifHigh(true, x, cons(y, ys))
----------------------------------------

(2)
Obligation:
Probabilistic Q term rewrite system:
The PQTRS has the following probabilistic rules:

   rotate(cons(x, xs)) -> 1 / 2 : cons(x, xs) || 1 / 2 : rotate(app(rotate(xs), cons(x, nil)))
   leq(0, x) -> 1 : true
   low(x, nil) -> 1 : nil
   ifLow(true, x, cons(y, ys)) -> 1 : low(x, ys)
   high(x, nil) -> 1 : nil
   leq(s(x), 0) -> 1 : false
   app(nil, ys) -> 1 : ys
   app(cons(x, xs), ys) -> 1 : cons(x, app(xs, ys))
   rotate(nil) -> 1 : nil
   qsHelp(cons(x, xs)) -> 1 : app(qs(low(x, xs)), cons(x, qs(high(x, xs))))
   low(x, cons(y, ys)) -> 1 : ifLow(leq(x, y), x, cons(y, ys))
   leq(s(x), s(y)) -> 1 : leq(x, y)
   qs(nil) -> 1 : nil
   qs(cons(x, xs)) -> 1 : qsHelp(rotate(cons(x, xs)))
   high(x, cons(y, ys)) -> 1 : ifHigh(leq(x, y), x, cons(y, ys))
   ifLow(false, x, cons(y, ys)) -> 1 : cons(y, low(x, ys))
   ifHigh(false, x, cons(y, ys)) -> 1 : high(x, ys)
   ifHigh(true, x, cons(y, ys)) -> 1 : cons(y, high(x, ys))

And Q contains the following terms:
   rotate(cons(x0, x1)), leq(0, x0), low(x0, nil), ifLow(true, x0, cons(x1, x2)), high(x0, nil), leq(s(x0), 0), app(nil, x0), app(cons(x0, x1), x2), rotate(nil), qsHelp(cons(x0, x1)), low(x0, cons(x1, x2)), leq(s(x0), s(x1)), qs(nil), qs(cons(x0, x1)), high(x0, cons(x1, x2)), ifLow(false, x0, cons(x1, x2)), ifHigh(false, x0, cons(x1, x2)), ifHigh(true, x0, cons(x1, x2))

----------------------------------------

(3) PQTRStoADPProblemProof (EQUIVALENT)


A PQTRS (R,Q) is innermost AST iff ADP(R) is innermost AST (Chain-Criterion)[FLOPS24].
----------------------------------------

(4)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   rotate(cons(x, xs)) -> 1 / 2 : cons(x, xs) || 1 / 2 : rotate(app(rotate(xs), cons(x, nil)))
   leq(0, x) -> 1 : true
   low(x, nil) -> 1 : nil
   ifLow(true, x, cons(y, ys)) -> 1 : low(x, ys)
   high(x, nil) -> 1 : nil
   leq(s(x), 0) -> 1 : false
   app(nil, ys) -> 1 : ys
   app(cons(x, xs), ys) -> 1 : cons(x, app(xs, ys))
   rotate(nil) -> 1 : nil
   qsHelp(cons(x, xs)) -> 1 : app(qs(low(x, xs)), cons(x, qs(high(x, xs))))
   low(x, cons(y, ys)) -> 1 : ifLow(leq(x, y), x, cons(y, ys))
   leq(s(x), s(y)) -> 1 : leq(x, y)
   qs(nil) -> 1 : nil
   qs(cons(x, xs)) -> 1 : qsHelp(rotate(cons(x, xs)))
   high(x, cons(y, ys)) -> 1 : ifHigh(leq(x, y), x, cons(y, ys))
   ifLow(false, x, cons(y, ys)) -> 1 : cons(y, low(x, ys))
   ifHigh(false, x, cons(y, ys)) -> 1 : high(x, ys)
   ifHigh(true, x, cons(y, ys)) -> 1 : cons(y, high(x, ys))

The ADP Problem has the following rules with annotations:

   ROTATE(cons(x, xs)) -> 1 / 2 : cons(x, xs) || 1 / 2 : ROTATE(APP(ROTATE(xs), cons(x, nil)))
   LEQ(0, x) -> 1 : true
   LOW(x, nil) -> 1 : nil
   IFLOW(true, x, cons(y, ys)) -> 1 : LOW(x, ys)
   HIGH(x, nil) -> 1 : nil
   LEQ(s(x), 0) -> 1 : false
   APP(nil, ys) -> 1 : ys
   APP(cons(x, xs), ys) -> 1 : cons(x, APP(xs, ys))
   ROTATE(nil) -> 1 : nil
   QSHELP(cons(x, xs)) -> 1 : APP(QS(LOW(x, xs)), cons(x, QS(HIGH(x, xs))))
   LOW(x, cons(y, ys)) -> 1 : IFLOW(LEQ(x, y), x, cons(y, ys))
   LEQ(s(x), s(y)) -> 1 : LEQ(x, y)
   QS(nil) -> 1 : nil
   QS(cons(x, xs)) -> 1 : QSHELP(ROTATE(cons(x, xs)))
   HIGH(x, cons(y, ys)) -> 1 : IFHIGH(LEQ(x, y), x, cons(y, ys))
   IFLOW(false, x, cons(y, ys)) -> 1 : cons(y, LOW(x, ys))
   IFHIGH(false, x, cons(y, ys)) -> 1 : HIGH(x, ys)
   IFHIGH(true, x, cons(y, ys)) -> 1 : cons(y, HIGH(x, ys))


----------------------------------------

(5) AST_ADPDependencyGraphProof (EQUIVALENT)


We use the dependency graph processor [FLOPS24].
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 6 SCCs with 7 less nodes.
----------------------------------------

(6)
Complex Obligation (AND)

----------------------------------------

(7)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   rotate(cons(x, xs)) -> 1 / 2 : cons(x, xs) || 1 / 2 : rotate(app(rotate(xs), cons(x, nil)))
   leq(0, x) -> 1 : true
   low(x, nil) -> 1 : nil
   ifLow(true, x, cons(y, ys)) -> 1 : low(x, ys)
   high(x, nil) -> 1 : nil
   leq(s(x), 0) -> 1 : false
   app(nil, ys) -> 1 : ys
   app(cons(x, xs), ys) -> 1 : cons(x, app(xs, ys))
   rotate(nil) -> 1 : nil
   qsHelp(cons(x, xs)) -> 1 : app(qs(low(x, xs)), cons(x, qs(high(x, xs))))
   low(x, cons(y, ys)) -> 1 : ifLow(leq(x, y), x, cons(y, ys))
   leq(s(x), s(y)) -> 1 : leq(x, y)
   qs(nil) -> 1 : nil
   qs(cons(x, xs)) -> 1 : qsHelp(rotate(cons(x, xs)))
   high(x, cons(y, ys)) -> 1 : ifHigh(leq(x, y), x, cons(y, ys))
   ifLow(false, x, cons(y, ys)) -> 1 : cons(y, low(x, ys))
   ifHigh(false, x, cons(y, ys)) -> 1 : high(x, ys)
   ifHigh(true, x, cons(y, ys)) -> 1 : cons(y, high(x, ys))

The ADP Problem has the following rules with annotations:

   APP(cons(x, xs), ys) -> 1 : cons(x, APP(xs, ys))


----------------------------------------

(8) AST_ADPUsableRulesProof (EQUIVALENT)


We use the usable rules processor [FLOPS24].
Hence, by the usable rules processor [FLOPS24] we can deactivate the flags for all non-usable rules [FROCOS05]
----------------------------------------

(9)
Obligation:
Probabilistic ADP Problem:
The set of rules with active return value flag is empty.
The ADP Problem has the following rules with annotations:

   APP(cons(x, xs), ys) -> 1 : cons(x, APP(xs, ys))


----------------------------------------

(10) AST_ADPProbabilityRemovalProof (EQUIVALENT)


We use the probability removal processor [FLOPS24].
As all rules have a trivial probability (1:r), we can transform it into a non-probabilistic DP problem
----------------------------------------

(11)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   APP(cons(x, xs), ys) -> APP(xs, ys)

R is empty.
The set Q consists of the following terms:

   rotate(cons(x0, x1))
   leq(0, x0)
   low(x0, nil)
   ifLow(true, x0, cons(x1, x2))
   high(x0, nil)
   leq(s(x0), 0)
   app(nil, x0)
   app(cons(x0, x1), x2)
   rotate(nil)
   qsHelp(cons(x0, x1))
   low(x0, cons(x1, x2))
   leq(s(x0), s(x1))
   qs(nil)
   qs(cons(x0, x1))
   high(x0, cons(x1, x2))
   ifLow(false, x0, cons(x1, x2))
   ifHigh(false, x0, cons(x1, x2))
   ifHigh(true, x0, cons(x1, x2))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(12) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   rotate(cons(x0, x1))
   leq(0, x0)
   low(x0, nil)
   ifLow(true, x0, cons(x1, x2))
   high(x0, nil)
   leq(s(x0), 0)
   app(nil, x0)
   app(cons(x0, x1), x2)
   rotate(nil)
   qsHelp(cons(x0, x1))
   low(x0, cons(x1, x2))
   leq(s(x0), s(x1))
   qs(nil)
   qs(cons(x0, x1))
   high(x0, cons(x1, x2))
   ifLow(false, x0, cons(x1, x2))
   ifHigh(false, x0, cons(x1, x2))
   ifHigh(true, x0, cons(x1, x2))


----------------------------------------

(13)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   APP(cons(x, xs), ys) -> APP(xs, ys)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(14) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*APP(cons(x, xs), ys) -> APP(xs, ys)
The graph contains the following edges 1 > 1, 2 >= 2


----------------------------------------

(15)
YES

----------------------------------------

(16)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   rotate(cons(x, xs)) -> 1 / 2 : cons(x, xs) || 1 / 2 : rotate(app(rotate(xs), cons(x, nil)))
   leq(0, x) -> 1 : true
   low(x, nil) -> 1 : nil
   ifLow(true, x, cons(y, ys)) -> 1 : low(x, ys)
   high(x, nil) -> 1 : nil
   leq(s(x), 0) -> 1 : false
   app(nil, ys) -> 1 : ys
   app(cons(x, xs), ys) -> 1 : cons(x, app(xs, ys))
   rotate(nil) -> 1 : nil
   qsHelp(cons(x, xs)) -> 1 : app(qs(low(x, xs)), cons(x, qs(high(x, xs))))
   low(x, cons(y, ys)) -> 1 : ifLow(leq(x, y), x, cons(y, ys))
   leq(s(x), s(y)) -> 1 : leq(x, y)
   qs(nil) -> 1 : nil
   qs(cons(x, xs)) -> 1 : qsHelp(rotate(cons(x, xs)))
   high(x, cons(y, ys)) -> 1 : ifHigh(leq(x, y), x, cons(y, ys))
   ifLow(false, x, cons(y, ys)) -> 1 : cons(y, low(x, ys))
   ifHigh(false, x, cons(y, ys)) -> 1 : high(x, ys)
   ifHigh(true, x, cons(y, ys)) -> 1 : cons(y, high(x, ys))

The ADP Problem has the following rules with annotations:

   LEQ(s(x), s(y)) -> 1 : LEQ(x, y)


----------------------------------------

(17) AST_ADPUsableRulesProof (EQUIVALENT)


We use the usable rules processor [FLOPS24].
Hence, by the usable rules processor [FLOPS24] we can deactivate the flags for all non-usable rules [FROCOS05]
----------------------------------------

(18)
Obligation:
Probabilistic ADP Problem:
The set of rules with active return value flag is empty.
The ADP Problem has the following rules with annotations:

   LEQ(s(x), s(y)) -> 1 : LEQ(x, y)


----------------------------------------

(19) AST_ADPProbabilityRemovalProof (EQUIVALENT)


We use the probability removal processor [FLOPS24].
As all rules have a trivial probability (1:r), we can transform it into a non-probabilistic DP problem
----------------------------------------

(20)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LEQ(s(x), s(y)) -> LEQ(x, y)

R is empty.
The set Q consists of the following terms:

   rotate(cons(x0, x1))
   leq(0, x0)
   low(x0, nil)
   ifLow(true, x0, cons(x1, x2))
   high(x0, nil)
   leq(s(x0), 0)
   app(nil, x0)
   app(cons(x0, x1), x2)
   rotate(nil)
   qsHelp(cons(x0, x1))
   low(x0, cons(x1, x2))
   leq(s(x0), s(x1))
   qs(nil)
   qs(cons(x0, x1))
   high(x0, cons(x1, x2))
   ifLow(false, x0, cons(x1, x2))
   ifHigh(false, x0, cons(x1, x2))
   ifHigh(true, x0, cons(x1, x2))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(21) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   rotate(cons(x0, x1))
   leq(0, x0)
   low(x0, nil)
   ifLow(true, x0, cons(x1, x2))
   high(x0, nil)
   leq(s(x0), 0)
   app(nil, x0)
   app(cons(x0, x1), x2)
   rotate(nil)
   qsHelp(cons(x0, x1))
   low(x0, cons(x1, x2))
   leq(s(x0), s(x1))
   qs(nil)
   qs(cons(x0, x1))
   high(x0, cons(x1, x2))
   ifLow(false, x0, cons(x1, x2))
   ifHigh(false, x0, cons(x1, x2))
   ifHigh(true, x0, cons(x1, x2))


----------------------------------------

(22)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   LEQ(s(x), s(y)) -> LEQ(x, y)

R is empty.
Q is empty.
We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(23) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*LEQ(s(x), s(y)) -> LEQ(x, y)
The graph contains the following edges 1 > 1, 2 > 2


----------------------------------------

(24)
YES

----------------------------------------

(25)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   rotate(cons(x, xs)) -> 1 / 2 : cons(x, xs) || 1 / 2 : rotate(app(rotate(xs), cons(x, nil)))
   leq(0, x) -> 1 : true
   low(x, nil) -> 1 : nil
   ifLow(true, x, cons(y, ys)) -> 1 : low(x, ys)
   high(x, nil) -> 1 : nil
   leq(s(x), 0) -> 1 : false
   app(nil, ys) -> 1 : ys
   app(cons(x, xs), ys) -> 1 : cons(x, app(xs, ys))
   rotate(nil) -> 1 : nil
   qsHelp(cons(x, xs)) -> 1 : app(qs(low(x, xs)), cons(x, qs(high(x, xs))))
   low(x, cons(y, ys)) -> 1 : ifLow(leq(x, y), x, cons(y, ys))
   leq(s(x), s(y)) -> 1 : leq(x, y)
   qs(nil) -> 1 : nil
   qs(cons(x, xs)) -> 1 : qsHelp(rotate(cons(x, xs)))
   high(x, cons(y, ys)) -> 1 : ifHigh(leq(x, y), x, cons(y, ys))
   ifLow(false, x, cons(y, ys)) -> 1 : cons(y, low(x, ys))
   ifHigh(false, x, cons(y, ys)) -> 1 : high(x, ys)
   ifHigh(true, x, cons(y, ys)) -> 1 : cons(y, high(x, ys))

The ADP Problem has the following rules with annotations:

   IFHIGH(false, x, cons(y, ys)) -> 1 : HIGH(x, ys)
   HIGH(x, cons(y, ys)) -> 1 : IFHIGH(LEQ(x, y), x, cons(y, ys))
   IFHIGH(true, x, cons(y, ys)) -> 1 : cons(y, HIGH(x, ys))


----------------------------------------

(26) AST_ADPUsableTermsProof (EQUIVALENT)


We use the usable terms processor [FLOPS24].
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] gives us the following unusable Terms: 
[LEQ(x, y)]
Hence, we can remove the annotations from these terms from every RHS of every ADP
----------------------------------------

(27)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   rotate(cons(x, xs)) -> 1 / 2 : cons(x, xs) || 1 / 2 : rotate(app(rotate(xs), cons(x, nil)))
   leq(0, x) -> 1 : true
   low(x, nil) -> 1 : nil
   ifLow(true, x, cons(y, ys)) -> 1 : low(x, ys)
   high(x, nil) -> 1 : nil
   leq(s(x), 0) -> 1 : false
   app(nil, ys) -> 1 : ys
   app(cons(x, xs), ys) -> 1 : cons(x, app(xs, ys))
   rotate(nil) -> 1 : nil
   qsHelp(cons(x, xs)) -> 1 : app(qs(low(x, xs)), cons(x, qs(high(x, xs))))
   low(x, cons(y, ys)) -> 1 : ifLow(leq(x, y), x, cons(y, ys))
   leq(s(x), s(y)) -> 1 : leq(x, y)
   qs(nil) -> 1 : nil
   qs(cons(x, xs)) -> 1 : qsHelp(rotate(cons(x, xs)))
   high(x, cons(y, ys)) -> 1 : ifHigh(leq(x, y), x, cons(y, ys))
   ifLow(false, x, cons(y, ys)) -> 1 : cons(y, low(x, ys))
   ifHigh(false, x, cons(y, ys)) -> 1 : high(x, ys)
   ifHigh(true, x, cons(y, ys)) -> 1 : cons(y, high(x, ys))

The ADP Problem has the following rules with annotations:

   IFHIGH(false, x, cons(y, ys)) -> 1 : HIGH(x, ys)
   IFHIGH(true, x, cons(y, ys)) -> 1 : cons(y, HIGH(x, ys))
   HIGH(x, cons(y, ys)) -> 1 : IFHIGH(leq(x, y), x, cons(y, ys))


----------------------------------------

(28) AST_ADPUsableRulesProof (EQUIVALENT)


We use the usable rules processor [FLOPS24].
Hence, by the usable rules processor [FLOPS24] we can deactivate the flags for all non-usable rules [FROCOS05]
----------------------------------------

(29)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   leq(0, x) -> 1 : true
   leq(s(x), 0) -> 1 : false
   leq(s(x), s(y)) -> 1 : leq(x, y)

The ADP Problem has the following rules with annotations:

   IFHIGH(false, x, cons(y, ys)) -> 1 : HIGH(x, ys)
   IFHIGH(true, x, cons(y, ys)) -> 1 : cons(y, HIGH(x, ys))
   HIGH(x, cons(y, ys)) -> 1 : IFHIGH(leq(x, y), x, cons(y, ys))


----------------------------------------

(30) AST_ADPProbabilityRemovalProof (EQUIVALENT)


We use the probability removal processor [FLOPS24].
As all rules have a trivial probability (1:r), we can transform it into a non-probabilistic DP problem
----------------------------------------

(31)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IFHIGH(true, x, cons(y, ys)) -> HIGH(x, ys)
   IFHIGH(false, x, cons(y, ys)) -> HIGH(x, ys)
   HIGH(x, cons(y, ys)) -> IFHIGH(leq(x, y), x, cons(y, ys))

The TRS R consists of the following rules:

   leq(0, x) -> true
   leq(s(x), 0) -> false
   leq(s(x), s(y)) -> leq(x, y)

The set Q consists of the following terms:

   rotate(cons(x0, x1))
   leq(0, x0)
   low(x0, nil)
   ifLow(true, x0, cons(x1, x2))
   high(x0, nil)
   leq(s(x0), 0)
   app(nil, x0)
   app(cons(x0, x1), x2)
   rotate(nil)
   qsHelp(cons(x0, x1))
   low(x0, cons(x1, x2))
   leq(s(x0), s(x1))
   qs(nil)
   qs(cons(x0, x1))
   high(x0, cons(x1, x2))
   ifLow(false, x0, cons(x1, x2))
   ifHigh(false, x0, cons(x1, x2))
   ifHigh(true, x0, cons(x1, x2))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(32) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   rotate(cons(x0, x1))
   low(x0, nil)
   ifLow(true, x0, cons(x1, x2))
   high(x0, nil)
   app(nil, x0)
   app(cons(x0, x1), x2)
   rotate(nil)
   qsHelp(cons(x0, x1))
   low(x0, cons(x1, x2))
   qs(nil)
   qs(cons(x0, x1))
   high(x0, cons(x1, x2))
   ifLow(false, x0, cons(x1, x2))
   ifHigh(false, x0, cons(x1, x2))
   ifHigh(true, x0, cons(x1, x2))


----------------------------------------

(33)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IFHIGH(true, x, cons(y, ys)) -> HIGH(x, ys)
   IFHIGH(false, x, cons(y, ys)) -> HIGH(x, ys)
   HIGH(x, cons(y, ys)) -> IFHIGH(leq(x, y), x, cons(y, ys))

The TRS R consists of the following rules:

   leq(0, x) -> true
   leq(s(x), 0) -> false
   leq(s(x), s(y)) -> leq(x, y)

The set Q consists of the following terms:

   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(34) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*HIGH(x, cons(y, ys)) -> IFHIGH(leq(x, y), x, cons(y, ys))
The graph contains the following edges 1 >= 2, 2 >= 3


*IFHIGH(true, x, cons(y, ys)) -> HIGH(x, ys)
The graph contains the following edges 2 >= 1, 3 > 2


*IFHIGH(false, x, cons(y, ys)) -> HIGH(x, ys)
The graph contains the following edges 2 >= 1, 3 > 2


----------------------------------------

(35)
YES

----------------------------------------

(36)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   rotate(cons(x, xs)) -> 1 / 2 : cons(x, xs) || 1 / 2 : rotate(app(rotate(xs), cons(x, nil)))
   leq(0, x) -> 1 : true
   low(x, nil) -> 1 : nil
   ifLow(true, x, cons(y, ys)) -> 1 : low(x, ys)
   high(x, nil) -> 1 : nil
   leq(s(x), 0) -> 1 : false
   app(nil, ys) -> 1 : ys
   app(cons(x, xs), ys) -> 1 : cons(x, app(xs, ys))
   rotate(nil) -> 1 : nil
   qsHelp(cons(x, xs)) -> 1 : app(qs(low(x, xs)), cons(x, qs(high(x, xs))))
   low(x, cons(y, ys)) -> 1 : ifLow(leq(x, y), x, cons(y, ys))
   leq(s(x), s(y)) -> 1 : leq(x, y)
   qs(nil) -> 1 : nil
   qs(cons(x, xs)) -> 1 : qsHelp(rotate(cons(x, xs)))
   high(x, cons(y, ys)) -> 1 : ifHigh(leq(x, y), x, cons(y, ys))
   ifLow(false, x, cons(y, ys)) -> 1 : cons(y, low(x, ys))
   ifHigh(false, x, cons(y, ys)) -> 1 : high(x, ys)
   ifHigh(true, x, cons(y, ys)) -> 1 : cons(y, high(x, ys))

The ADP Problem has the following rules with annotations:

   IFLOW(true, x, cons(y, ys)) -> 1 : LOW(x, ys)
   LOW(x, cons(y, ys)) -> 1 : IFLOW(LEQ(x, y), x, cons(y, ys))
   IFLOW(false, x, cons(y, ys)) -> 1 : cons(y, LOW(x, ys))


----------------------------------------

(37) AST_ADPUsableTermsProof (EQUIVALENT)


We use the usable terms processor [FLOPS24].
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] gives us the following unusable Terms: 
[LEQ(x, y)]
Hence, we can remove the annotations from these terms from every RHS of every ADP
----------------------------------------

(38)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   rotate(cons(x, xs)) -> 1 / 2 : cons(x, xs) || 1 / 2 : rotate(app(rotate(xs), cons(x, nil)))
   leq(0, x) -> 1 : true
   low(x, nil) -> 1 : nil
   ifLow(true, x, cons(y, ys)) -> 1 : low(x, ys)
   high(x, nil) -> 1 : nil
   leq(s(x), 0) -> 1 : false
   app(nil, ys) -> 1 : ys
   app(cons(x, xs), ys) -> 1 : cons(x, app(xs, ys))
   rotate(nil) -> 1 : nil
   qsHelp(cons(x, xs)) -> 1 : app(qs(low(x, xs)), cons(x, qs(high(x, xs))))
   low(x, cons(y, ys)) -> 1 : ifLow(leq(x, y), x, cons(y, ys))
   leq(s(x), s(y)) -> 1 : leq(x, y)
   qs(nil) -> 1 : nil
   qs(cons(x, xs)) -> 1 : qsHelp(rotate(cons(x, xs)))
   high(x, cons(y, ys)) -> 1 : ifHigh(leq(x, y), x, cons(y, ys))
   ifLow(false, x, cons(y, ys)) -> 1 : cons(y, low(x, ys))
   ifHigh(false, x, cons(y, ys)) -> 1 : high(x, ys)
   ifHigh(true, x, cons(y, ys)) -> 1 : cons(y, high(x, ys))

The ADP Problem has the following rules with annotations:

   LOW(x, cons(y, ys)) -> 1 : IFLOW(leq(x, y), x, cons(y, ys))
   IFLOW(false, x, cons(y, ys)) -> 1 : cons(y, LOW(x, ys))
   IFLOW(true, x, cons(y, ys)) -> 1 : LOW(x, ys)


----------------------------------------

(39) AST_ADPUsableRulesProof (EQUIVALENT)


We use the usable rules processor [FLOPS24].
Hence, by the usable rules processor [FLOPS24] we can deactivate the flags for all non-usable rules [FROCOS05]
----------------------------------------

(40)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   leq(0, x) -> 1 : true
   leq(s(x), 0) -> 1 : false
   leq(s(x), s(y)) -> 1 : leq(x, y)

The ADP Problem has the following rules with annotations:

   LOW(x, cons(y, ys)) -> 1 : IFLOW(leq(x, y), x, cons(y, ys))
   IFLOW(false, x, cons(y, ys)) -> 1 : cons(y, LOW(x, ys))
   IFLOW(true, x, cons(y, ys)) -> 1 : LOW(x, ys)


----------------------------------------

(41) AST_ADPProbabilityRemovalProof (EQUIVALENT)


We use the probability removal processor [FLOPS24].
As all rules have a trivial probability (1:r), we can transform it into a non-probabilistic DP problem
----------------------------------------

(42)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IFLOW(false, x, cons(y, ys)) -> LOW(x, ys)
   LOW(x, cons(y, ys)) -> IFLOW(leq(x, y), x, cons(y, ys))
   IFLOW(true, x, cons(y, ys)) -> LOW(x, ys)

The TRS R consists of the following rules:

   leq(0, x) -> true
   leq(s(x), 0) -> false
   leq(s(x), s(y)) -> leq(x, y)

The set Q consists of the following terms:

   rotate(cons(x0, x1))
   leq(0, x0)
   low(x0, nil)
   ifLow(true, x0, cons(x1, x2))
   high(x0, nil)
   leq(s(x0), 0)
   app(nil, x0)
   app(cons(x0, x1), x2)
   rotate(nil)
   qsHelp(cons(x0, x1))
   low(x0, cons(x1, x2))
   leq(s(x0), s(x1))
   qs(nil)
   qs(cons(x0, x1))
   high(x0, cons(x1, x2))
   ifLow(false, x0, cons(x1, x2))
   ifHigh(false, x0, cons(x1, x2))
   ifHigh(true, x0, cons(x1, x2))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(43) QReductionProof (EQUIVALENT)
We deleted the following terms from Q as each root-symbol of these terms does neither occur in P nor in R.[THIEMANN].

   rotate(cons(x0, x1))
   low(x0, nil)
   ifLow(true, x0, cons(x1, x2))
   high(x0, nil)
   app(nil, x0)
   app(cons(x0, x1), x2)
   rotate(nil)
   qsHelp(cons(x0, x1))
   low(x0, cons(x1, x2))
   qs(nil)
   qs(cons(x0, x1))
   high(x0, cons(x1, x2))
   ifLow(false, x0, cons(x1, x2))
   ifHigh(false, x0, cons(x1, x2))
   ifHigh(true, x0, cons(x1, x2))


----------------------------------------

(44)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   IFLOW(false, x, cons(y, ys)) -> LOW(x, ys)
   LOW(x, cons(y, ys)) -> IFLOW(leq(x, y), x, cons(y, ys))
   IFLOW(true, x, cons(y, ys)) -> LOW(x, ys)

The TRS R consists of the following rules:

   leq(0, x) -> true
   leq(s(x), 0) -> false
   leq(s(x), s(y)) -> leq(x, y)

The set Q consists of the following terms:

   leq(0, x0)
   leq(s(x0), 0)
   leq(s(x0), s(x1))

We have to consider all minimal (P,Q,R)-chains.
----------------------------------------

(45) QDPSizeChangeProof (EQUIVALENT)
By using the subterm criterion [SUBTERM_CRITERION] together with the size-change analysis [AAECC05] we have proven that there are no infinite chains for this DP problem. 

From the DPs we obtained the following set of size-change graphs:
*LOW(x, cons(y, ys)) -> IFLOW(leq(x, y), x, cons(y, ys))
The graph contains the following edges 1 >= 2, 2 >= 3


*IFLOW(false, x, cons(y, ys)) -> LOW(x, ys)
The graph contains the following edges 2 >= 1, 3 > 2


*IFLOW(true, x, cons(y, ys)) -> LOW(x, ys)
The graph contains the following edges 2 >= 1, 3 > 2


----------------------------------------

(46)
YES

----------------------------------------

(47)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   rotate(cons(x, xs)) -> 1 / 2 : cons(x, xs) || 1 / 2 : rotate(app(rotate(xs), cons(x, nil)))
   leq(0, x) -> 1 : true
   low(x, nil) -> 1 : nil
   ifLow(true, x, cons(y, ys)) -> 1 : low(x, ys)
   high(x, nil) -> 1 : nil
   leq(s(x), 0) -> 1 : false
   app(nil, ys) -> 1 : ys
   app(cons(x, xs), ys) -> 1 : cons(x, app(xs, ys))
   rotate(nil) -> 1 : nil
   qsHelp(cons(x, xs)) -> 1 : app(qs(low(x, xs)), cons(x, qs(high(x, xs))))
   low(x, cons(y, ys)) -> 1 : ifLow(leq(x, y), x, cons(y, ys))
   leq(s(x), s(y)) -> 1 : leq(x, y)
   qs(nil) -> 1 : nil
   qs(cons(x, xs)) -> 1 : qsHelp(rotate(cons(x, xs)))
   high(x, cons(y, ys)) -> 1 : ifHigh(leq(x, y), x, cons(y, ys))
   ifLow(false, x, cons(y, ys)) -> 1 : cons(y, low(x, ys))
   ifHigh(false, x, cons(y, ys)) -> 1 : high(x, ys)
   ifHigh(true, x, cons(y, ys)) -> 1 : cons(y, high(x, ys))

The ADP Problem has the following rules with annotations:

   ROTATE(cons(x, xs)) -> 1 / 2 : cons(x, xs) || 1 / 2 : ROTATE(APP(ROTATE(xs), cons(x, nil)))


----------------------------------------

(48) AST_ADPUsableTermsProof (EQUIVALENT)


We use the usable terms processor [FLOPS24].
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] gives us the following unusable Terms: 
[APP(rotate(xs), cons(x, nil))]
Hence, we can remove the annotations from these terms from every RHS of every ADP
----------------------------------------

(49)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   rotate(cons(x, xs)) -> 1 / 2 : cons(x, xs) || 1 / 2 : rotate(app(rotate(xs), cons(x, nil)))
   leq(0, x) -> 1 : true
   low(x, nil) -> 1 : nil
   ifLow(true, x, cons(y, ys)) -> 1 : low(x, ys)
   high(x, nil) -> 1 : nil
   leq(s(x), 0) -> 1 : false
   app(nil, ys) -> 1 : ys
   app(cons(x, xs), ys) -> 1 : cons(x, app(xs, ys))
   rotate(nil) -> 1 : nil
   qsHelp(cons(x, xs)) -> 1 : app(qs(low(x, xs)), cons(x, qs(high(x, xs))))
   low(x, cons(y, ys)) -> 1 : ifLow(leq(x, y), x, cons(y, ys))
   leq(s(x), s(y)) -> 1 : leq(x, y)
   qs(nil) -> 1 : nil
   qs(cons(x, xs)) -> 1 : qsHelp(rotate(cons(x, xs)))
   high(x, cons(y, ys)) -> 1 : ifHigh(leq(x, y), x, cons(y, ys))
   ifLow(false, x, cons(y, ys)) -> 1 : cons(y, low(x, ys))
   ifHigh(false, x, cons(y, ys)) -> 1 : high(x, ys)
   ifHigh(true, x, cons(y, ys)) -> 1 : cons(y, high(x, ys))

The ADP Problem has the following rules with annotations:

   ROTATE(cons(x, xs)) -> 1 / 2 : cons(x, xs) || 1 / 2 : ROTATE(app(ROTATE(xs), cons(x, nil)))


----------------------------------------

(50) AST_ADPUsableRulesProof (EQUIVALENT)


We use the usable rules processor [FLOPS24].
Hence, by the usable rules processor [FLOPS24] we can deactivate the flags for all non-usable rules [FROCOS05]
----------------------------------------

(51)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   rotate(cons(x, xs)) -> 1 / 2 : cons(x, xs) || 1 / 2 : rotate(app(rotate(xs), cons(x, nil)))
   rotate(nil) -> 1 : nil
   app(nil, ys) -> 1 : ys
   app(cons(x, xs), ys) -> 1 : cons(x, app(xs, ys))

The ADP Problem has the following rules with annotations:

   ROTATE(cons(x, xs)) -> 1 / 2 : cons(x, xs) || 1 / 2 : ROTATE(app(ROTATE(xs), cons(x, nil)))


----------------------------------------

(52) AST_ADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [FLOPS24].
The following pairs can be oriented strictly and we delete all annotations:

   ROTATE(cons(x, xs)) -> 1 / 2 : cons(x, xs) || 1 / 2 : ROTATE(app(ROTATE(xs), cons(x, nil)))

The remaining pairs can at least be oriented weakly:
none

Used ordering:  Polynomial interpretation [POLO]:

   POL(ROTATE(x_1)) = 2
   POL(app(x_1, x_2)) = x_2
   POL(cons(x_1, x_2)) = 0
   POL(nil) = 0
   POL(rotate(x_1)) = 0

----------------------------------------

(53)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   rotate(cons(x, xs)) -> 1 / 2 : cons(x, xs) || 1 / 2 : rotate(app(rotate(xs), cons(x, nil)))
   rotate(nil) -> 1 : nil
   app(nil, ys) -> 1 : ys
   app(cons(x, xs), ys) -> 1 : cons(x, app(xs, ys))

The set of rules with annotations is empty.

----------------------------------------

(54) PisEmptyProof (EQUIVALENT)
P contains no annotations anymore. Hence, there exists no infinite P-CT.
----------------------------------------

(55)
YES

----------------------------------------

(56)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   rotate(cons(x, xs)) -> 1 / 2 : cons(x, xs) || 1 / 2 : rotate(app(rotate(xs), cons(x, nil)))
   leq(0, x) -> 1 : true
   low(x, nil) -> 1 : nil
   ifLow(true, x, cons(y, ys)) -> 1 : low(x, ys)
   high(x, nil) -> 1 : nil
   leq(s(x), 0) -> 1 : false
   app(nil, ys) -> 1 : ys
   app(cons(x, xs), ys) -> 1 : cons(x, app(xs, ys))
   rotate(nil) -> 1 : nil
   qsHelp(cons(x, xs)) -> 1 : app(qs(low(x, xs)), cons(x, qs(high(x, xs))))
   low(x, cons(y, ys)) -> 1 : ifLow(leq(x, y), x, cons(y, ys))
   leq(s(x), s(y)) -> 1 : leq(x, y)
   qs(nil) -> 1 : nil
   qs(cons(x, xs)) -> 1 : qsHelp(rotate(cons(x, xs)))
   high(x, cons(y, ys)) -> 1 : ifHigh(leq(x, y), x, cons(y, ys))
   ifLow(false, x, cons(y, ys)) -> 1 : cons(y, low(x, ys))
   ifHigh(false, x, cons(y, ys)) -> 1 : high(x, ys)
   ifHigh(true, x, cons(y, ys)) -> 1 : cons(y, high(x, ys))

The ADP Problem has the following rules with annotations:

   QSHELP(cons(x, xs)) -> 1 : APP(QS(LOW(x, xs)), cons(x, QS(HIGH(x, xs))))
   QS(cons(x, xs)) -> 1 : QSHELP(ROTATE(cons(x, xs)))


----------------------------------------

(57) AST_ADPUsableTermsProof (EQUIVALENT)


We use the usable terms processor [FLOPS24].
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] gives us the following unusable Terms: 
[HIGH(x, xs), ROTATE(cons(x, xs)), LOW(x, xs), APP(qs(low(x, xs)), cons(x, qs(high(x, xs))))]
Hence, we can remove the annotations from these terms from every RHS of every ADP
----------------------------------------

(58)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   rotate(cons(x, xs)) -> 1 / 2 : cons(x, xs) || 1 / 2 : rotate(app(rotate(xs), cons(x, nil)))
   leq(0, x) -> 1 : true
   low(x, nil) -> 1 : nil
   ifLow(true, x, cons(y, ys)) -> 1 : low(x, ys)
   high(x, nil) -> 1 : nil
   leq(s(x), 0) -> 1 : false
   app(nil, ys) -> 1 : ys
   app(cons(x, xs), ys) -> 1 : cons(x, app(xs, ys))
   rotate(nil) -> 1 : nil
   qsHelp(cons(x, xs)) -> 1 : app(qs(low(x, xs)), cons(x, qs(high(x, xs))))
   low(x, cons(y, ys)) -> 1 : ifLow(leq(x, y), x, cons(y, ys))
   leq(s(x), s(y)) -> 1 : leq(x, y)
   qs(nil) -> 1 : nil
   qs(cons(x, xs)) -> 1 : qsHelp(rotate(cons(x, xs)))
   high(x, cons(y, ys)) -> 1 : ifHigh(leq(x, y), x, cons(y, ys))
   ifLow(false, x, cons(y, ys)) -> 1 : cons(y, low(x, ys))
   ifHigh(false, x, cons(y, ys)) -> 1 : high(x, ys)
   ifHigh(true, x, cons(y, ys)) -> 1 : cons(y, high(x, ys))

The ADP Problem has the following rules with annotations:

   QSHELP(cons(x, xs)) -> 1 : app(QS(low(x, xs)), cons(x, QS(high(x, xs))))
   QS(cons(x, xs)) -> 1 : QSHELP(rotate(cons(x, xs)))


----------------------------------------

(59) AST_ADPUsableRulesProof (EQUIVALENT)


We use the usable rules processor [FLOPS24].
Hence, by the usable rules processor [FLOPS24] we can deactivate the flags for all non-usable rules [FROCOS05]
----------------------------------------

(60)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   rotate(cons(x, xs)) -> 1 / 2 : cons(x, xs) || 1 / 2 : rotate(app(rotate(xs), cons(x, nil)))
   rotate(nil) -> 1 : nil
   app(nil, ys) -> 1 : ys
   app(cons(x, xs), ys) -> 1 : cons(x, app(xs, ys))
   low(x, nil) -> 1 : nil
   low(x, cons(y, ys)) -> 1 : ifLow(leq(x, y), x, cons(y, ys))
   ifLow(true, x, cons(y, ys)) -> 1 : low(x, ys)
   high(x, nil) -> 1 : nil
   high(x, cons(y, ys)) -> 1 : ifHigh(leq(x, y), x, cons(y, ys))
   ifHigh(false, x, cons(y, ys)) -> 1 : high(x, ys)
   leq(0, x) -> 1 : true
   leq(s(x), 0) -> 1 : false
   leq(s(x), s(y)) -> 1 : leq(x, y)
   ifHigh(true, x, cons(y, ys)) -> 1 : cons(y, high(x, ys))
   ifLow(false, x, cons(y, ys)) -> 1 : cons(y, low(x, ys))

The ADP Problem has the following rules with annotations:

   QSHELP(cons(x, xs)) -> 1 : app(QS(low(x, xs)), cons(x, QS(high(x, xs))))
   QS(cons(x, xs)) -> 1 : QSHELP(rotate(cons(x, xs)))


----------------------------------------

(61) AST_ADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [FLOPS24].
The following pairs can be oriented strictly and we delete all annotations:

   QSHELP(cons(x, xs)) -> 1 : app(QS(low(x, xs)), cons(x, QS(high(x, xs))))

The remaining pairs can at least be oriented weakly:

   QS(cons(x, xs)) -> 1 : QSHELP(rotate(cons(x, xs)))

Used ordering:  Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(QS(x_1)) = x_1
   POL(QSHELP(x_1)) = x_1
   POL(app(x_1, x_2)) = x_1 + x_1*x_2 + x_2
   POL(cons(x_1, x_2)) = 1 + 2*x_2
   POL(false) = 0
   POL(high(x_1, x_2)) = x_2
   POL(ifHigh(x_1, x_2, x_3)) = x_3
   POL(ifLow(x_1, x_2, x_3)) = x_3
   POL(leq(x_1, x_2)) = 0
   POL(low(x_1, x_2)) = x_2
   POL(nil) = 0
   POL(rotate(x_1)) = x_1
   POL(s(x_1)) = 0
   POL(true) = 0

----------------------------------------

(62)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   rotate(cons(x, xs)) -> 1 / 2 : cons(x, xs) || 1 / 2 : rotate(app(rotate(xs), cons(x, nil)))
   rotate(nil) -> 1 : nil
   app(nil, ys) -> 1 : ys
   app(cons(x, xs), ys) -> 1 : cons(x, app(xs, ys))
   low(x, nil) -> 1 : nil
   low(x, cons(y, ys)) -> 1 : ifLow(leq(x, y), x, cons(y, ys))
   ifLow(true, x, cons(y, ys)) -> 1 : low(x, ys)
   high(x, nil) -> 1 : nil
   high(x, cons(y, ys)) -> 1 : ifHigh(leq(x, y), x, cons(y, ys))
   ifHigh(false, x, cons(y, ys)) -> 1 : high(x, ys)
   leq(0, x) -> 1 : true
   leq(s(x), 0) -> 1 : false
   leq(s(x), s(y)) -> 1 : leq(x, y)
   ifHigh(true, x, cons(y, ys)) -> 1 : cons(y, high(x, ys))
   ifLow(false, x, cons(y, ys)) -> 1 : cons(y, low(x, ys))

The ADP Problem has the following rules with annotations:

   QS(cons(x, xs)) -> 1 : QSHELP(rotate(cons(x, xs)))


----------------------------------------

(63) AST_ADPDependencyGraphProof (EQUIVALENT)


We use the dependency graph processor [FLOPS24].
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 1 less node.
----------------------------------------

(64)
TRUE
