SAST
proof of /home/ff862203/input_V4RoASsxFh.ari
# AProVE Commit ID: 1c9e2a6453f9f0dca490585733f1cff3767d3e54 jan-christoph 20250828 unpublished


Complexity of the given CpxPTRS could be proven:

(0) CpxPTRS
(1) CpxPTRS_DerivationToRuntimeComplexityProof [UNSOUND LOWER BOUND(ID)SOUND UPPER BOUND(ID), 0 ms]
(2) CpxPTRS
(3) CpxPTRS_ToPQTRSProof [BOTH BOUNDS(ID, ID), 0 ms]
(4) PQTRS
(5) CpxPQTRS_ToADPProblemProof [BOTH BOUNDS(ID, ID), 0 ms]
(6) ADP
(7) CpxADP_SCCSplitProof [UPPER BOUND(ID), 3 ms]
(8) MAX
    (9) ADP
        (10) CpxADP_UsableTermsProof [UPPER BOUND(ID), 0 ms]
        (11) ADP
        (12) CpxADP_UsableRulesProof [BOTH BOUNDS(ID, ID), 0 ms]
        (13) ADP
        (14) CpxADP_ProbabilityRemovalProof [UPPER BOUND(ID), 0 ms]
        (15) CdtProblem
        (16) CdtLeafRemovalProof [ComplexityIfPolyImplication, 0 ms]
        (17) CdtProblem
        (18) CdtToCpxRelTrsProof [BOTH BOUNDS(ID, ID), 0 ms]
        (19) CpxTRS
        (20) RelTrsToTrsProof [UPPER BOUND(ID), 0 ms]
        (21) CpxTRS
        (22) CpxTrsMatchBoundsTAProof [FINISHED, 0 ms]
        (23) BOUNDS(1, n^1)
    (24) ADP
        (25) CpxADP_UsableTermsProof [UPPER BOUND(ID), 3 ms]
        (26) ADP
        (27) CpxADP_UsableRulesProof [BOTH BOUNDS(ID, ID), 0 ms]
        (28) ADP
        (29) CpxADP_ReductionPairProof [UPPER BOUND(ADD(n^1)), 2 ms]
        (30) ADP
        (31) SisEmptyProof [FINISHED, 0 ms]
        (32) BOUNDS(1, 1)


----------------------------------------

(0)
Obligation:
Probabilistic term rewrite system:
The TRS has the following probabilistic rules:

   g -> 1 / 2 : O || 1 / 2 : h(g)
   h(x) -> 1 : f(x, x, x)

and uses the innermost rewrite strategy.

----------------------------------------

(1) CpxPTRS_DerivationToRuntimeComplexityProof (UNSOUND LOWER BOUND(ID)SOUND UPPER BOUND(ID))
The following rules have been added to R to convert the given derivational complexity problem to a runtime complexity problem:

   encArg(f(x_1, x_2, x_3)) -> 1 : f(encArg(x_1), encArg(x_2), encArg(x_3))
   encArg(O) -> 1 : O
   encArg(cons_h(x_1)) -> 1 : h(encArg(x_1))
   encArg(cons_g) -> 1 : g
   encode_h(x_1) -> 1 : h(encArg(x_1))
   encode_f(x_1, x_2, x_3) -> 1 : f(encArg(x_1), encArg(x_2), encArg(x_3))
   encode_g -> 1 : g
   encode_O -> 1 : O


----------------------------------------

(2)
Obligation:
Probabilistic term rewrite system:
The TRS has the following probabilistic rules:

   encArg(f(x_1, x_2, x_3)) -> 1 : f(encArg(x_1), encArg(x_2), encArg(x_3))
   encArg(O) -> 1 : O
   encArg(cons_h(x_1)) -> 1 : h(encArg(x_1))
   encArg(cons_g) -> 1 : g
   encode_h(x_1) -> 1 : h(encArg(x_1))
   encode_f(x_1, x_2, x_3) -> 1 : f(encArg(x_1), encArg(x_2), encArg(x_3))
   encode_g -> 1 : g
   encode_O -> 1 : O
   g -> 1 / 2 : O || 1 / 2 : h(g)
   h(x) -> 1 : f(x, x, x)

and uses the innermost rewrite strategy.

----------------------------------------

(3) CpxPTRS_ToPQTRSProof (BOTH BOUNDS(ID, ID))
Transformed PTRS into PQTRS. Q is:
   encArg(f(x_1, x_2, x_3)), encArg(O), encArg(cons_h(x_1)), encArg(cons_g), encode_h(x_1), encode_f(x_1, x_2, x_3), encode_g, encode_O, g, h(x)
----------------------------------------

(4)
Obligation:
Probabilistic Q term rewrite system:
The PQTRS has the following probabilistic rules:

   encArg(f(x_1, x_2, x_3)) -> 1 : f(encArg(x_1), encArg(x_2), encArg(x_3))
   encArg(O) -> 1 : O
   encArg(cons_h(x_1)) -> 1 : h(encArg(x_1))
   encArg(cons_g) -> 1 : g
   encode_h(x_1) -> 1 : h(encArg(x_1))
   encode_f(x_1, x_2, x_3) -> 1 : f(encArg(x_1), encArg(x_2), encArg(x_3))
   encode_g -> 1 : g
   encode_O -> 1 : O
   g -> 1 / 2 : O || 1 / 2 : h(g)
   h(x) -> 1 : f(x, x, x)

And Q contains the following terms:
   encArg(f(x0, x1, x2)), encArg(O), encArg(cons_h(x0)), encArg(cons_g), encode_h(x0), encode_f(x0, x1, x2), encode_g, encode_O, g, h(x0)

----------------------------------------

(5) CpxPQTRS_ToADPProblemProof (BOTH BOUNDS(ID, ID))


The complexity of a PQTRS (R,Q) is equivalent to the complexity of the ADP Problem A(R) (Chain-Criterion) (Leon's master's thesis).
The ADPs are:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(f(x_1, x_2, x_3)) -> 1 : f(encArg(x_1), encArg(x_2), encArg(x_3))
   encArg(O) -> 1 : O
   encArg(cons_h(x_1)) -> 1 : h(encArg(x_1))
   encArg(cons_g) -> 1 : g
   encode_h(x_1) -> 1 : h(encArg(x_1))
   encode_f(x_1, x_2, x_3) -> 1 : f(encArg(x_1), encArg(x_2), encArg(x_3))
   encode_g -> 1 : g
   encode_O -> 1 : O
   g -> 1 / 2 : O || 1 / 2 : h(g)
   h(x) -> 1 : f(x, x, x)

Rules with annotation in P:

   ENCARG(f(x_1, x_2, x_3)) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(O) -> 1 : O
   ENCARG(cons_h(x_1)) -> 1 : H(ENCARG(x_1))
   ENCARG(cons_g) -> 1 : G
   ENCODE_H(x_1) -> 1 : H(ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCODE_G -> 1 : G
   ENCODE_O -> 1 : O
   G -> 1 / 2 : O || 1 / 2 : H(G)
   H(x) -> 1 : f(x, x, x)

Rules with annotation in S:

   ENCARG(f(x_1, x_2, x_3)) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(O) -> 1 : O
   ENCARG(cons_h(x_1)) -> 1 : H(ENCARG(x_1))
   ENCARG(cons_g) -> 1 : G
   ENCODE_H(x_1) -> 1 : H(ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCODE_G -> 1 : G
   ENCODE_O -> 1 : O
   G -> 1 / 2 : O || 1 / 2 : H(G)
   H(x) -> 1 : f(x, x, x)

Rules with annotation and a known complexity:

   none

----------------------------------------

(6)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(f(x_1, x_2, x_3)) -> 1 : f(encArg(x_1), encArg(x_2), encArg(x_3))
   encArg(O) -> 1 : O
   encArg(cons_h(x_1)) -> 1 : h(encArg(x_1))
   encArg(cons_g) -> 1 : g
   encode_h(x_1) -> 1 : h(encArg(x_1))
   encode_f(x_1, x_2, x_3) -> 1 : f(encArg(x_1), encArg(x_2), encArg(x_3))
   encode_g -> 1 : g
   encode_O -> 1 : O
   g -> 1 / 2 : O || 1 / 2 : h(g)
   h(x) -> 1 : f(x, x, x)

Rules with annotation in P:

   ENCARG(f(x_1, x_2, x_3)) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(O) -> 1 : O
   ENCARG(cons_h(x_1)) -> 1 : H(ENCARG(x_1))
   ENCARG(cons_g) -> 1 : G
   ENCODE_H(x_1) -> 1 : H(ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCODE_G -> 1 : G
   ENCODE_O -> 1 : O
   G -> 1 / 2 : O || 1 / 2 : H(G)
   H(x) -> 1 : f(x, x, x)

Rules with annotation in S:

   ENCARG(f(x_1, x_2, x_3)) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(O) -> 1 : O
   ENCARG(cons_h(x_1)) -> 1 : H(ENCARG(x_1))
   ENCARG(cons_g) -> 1 : G
   ENCODE_H(x_1) -> 1 : H(ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCODE_G -> 1 : G
   ENCODE_O -> 1 : O
   G -> 1 / 2 : O || 1 / 2 : H(G)
   H(x) -> 1 : f(x, x, x)

Rules with annotation and a known complexity:

   none

----------------------------------------

(7) CpxADP_SCCSplitProof (UPPER BOUND(ID))
As part of the dependency graph processor, we can split problem in 2 new components.
----------------------------------------

(8)
Complex Obligation (MAX)

----------------------------------------

(9)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(f(x_1, x_2, x_3)) -> 1 : f(encArg(x_1), encArg(x_2), encArg(x_3))
   encArg(O) -> 1 : O
   encArg(cons_h(x_1)) -> 1 : h(encArg(x_1))
   encArg(cons_g) -> 1 : g
   encode_h(x_1) -> 1 : h(encArg(x_1))
   encode_f(x_1, x_2, x_3) -> 1 : f(encArg(x_1), encArg(x_2), encArg(x_3))
   encode_g -> 1 : g
   encode_O -> 1 : O
   g -> 1 / 2 : O || 1 / 2 : h(g)
   h(x) -> 1 : f(x, x, x)

Rules with annotation in P:

   ENCODE_H(x_1) -> 1 : H(ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(cons_h(x_1)) -> 1 : H(ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))

Rules with annotation in S:

   ENCARG(cons_h(x_1)) -> 1 : H(ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))

Rules with annotation and a known complexity:

   ENCODE_H(x_1) -> 1 : H(ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))


----------------------------------------

(10) CpxADP_UsableTermsProof (UPPER BOUND(ID))


The approximation of the Dependency Graph  gives us the following unusable Terms: 
   H(encArg(x_1))
Hence, as part of the dependency graph processor, we can remove the annotations from these terms from every RHS of every ADP in P and S.

----------------------------------------

(11)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(f(x_1, x_2, x_3)) -> 1 : f(encArg(x_1), encArg(x_2), encArg(x_3))
   encArg(O) -> 1 : O
   encArg(cons_h(x_1)) -> 1 : h(encArg(x_1))
   encArg(cons_g) -> 1 : g
   encode_h(x_1) -> 1 : h(encArg(x_1))
   encode_f(x_1, x_2, x_3) -> 1 : f(encArg(x_1), encArg(x_2), encArg(x_3))
   encode_g -> 1 : g
   encode_O -> 1 : O
   g -> 1 / 2 : O || 1 / 2 : h(g)
   h(x) -> 1 : f(x, x, x)

Rules with annotation in P:

   ENCODE_H(x_1) -> 1 : h(ENCARG(x_1))
   ENCARG(cons_h(x_1)) -> 1 : h(ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(f(x_1, x_2, x_3)) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))

Rules with annotation in S:

   ENCARG(cons_h(x_1)) -> 1 : h(ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))

Rules with annotation and a known complexity:

   ENCODE_H(x_1) -> 1 : h(ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))


----------------------------------------

(12) CpxADP_UsableRulesProof (BOTH BOUNDS(ID, ID))


We use the usable rules processor.
We can deactivate the flags for all non-usable rules [FROCOS05]

Rules which have been flagged as non usable in this step:

   encode_f(x_1, x_2, x_3) -> 1 : f(encArg(x_1), encArg(x_2), encArg(x_3))
   g -> 1 / 2 : O || 1 / 2 : h(g)
   encode_g -> 1 : g
   encArg(cons_g) -> 1 : g
   encArg(cons_h(x_1)) -> 1 : h(encArg(x_1))
   encode_h(x_1) -> 1 : h(encArg(x_1))
   encArg(f(x_1, x_2, x_3)) -> 1 : f(encArg(x_1), encArg(x_2), encArg(x_3))
   encode_O -> 1 : O
   encArg(O) -> 1 : O
   h(x) -> 1 : f(x, x, x)

----------------------------------------

(13)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:
   none
Rules with annotation in P:

   ENCODE_H(x_1) -> 1 : h(ENCARG(x_1))
   ENCARG(cons_h(x_1)) -> 1 : h(ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(f(x_1, x_2, x_3)) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))

Rules with annotation in S:

   ENCARG(cons_h(x_1)) -> 1 : h(ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))

Rules with annotation and a known complexity:

   ENCODE_H(x_1) -> 1 : h(ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))


----------------------------------------

(14) CpxADP_ProbabilityRemovalProof (UPPER BOUND(ID))


We use the probability removal processor to move to dependecy tuples without probabilities.
As all rules have a trivial probability (1:r), we can transform it into a non-probabilistic DT problem

----------------------------------------

(15)
Obligation:
Complexity Dependency Tuples Problem

Rules:none
Tuples:
   ENCODE_H(x_1) -> c(ENCARG(x_1))
   ENCARG(cons_h(x_1)) -> c1(ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> c2(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> c3(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> c4(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> c5(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> c6(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> c7(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
S tuples:
   ENCODE_H(x_1) -> c(ENCARG(x_1))
   ENCARG(cons_h(x_1)) -> c1(ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> c2(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> c3(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> c4(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> c5(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> c6(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> c7(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
K tuples:none
Defined Rule Symbols:   encArg_1, encode_h_1, encode_f_3, encode_g, encode_O, g, h_1

Defined Pair Symbols:none

Compound Symbols:   c_1, c1_1, c2_3, c3_3, c4_3, c5_3, c6_3, c7_3


----------------------------------------

(16) CdtLeafRemovalProof (ComplexityIfPolyImplication)
Removed 4 leading nodes:
   ENCODE_H(x_1) -> c(ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> c2(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> c3(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> c4(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))

----------------------------------------

(17)
Obligation:
Complexity Dependency Tuples Problem

Rules:none
Tuples:
   ENCARG(cons_h(x_1)) -> c1(ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> c5(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> c6(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> c7(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
S tuples:
   ENCARG(cons_h(x_1)) -> c1(ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> c5(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> c6(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> c7(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
K tuples:none
Defined Rule Symbols:   encArg_1, encode_h_1, encode_f_3, encode_g, encode_O, g, h_1

Defined Pair Symbols:   ENCARG_1

Compound Symbols:   c1_1, c5_3, c6_3, c7_3


----------------------------------------

(18) CdtToCpxRelTrsProof (BOTH BOUNDS(ID, ID))
Converted S to standard rules, and D \ S as well as R to relative rules.
----------------------------------------

(19)
Obligation:
The Runtime Complexity (innermost) of the given CpxTRS could be proven to be BOUNDS(1, n^1).


The TRS R consists of the following rules:

   ENCARG(cons_h(x_1)) -> c1(ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> c5(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> c6(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> c7(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))

S is empty.
Rewrite Strategy: INNERMOST
----------------------------------------

(20) RelTrsToTrsProof (UPPER BOUND(ID))
transformed relative TRS to TRS
----------------------------------------

(21)
Obligation:
The Runtime Complexity (innermost) of the given CpxTRS could be proven to be BOUNDS(1, n^1).


The TRS R consists of the following rules:

   ENCARG(cons_h(x_1)) -> c1(ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> c5(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> c6(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> c7(ENCARG(x_2), ENCARG(x_3), ENCARG(x_1))

S is empty.
Rewrite Strategy: INNERMOST
----------------------------------------

(22) CpxTrsMatchBoundsTAProof (FINISHED)
A linear upper bound on the runtime complexity of the TRS R could be shown with a Match-Bound[TAB_LEFTLINEAR,TAB_NONLEFTLINEAR] (for contructor-based start-terms) of 1. 

The compatible tree automaton used to show the Match-Boundedness (for constructor-based start-terms) is represented by: 
final states : [1]
transitions: 
cons_h0(0) -> 0
c10(0) -> 0
f0(0, 0, 0) -> 0
c50(0, 0, 0) -> 0
c60(0, 0, 0) -> 0
c70(0, 0, 0) -> 0
ENCARG0(0) -> 1
ENCARG1(0) -> 2
c11(2) -> 1
ENCARG1(0) -> 3
ENCARG1(0) -> 4
ENCARG1(0) -> 5
c51(3, 4, 5) -> 1
ENCARG1(0) -> 6
ENCARG1(0) -> 7
ENCARG1(0) -> 8
c61(6, 7, 8) -> 1
ENCARG1(0) -> 9
ENCARG1(0) -> 10
ENCARG1(0) -> 11
c71(9, 10, 11) -> 1
c11(2) -> 2
c11(2) -> 3
c11(2) -> 4
c11(2) -> 5
c11(2) -> 6
c11(2) -> 7
c11(2) -> 8
c11(2) -> 9
c11(2) -> 10
c11(2) -> 11
c51(3, 4, 5) -> 2
c51(3, 4, 5) -> 3
c51(3, 4, 5) -> 4
c51(3, 4, 5) -> 5
c51(3, 4, 5) -> 6
c51(3, 4, 5) -> 7
c51(3, 4, 5) -> 8
c51(3, 4, 5) -> 9
c51(3, 4, 5) -> 10
c51(3, 4, 5) -> 11
c61(6, 7, 8) -> 2
c61(6, 7, 8) -> 3
c61(6, 7, 8) -> 4
c61(6, 7, 8) -> 5
c61(6, 7, 8) -> 6
c61(6, 7, 8) -> 7
c61(6, 7, 8) -> 8
c61(6, 7, 8) -> 9
c61(6, 7, 8) -> 10
c61(6, 7, 8) -> 11
c71(9, 10, 11) -> 2
c71(9, 10, 11) -> 3
c71(9, 10, 11) -> 4
c71(9, 10, 11) -> 5
c71(9, 10, 11) -> 6
c71(9, 10, 11) -> 7
c71(9, 10, 11) -> 8
c71(9, 10, 11) -> 9
c71(9, 10, 11) -> 10
c71(9, 10, 11) -> 11

----------------------------------------

(23)
BOUNDS(1, n^1)

----------------------------------------

(24)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(f(x_1, x_2, x_3)) -> 1 : f(encArg(x_1), encArg(x_2), encArg(x_3))
   encArg(O) -> 1 : O
   encArg(cons_h(x_1)) -> 1 : h(encArg(x_1))
   encArg(cons_g) -> 1 : g
   encode_h(x_1) -> 1 : h(encArg(x_1))
   encode_f(x_1, x_2, x_3) -> 1 : f(encArg(x_1), encArg(x_2), encArg(x_3))
   encode_g -> 1 : g
   encode_O -> 1 : O
   g -> 1 / 2 : O || 1 / 2 : h(g)
   h(x) -> 1 : f(x, x, x)

Rules with annotation in P:

   ENCODE_H(x_1) -> 1 : H(ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(cons_h(x_1)) -> 1 : H(ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(cons_g) -> 1 : G
   ENCODE_G -> 1 : G
   G -> 1 / 2 : O || 1 / 2 : H(G)

Rules with annotation in S:

   G -> 1 / 2 : O || 1 / 2 : H(G)

Rules with annotation and a known complexity:

   ENCODE_H(x_1) -> 1 : H(ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(cons_h(x_1)) -> 1 : H(ENCARG(x_1))
   ENCARG(f(x_1, x_2, x_3)) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(cons_g) -> 1 : G
   ENCODE_G -> 1 : G


----------------------------------------

(25) CpxADP_UsableTermsProof (UPPER BOUND(ID))


The approximation of the Dependency Graph  gives us the following unusable Terms: 
   H(encArg(x_1)), H(g)
Hence, as part of the dependency graph processor, we can remove the annotations from these terms from every RHS of every ADP in P and S.

----------------------------------------

(26)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(f(x_1, x_2, x_3)) -> 1 : f(encArg(x_1), encArg(x_2), encArg(x_3))
   encArg(O) -> 1 : O
   encArg(cons_h(x_1)) -> 1 : h(encArg(x_1))
   encArg(cons_g) -> 1 : g
   encode_h(x_1) -> 1 : h(encArg(x_1))
   encode_f(x_1, x_2, x_3) -> 1 : f(encArg(x_1), encArg(x_2), encArg(x_3))
   encode_g -> 1 : g
   encode_O -> 1 : O
   g -> 1 / 2 : O || 1 / 2 : h(g)
   h(x) -> 1 : f(x, x, x)

Rules with annotation in P:

   ENCODE_G -> 1 : G
   ENCODE_H(x_1) -> 1 : h(ENCARG(x_1))
   ENCARG(cons_h(x_1)) -> 1 : h(ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(cons_g) -> 1 : G
   G -> 1 / 2 : O || 1 / 2 : h(G)
   ENCARG(f(x_1, x_2, x_3)) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))

Rules with annotation in S:

   G -> 1 / 2 : O || 1 / 2 : h(G)

Rules with annotation and a known complexity:

   ENCODE_G -> 1 : G
   ENCODE_H(x_1) -> 1 : h(ENCARG(x_1))
   ENCARG(cons_h(x_1)) -> 1 : h(ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(cons_g) -> 1 : G
   ENCARG(f(x_1, x_2, x_3)) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))


----------------------------------------

(27) CpxADP_UsableRulesProof (BOTH BOUNDS(ID, ID))


We use the usable rules processor.
We can deactivate the flags for all non-usable rules [FROCOS05]

Rules which have been flagged as non usable in this step:

   encode_f(x_1, x_2, x_3) -> 1 : f(encArg(x_1), encArg(x_2), encArg(x_3))
   g -> 1 / 2 : O || 1 / 2 : h(g)
   encode_g -> 1 : g
   encArg(cons_g) -> 1 : g
   encArg(cons_h(x_1)) -> 1 : h(encArg(x_1))
   encode_h(x_1) -> 1 : h(encArg(x_1))
   encArg(f(x_1, x_2, x_3)) -> 1 : f(encArg(x_1), encArg(x_2), encArg(x_3))
   encode_O -> 1 : O
   encArg(O) -> 1 : O
   h(x) -> 1 : f(x, x, x)

----------------------------------------

(28)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:
   none
Rules with annotation in P:

   ENCODE_G -> 1 : G
   ENCODE_H(x_1) -> 1 : h(ENCARG(x_1))
   ENCARG(cons_h(x_1)) -> 1 : h(ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(cons_g) -> 1 : G
   G -> 1 / 2 : O || 1 / 2 : h(G)
   ENCARG(f(x_1, x_2, x_3)) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))

Rules with annotation in S:

   G -> 1 / 2 : O || 1 / 2 : h(G)

Rules with annotation and a known complexity:

   ENCODE_G -> 1 : G
   ENCODE_H(x_1) -> 1 : h(ENCARG(x_1))
   ENCARG(cons_h(x_1)) -> 1 : h(ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(cons_g) -> 1 : G
   ENCARG(f(x_1, x_2, x_3)) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))


----------------------------------------

(29) CpxADP_ReductionPairProof (UPPER BOUND(ADD(n^1)))


We use the reduction pair processor.
The following pairs can be oriented strictly and are moved from S:

   ENCARG(cons_h(x_1)) -> 1 : h(ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   G -> 1 / 2 : O || 1 / 2 : h(G)
   ENCARG(f(x_1, x_2, x_3)) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))

The remaining pairs can at least be oriented weakly:

   ENCODE_G -> 1 : G
   ENCODE_H(x_1) -> 1 : h(ENCARG(x_1))
   ENCARG(cons_g) -> 1 : G

Used ordering:Polynomial interpretation [POLO]:

   POL(ENCARG(x_1)) = x_1
   POL(ENCODE_F(x_1, x_2, x_3)) = 1 + x_1 + x_2 + x_3
   POL(ENCODE_G) = 1
   POL(ENCODE_H(x_1)) = x_1
   POL(ENCODE_O) = 0
   POL(G) = 1
   POL(H(x_1)) = 0
   POL(O) = 0
   POL(cons_g) = 1
   POL(cons_h(x_1)) = 1 + x_1
   POL(f(x_1, x_2, x_3)) = 1 + x_1 + x_2 + x_3
   POL(h(x_1)) = 0

The complexity of the removed ADPs is bounded by:n^1
----------------------------------------

(30)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:
   none
Rules with annotation in P:

   ENCODE_G -> 1 : G
   ENCODE_H(x_1) -> 1 : h(ENCARG(x_1))
   ENCARG(cons_h(x_1)) -> 1 : h(ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(cons_g) -> 1 : G
   G -> 1 / 2 : O || 1 / 2 : h(G)
   ENCARG(f(x_1, x_2, x_3)) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))

Rules with annotation in S:

   none

Rules with annotation and a known complexity:

   ENCODE_G -> 1 : G
   ENCODE_H(x_1) -> 1 : h(ENCARG(x_1))
   ENCARG(cons_h(x_1)) -> 1 : h(ENCARG(x_1))
   ENCODE_F(x_1, x_2, x_3) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))
   ENCARG(cons_g) -> 1 : G
   G -> 1 / 2 : O || 1 / 2 : h(G)
   ENCARG(f(x_1, x_2, x_3)) -> 1 : f(ENCARG(x_1), ENCARG(x_2), ENCARG(x_3))


----------------------------------------

(31) SisEmptyProof (FINISHED)


S contains no annotations anymore. Hence, there exists no P-CT with infinitely many S-Nodes.
Resulting upper bound: O(1)

----------------------------------------

(32)
BOUNDS(1, 1)
