SAST
proof of /home/ff862203/input_kpeWzueIf3.ari
# AProVE Commit ID: 1c9e2a6453f9f0dca490585733f1cff3767d3e54 jan-christoph 20250828 unpublished


Complexity of the given CpxPTRS could be proven:

(0) CpxPTRS
(1) CpxPTRS_DerivationToRuntimeComplexityProof [UNSOUND LOWER BOUND(ID)SOUND UPPER BOUND(ID), 0 ms]
(2) CpxPTRS
(3) CpxPTRS_ToPQTRSProof [BOTH BOUNDS(ID, ID), 0 ms]
(4) PQTRS
(5) CpxPQTRS_ToADPProblemProof [BOTH BOUNDS(ID, ID), 27 ms]
(6) ADP
(7) CpxADP_SCCSplitProof [UPPER BOUND(ID), 0 ms]
(8) MAX
    (9) ADP
        (10) CpxADP_UsableTermsProof [UPPER BOUND(ID), 0 ms]
        (11) ADP
        (12) CpxADP_UsableRulesProof [BOTH BOUNDS(ID, ID), 0 ms]
        (13) ADP
        (14) CpxADP_ProbabilityRemovalProof [UPPER BOUND(ID), 0 ms]
        (15) CdtProblem
        (16) CdtLeafRemovalProof [ComplexityIfPolyImplication, 0 ms]
        (17) CdtProblem
        (18) CdtToCpxRelTrsProof [BOTH BOUNDS(ID, ID), 0 ms]
        (19) CpxTRS
        (20) RelTrsToTrsProof [UPPER BOUND(ID), 0 ms]
        (21) CpxTRS
        (22) CpxTrsMatchBoundsTAProof [FINISHED, 0 ms]
        (23) BOUNDS(1, n^1)
    (24) ADP
        (25) CpxADP_UsableTermsProof [UPPER BOUND(ID), 0 ms]
        (26) ADP
        (27) CpxADP_UsableRulesProof [BOTH BOUNDS(ID, ID), 0 ms]
        (28) ADP
        (29) CpxADP_ReductionPairProof [UPPER BOUND(ADD(n^1)), 3 ms]
        (30) ADP
        (31) SisEmptyProof [FINISHED, 0 ms]
        (32) BOUNDS(1, 1)


----------------------------------------

(0)
Obligation:
Probabilistic term rewrite system:
The TRS has the following probabilistic rules:

   d(x) -> 1 : c(x, x)
   g -> 3 / 4 : d(g) || 1 / 4 : bot

and uses the innermost rewrite strategy.

----------------------------------------

(1) CpxPTRS_DerivationToRuntimeComplexityProof (UNSOUND LOWER BOUND(ID)SOUND UPPER BOUND(ID))
The following rules have been added to R to convert the given derivational complexity problem to a runtime complexity problem:

   encArg(c(x_1, x_2)) -> 1 : c(encArg(x_1), encArg(x_2))
   encArg(bot) -> 1 : bot
   encArg(cons_g) -> 1 : g
   encArg(cons_d(x_1)) -> 1 : d(encArg(x_1))
   encode_g -> 1 : g
   encode_d(x_1) -> 1 : d(encArg(x_1))
   encode_c(x_1, x_2) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_bot -> 1 : bot


----------------------------------------

(2)
Obligation:
Probabilistic term rewrite system:
The TRS has the following probabilistic rules:

   encArg(c(x_1, x_2)) -> 1 : c(encArg(x_1), encArg(x_2))
   encArg(bot) -> 1 : bot
   encArg(cons_g) -> 1 : g
   encArg(cons_d(x_1)) -> 1 : d(encArg(x_1))
   encode_g -> 1 : g
   encode_d(x_1) -> 1 : d(encArg(x_1))
   encode_c(x_1, x_2) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_bot -> 1 : bot
   d(x) -> 1 : c(x, x)
   g -> 3 / 4 : d(g) || 1 / 4 : bot

and uses the innermost rewrite strategy.

----------------------------------------

(3) CpxPTRS_ToPQTRSProof (BOTH BOUNDS(ID, ID))
Transformed PTRS into PQTRS. Q is:
   encArg(c(x_1, x_2)), encArg(bot), encArg(cons_g), encArg(cons_d(x_1)), encode_g, encode_d(x_1), encode_c(x_1, x_2), encode_bot, d(x), g
----------------------------------------

(4)
Obligation:
Probabilistic Q term rewrite system:
The PQTRS has the following probabilistic rules:

   encArg(c(x_1, x_2)) -> 1 : c(encArg(x_1), encArg(x_2))
   encArg(bot) -> 1 : bot
   encArg(cons_g) -> 1 : g
   encArg(cons_d(x_1)) -> 1 : d(encArg(x_1))
   encode_g -> 1 : g
   encode_d(x_1) -> 1 : d(encArg(x_1))
   encode_c(x_1, x_2) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_bot -> 1 : bot
   d(x) -> 1 : c(x, x)
   g -> 3 / 4 : d(g) || 1 / 4 : bot

And Q contains the following terms:
   encArg(c(x0, x1)), encArg(bot), encArg(cons_g), encArg(cons_d(x0)), encode_g, encode_d(x0), encode_c(x0, x1), encode_bot, d(x0), g

----------------------------------------

(5) CpxPQTRS_ToADPProblemProof (BOTH BOUNDS(ID, ID))


The complexity of a PQTRS (R,Q) is equivalent to the complexity of the ADP Problem A(R) (Chain-Criterion) (Leon's master's thesis).
The ADPs are:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(c(x_1, x_2)) -> 1 : c(encArg(x_1), encArg(x_2))
   encArg(bot) -> 1 : bot
   encArg(cons_g) -> 1 : g
   encArg(cons_d(x_1)) -> 1 : d(encArg(x_1))
   encode_g -> 1 : g
   encode_d(x_1) -> 1 : d(encArg(x_1))
   encode_c(x_1, x_2) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_bot -> 1 : bot
   d(x) -> 1 : c(x, x)
   g -> 3 / 4 : d(g) || 1 / 4 : bot

Rules with annotation in P:

   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(bot) -> 1 : bot
   ENCARG(cons_g) -> 1 : G
   ENCARG(cons_d(x_1)) -> 1 : D(ENCARG(x_1))
   ENCODE_G -> 1 : G
   ENCODE_D(x_1) -> 1 : D(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_BOT -> 1 : bot
   D(x) -> 1 : c(x, x)
   G -> 3 / 4 : D(G) || 1 / 4 : bot

Rules with annotation in S:

   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(bot) -> 1 : bot
   ENCARG(cons_g) -> 1 : G
   ENCARG(cons_d(x_1)) -> 1 : D(ENCARG(x_1))
   ENCODE_G -> 1 : G
   ENCODE_D(x_1) -> 1 : D(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_BOT -> 1 : bot
   D(x) -> 1 : c(x, x)
   G -> 3 / 4 : D(G) || 1 / 4 : bot

Rules with annotation and a known complexity:

   none

----------------------------------------

(6)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(c(x_1, x_2)) -> 1 : c(encArg(x_1), encArg(x_2))
   encArg(bot) -> 1 : bot
   encArg(cons_g) -> 1 : g
   encArg(cons_d(x_1)) -> 1 : d(encArg(x_1))
   encode_g -> 1 : g
   encode_d(x_1) -> 1 : d(encArg(x_1))
   encode_c(x_1, x_2) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_bot -> 1 : bot
   d(x) -> 1 : c(x, x)
   g -> 3 / 4 : d(g) || 1 / 4 : bot

Rules with annotation in P:

   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(bot) -> 1 : bot
   ENCARG(cons_g) -> 1 : G
   ENCARG(cons_d(x_1)) -> 1 : D(ENCARG(x_1))
   ENCODE_G -> 1 : G
   ENCODE_D(x_1) -> 1 : D(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_BOT -> 1 : bot
   D(x) -> 1 : c(x, x)
   G -> 3 / 4 : D(G) || 1 / 4 : bot

Rules with annotation in S:

   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(bot) -> 1 : bot
   ENCARG(cons_g) -> 1 : G
   ENCARG(cons_d(x_1)) -> 1 : D(ENCARG(x_1))
   ENCODE_G -> 1 : G
   ENCODE_D(x_1) -> 1 : D(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_BOT -> 1 : bot
   D(x) -> 1 : c(x, x)
   G -> 3 / 4 : D(G) || 1 / 4 : bot

Rules with annotation and a known complexity:

   none

----------------------------------------

(7) CpxADP_SCCSplitProof (UPPER BOUND(ID))
As part of the dependency graph processor, we can split problem in 2 new components.
----------------------------------------

(8)
Complex Obligation (MAX)

----------------------------------------

(9)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(c(x_1, x_2)) -> 1 : c(encArg(x_1), encArg(x_2))
   encArg(bot) -> 1 : bot
   encArg(cons_g) -> 1 : g
   encArg(cons_d(x_1)) -> 1 : d(encArg(x_1))
   encode_g -> 1 : g
   encode_d(x_1) -> 1 : d(encArg(x_1))
   encode_c(x_1, x_2) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_bot -> 1 : bot
   d(x) -> 1 : c(x, x)
   g -> 3 / 4 : d(g) || 1 / 4 : bot

Rules with annotation in P:

   ENCODE_D(x_1) -> 1 : D(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_d(x_1)) -> 1 : D(ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))

Rules with annotation in S:

   ENCARG(cons_d(x_1)) -> 1 : D(ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))

Rules with annotation and a known complexity:

   ENCODE_D(x_1) -> 1 : D(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))


----------------------------------------

(10) CpxADP_UsableTermsProof (UPPER BOUND(ID))


The approximation of the Dependency Graph  gives us the following unusable Terms: 
   D(encArg(x_1))
Hence, as part of the dependency graph processor, we can remove the annotations from these terms from every RHS of every ADP in P and S.

----------------------------------------

(11)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(c(x_1, x_2)) -> 1 : c(encArg(x_1), encArg(x_2))
   encArg(bot) -> 1 : bot
   encArg(cons_g) -> 1 : g
   encArg(cons_d(x_1)) -> 1 : d(encArg(x_1))
   encode_g -> 1 : g
   encode_d(x_1) -> 1 : d(encArg(x_1))
   encode_c(x_1, x_2) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_bot -> 1 : bot
   d(x) -> 1 : c(x, x)
   g -> 3 / 4 : d(g) || 1 / 4 : bot

Rules with annotation in P:

   ENCARG(cons_d(x_1)) -> 1 : d(ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_D(x_1) -> 1 : d(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))

Rules with annotation in S:

   ENCARG(cons_d(x_1)) -> 1 : d(ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))

Rules with annotation and a known complexity:

   ENCODE_D(x_1) -> 1 : d(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))


----------------------------------------

(12) CpxADP_UsableRulesProof (BOTH BOUNDS(ID, ID))


We use the usable rules processor.
We can deactivate the flags for all non-usable rules [FROCOS05]

Rules which have been flagged as non usable in this step:

   encode_bot -> 1 : bot
   encArg(c(x_1, x_2)) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_c(x_1, x_2) -> 1 : c(encArg(x_1), encArg(x_2))
   d(x) -> 1 : c(x, x)
   encode_g -> 1 : g
   encArg(cons_g) -> 1 : g
   encode_d(x_1) -> 1 : d(encArg(x_1))
   encArg(cons_d(x_1)) -> 1 : d(encArg(x_1))
   g -> 3 / 4 : d(g) || 1 / 4 : bot
   encArg(bot) -> 1 : bot

----------------------------------------

(13)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:
   none
Rules with annotation in P:

   ENCARG(cons_d(x_1)) -> 1 : d(ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_D(x_1) -> 1 : d(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))

Rules with annotation in S:

   ENCARG(cons_d(x_1)) -> 1 : d(ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))

Rules with annotation and a known complexity:

   ENCODE_D(x_1) -> 1 : d(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))


----------------------------------------

(14) CpxADP_ProbabilityRemovalProof (UPPER BOUND(ID))


We use the probability removal processor to move to dependecy tuples without probabilities.
As all rules have a trivial probability (1:r), we can transform it into a non-probabilistic DT problem

----------------------------------------

(15)
Obligation:
Complexity Dependency Tuples Problem

Rules:none
Tuples:
   ENCARG(cons_d(x_1)) -> c1(ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> c3(ENCARG(x_2), ENCARG(x_1))
   ENCODE_D(x_1) -> c4(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> c5(ENCARG(x_2), ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> c6(ENCARG(x_2), ENCARG(x_1))
S tuples:
   ENCARG(cons_d(x_1)) -> c1(ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> c3(ENCARG(x_2), ENCARG(x_1))
   ENCODE_D(x_1) -> c4(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> c5(ENCARG(x_2), ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> c6(ENCARG(x_2), ENCARG(x_1))
K tuples:none
Defined Rule Symbols:   encArg_1, encode_g, encode_d_1, encode_c_2, encode_bot, d_1, g

Defined Pair Symbols:none

Compound Symbols:   c1_1, c2_2, c3_2, c4_1, c5_2, c6_2


----------------------------------------

(16) CdtLeafRemovalProof (ComplexityIfPolyImplication)
Removed 3 leading nodes:
   ENCODE_D(x_1) -> c4(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> c5(ENCARG(x_2), ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> c6(ENCARG(x_2), ENCARG(x_1))

----------------------------------------

(17)
Obligation:
Complexity Dependency Tuples Problem

Rules:none
Tuples:
   ENCARG(cons_d(x_1)) -> c1(ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> c3(ENCARG(x_2), ENCARG(x_1))
S tuples:
   ENCARG(cons_d(x_1)) -> c1(ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> c3(ENCARG(x_2), ENCARG(x_1))
K tuples:none
Defined Rule Symbols:   encArg_1, encode_g, encode_d_1, encode_c_2, encode_bot, d_1, g

Defined Pair Symbols:   ENCARG_1

Compound Symbols:   c1_1, c2_2, c3_2


----------------------------------------

(18) CdtToCpxRelTrsProof (BOTH BOUNDS(ID, ID))
Converted S to standard rules, and D \ S as well as R to relative rules.
----------------------------------------

(19)
Obligation:
The Runtime Complexity (innermost) of the given CpxTRS could be proven to be BOUNDS(1, n^1).


The TRS R consists of the following rules:

   ENCARG(cons_d(x_1)) -> c1(ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> c3(ENCARG(x_2), ENCARG(x_1))

S is empty.
Rewrite Strategy: INNERMOST
----------------------------------------

(20) RelTrsToTrsProof (UPPER BOUND(ID))
transformed relative TRS to TRS
----------------------------------------

(21)
Obligation:
The Runtime Complexity (innermost) of the given CpxTRS could be proven to be BOUNDS(1, n^1).


The TRS R consists of the following rules:

   ENCARG(cons_d(x_1)) -> c1(ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> c3(ENCARG(x_2), ENCARG(x_1))

S is empty.
Rewrite Strategy: INNERMOST
----------------------------------------

(22) CpxTrsMatchBoundsTAProof (FINISHED)
A linear upper bound on the runtime complexity of the TRS R could be shown with a Match-Bound[TAB_LEFTLINEAR,TAB_NONLEFTLINEAR] (for contructor-based start-terms) of 1. 

The compatible tree automaton used to show the Match-Boundedness (for constructor-based start-terms) is represented by: 
final states : [1]
transitions: 
cons_d0(0) -> 0
c10(0) -> 0
c0(0, 0) -> 0
c20(0, 0) -> 0
c30(0, 0) -> 0
ENCARG0(0) -> 1
ENCARG1(0) -> 2
c11(2) -> 1
ENCARG1(0) -> 3
ENCARG1(0) -> 4
c21(3, 4) -> 1
ENCARG1(0) -> 5
ENCARG1(0) -> 6
c31(5, 6) -> 1
c11(2) -> 2
c11(2) -> 3
c11(2) -> 4
c11(2) -> 5
c11(2) -> 6
c21(3, 4) -> 2
c21(3, 4) -> 3
c21(3, 4) -> 4
c21(3, 4) -> 5
c21(3, 4) -> 6
c31(5, 6) -> 2
c31(5, 6) -> 3
c31(5, 6) -> 4
c31(5, 6) -> 5
c31(5, 6) -> 6

----------------------------------------

(23)
BOUNDS(1, n^1)

----------------------------------------

(24)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(c(x_1, x_2)) -> 1 : c(encArg(x_1), encArg(x_2))
   encArg(bot) -> 1 : bot
   encArg(cons_g) -> 1 : g
   encArg(cons_d(x_1)) -> 1 : d(encArg(x_1))
   encode_g -> 1 : g
   encode_d(x_1) -> 1 : d(encArg(x_1))
   encode_c(x_1, x_2) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_bot -> 1 : bot
   d(x) -> 1 : c(x, x)
   g -> 3 / 4 : d(g) || 1 / 4 : bot

Rules with annotation in P:

   ENCODE_D(x_1) -> 1 : D(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_d(x_1)) -> 1 : D(ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_g) -> 1 : G
   ENCODE_G -> 1 : G
   G -> 3 / 4 : D(G) || 1 / 4 : bot

Rules with annotation in S:

   G -> 3 / 4 : D(G) || 1 / 4 : bot

Rules with annotation and a known complexity:

   ENCODE_D(x_1) -> 1 : D(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_d(x_1)) -> 1 : D(ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_g) -> 1 : G
   ENCODE_G -> 1 : G


----------------------------------------

(25) CpxADP_UsableTermsProof (UPPER BOUND(ID))


The approximation of the Dependency Graph  gives us the following unusable Terms: 
   D(encArg(x_1)), D(g)
Hence, as part of the dependency graph processor, we can remove the annotations from these terms from every RHS of every ADP in P and S.

----------------------------------------

(26)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(c(x_1, x_2)) -> 1 : c(encArg(x_1), encArg(x_2))
   encArg(bot) -> 1 : bot
   encArg(cons_g) -> 1 : g
   encArg(cons_d(x_1)) -> 1 : d(encArg(x_1))
   encode_g -> 1 : g
   encode_d(x_1) -> 1 : d(encArg(x_1))
   encode_c(x_1, x_2) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_bot -> 1 : bot
   d(x) -> 1 : c(x, x)
   g -> 3 / 4 : d(g) || 1 / 4 : bot

Rules with annotation in P:

   ENCARG(cons_d(x_1)) -> 1 : d(ENCARG(x_1))
   ENCODE_G -> 1 : G
   G -> 3 / 4 : d(G) || 1 / 4 : bot
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_D(x_1) -> 1 : d(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_g) -> 1 : G

Rules with annotation in S:

   G -> 3 / 4 : d(G) || 1 / 4 : bot

Rules with annotation and a known complexity:

   ENCARG(cons_d(x_1)) -> 1 : d(ENCARG(x_1))
   ENCODE_G -> 1 : G
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_D(x_1) -> 1 : d(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_g) -> 1 : G


----------------------------------------

(27) CpxADP_UsableRulesProof (BOTH BOUNDS(ID, ID))


We use the usable rules processor.
We can deactivate the flags for all non-usable rules [FROCOS05]

Rules which have been flagged as non usable in this step:

   encode_bot -> 1 : bot
   encArg(c(x_1, x_2)) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_c(x_1, x_2) -> 1 : c(encArg(x_1), encArg(x_2))
   d(x) -> 1 : c(x, x)
   encode_g -> 1 : g
   encArg(cons_g) -> 1 : g
   encode_d(x_1) -> 1 : d(encArg(x_1))
   encArg(cons_d(x_1)) -> 1 : d(encArg(x_1))
   g -> 3 / 4 : d(g) || 1 / 4 : bot
   encArg(bot) -> 1 : bot

----------------------------------------

(28)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:
   none
Rules with annotation in P:

   ENCARG(cons_d(x_1)) -> 1 : d(ENCARG(x_1))
   ENCODE_G -> 1 : G
   G -> 3 / 4 : d(G) || 1 / 4 : bot
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_D(x_1) -> 1 : d(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_g) -> 1 : G

Rules with annotation in S:

   G -> 3 / 4 : d(G) || 1 / 4 : bot

Rules with annotation and a known complexity:

   ENCARG(cons_d(x_1)) -> 1 : d(ENCARG(x_1))
   ENCODE_G -> 1 : G
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_D(x_1) -> 1 : d(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_g) -> 1 : G


----------------------------------------

(29) CpxADP_ReductionPairProof (UPPER BOUND(ADD(n^1)))


We use the reduction pair processor.
The following pairs can be oriented strictly and are moved from S:

   ENCARG(cons_d(x_1)) -> 1 : d(ENCARG(x_1))
   G -> 3 / 4 : d(G) || 1 / 4 : bot
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_D(x_1) -> 1 : d(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))

The remaining pairs can at least be oriented weakly:

   ENCODE_G -> 1 : G
   ENCARG(cons_g) -> 1 : G

Used ordering:Polynomial interpretation [POLO]:

   POL(D(x_1)) = 0
   POL(ENCARG(x_1)) = x_1
   POL(ENCODE_BOT) = 0
   POL(ENCODE_C(x_1, x_2)) = 1 + x_1 + x_2
   POL(ENCODE_D(x_1)) = 1 + x_1
   POL(ENCODE_G) = 1
   POL(G) = 1
   POL(bot) = 0
   POL(c(x_1, x_2)) = 1 + x_1 + x_2
   POL(cons_d(x_1)) = 1 + x_1
   POL(cons_g) = 1
   POL(d(x_1)) = 0

The complexity of the removed ADPs is bounded by:n^1
----------------------------------------

(30)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:
   none
Rules with annotation in P:

   ENCARG(cons_d(x_1)) -> 1 : d(ENCARG(x_1))
   ENCODE_G -> 1 : G
   G -> 3 / 4 : d(G) || 1 / 4 : bot
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_D(x_1) -> 1 : d(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_g) -> 1 : G

Rules with annotation in S:

   none

Rules with annotation and a known complexity:

   ENCARG(cons_d(x_1)) -> 1 : d(ENCARG(x_1))
   ENCODE_G -> 1 : G
   G -> 3 / 4 : d(G) || 1 / 4 : bot
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_D(x_1) -> 1 : d(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_g) -> 1 : G


----------------------------------------

(31) SisEmptyProof (FINISHED)


S contains no annotations anymore. Hence, there exists no P-CT with infinitely many S-Nodes.
Resulting upper bound: O(1)

----------------------------------------

(32)
BOUNDS(1, 1)
