SAST
proof of /home/ff862203/input_YsKbIthAyE.ari
# AProVE Commit ID: 1c9e2a6453f9f0dca490585733f1cff3767d3e54 jan-christoph 20250828 unpublished


Complexity of the given CpxPTRS could be proven:

(0) CpxPTRS
(1) CpxPTRS_DerivationToRuntimeComplexityProof [UNSOUND LOWER BOUND(ID)SOUND UPPER BOUND(ID), 0 ms]
(2) CpxPTRS
(3) CpxPTRS_ToPQTRSProof [BOTH BOUNDS(ID, ID), 0 ms]
(4) PQTRS
(5) CpxPQTRS_ToADPProblemProof [BOTH BOUNDS(ID, ID), 65 ms]
(6) ADP
(7) CpxADP_TransformationProof [BOTH BOUNDS(ID, ID), 40 ms]
(8) ADP
(9) CpxADP_SCCSplitProof [UPPER BOUND(ID), 10 ms]
(10) MAX
    (11) ADP
        (12) CpxADP_UsableTermsProof [UPPER BOUND(ID), 0 ms]
        (13) ADP
        (14) CpxADP_UsableRulesProof [BOTH BOUNDS(ID, ID), 0 ms]
        (15) ADP
        (16) CpxADP_ProbabilityRemovalProof [UPPER BOUND(ID), 0 ms]
        (17) CdtProblem
        (18) CdtLeafRemovalProof [ComplexityIfPolyImplication, 0 ms]
        (19) CdtProblem
        (20) CdtToCpxRelTrsProof [BOTH BOUNDS(ID, ID), 0 ms]
        (21) CpxTRS
        (22) RelTrsToTrsProof [UPPER BOUND(ID), 0 ms]
        (23) CpxTRS
        (24) CpxTrsMatchBoundsTAProof [FINISHED, 20 ms]
        (25) BOUNDS(1, n^1)
    (26) ADP
        (27) CpxADP_UsableTermsProof [UPPER BOUND(ID), 0 ms]
        (28) ADP
        (29) CpxADP_UsableRulesProof [BOTH BOUNDS(ID, ID), 0 ms]
        (30) ADP
        (31) CpxADP_ReductionPairProof [UPPER BOUND(ADD(n^1)), 3 ms]
        (32) ADP
        (33) SisEmptyProof [FINISHED, 0 ms]
        (34) BOUNDS(1, 1)
    (35) ADP
        (36) CpxADP_UsableTermsProof [UPPER BOUND(ID), 0 ms]
        (37) ADP
        (38) CpxADP_UsableRulesProof [BOTH BOUNDS(ID, ID), 0 ms]
        (39) ADP
        (40) CpxADP_ReductionPairProof [UPPER BOUND(ADD(n^1)), 1 ms]
        (41) ADP
        (42) SisEmptyProof [FINISHED, 0 ms]
        (43) BOUNDS(1, 1)
    (44) ADP
        (45) CpxADP_UsableTermsProof [UPPER BOUND(ID), 0 ms]
        (46) ADP
        (47) CpxADP_UsableRulesProof [BOTH BOUNDS(ID, ID), 4 ms]
        (48) ADP
        (49) CpxADP_ReductionPairProof [UPPER BOUND(ADD(2-EXP)), 933 ms]
        (50) ADP
        (51) CpxADP_KnowledgePropagationProof [BOTH BOUNDS(ID, ID), 0 ms]
        (52) ADP
        (53) SisEmptyProof [FINISHED, 0 ms]
        (54) BOUNDS(1, 1)


----------------------------------------

(0)
Obligation:
Probabilistic term rewrite system:
The TRS has the following probabilistic rules:

   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateOII -> 1 : s(s(s(s(O))))
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   f(s(x)) -> 1 : f(g(x, x))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateIOO -> 1 : s(s(s(O)))
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateOOI -> 1 : s(s(s(s(s(O)))))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   start -> 1 : f(dice)
   stateIOI -> 1 : s(s(O))
   stateIII -> 1 : s(O)
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   f(g(x, y)) -> 1 : g(f(x), f(y))
   stateOOO -> 1 : s(s(s(s(s(s(O))))))

and uses the innermost rewrite strategy.

----------------------------------------

(1) CpxPTRS_DerivationToRuntimeComplexityProof (UNSOUND LOWER BOUND(ID)SOUND UPPER BOUND(ID))
The following rules have been added to R to convert the given derivational complexity problem to a runtime complexity problem:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   encArg(cons_dice) -> 1 : dice
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateIII) -> 1 : stateIII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_start) -> 1 : start
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOI) -> 1 : stateOI
   encode_dice -> 1 : dice
   encode_stateO -> 1 : stateO
   encode_stateI -> 1 : stateI
   encode_stateIOO -> 1 : stateIOO
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_O -> 1 : O
   encode_stateOO -> 1 : stateOO
   encode_stateOI -> 1 : stateOI
   encode_stateIII -> 1 : stateIII
   encode_stateOOI -> 1 : stateOOI
   encode_stateII -> 1 : stateII
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encode_start -> 1 : start
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   encode_stateOOO -> 1 : stateOOO
   encode_stateOII -> 1 : stateOII


----------------------------------------

(2)
Obligation:
Probabilistic term rewrite system:
The TRS has the following probabilistic rules:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   encArg(cons_dice) -> 1 : dice
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateIII) -> 1 : stateIII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_start) -> 1 : start
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOI) -> 1 : stateOI
   encode_dice -> 1 : dice
   encode_stateO -> 1 : stateO
   encode_stateI -> 1 : stateI
   encode_stateIOO -> 1 : stateIOO
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_O -> 1 : O
   encode_stateOO -> 1 : stateOO
   encode_stateOI -> 1 : stateOI
   encode_stateIII -> 1 : stateIII
   encode_stateOOI -> 1 : stateOOI
   encode_stateII -> 1 : stateII
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encode_start -> 1 : start
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   encode_stateOOO -> 1 : stateOOO
   encode_stateOII -> 1 : stateOII
   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateOII -> 1 : s(s(s(s(O))))
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   f(s(x)) -> 1 : f(g(x, x))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateIOO -> 1 : s(s(s(O)))
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateOOI -> 1 : s(s(s(s(s(O)))))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   start -> 1 : f(dice)
   stateIOI -> 1 : s(s(O))
   stateIII -> 1 : s(O)
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   f(g(x, y)) -> 1 : g(f(x), f(y))
   stateOOO -> 1 : s(s(s(s(s(s(O))))))

and uses the innermost rewrite strategy.

----------------------------------------

(3) CpxPTRS_ToPQTRSProof (BOTH BOUNDS(ID, ID))
Transformed PTRS into PQTRS. Q is:
   encArg(s(x_1)), encArg(O), encArg(g(x_1, x_2)), encArg(cons_dice), encArg(cons_stateIOO), encArg(cons_stateO), encArg(cons_stateIII), encArg(cons_stateOO), encArg(cons_stateII), encArg(cons_stateIO), encArg(cons_start), encArg(cons_f(x_1)), encArg(cons_stateI), encArg(cons_stateOOI), encArg(cons_stateIOI), encArg(cons_stateOII), encArg(cons_stateOOO), encArg(cons_stateOI), encode_dice, encode_stateO, encode_stateI, encode_stateIOO, encode_s(x_1), encode_O, encode_stateOO, encode_stateOI, encode_stateIII, encode_stateOOI, encode_stateII, encode_stateIO, encode_stateIOI, encode_start, encode_f(x_1), encode_g(x_1, x_2), encode_stateOOO, encode_stateOII, dice, stateOII, stateIO, f(s(x)), stateOO, stateIOO, stateOI, stateOOI, stateO, start, stateIOI, stateIII, stateI, stateII, f(g(x, y)), stateOOO
----------------------------------------

(4)
Obligation:
Probabilistic Q term rewrite system:
The PQTRS has the following probabilistic rules:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   encArg(cons_dice) -> 1 : dice
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateIII) -> 1 : stateIII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_start) -> 1 : start
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOI) -> 1 : stateOI
   encode_dice -> 1 : dice
   encode_stateO -> 1 : stateO
   encode_stateI -> 1 : stateI
   encode_stateIOO -> 1 : stateIOO
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_O -> 1 : O
   encode_stateOO -> 1 : stateOO
   encode_stateOI -> 1 : stateOI
   encode_stateIII -> 1 : stateIII
   encode_stateOOI -> 1 : stateOOI
   encode_stateII -> 1 : stateII
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encode_start -> 1 : start
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   encode_stateOOO -> 1 : stateOOO
   encode_stateOII -> 1 : stateOII
   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateOII -> 1 : s(s(s(s(O))))
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   f(s(x)) -> 1 : f(g(x, x))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateIOO -> 1 : s(s(s(O)))
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateOOI -> 1 : s(s(s(s(s(O)))))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   start -> 1 : f(dice)
   stateIOI -> 1 : s(s(O))
   stateIII -> 1 : s(O)
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   f(g(x, y)) -> 1 : g(f(x), f(y))
   stateOOO -> 1 : s(s(s(s(s(s(O))))))

And Q contains the following terms:
   encArg(s(x0)), encArg(O), encArg(g(x0, x1)), encArg(cons_dice), encArg(cons_stateIOO), encArg(cons_stateO), encArg(cons_stateIII), encArg(cons_stateOO), encArg(cons_stateII), encArg(cons_stateIO), encArg(cons_start), encArg(cons_f(x0)), encArg(cons_stateI), encArg(cons_stateOOI), encArg(cons_stateIOI), encArg(cons_stateOII), encArg(cons_stateOOO), encArg(cons_stateOI), encode_dice, encode_stateO, encode_stateI, encode_stateIOO, encode_s(x0), encode_O, encode_stateOO, encode_stateOI, encode_stateIII, encode_stateOOI, encode_stateII, encode_stateIO, encode_stateIOI, encode_start, encode_f(x0), encode_g(x0, x1), encode_stateOOO, encode_stateOII, dice, stateOII, stateIO, f(s(x0)), stateOO, stateIOO, stateOI, stateOOI, stateO, start, stateIOI, stateIII, stateI, stateII, f(g(x0, x1)), stateOOO

----------------------------------------

(5) CpxPQTRS_ToADPProblemProof (BOTH BOUNDS(ID, ID))


The complexity of a PQTRS (R,Q) is equivalent to the complexity of the ADP Problem A(R) (Chain-Criterion) (Leon's master's thesis).
The ADPs are:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   encArg(cons_dice) -> 1 : dice
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateIII) -> 1 : stateIII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_start) -> 1 : start
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOI) -> 1 : stateOI
   encode_dice -> 1 : dice
   encode_stateO -> 1 : stateO
   encode_stateI -> 1 : stateI
   encode_stateIOO -> 1 : stateIOO
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_O -> 1 : O
   encode_stateOO -> 1 : stateOO
   encode_stateOI -> 1 : stateOI
   encode_stateIII -> 1 : stateIII
   encode_stateOOI -> 1 : stateOOI
   encode_stateII -> 1 : stateII
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encode_start -> 1 : start
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   encode_stateOOO -> 1 : stateOOO
   encode_stateOII -> 1 : stateOII
   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateOII -> 1 : s(s(s(s(O))))
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   f(s(x)) -> 1 : f(g(x, x))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateIOO -> 1 : s(s(s(O)))
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateOOI -> 1 : s(s(s(s(s(O)))))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   start -> 1 : f(dice)
   stateIOI -> 1 : s(s(O))
   stateIII -> 1 : s(O)
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   f(g(x, y)) -> 1 : g(f(x), f(y))
   stateOOO -> 1 : s(s(s(s(s(s(O))))))

Rules with annotation in P:

   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(O) -> 1 : O
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateIOO) -> 1 : STATEIOO
   ENCARG(cons_stateO) -> 1 : STATEO
   ENCARG(cons_stateIII) -> 1 : STATEIII
   ENCARG(cons_stateOO) -> 1 : STATEOO
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(cons_stateIO) -> 1 : STATEIO
   ENCARG(cons_start) -> 1 : START
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCARG(cons_stateOOI) -> 1 : STATEOOI
   ENCARG(cons_stateIOI) -> 1 : STATEIOI
   ENCARG(cons_stateOII) -> 1 : STATEOII
   ENCARG(cons_stateOOO) -> 1 : STATEOOO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEO -> 1 : STATEO
   ENCODE_STATEI -> 1 : STATEI
   ENCODE_STATEIOO -> 1 : STATEIOO
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_O -> 1 : O
   ENCODE_STATEOO -> 1 : STATEOO
   ENCODE_STATEOI -> 1 : STATEOI
   ENCODE_STATEIII -> 1 : STATEIII
   ENCODE_STATEOOI -> 1 : STATEOOI
   ENCODE_STATEII -> 1 : STATEII
   ENCODE_STATEIO -> 1 : STATEIO
   ENCODE_STATEIOI -> 1 : STATEIOI
   ENCODE_START -> 1 : START
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCODE_STATEOOO -> 1 : STATEOOO
   ENCODE_STATEOII -> 1 : STATEOII
   DICE -> 1 / 2 : STATEI || 1 / 2 : STATEO
   STATEOII -> 1 : s(s(s(s(O))))
   STATEIO -> 1 / 2 : STATEIOI || 1 / 2 : STATEIOO
   F(s(x)) -> 1 : F(g(x, x))
   STATEOO -> 1 / 2 : STATEOOI || 1 / 2 : STATEOOO
   STATEIOO -> 1 : s(s(s(O)))
   STATEOI -> 1 / 2 : STATEOII || 1 / 2 : STATEO
   STATEOOI -> 1 : s(s(s(s(s(O)))))
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : STATEOO
   START -> 1 : F(DICE)
   STATEIOI -> 1 : s(s(O))
   STATEIII -> 1 : s(O)
   STATEI -> 1 / 2 : STATEII || 1 / 2 : STATEIO
   STATEII -> 1 / 2 : STATEIII || 1 / 2 : STATEI
   F(g(x, y)) -> 1 : g(F(x), F(y))
   STATEOOO -> 1 : s(s(s(s(s(s(O))))))

Rules with annotation in S:

   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(O) -> 1 : O
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateIOO) -> 1 : STATEIOO
   ENCARG(cons_stateO) -> 1 : STATEO
   ENCARG(cons_stateIII) -> 1 : STATEIII
   ENCARG(cons_stateOO) -> 1 : STATEOO
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(cons_stateIO) -> 1 : STATEIO
   ENCARG(cons_start) -> 1 : START
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCARG(cons_stateOOI) -> 1 : STATEOOI
   ENCARG(cons_stateIOI) -> 1 : STATEIOI
   ENCARG(cons_stateOII) -> 1 : STATEOII
   ENCARG(cons_stateOOO) -> 1 : STATEOOO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEO -> 1 : STATEO
   ENCODE_STATEI -> 1 : STATEI
   ENCODE_STATEIOO -> 1 : STATEIOO
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_O -> 1 : O
   ENCODE_STATEOO -> 1 : STATEOO
   ENCODE_STATEOI -> 1 : STATEOI
   ENCODE_STATEIII -> 1 : STATEIII
   ENCODE_STATEOOI -> 1 : STATEOOI
   ENCODE_STATEII -> 1 : STATEII
   ENCODE_STATEIO -> 1 : STATEIO
   ENCODE_STATEIOI -> 1 : STATEIOI
   ENCODE_START -> 1 : START
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCODE_STATEOOO -> 1 : STATEOOO
   ENCODE_STATEOII -> 1 : STATEOII
   DICE -> 1 / 2 : STATEI || 1 / 2 : STATEO
   STATEOII -> 1 : s(s(s(s(O))))
   STATEIO -> 1 / 2 : STATEIOI || 1 / 2 : STATEIOO
   F(s(x)) -> 1 : F(g(x, x))
   STATEOO -> 1 / 2 : STATEOOI || 1 / 2 : STATEOOO
   STATEIOO -> 1 : s(s(s(O)))
   STATEOI -> 1 / 2 : STATEOII || 1 / 2 : STATEO
   STATEOOI -> 1 : s(s(s(s(s(O)))))
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : STATEOO
   START -> 1 : F(DICE)
   STATEIOI -> 1 : s(s(O))
   STATEIII -> 1 : s(O)
   STATEI -> 1 / 2 : STATEII || 1 / 2 : STATEIO
   STATEII -> 1 / 2 : STATEIII || 1 / 2 : STATEI
   F(g(x, y)) -> 1 : g(F(x), F(y))
   STATEOOO -> 1 : s(s(s(s(s(s(O))))))

Rules with annotation and a known complexity:

   none

----------------------------------------

(6)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(O) -> 1 : O
   encArg(g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   encArg(cons_dice) -> 1 : dice
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateO) -> 1 : stateO
   encArg(cons_stateIII) -> 1 : stateIII
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(cons_start) -> 1 : start
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(cons_stateOI) -> 1 : stateOI
   encode_dice -> 1 : dice
   encode_stateO -> 1 : stateO
   encode_stateI -> 1 : stateI
   encode_stateIOO -> 1 : stateIOO
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_O -> 1 : O
   encode_stateOO -> 1 : stateOO
   encode_stateOI -> 1 : stateOI
   encode_stateIII -> 1 : stateIII
   encode_stateOOI -> 1 : stateOOI
   encode_stateII -> 1 : stateII
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encode_start -> 1 : start
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   encode_stateOOO -> 1 : stateOOO
   encode_stateOII -> 1 : stateOII
   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateOII -> 1 : s(s(s(s(O))))
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   f(s(x)) -> 1 : f(g(x, x))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateIOO -> 1 : s(s(s(O)))
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateOOI -> 1 : s(s(s(s(s(O)))))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   start -> 1 : f(dice)
   stateIOI -> 1 : s(s(O))
   stateIII -> 1 : s(O)
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   f(g(x, y)) -> 1 : g(f(x), f(y))
   stateOOO -> 1 : s(s(s(s(s(s(O))))))

Rules with annotation in P:

   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(O) -> 1 : O
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateIOO) -> 1 : STATEIOO
   ENCARG(cons_stateO) -> 1 : STATEO
   ENCARG(cons_stateIII) -> 1 : STATEIII
   ENCARG(cons_stateOO) -> 1 : STATEOO
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(cons_stateIO) -> 1 : STATEIO
   ENCARG(cons_start) -> 1 : START
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCARG(cons_stateOOI) -> 1 : STATEOOI
   ENCARG(cons_stateIOI) -> 1 : STATEIOI
   ENCARG(cons_stateOII) -> 1 : STATEOII
   ENCARG(cons_stateOOO) -> 1 : STATEOOO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEO -> 1 : STATEO
   ENCODE_STATEI -> 1 : STATEI
   ENCODE_STATEIOO -> 1 : STATEIOO
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_O -> 1 : O
   ENCODE_STATEOO -> 1 : STATEOO
   ENCODE_STATEOI -> 1 : STATEOI
   ENCODE_STATEIII -> 1 : STATEIII
   ENCODE_STATEOOI -> 1 : STATEOOI
   ENCODE_STATEII -> 1 : STATEII
   ENCODE_STATEIO -> 1 : STATEIO
   ENCODE_STATEIOI -> 1 : STATEIOI
   ENCODE_START -> 1 : START
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCODE_STATEOOO -> 1 : STATEOOO
   ENCODE_STATEOII -> 1 : STATEOII
   DICE -> 1 / 2 : STATEI || 1 / 2 : STATEO
   STATEOII -> 1 : s(s(s(s(O))))
   STATEIO -> 1 / 2 : STATEIOI || 1 / 2 : STATEIOO
   F(s(x)) -> 1 : F(g(x, x))
   STATEOO -> 1 / 2 : STATEOOI || 1 / 2 : STATEOOO
   STATEIOO -> 1 : s(s(s(O)))
   STATEOI -> 1 / 2 : STATEOII || 1 / 2 : STATEO
   STATEOOI -> 1 : s(s(s(s(s(O)))))
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : STATEOO
   START -> 1 : F(DICE)
   STATEIOI -> 1 : s(s(O))
   STATEIII -> 1 : s(O)
   STATEI -> 1 / 2 : STATEII || 1 / 2 : STATEIO
   STATEII -> 1 / 2 : STATEIII || 1 / 2 : STATEI
   F(g(x, y)) -> 1 : g(F(x), F(y))
   STATEOOO -> 1 : s(s(s(s(s(s(O))))))

Rules with annotation in S:

   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(O) -> 1 : O
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateIOO) -> 1 : STATEIOO
   ENCARG(cons_stateO) -> 1 : STATEO
   ENCARG(cons_stateIII) -> 1 : STATEIII
   ENCARG(cons_stateOO) -> 1 : STATEOO
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(cons_stateIO) -> 1 : STATEIO
   ENCARG(cons_start) -> 1 : START
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCARG(cons_stateOOI) -> 1 : STATEOOI
   ENCARG(cons_stateIOI) -> 1 : STATEIOI
   ENCARG(cons_stateOII) -> 1 : STATEOII
   ENCARG(cons_stateOOO) -> 1 : STATEOOO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEO -> 1 : STATEO
   ENCODE_STATEI -> 1 : STATEI
   ENCODE_STATEIOO -> 1 : STATEIOO
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_O -> 1 : O
   ENCODE_STATEOO -> 1 : STATEOO
   ENCODE_STATEOI -> 1 : STATEOI
   ENCODE_STATEIII -> 1 : STATEIII
   ENCODE_STATEOOI -> 1 : STATEOOI
   ENCODE_STATEII -> 1 : STATEII
   ENCODE_STATEIO -> 1 : STATEIO
   ENCODE_STATEIOI -> 1 : STATEIOI
   ENCODE_START -> 1 : START
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCODE_STATEOOO -> 1 : STATEOOO
   ENCODE_STATEOII -> 1 : STATEOII
   DICE -> 1 / 2 : STATEI || 1 / 2 : STATEO
   STATEOII -> 1 : s(s(s(s(O))))
   STATEIO -> 1 / 2 : STATEIOI || 1 / 2 : STATEIOO
   F(s(x)) -> 1 : F(g(x, x))
   STATEOO -> 1 / 2 : STATEOOI || 1 / 2 : STATEOOO
   STATEIOO -> 1 : s(s(s(O)))
   STATEOI -> 1 / 2 : STATEOII || 1 / 2 : STATEO
   STATEOOI -> 1 : s(s(s(s(s(O)))))
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : STATEOO
   START -> 1 : F(DICE)
   STATEIOI -> 1 : s(s(O))
   STATEIII -> 1 : s(O)
   STATEI -> 1 / 2 : STATEII || 1 / 2 : STATEIO
   STATEII -> 1 / 2 : STATEIII || 1 / 2 : STATEI
   F(g(x, y)) -> 1 : g(F(x), F(y))
   STATEOOO -> 1 : s(s(s(s(s(s(O))))))

Rules with annotation and a known complexity:

   none

----------------------------------------

(7) CpxADP_TransformationProof (BOTH BOUNDS(ID, ID))
By rule overlap instantiation for the rule ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1)) we obtained the following new ADPs :

   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(O)) -> 1 : s(ENCARG(O))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCARG(s(cons_dice)) -> 1 : s(ENCARG(cons_dice))
   ENCARG(s(cons_stateIOO)) -> 1 : s(ENCARG(cons_stateIOO))
   ENCARG(s(cons_stateO)) -> 1 : s(ENCARG(cons_stateO))
   ENCARG(s(cons_stateIII)) -> 1 : s(ENCARG(cons_stateIII))
   ENCARG(s(cons_stateOO)) -> 1 : s(ENCARG(cons_stateOO))
   ENCARG(s(cons_stateII)) -> 1 : s(ENCARG(cons_stateII))
   ENCARG(s(cons_stateIO)) -> 1 : s(ENCARG(cons_stateIO))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(cons_stateI)) -> 1 : s(ENCARG(cons_stateI))
   ENCARG(s(cons_stateOOI)) -> 1 : s(ENCARG(cons_stateOOI))
   ENCARG(s(cons_stateIOI)) -> 1 : s(ENCARG(cons_stateIOI))
   ENCARG(s(cons_stateOII)) -> 1 : s(ENCARG(cons_stateOII))
   ENCARG(s(cons_stateOOO)) -> 1 : s(ENCARG(cons_stateOOO))
   ENCARG(s(cons_stateOI)) -> 1 : s(ENCARG(cons_stateOI))

and we added the following new probabilistic rules with active return value flag:

   encArg(s(s(y0))) -> 1 : s(encArg(s(y0)))
   encArg(s(O)) -> 1 : s(encArg(O))
   encArg(s(g(y0, y1))) -> 1 : s(encArg(g(y0, y1)))
   encArg(s(cons_dice)) -> 1 : s(encArg(cons_dice))
   encArg(s(cons_stateIOO)) -> 1 : s(encArg(cons_stateIOO))
   encArg(s(cons_stateO)) -> 1 : s(encArg(cons_stateO))
   encArg(s(cons_stateIII)) -> 1 : s(encArg(cons_stateIII))
   encArg(s(cons_stateOO)) -> 1 : s(encArg(cons_stateOO))
   encArg(s(cons_stateII)) -> 1 : s(encArg(cons_stateII))
   encArg(s(cons_stateIO)) -> 1 : s(encArg(cons_stateIO))
   encArg(s(cons_start)) -> 1 : s(encArg(cons_start))
   encArg(s(cons_f(y0))) -> 1 : s(encArg(cons_f(y0)))
   encArg(s(cons_stateI)) -> 1 : s(encArg(cons_stateI))
   encArg(s(cons_stateOOI)) -> 1 : s(encArg(cons_stateOOI))
   encArg(s(cons_stateIOI)) -> 1 : s(encArg(cons_stateIOI))
   encArg(s(cons_stateOII)) -> 1 : s(encArg(cons_stateOII))
   encArg(s(cons_stateOOO)) -> 1 : s(encArg(cons_stateOOO))
   encArg(s(cons_stateOI)) -> 1 : s(encArg(cons_stateOI))

----------------------------------------

(8)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   encArg(s(cons_stateIO)) -> 1 : s(encArg(cons_stateIO))
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(s(O)) -> 1 : s(encArg(O))
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   f(s(x)) -> 1 : f(g(x, x))
   encode_stateO -> 1 : stateO
   stateIOO -> 1 : s(s(s(O)))
   stateOOI -> 1 : s(s(s(s(s(O)))))
   encArg(s(cons_stateOI)) -> 1 : s(encArg(cons_stateOI))
   encode_stateI -> 1 : stateI
   stateIOI -> 1 : s(s(O))
   encArg(cons_stateOOO) -> 1 : stateOOO
   encode_dice -> 1 : dice
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   encode_O -> 1 : O
   encode_stateOOO -> 1 : stateOOO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   encArg(s(cons_stateOO)) -> 1 : s(encArg(cons_stateOO))
   encArg(cons_stateIOO) -> 1 : stateIOO
   f(g(x, y)) -> 1 : g(f(x), f(y))
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateIOI) -> 1 : stateIOI
   encode_stateIII -> 1 : stateIII
   encArg(s(cons_f(y0))) -> 1 : s(encArg(cons_f(y0)))
   start -> 1 : f(dice)
   encArg(s(cons_stateOII)) -> 1 : s(encArg(cons_stateOII))
   encArg(cons_stateO) -> 1 : stateO
   encArg(s(cons_stateI)) -> 1 : s(encArg(cons_stateI))
   encode_stateOII -> 1 : stateOII
   encArg(s(cons_stateII)) -> 1 : s(encArg(cons_stateII))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_stateOOI -> 1 : stateOOI
   encArg(s(cons_stateIOI)) -> 1 : s(encArg(cons_stateIOI))
   encArg(g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   stateOOO -> 1 : s(s(s(s(s(s(O))))))
   encArg(cons_start) -> 1 : start
   encode_start -> 1 : start
   stateOII -> 1 : s(s(s(s(O))))
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(s(cons_stateO)) -> 1 : s(encArg(cons_stateO))
   encode_stateIOO -> 1 : stateIOO
   encArg(s(cons_stateOOI)) -> 1 : s(encArg(cons_stateOOI))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   encode_stateOO -> 1 : stateOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   encArg(s(cons_start)) -> 1 : s(encArg(cons_start))
   encArg(O) -> 1 : O
   encode_stateOI -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   stateIII -> 1 : s(O)
   encArg(s(cons_stateOOO)) -> 1 : s(encArg(cons_stateOOO))
   encArg(s(cons_stateIOO)) -> 1 : s(encArg(cons_stateIOO))
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateII) -> 1 : stateII
   encode_stateII -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   encArg(s(g(y0, y1))) -> 1 : s(encArg(g(y0, y1)))
   encArg(s(cons_stateIII)) -> 1 : s(encArg(cons_stateIII))
   encArg(s(s(y0))) -> 1 : s(encArg(s(y0)))
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_dice) -> 1 : dice
   encArg(s(cons_dice)) -> 1 : s(encArg(cons_dice))

Rules with annotation in P:

   ENCARG(O) -> 1 : O
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateIOO) -> 1 : STATEIOO
   ENCARG(cons_stateO) -> 1 : STATEO
   ENCARG(cons_stateIII) -> 1 : STATEIII
   ENCARG(cons_stateOO) -> 1 : STATEOO
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(cons_stateIO) -> 1 : STATEIO
   ENCARG(cons_start) -> 1 : START
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCARG(cons_stateOOI) -> 1 : STATEOOI
   ENCARG(cons_stateIOI) -> 1 : STATEIOI
   ENCARG(cons_stateOII) -> 1 : STATEOII
   ENCARG(cons_stateOOO) -> 1 : STATEOOO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEO -> 1 : STATEO
   ENCODE_STATEI -> 1 : STATEI
   ENCODE_STATEIOO -> 1 : STATEIOO
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_O -> 1 : O
   ENCODE_STATEOO -> 1 : STATEOO
   ENCODE_STATEOI -> 1 : STATEOI
   ENCODE_STATEIII -> 1 : STATEIII
   ENCODE_STATEOOI -> 1 : STATEOOI
   ENCODE_STATEII -> 1 : STATEII
   ENCODE_STATEIO -> 1 : STATEIO
   ENCODE_STATEIOI -> 1 : STATEIOI
   ENCODE_START -> 1 : START
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCODE_STATEOOO -> 1 : STATEOOO
   ENCODE_STATEOII -> 1 : STATEOII
   DICE -> 1 / 2 : STATEI || 1 / 2 : STATEO
   STATEOII -> 1 : s(s(s(s(O))))
   STATEIO -> 1 / 2 : STATEIOI || 1 / 2 : STATEIOO
   F(s(x)) -> 1 : F(g(x, x))
   STATEOO -> 1 / 2 : STATEOOI || 1 / 2 : STATEOOO
   STATEIOO -> 1 : s(s(s(O)))
   STATEOI -> 1 / 2 : STATEOII || 1 / 2 : STATEO
   STATEOOI -> 1 : s(s(s(s(s(O)))))
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : STATEOO
   START -> 1 : F(DICE)
   STATEIOI -> 1 : s(s(O))
   STATEIII -> 1 : s(O)
   STATEI -> 1 / 2 : STATEII || 1 / 2 : STATEIO
   STATEII -> 1 / 2 : STATEIII || 1 / 2 : STATEI
   F(g(x, y)) -> 1 : g(F(x), F(y))
   STATEOOO -> 1 : s(s(s(s(s(s(O))))))
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(O)) -> 1 : s(ENCARG(O))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCARG(s(cons_dice)) -> 1 : s(ENCARG(cons_dice))
   ENCARG(s(cons_stateIOO)) -> 1 : s(ENCARG(cons_stateIOO))
   ENCARG(s(cons_stateO)) -> 1 : s(ENCARG(cons_stateO))
   ENCARG(s(cons_stateIII)) -> 1 : s(ENCARG(cons_stateIII))
   ENCARG(s(cons_stateOO)) -> 1 : s(ENCARG(cons_stateOO))
   ENCARG(s(cons_stateII)) -> 1 : s(ENCARG(cons_stateII))
   ENCARG(s(cons_stateIO)) -> 1 : s(ENCARG(cons_stateIO))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(cons_stateI)) -> 1 : s(ENCARG(cons_stateI))
   ENCARG(s(cons_stateOOI)) -> 1 : s(ENCARG(cons_stateOOI))
   ENCARG(s(cons_stateIOI)) -> 1 : s(ENCARG(cons_stateIOI))
   ENCARG(s(cons_stateOII)) -> 1 : s(ENCARG(cons_stateOII))
   ENCARG(s(cons_stateOOO)) -> 1 : s(ENCARG(cons_stateOOO))
   ENCARG(s(cons_stateOI)) -> 1 : s(ENCARG(cons_stateOI))

Rules with annotation in S:

   ENCODE_STATEOOI -> 1 : STATEOOI
   ENCODE_STATEII -> 1 : STATEII
   STATEOII -> 1 : s(s(s(s(O))))
   STATEIO -> 1 / 2 : STATEIOI || 1 / 2 : STATEIOO
   ENCARG(s(cons_stateOO)) -> 1 : s(ENCARG(cons_stateOO))
   ENCARG(cons_stateIO) -> 1 : STATEIO
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_STATEOOO -> 1 : STATEOOO
   ENCARG(cons_stateOII) -> 1 : STATEOII
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCODE_START -> 1 : START
   ENCODE_STATEOI -> 1 : STATEOI
   STATEIII -> 1 : s(O)
   ENCARG(s(cons_stateIII)) -> 1 : s(ENCARG(cons_stateIII))
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCARG(cons_stateOI) -> 1 : STATEOI
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCARG(cons_stateOOI) -> 1 : STATEOOI
   F(g(x, y)) -> 1 : g(F(x), F(y))
   ENCARG(s(cons_stateI)) -> 1 : s(ENCARG(cons_stateI))
   ENCODE_O -> 1 : O
   ENCODE_STATEOO -> 1 : STATEOO
   START -> 1 : F(DICE)
   STATEII -> 1 / 2 : STATEIII || 1 / 2 : STATEI
   ENCARG(s(O)) -> 1 : s(ENCARG(O))
   ENCARG(s(cons_stateOI)) -> 1 : s(ENCARG(cons_stateOI))
   ENCARG(cons_stateO) -> 1 : STATEO
   ENCARG(s(cons_stateOOI)) -> 1 : s(ENCARG(cons_stateOOI))
   ENCARG(O) -> 1 : O
   ENCODE_STATEIO -> 1 : STATEIO
   ENCARG(cons_stateIOO) -> 1 : STATEIOO
   ENCARG(cons_stateOO) -> 1 : STATEOO
   ENCARG(s(cons_stateO)) -> 1 : s(ENCARG(cons_stateO))
   ENCARG(s(cons_stateIO)) -> 1 : s(ENCARG(cons_stateIO))
   ENCARG(cons_stateOOO) -> 1 : STATEOOO
   STATEOI -> 1 / 2 : STATEOII || 1 / 2 : STATEO
   ENCARG(s(cons_stateIOO)) -> 1 : s(ENCARG(cons_stateIOO))
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : STATEOO
   STATEOOO -> 1 : s(s(s(s(s(s(O))))))
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   STATEOOI -> 1 : s(s(s(s(s(O)))))
   ENCODE_STATEIOO -> 1 : STATEIOO
   STATEOO -> 1 / 2 : STATEOOI || 1 / 2 : STATEOOO
   STATEIOO -> 1 : s(s(s(O)))
   ENCARG(s(cons_stateOOO)) -> 1 : s(ENCARG(cons_stateOOO))
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   STATEIOI -> 1 : s(s(O))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCARG(s(cons_stateIOI)) -> 1 : s(ENCARG(cons_stateIOI))
   ENCARG(cons_stateIOI) -> 1 : STATEIOI
   ENCODE_STATEI -> 1 : STATEI
   DICE -> 1 / 2 : STATEI || 1 / 2 : STATEO
   ENCARG(s(cons_dice)) -> 1 : s(ENCARG(cons_dice))
   ENCARG(cons_start) -> 1 : START
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCARG(s(cons_stateII)) -> 1 : s(ENCARG(cons_stateII))
   ENCARG(cons_stateIII) -> 1 : STATEIII
   ENCODE_STATEIOI -> 1 : STATEIOI
   STATEI -> 1 / 2 : STATEII || 1 / 2 : STATEIO
   ENCODE_STATEIII -> 1 : STATEIII
   ENCARG(s(cons_stateOII)) -> 1 : s(ENCARG(cons_stateOII))
   ENCODE_STATEOII -> 1 : STATEOII
   F(s(x)) -> 1 : F(g(x, x))
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEO -> 1 : STATEO

Rules with annotation and a known complexity:

   none

----------------------------------------

(9) CpxADP_SCCSplitProof (UPPER BOUND(ID))
As part of the dependency graph processor, we can split problem in 4 new components.
----------------------------------------

(10)
Complex Obligation (MAX)

----------------------------------------

(11)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   encArg(s(cons_stateIO)) -> 1 : s(encArg(cons_stateIO))
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(s(O)) -> 1 : s(encArg(O))
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   f(s(x)) -> 1 : f(g(x, x))
   encode_stateO -> 1 : stateO
   stateIOO -> 1 : s(s(s(O)))
   stateOOI -> 1 : s(s(s(s(s(O)))))
   encArg(s(cons_stateOI)) -> 1 : s(encArg(cons_stateOI))
   encode_stateI -> 1 : stateI
   stateIOI -> 1 : s(s(O))
   encArg(cons_stateOOO) -> 1 : stateOOO
   encode_dice -> 1 : dice
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   encode_O -> 1 : O
   encode_stateOOO -> 1 : stateOOO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   encArg(s(cons_stateOO)) -> 1 : s(encArg(cons_stateOO))
   encArg(cons_stateIOO) -> 1 : stateIOO
   f(g(x, y)) -> 1 : g(f(x), f(y))
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateIOI) -> 1 : stateIOI
   encode_stateIII -> 1 : stateIII
   encArg(s(cons_f(y0))) -> 1 : s(encArg(cons_f(y0)))
   start -> 1 : f(dice)
   encArg(s(cons_stateOII)) -> 1 : s(encArg(cons_stateOII))
   encArg(cons_stateO) -> 1 : stateO
   encArg(s(cons_stateI)) -> 1 : s(encArg(cons_stateI))
   encode_stateOII -> 1 : stateOII
   encArg(s(cons_stateII)) -> 1 : s(encArg(cons_stateII))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_stateOOI -> 1 : stateOOI
   encArg(s(cons_stateIOI)) -> 1 : s(encArg(cons_stateIOI))
   encArg(g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   stateOOO -> 1 : s(s(s(s(s(s(O))))))
   encArg(cons_start) -> 1 : start
   encode_start -> 1 : start
   stateOII -> 1 : s(s(s(s(O))))
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(s(cons_stateO)) -> 1 : s(encArg(cons_stateO))
   encode_stateIOO -> 1 : stateIOO
   encArg(s(cons_stateOOI)) -> 1 : s(encArg(cons_stateOOI))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   encode_stateOO -> 1 : stateOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   encArg(s(cons_start)) -> 1 : s(encArg(cons_start))
   encArg(O) -> 1 : O
   encode_stateOI -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   stateIII -> 1 : s(O)
   encArg(s(cons_stateOOO)) -> 1 : s(encArg(cons_stateOOO))
   encArg(s(cons_stateIOO)) -> 1 : s(encArg(cons_stateIOO))
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateII) -> 1 : stateII
   encode_stateII -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   encArg(s(g(y0, y1))) -> 1 : s(encArg(g(y0, y1)))
   encArg(s(cons_stateIII)) -> 1 : s(encArg(cons_stateIII))
   encArg(s(s(y0))) -> 1 : s(encArg(s(y0)))
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_dice) -> 1 : dice
   encArg(s(cons_dice)) -> 1 : s(encArg(cons_dice))

Rules with annotation in P:

   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))

Rules with annotation in S:

   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))

Rules with annotation and a known complexity:

   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))


----------------------------------------

(12) CpxADP_UsableTermsProof (UPPER BOUND(ID))


The approximation of the Dependency Graph  gives us the following unusable Terms: 
   F(encArg(x_1))
Hence, as part of the dependency graph processor, we can remove the annotations from these terms from every RHS of every ADP in P and S.

----------------------------------------

(13)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   encArg(s(cons_stateIO)) -> 1 : s(encArg(cons_stateIO))
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(s(O)) -> 1 : s(encArg(O))
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   f(s(x)) -> 1 : f(g(x, x))
   encode_stateO -> 1 : stateO
   stateIOO -> 1 : s(s(s(O)))
   stateOOI -> 1 : s(s(s(s(s(O)))))
   encArg(s(cons_stateOI)) -> 1 : s(encArg(cons_stateOI))
   encode_stateI -> 1 : stateI
   stateIOI -> 1 : s(s(O))
   encArg(cons_stateOOO) -> 1 : stateOOO
   encode_dice -> 1 : dice
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   encode_O -> 1 : O
   encode_stateOOO -> 1 : stateOOO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   encArg(s(cons_stateOO)) -> 1 : s(encArg(cons_stateOO))
   encArg(cons_stateIOO) -> 1 : stateIOO
   f(g(x, y)) -> 1 : g(f(x), f(y))
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateIOI) -> 1 : stateIOI
   encode_stateIII -> 1 : stateIII
   encArg(s(cons_f(y0))) -> 1 : s(encArg(cons_f(y0)))
   start -> 1 : f(dice)
   encArg(s(cons_stateOII)) -> 1 : s(encArg(cons_stateOII))
   encArg(cons_stateO) -> 1 : stateO
   encArg(s(cons_stateI)) -> 1 : s(encArg(cons_stateI))
   encode_stateOII -> 1 : stateOII
   encArg(s(cons_stateII)) -> 1 : s(encArg(cons_stateII))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_stateOOI -> 1 : stateOOI
   encArg(s(cons_stateIOI)) -> 1 : s(encArg(cons_stateIOI))
   encArg(g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   stateOOO -> 1 : s(s(s(s(s(s(O))))))
   encArg(cons_start) -> 1 : start
   encode_start -> 1 : start
   stateOII -> 1 : s(s(s(s(O))))
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(s(cons_stateO)) -> 1 : s(encArg(cons_stateO))
   encode_stateIOO -> 1 : stateIOO
   encArg(s(cons_stateOOI)) -> 1 : s(encArg(cons_stateOOI))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   encode_stateOO -> 1 : stateOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   encArg(s(cons_start)) -> 1 : s(encArg(cons_start))
   encArg(O) -> 1 : O
   encode_stateOI -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   stateIII -> 1 : s(O)
   encArg(s(cons_stateOOO)) -> 1 : s(encArg(cons_stateOOO))
   encArg(s(cons_stateIOO)) -> 1 : s(encArg(cons_stateIOO))
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateII) -> 1 : stateII
   encode_stateII -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   encArg(s(g(y0, y1))) -> 1 : s(encArg(g(y0, y1)))
   encArg(s(cons_stateIII)) -> 1 : s(encArg(cons_stateIII))
   encArg(s(s(y0))) -> 1 : s(encArg(s(y0)))
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_dice) -> 1 : dice
   encArg(s(cons_dice)) -> 1 : s(encArg(cons_dice))

Rules with annotation in P:

   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))

Rules with annotation in S:

   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))

Rules with annotation and a known complexity:

   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))


----------------------------------------

(14) CpxADP_UsableRulesProof (BOTH BOUNDS(ID, ID))


We use the usable rules processor.
We can deactivate the flags for all non-usable rules [FROCOS05]

Rules which have been flagged as non usable in this step:

   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   encArg(s(cons_stateIO)) -> 1 : s(encArg(cons_stateIO))
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(s(O)) -> 1 : s(encArg(O))
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   f(s(x)) -> 1 : f(g(x, x))
   encode_stateO -> 1 : stateO
   stateIOO -> 1 : s(s(s(O)))
   stateOOI -> 1 : s(s(s(s(s(O)))))
   encArg(s(cons_stateOI)) -> 1 : s(encArg(cons_stateOI))
   encode_stateI -> 1 : stateI
   stateIOI -> 1 : s(s(O))
   encArg(cons_stateOOO) -> 1 : stateOOO
   encode_dice -> 1 : dice
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   encode_O -> 1 : O
   encode_stateOOO -> 1 : stateOOO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   encArg(s(cons_stateOO)) -> 1 : s(encArg(cons_stateOO))
   encArg(cons_stateIOO) -> 1 : stateIOO
   f(g(x, y)) -> 1 : g(f(x), f(y))
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateIOI) -> 1 : stateIOI
   encode_stateIII -> 1 : stateIII
   encArg(s(cons_f(y0))) -> 1 : s(encArg(cons_f(y0)))
   start -> 1 : f(dice)
   encArg(s(cons_stateOII)) -> 1 : s(encArg(cons_stateOII))
   encArg(cons_stateO) -> 1 : stateO
   encArg(s(cons_stateI)) -> 1 : s(encArg(cons_stateI))
   encode_stateOII -> 1 : stateOII
   encArg(s(cons_stateII)) -> 1 : s(encArg(cons_stateII))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_stateOOI -> 1 : stateOOI
   encArg(s(cons_stateIOI)) -> 1 : s(encArg(cons_stateIOI))
   encArg(g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   stateOOO -> 1 : s(s(s(s(s(s(O))))))
   encArg(cons_start) -> 1 : start
   encode_start -> 1 : start
   stateOII -> 1 : s(s(s(s(O))))
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(s(cons_stateO)) -> 1 : s(encArg(cons_stateO))
   encode_stateIOO -> 1 : stateIOO
   encArg(s(cons_stateOOI)) -> 1 : s(encArg(cons_stateOOI))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   encode_stateOO -> 1 : stateOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   encArg(s(cons_start)) -> 1 : s(encArg(cons_start))
   encArg(O) -> 1 : O
   encode_stateOI -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   stateIII -> 1 : s(O)
   encArg(s(cons_stateOOO)) -> 1 : s(encArg(cons_stateOOO))
   encArg(s(cons_stateIOO)) -> 1 : s(encArg(cons_stateIOO))
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateII) -> 1 : stateII
   encode_stateII -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   encArg(s(g(y0, y1))) -> 1 : s(encArg(g(y0, y1)))
   encArg(s(cons_stateIII)) -> 1 : s(encArg(cons_stateIII))
   encArg(s(s(y0))) -> 1 : s(encArg(s(y0)))
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_dice) -> 1 : dice
   encArg(s(cons_dice)) -> 1 : s(encArg(cons_dice))

----------------------------------------

(15)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:
   none
Rules with annotation in P:

   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))

Rules with annotation in S:

   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))

Rules with annotation and a known complexity:

   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))


----------------------------------------

(16) CpxADP_ProbabilityRemovalProof (UPPER BOUND(ID))


We use the probability removal processor to move to dependecy tuples without probabilities.
As all rules have a trivial probability (1:r), we can transform it into a non-probabilistic DT problem

----------------------------------------

(17)
Obligation:
Complexity Dependency Tuples Problem

Rules:none
Tuples:
   ENCARG(s(s(y0))) -> c(ENCARG(s(y0)))
   ENCARG(g(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCARG(g(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCARG(s(g(y0, y1))) -> c3(ENCARG(g(y0, y1)))
   ENCODE_F(x_1) -> c4(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> c5(ENCARG(x_1))
   ENCODE_S(x_1) -> c6(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> c7(ENCARG(x_2), ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> c8(ENCARG(x_2), ENCARG(x_1))
   ENCARG(s(cons_f(y0))) -> c9(ENCARG(cons_f(y0)))
S tuples:
   ENCARG(s(s(y0))) -> c(ENCARG(s(y0)))
   ENCARG(g(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCARG(g(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCARG(s(g(y0, y1))) -> c3(ENCARG(g(y0, y1)))
   ENCODE_F(x_1) -> c4(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> c5(ENCARG(x_1))
   ENCODE_S(x_1) -> c6(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> c7(ENCARG(x_2), ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> c8(ENCARG(x_2), ENCARG(x_1))
   ENCARG(s(cons_f(y0))) -> c9(ENCARG(cons_f(y0)))
K tuples:none
Defined Rule Symbols:   encArg_1, encode_dice, encode_stateO, encode_stateI, encode_stateIOO, encode_s_1, encode_O, encode_stateOO, encode_stateOI, encode_stateIII, encode_stateOOI, encode_stateII, encode_stateIO, encode_stateIOI, encode_start, encode_f_1, encode_g_2, encode_stateOOO, encode_stateOII, dice, stateOII, stateIO, f_1, stateOO, stateIOO, stateOI, stateOOI, stateO, start, stateIOI, stateIII, stateI, stateII, stateOOO

Defined Pair Symbols:none

Compound Symbols:   c_1, c1_2, c2_2, c3_1, c4_1, c5_1, c6_1, c7_2, c8_2, c9_1


----------------------------------------

(18) CdtLeafRemovalProof (ComplexityIfPolyImplication)
Removed 4 leading nodes:
   ENCODE_F(x_1) -> c4(ENCARG(x_1))
   ENCODE_S(x_1) -> c6(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> c7(ENCARG(x_2), ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> c8(ENCARG(x_2), ENCARG(x_1))

----------------------------------------

(19)
Obligation:
Complexity Dependency Tuples Problem

Rules:none
Tuples:
   ENCARG(s(s(y0))) -> c(ENCARG(s(y0)))
   ENCARG(g(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCARG(g(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCARG(s(g(y0, y1))) -> c3(ENCARG(g(y0, y1)))
   ENCARG(cons_f(x_1)) -> c5(ENCARG(x_1))
   ENCARG(s(cons_f(y0))) -> c9(ENCARG(cons_f(y0)))
S tuples:
   ENCARG(s(s(y0))) -> c(ENCARG(s(y0)))
   ENCARG(g(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCARG(g(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCARG(s(g(y0, y1))) -> c3(ENCARG(g(y0, y1)))
   ENCARG(cons_f(x_1)) -> c5(ENCARG(x_1))
   ENCARG(s(cons_f(y0))) -> c9(ENCARG(cons_f(y0)))
K tuples:none
Defined Rule Symbols:   encArg_1, encode_dice, encode_stateO, encode_stateI, encode_stateIOO, encode_s_1, encode_O, encode_stateOO, encode_stateOI, encode_stateIII, encode_stateOOI, encode_stateII, encode_stateIO, encode_stateIOI, encode_start, encode_f_1, encode_g_2, encode_stateOOO, encode_stateOII, dice, stateOII, stateIO, f_1, stateOO, stateIOO, stateOI, stateOOI, stateO, start, stateIOI, stateIII, stateI, stateII, stateOOO

Defined Pair Symbols:   ENCARG_1

Compound Symbols:   c_1, c1_2, c2_2, c3_1, c5_1, c9_1


----------------------------------------

(20) CdtToCpxRelTrsProof (BOTH BOUNDS(ID, ID))
Converted S to standard rules, and D \ S as well as R to relative rules.
----------------------------------------

(21)
Obligation:
The Runtime Complexity (innermost) of the given CpxTRS could be proven to be BOUNDS(1, n^1).


The TRS R consists of the following rules:

   ENCARG(s(s(y0))) -> c(ENCARG(s(y0)))
   ENCARG(g(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCARG(g(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCARG(s(g(y0, y1))) -> c3(ENCARG(g(y0, y1)))
   ENCARG(cons_f(x_1)) -> c5(ENCARG(x_1))
   ENCARG(s(cons_f(y0))) -> c9(ENCARG(cons_f(y0)))

S is empty.
Rewrite Strategy: INNERMOST
----------------------------------------

(22) RelTrsToTrsProof (UPPER BOUND(ID))
transformed relative TRS to TRS
----------------------------------------

(23)
Obligation:
The Runtime Complexity (innermost) of the given CpxTRS could be proven to be BOUNDS(1, n^1).


The TRS R consists of the following rules:

   ENCARG(s(s(y0))) -> c(ENCARG(s(y0)))
   ENCARG(g(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCARG(g(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCARG(s(g(y0, y1))) -> c3(ENCARG(g(y0, y1)))
   ENCARG(cons_f(x_1)) -> c5(ENCARG(x_1))
   ENCARG(s(cons_f(y0))) -> c9(ENCARG(cons_f(y0)))

S is empty.
Rewrite Strategy: INNERMOST
----------------------------------------

(24) CpxTrsMatchBoundsTAProof (FINISHED)
A linear upper bound on the runtime complexity of the TRS R could be shown with a Match-Bound[TAB_LEFTLINEAR,TAB_NONLEFTLINEAR] (for contructor-based start-terms) of 2. 

The compatible tree automaton used to show the Match-Boundedness (for constructor-based start-terms) is represented by: 
final states : [1]
transitions: 
s0(0) -> 0
c0(0) -> 0
g0(0, 0) -> 0
c10(0, 0) -> 0
c20(0, 0) -> 0
c30(0) -> 0
cons_f0(0) -> 0
c50(0) -> 0
c90(0) -> 0
ENCARG0(0) -> 1
s1(0) -> 3
ENCARG1(3) -> 2
c1(2) -> 1
ENCARG1(0) -> 4
ENCARG1(0) -> 5
c11(4, 5) -> 1
ENCARG1(0) -> 6
ENCARG1(0) -> 7
c21(6, 7) -> 1
g1(0, 0) -> 9
ENCARG1(9) -> 8
c31(8) -> 1
ENCARG1(0) -> 10
c51(10) -> 1
cons_f1(0) -> 12
ENCARG1(12) -> 11
c91(11) -> 1
c1(2) -> 4
c1(2) -> 5
c1(2) -> 6
c1(2) -> 7
c1(2) -> 10
c1(2) -> 2
c11(4, 5) -> 4
c11(4, 5) -> 5
c11(4, 5) -> 6
c11(4, 5) -> 7
c11(4, 5) -> 10
ENCARG2(0) -> 13
ENCARG2(0) -> 14
c12(13, 14) -> 8
c21(6, 7) -> 4
c21(6, 7) -> 5
c21(6, 7) -> 6
c21(6, 7) -> 7
c21(6, 7) -> 10
ENCARG2(0) -> 15
ENCARG2(0) -> 16
c22(15, 16) -> 8
c31(8) -> 4
c31(8) -> 5
c31(8) -> 6
c31(8) -> 7
c31(8) -> 10
c31(8) -> 2
c51(10) -> 4
c51(10) -> 5
c51(10) -> 6
c51(10) -> 7
c51(10) -> 10
ENCARG2(0) -> 17
c52(17) -> 11
c91(11) -> 4
c91(11) -> 5
c91(11) -> 6
c91(11) -> 7
c91(11) -> 10
c91(11) -> 2
c1(2) -> 13
c1(2) -> 14
c1(2) -> 15
c1(2) -> 16
c1(2) -> 17
c11(4, 5) -> 13
c11(4, 5) -> 14
c11(4, 5) -> 15
c11(4, 5) -> 16
c11(4, 5) -> 17
c21(6, 7) -> 13
c21(6, 7) -> 14
c21(6, 7) -> 15
c21(6, 7) -> 16
c21(6, 7) -> 17
c31(8) -> 13
c31(8) -> 14
c31(8) -> 15
c31(8) -> 16
c31(8) -> 17
c51(10) -> 13
c51(10) -> 14
c51(10) -> 15
c51(10) -> 16
c51(10) -> 17
c91(11) -> 13
c91(11) -> 14
c91(11) -> 15
c91(11) -> 16
c91(11) -> 17

----------------------------------------

(25)
BOUNDS(1, n^1)

----------------------------------------

(26)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   encArg(s(cons_stateIO)) -> 1 : s(encArg(cons_stateIO))
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(s(O)) -> 1 : s(encArg(O))
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   f(s(x)) -> 1 : f(g(x, x))
   encode_stateO -> 1 : stateO
   stateIOO -> 1 : s(s(s(O)))
   stateOOI -> 1 : s(s(s(s(s(O)))))
   encArg(s(cons_stateOI)) -> 1 : s(encArg(cons_stateOI))
   encode_stateI -> 1 : stateI
   stateIOI -> 1 : s(s(O))
   encArg(cons_stateOOO) -> 1 : stateOOO
   encode_dice -> 1 : dice
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   encode_O -> 1 : O
   encode_stateOOO -> 1 : stateOOO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   encArg(s(cons_stateOO)) -> 1 : s(encArg(cons_stateOO))
   encArg(cons_stateIOO) -> 1 : stateIOO
   f(g(x, y)) -> 1 : g(f(x), f(y))
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateIOI) -> 1 : stateIOI
   encode_stateIII -> 1 : stateIII
   encArg(s(cons_f(y0))) -> 1 : s(encArg(cons_f(y0)))
   start -> 1 : f(dice)
   encArg(s(cons_stateOII)) -> 1 : s(encArg(cons_stateOII))
   encArg(cons_stateO) -> 1 : stateO
   encArg(s(cons_stateI)) -> 1 : s(encArg(cons_stateI))
   encode_stateOII -> 1 : stateOII
   encArg(s(cons_stateII)) -> 1 : s(encArg(cons_stateII))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_stateOOI -> 1 : stateOOI
   encArg(s(cons_stateIOI)) -> 1 : s(encArg(cons_stateIOI))
   encArg(g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   stateOOO -> 1 : s(s(s(s(s(s(O))))))
   encArg(cons_start) -> 1 : start
   encode_start -> 1 : start
   stateOII -> 1 : s(s(s(s(O))))
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(s(cons_stateO)) -> 1 : s(encArg(cons_stateO))
   encode_stateIOO -> 1 : stateIOO
   encArg(s(cons_stateOOI)) -> 1 : s(encArg(cons_stateOOI))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   encode_stateOO -> 1 : stateOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   encArg(s(cons_start)) -> 1 : s(encArg(cons_start))
   encArg(O) -> 1 : O
   encode_stateOI -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   stateIII -> 1 : s(O)
   encArg(s(cons_stateOOO)) -> 1 : s(encArg(cons_stateOOO))
   encArg(s(cons_stateIOO)) -> 1 : s(encArg(cons_stateIOO))
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateII) -> 1 : stateII
   encode_stateII -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   encArg(s(g(y0, y1))) -> 1 : s(encArg(g(y0, y1)))
   encArg(s(cons_stateIII)) -> 1 : s(encArg(cons_stateIII))
   encArg(s(s(y0))) -> 1 : s(encArg(s(y0)))
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_dice) -> 1 : dice
   encArg(s(cons_dice)) -> 1 : s(encArg(cons_dice))

Rules with annotation in P:

   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(cons_dice)) -> 1 : s(ENCARG(cons_dice))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(s(cons_stateO)) -> 1 : s(ENCARG(cons_stateO))
   ENCARG(cons_stateO) -> 1 : STATEO
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCARG(cons_start) -> 1 : START
   ENCARG(s(cons_stateOI)) -> 1 : s(ENCARG(cons_stateOI))
   ENCARG(cons_stateOI) -> 1 : STATEOI
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEO -> 1 : STATEO
   ENCODE_STATEOI -> 1 : STATEOI
   ENCODE_START -> 1 : START
   START -> 1 : F(DICE)
   DICE -> 1 / 2 : STATEI || 1 / 2 : STATEO
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : STATEOO
   STATEOI -> 1 / 2 : STATEOII || 1 / 2 : STATEO

Rules with annotation in S:

   STATEO -> 1 / 2 : STATEOI || 1 / 2 : STATEOO
   STATEOI -> 1 / 2 : STATEOII || 1 / 2 : STATEO

Rules with annotation and a known complexity:

   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(cons_dice)) -> 1 : s(ENCARG(cons_dice))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(s(cons_stateO)) -> 1 : s(ENCARG(cons_stateO))
   ENCARG(cons_stateO) -> 1 : STATEO
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCARG(cons_start) -> 1 : START
   ENCARG(s(cons_stateOI)) -> 1 : s(ENCARG(cons_stateOI))
   ENCARG(cons_stateOI) -> 1 : STATEOI
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEO -> 1 : STATEO
   ENCODE_STATEOI -> 1 : STATEOI
   ENCODE_START -> 1 : START
   START -> 1 : F(DICE)
   DICE -> 1 / 2 : STATEI || 1 / 2 : STATEO


----------------------------------------

(27) CpxADP_UsableTermsProof (UPPER BOUND(ID))


The approximation of the Dependency Graph  gives us the following unusable Terms: 
   STATEOO, F(encArg(x_1)), STATEI, STATEOII, F(dice)
Hence, as part of the dependency graph processor, we can remove the annotations from these terms from every RHS of every ADP in P and S.

----------------------------------------

(28)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   encArg(s(cons_stateIO)) -> 1 : s(encArg(cons_stateIO))
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(s(O)) -> 1 : s(encArg(O))
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   f(s(x)) -> 1 : f(g(x, x))
   encode_stateO -> 1 : stateO
   stateIOO -> 1 : s(s(s(O)))
   stateOOI -> 1 : s(s(s(s(s(O)))))
   encArg(s(cons_stateOI)) -> 1 : s(encArg(cons_stateOI))
   encode_stateI -> 1 : stateI
   stateIOI -> 1 : s(s(O))
   encArg(cons_stateOOO) -> 1 : stateOOO
   encode_dice -> 1 : dice
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   encode_O -> 1 : O
   encode_stateOOO -> 1 : stateOOO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   encArg(s(cons_stateOO)) -> 1 : s(encArg(cons_stateOO))
   encArg(cons_stateIOO) -> 1 : stateIOO
   f(g(x, y)) -> 1 : g(f(x), f(y))
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateIOI) -> 1 : stateIOI
   encode_stateIII -> 1 : stateIII
   encArg(s(cons_f(y0))) -> 1 : s(encArg(cons_f(y0)))
   start -> 1 : f(dice)
   encArg(s(cons_stateOII)) -> 1 : s(encArg(cons_stateOII))
   encArg(cons_stateO) -> 1 : stateO
   encArg(s(cons_stateI)) -> 1 : s(encArg(cons_stateI))
   encode_stateOII -> 1 : stateOII
   encArg(s(cons_stateII)) -> 1 : s(encArg(cons_stateII))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_stateOOI -> 1 : stateOOI
   encArg(s(cons_stateIOI)) -> 1 : s(encArg(cons_stateIOI))
   encArg(g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   stateOOO -> 1 : s(s(s(s(s(s(O))))))
   encArg(cons_start) -> 1 : start
   encode_start -> 1 : start
   stateOII -> 1 : s(s(s(s(O))))
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(s(cons_stateO)) -> 1 : s(encArg(cons_stateO))
   encode_stateIOO -> 1 : stateIOO
   encArg(s(cons_stateOOI)) -> 1 : s(encArg(cons_stateOOI))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   encode_stateOO -> 1 : stateOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   encArg(s(cons_start)) -> 1 : s(encArg(cons_start))
   encArg(O) -> 1 : O
   encode_stateOI -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   stateIII -> 1 : s(O)
   encArg(s(cons_stateOOO)) -> 1 : s(encArg(cons_stateOOO))
   encArg(s(cons_stateIOO)) -> 1 : s(encArg(cons_stateIOO))
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateII) -> 1 : stateII
   encode_stateII -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   encArg(s(g(y0, y1))) -> 1 : s(encArg(g(y0, y1)))
   encArg(s(cons_stateIII)) -> 1 : s(encArg(cons_stateIII))
   encArg(s(s(y0))) -> 1 : s(encArg(s(y0)))
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_dice) -> 1 : dice
   encArg(s(cons_dice)) -> 1 : s(encArg(cons_dice))

Rules with annotation in P:

   ENCARG(cons_start) -> 1 : START
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   DICE -> 1 / 2 : stateI || 1 / 2 : STATEO
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(cons_stateOI)) -> 1 : s(ENCARG(cons_stateOI))
   ENCARG(cons_stateO) -> 1 : STATEO
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : stateOO
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCODE_DICE -> 1 : DICE
   ENCODE_START -> 1 : START
   ENCODE_STATEOI -> 1 : STATEOI
   ENCARG(s(cons_stateO)) -> 1 : s(ENCARG(cons_stateO))
   ENCODE_STATEO -> 1 : STATEO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   START -> 1 : f(DICE)
   STATEOI -> 1 / 2 : stateOII || 1 / 2 : STATEO
   ENCARG(s(cons_dice)) -> 1 : s(ENCARG(cons_dice))

Rules with annotation in S:

   STATEO -> 1 / 2 : STATEOI || 1 / 2 : stateOO
   STATEOI -> 1 / 2 : stateOII || 1 / 2 : STATEO

Rules with annotation and a known complexity:

   ENCARG(cons_start) -> 1 : START
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   DICE -> 1 / 2 : stateI || 1 / 2 : STATEO
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(cons_stateOI)) -> 1 : s(ENCARG(cons_stateOI))
   ENCARG(cons_stateO) -> 1 : STATEO
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCODE_DICE -> 1 : DICE
   ENCODE_START -> 1 : START
   ENCODE_STATEOI -> 1 : STATEOI
   ENCARG(s(cons_stateO)) -> 1 : s(ENCARG(cons_stateO))
   ENCODE_STATEO -> 1 : STATEO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   START -> 1 : f(DICE)
   ENCARG(s(cons_dice)) -> 1 : s(ENCARG(cons_dice))


----------------------------------------

(29) CpxADP_UsableRulesProof (BOTH BOUNDS(ID, ID))


We use the usable rules processor.
We can deactivate the flags for all non-usable rules [FROCOS05]

Rules which have been flagged as non usable in this step:

   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   encArg(s(cons_stateIO)) -> 1 : s(encArg(cons_stateIO))
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(s(O)) -> 1 : s(encArg(O))
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   f(s(x)) -> 1 : f(g(x, x))
   encode_stateO -> 1 : stateO
   stateIOO -> 1 : s(s(s(O)))
   stateOOI -> 1 : s(s(s(s(s(O)))))
   encArg(s(cons_stateOI)) -> 1 : s(encArg(cons_stateOI))
   encode_stateI -> 1 : stateI
   stateIOI -> 1 : s(s(O))
   encArg(cons_stateOOO) -> 1 : stateOOO
   encode_dice -> 1 : dice
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   encode_O -> 1 : O
   encode_stateOOO -> 1 : stateOOO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   encArg(s(cons_stateOO)) -> 1 : s(encArg(cons_stateOO))
   encArg(cons_stateIOO) -> 1 : stateIOO
   f(g(x, y)) -> 1 : g(f(x), f(y))
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateIOI) -> 1 : stateIOI
   encode_stateIII -> 1 : stateIII
   encArg(s(cons_f(y0))) -> 1 : s(encArg(cons_f(y0)))
   start -> 1 : f(dice)
   encArg(s(cons_stateOII)) -> 1 : s(encArg(cons_stateOII))
   encArg(cons_stateO) -> 1 : stateO
   encArg(s(cons_stateI)) -> 1 : s(encArg(cons_stateI))
   encode_stateOII -> 1 : stateOII
   encArg(s(cons_stateII)) -> 1 : s(encArg(cons_stateII))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_stateOOI -> 1 : stateOOI
   encArg(s(cons_stateIOI)) -> 1 : s(encArg(cons_stateIOI))
   encArg(g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   stateOOO -> 1 : s(s(s(s(s(s(O))))))
   encArg(cons_start) -> 1 : start
   encode_start -> 1 : start
   stateOII -> 1 : s(s(s(s(O))))
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(s(cons_stateO)) -> 1 : s(encArg(cons_stateO))
   encode_stateIOO -> 1 : stateIOO
   encArg(s(cons_stateOOI)) -> 1 : s(encArg(cons_stateOOI))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   encode_stateOO -> 1 : stateOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   encArg(s(cons_start)) -> 1 : s(encArg(cons_start))
   encArg(O) -> 1 : O
   encode_stateOI -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   stateIII -> 1 : s(O)
   encArg(s(cons_stateOOO)) -> 1 : s(encArg(cons_stateOOO))
   encArg(s(cons_stateIOO)) -> 1 : s(encArg(cons_stateIOO))
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateII) -> 1 : stateII
   encode_stateII -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   encArg(s(g(y0, y1))) -> 1 : s(encArg(g(y0, y1)))
   encArg(s(cons_stateIII)) -> 1 : s(encArg(cons_stateIII))
   encArg(s(s(y0))) -> 1 : s(encArg(s(y0)))
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_dice) -> 1 : dice
   encArg(s(cons_dice)) -> 1 : s(encArg(cons_dice))

----------------------------------------

(30)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:
   none
Rules with annotation in P:

   ENCARG(cons_start) -> 1 : START
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   DICE -> 1 / 2 : stateI || 1 / 2 : STATEO
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(cons_stateOI)) -> 1 : s(ENCARG(cons_stateOI))
   ENCARG(cons_stateO) -> 1 : STATEO
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : stateOO
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCODE_DICE -> 1 : DICE
   ENCODE_START -> 1 : START
   ENCODE_STATEOI -> 1 : STATEOI
   ENCARG(s(cons_stateO)) -> 1 : s(ENCARG(cons_stateO))
   ENCODE_STATEO -> 1 : STATEO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   START -> 1 : f(DICE)
   STATEOI -> 1 / 2 : stateOII || 1 / 2 : STATEO
   ENCARG(s(cons_dice)) -> 1 : s(ENCARG(cons_dice))

Rules with annotation in S:

   STATEO -> 1 / 2 : STATEOI || 1 / 2 : stateOO
   STATEOI -> 1 / 2 : stateOII || 1 / 2 : STATEO

Rules with annotation and a known complexity:

   ENCARG(cons_start) -> 1 : START
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   DICE -> 1 / 2 : stateI || 1 / 2 : STATEO
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(cons_stateOI)) -> 1 : s(ENCARG(cons_stateOI))
   ENCARG(cons_stateO) -> 1 : STATEO
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCODE_DICE -> 1 : DICE
   ENCODE_START -> 1 : START
   ENCODE_STATEOI -> 1 : STATEOI
   ENCARG(s(cons_stateO)) -> 1 : s(ENCARG(cons_stateO))
   ENCODE_STATEO -> 1 : STATEO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   START -> 1 : f(DICE)
   ENCARG(s(cons_dice)) -> 1 : s(ENCARG(cons_dice))


----------------------------------------

(31) CpxADP_ReductionPairProof (UPPER BOUND(ADD(n^1)))


We use the reduction pair processor.
The following pairs can be oriented strictly and are moved from S:

   STATEO -> 1 / 2 : STATEOI || 1 / 2 : stateOO
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   DICE -> 1 / 2 : stateI || 1 / 2 : STATEO
   STATEOI -> 1 / 2 : stateOII || 1 / 2 : STATEO

The remaining pairs can at least be oriented weakly:

   ENCARG(cons_start) -> 1 : START
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(cons_stateOI)) -> 1 : s(ENCARG(cons_stateOI))
   ENCARG(cons_stateO) -> 1 : STATEO
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCODE_DICE -> 1 : DICE
   ENCODE_START -> 1 : START
   ENCODE_STATEOI -> 1 : STATEOI
   ENCARG(s(cons_stateO)) -> 1 : s(ENCARG(cons_stateO))
   ENCODE_STATEO -> 1 : STATEO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   START -> 1 : f(DICE)
   ENCARG(s(cons_dice)) -> 1 : s(ENCARG(cons_dice))

Used ordering:Polynomial interpretation [POLO]:

   POL(DICE) = 1
   POL(ENCARG(x_1)) = x_1
   POL(ENCODE_DICE) = 1
   POL(ENCODE_F(x_1)) = 1 + x_1
   POL(ENCODE_G(x_1, x_2)) = x_1 + x_2
   POL(ENCODE_O) = 0
   POL(ENCODE_S(x_1)) = x_1
   POL(ENCODE_START) = 1
   POL(ENCODE_STATEI) = 0
   POL(ENCODE_STATEII) = 0
   POL(ENCODE_STATEIII) = 0
   POL(ENCODE_STATEIO) = 0
   POL(ENCODE_STATEIOI) = 0
   POL(ENCODE_STATEIOO) = 0
   POL(ENCODE_STATEO) = 1
   POL(ENCODE_STATEOI) = 1
   POL(ENCODE_STATEOII) = 0
   POL(ENCODE_STATEOO) = 0
   POL(ENCODE_STATEOOI) = 0
   POL(ENCODE_STATEOOO) = 0
   POL(F(x_1)) = 0
   POL(START) = 1
   POL(STATEI) = 0
   POL(STATEII) = 0
   POL(STATEIII) = 0
   POL(STATEIO) = 0
   POL(STATEIOI) = 0
   POL(STATEIOO) = 0
   POL(STATEO) = 1
   POL(STATEOI) = 1
   POL(STATEOII) = 0
   POL(STATEOO) = 0
   POL(STATEOOI) = 0
   POL(STATEOOO) = 0
   POL(cons_dice) = 1
   POL(cons_f(x_1)) = 1 + x_1
   POL(cons_start) = 1
   POL(cons_stateO) = 1
   POL(cons_stateOI) = 1
   POL(f(x_1)) = x_1
   POL(g(x_1, x_2)) = 1 + x_1 + x_2
   POL(s(x_1)) = x_1
   POL(stateI) = 0
   POL(stateOII) = 0
   POL(stateOO) = 0

The complexity of the removed ADPs is bounded by:n^1
----------------------------------------

(32)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:
   none
Rules with annotation in P:

   ENCARG(cons_start) -> 1 : START
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   DICE -> 1 / 2 : stateI || 1 / 2 : STATEO
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(cons_stateOI)) -> 1 : s(ENCARG(cons_stateOI))
   ENCARG(cons_stateO) -> 1 : STATEO
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : stateOO
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCODE_DICE -> 1 : DICE
   ENCODE_START -> 1 : START
   ENCODE_STATEOI -> 1 : STATEOI
   ENCARG(s(cons_stateO)) -> 1 : s(ENCARG(cons_stateO))
   ENCODE_STATEO -> 1 : STATEO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   START -> 1 : f(DICE)
   STATEOI -> 1 / 2 : stateOII || 1 / 2 : STATEO
   ENCARG(s(cons_dice)) -> 1 : s(ENCARG(cons_dice))

Rules with annotation in S:

   none

Rules with annotation and a known complexity:

   ENCARG(cons_start) -> 1 : START
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   DICE -> 1 / 2 : stateI || 1 / 2 : STATEO
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(cons_stateOI)) -> 1 : s(ENCARG(cons_stateOI))
   ENCARG(cons_stateO) -> 1 : STATEO
   STATEO -> 1 / 2 : STATEOI || 1 / 2 : stateOO
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCODE_DICE -> 1 : DICE
   ENCODE_START -> 1 : START
   ENCODE_STATEOI -> 1 : STATEOI
   ENCARG(s(cons_stateO)) -> 1 : s(ENCARG(cons_stateO))
   ENCODE_STATEO -> 1 : STATEO
   ENCARG(cons_stateOI) -> 1 : STATEOI
   START -> 1 : f(DICE)
   STATEOI -> 1 / 2 : stateOII || 1 / 2 : STATEO
   ENCARG(s(cons_dice)) -> 1 : s(ENCARG(cons_dice))


----------------------------------------

(33) SisEmptyProof (FINISHED)


S contains no annotations anymore. Hence, there exists no P-CT with infinitely many S-Nodes.
Resulting upper bound: O(1)

----------------------------------------

(34)
BOUNDS(1, 1)

----------------------------------------

(35)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   encArg(s(cons_stateIO)) -> 1 : s(encArg(cons_stateIO))
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(s(O)) -> 1 : s(encArg(O))
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   f(s(x)) -> 1 : f(g(x, x))
   encode_stateO -> 1 : stateO
   stateIOO -> 1 : s(s(s(O)))
   stateOOI -> 1 : s(s(s(s(s(O)))))
   encArg(s(cons_stateOI)) -> 1 : s(encArg(cons_stateOI))
   encode_stateI -> 1 : stateI
   stateIOI -> 1 : s(s(O))
   encArg(cons_stateOOO) -> 1 : stateOOO
   encode_dice -> 1 : dice
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   encode_O -> 1 : O
   encode_stateOOO -> 1 : stateOOO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   encArg(s(cons_stateOO)) -> 1 : s(encArg(cons_stateOO))
   encArg(cons_stateIOO) -> 1 : stateIOO
   f(g(x, y)) -> 1 : g(f(x), f(y))
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateIOI) -> 1 : stateIOI
   encode_stateIII -> 1 : stateIII
   encArg(s(cons_f(y0))) -> 1 : s(encArg(cons_f(y0)))
   start -> 1 : f(dice)
   encArg(s(cons_stateOII)) -> 1 : s(encArg(cons_stateOII))
   encArg(cons_stateO) -> 1 : stateO
   encArg(s(cons_stateI)) -> 1 : s(encArg(cons_stateI))
   encode_stateOII -> 1 : stateOII
   encArg(s(cons_stateII)) -> 1 : s(encArg(cons_stateII))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_stateOOI -> 1 : stateOOI
   encArg(s(cons_stateIOI)) -> 1 : s(encArg(cons_stateIOI))
   encArg(g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   stateOOO -> 1 : s(s(s(s(s(s(O))))))
   encArg(cons_start) -> 1 : start
   encode_start -> 1 : start
   stateOII -> 1 : s(s(s(s(O))))
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(s(cons_stateO)) -> 1 : s(encArg(cons_stateO))
   encode_stateIOO -> 1 : stateIOO
   encArg(s(cons_stateOOI)) -> 1 : s(encArg(cons_stateOOI))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   encode_stateOO -> 1 : stateOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   encArg(s(cons_start)) -> 1 : s(encArg(cons_start))
   encArg(O) -> 1 : O
   encode_stateOI -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   stateIII -> 1 : s(O)
   encArg(s(cons_stateOOO)) -> 1 : s(encArg(cons_stateOOO))
   encArg(s(cons_stateIOO)) -> 1 : s(encArg(cons_stateIOO))
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateII) -> 1 : stateII
   encode_stateII -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   encArg(s(g(y0, y1))) -> 1 : s(encArg(g(y0, y1)))
   encArg(s(cons_stateIII)) -> 1 : s(encArg(cons_stateIII))
   encArg(s(s(y0))) -> 1 : s(encArg(s(y0)))
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_dice) -> 1 : dice
   encArg(s(cons_dice)) -> 1 : s(encArg(cons_dice))

Rules with annotation in P:

   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(cons_dice)) -> 1 : s(ENCARG(cons_dice))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(s(cons_stateII)) -> 1 : s(ENCARG(cons_stateII))
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCARG(cons_start) -> 1 : START
   ENCARG(s(cons_stateI)) -> 1 : s(ENCARG(cons_stateI))
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEI -> 1 : STATEI
   ENCODE_STATEII -> 1 : STATEII
   ENCODE_START -> 1 : START
   START -> 1 : F(DICE)
   DICE -> 1 / 2 : STATEI || 1 / 2 : STATEO
   STATEII -> 1 / 2 : STATEIII || 1 / 2 : STATEI
   STATEI -> 1 / 2 : STATEII || 1 / 2 : STATEIO

Rules with annotation in S:

   STATEII -> 1 / 2 : STATEIII || 1 / 2 : STATEI
   STATEI -> 1 / 2 : STATEII || 1 / 2 : STATEIO

Rules with annotation and a known complexity:

   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(cons_dice)) -> 1 : s(ENCARG(cons_dice))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(s(cons_stateII)) -> 1 : s(ENCARG(cons_stateII))
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCARG(cons_start) -> 1 : START
   ENCARG(s(cons_stateI)) -> 1 : s(ENCARG(cons_stateI))
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCODE_DICE -> 1 : DICE
   ENCODE_STATEI -> 1 : STATEI
   ENCODE_STATEII -> 1 : STATEII
   ENCODE_START -> 1 : START
   START -> 1 : F(DICE)
   DICE -> 1 / 2 : STATEI || 1 / 2 : STATEO


----------------------------------------

(36) CpxADP_UsableTermsProof (UPPER BOUND(ID))


The approximation of the Dependency Graph  gives us the following unusable Terms: 
   F(encArg(x_1)), STATEIO, STATEIII, F(dice), STATEO
Hence, as part of the dependency graph processor, we can remove the annotations from these terms from every RHS of every ADP in P and S.

----------------------------------------

(37)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   encArg(s(cons_stateIO)) -> 1 : s(encArg(cons_stateIO))
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(s(O)) -> 1 : s(encArg(O))
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   f(s(x)) -> 1 : f(g(x, x))
   encode_stateO -> 1 : stateO
   stateIOO -> 1 : s(s(s(O)))
   stateOOI -> 1 : s(s(s(s(s(O)))))
   encArg(s(cons_stateOI)) -> 1 : s(encArg(cons_stateOI))
   encode_stateI -> 1 : stateI
   stateIOI -> 1 : s(s(O))
   encArg(cons_stateOOO) -> 1 : stateOOO
   encode_dice -> 1 : dice
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   encode_O -> 1 : O
   encode_stateOOO -> 1 : stateOOO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   encArg(s(cons_stateOO)) -> 1 : s(encArg(cons_stateOO))
   encArg(cons_stateIOO) -> 1 : stateIOO
   f(g(x, y)) -> 1 : g(f(x), f(y))
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateIOI) -> 1 : stateIOI
   encode_stateIII -> 1 : stateIII
   encArg(s(cons_f(y0))) -> 1 : s(encArg(cons_f(y0)))
   start -> 1 : f(dice)
   encArg(s(cons_stateOII)) -> 1 : s(encArg(cons_stateOII))
   encArg(cons_stateO) -> 1 : stateO
   encArg(s(cons_stateI)) -> 1 : s(encArg(cons_stateI))
   encode_stateOII -> 1 : stateOII
   encArg(s(cons_stateII)) -> 1 : s(encArg(cons_stateII))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_stateOOI -> 1 : stateOOI
   encArg(s(cons_stateIOI)) -> 1 : s(encArg(cons_stateIOI))
   encArg(g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   stateOOO -> 1 : s(s(s(s(s(s(O))))))
   encArg(cons_start) -> 1 : start
   encode_start -> 1 : start
   stateOII -> 1 : s(s(s(s(O))))
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(s(cons_stateO)) -> 1 : s(encArg(cons_stateO))
   encode_stateIOO -> 1 : stateIOO
   encArg(s(cons_stateOOI)) -> 1 : s(encArg(cons_stateOOI))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   encode_stateOO -> 1 : stateOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   encArg(s(cons_start)) -> 1 : s(encArg(cons_start))
   encArg(O) -> 1 : O
   encode_stateOI -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   stateIII -> 1 : s(O)
   encArg(s(cons_stateOOO)) -> 1 : s(encArg(cons_stateOOO))
   encArg(s(cons_stateIOO)) -> 1 : s(encArg(cons_stateIOO))
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateII) -> 1 : stateII
   encode_stateII -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   encArg(s(g(y0, y1))) -> 1 : s(encArg(g(y0, y1)))
   encArg(s(cons_stateIII)) -> 1 : s(encArg(cons_stateIII))
   encArg(s(s(y0))) -> 1 : s(encArg(s(y0)))
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_dice) -> 1 : dice
   encArg(s(cons_dice)) -> 1 : s(encArg(cons_dice))

Rules with annotation in P:

   ENCARG(cons_start) -> 1 : START
   ENCODE_STATEII -> 1 : STATEII
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCARG(s(cons_stateII)) -> 1 : s(ENCARG(cons_stateII))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   STATEII -> 1 / 2 : stateIII || 1 / 2 : STATEI
   DICE -> 1 / 2 : STATEI || 1 / 2 : stateO
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCODE_DICE -> 1 : DICE
   ENCODE_START -> 1 : START
   STATEI -> 1 / 2 : STATEII || 1 / 2 : stateIO
   START -> 1 : f(DICE)
   ENCODE_STATEI -> 1 : STATEI
   ENCARG(s(cons_dice)) -> 1 : s(ENCARG(cons_dice))
   ENCARG(s(cons_stateI)) -> 1 : s(ENCARG(cons_stateI))

Rules with annotation in S:

   STATEI -> 1 / 2 : STATEII || 1 / 2 : stateIO
   STATEII -> 1 / 2 : stateIII || 1 / 2 : STATEI

Rules with annotation and a known complexity:

   ENCARG(cons_start) -> 1 : START
   ENCODE_STATEII -> 1 : STATEII
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCARG(s(cons_stateII)) -> 1 : s(ENCARG(cons_stateII))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   DICE -> 1 / 2 : STATEI || 1 / 2 : stateO
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCODE_DICE -> 1 : DICE
   ENCODE_START -> 1 : START
   START -> 1 : f(DICE)
   ENCODE_STATEI -> 1 : STATEI
   ENCARG(s(cons_dice)) -> 1 : s(ENCARG(cons_dice))
   ENCARG(s(cons_stateI)) -> 1 : s(ENCARG(cons_stateI))


----------------------------------------

(38) CpxADP_UsableRulesProof (BOTH BOUNDS(ID, ID))


We use the usable rules processor.
We can deactivate the flags for all non-usable rules [FROCOS05]

Rules which have been flagged as non usable in this step:

   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   encArg(s(cons_stateIO)) -> 1 : s(encArg(cons_stateIO))
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(s(O)) -> 1 : s(encArg(O))
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   f(s(x)) -> 1 : f(g(x, x))
   encode_stateO -> 1 : stateO
   stateIOO -> 1 : s(s(s(O)))
   stateOOI -> 1 : s(s(s(s(s(O)))))
   encArg(s(cons_stateOI)) -> 1 : s(encArg(cons_stateOI))
   encode_stateI -> 1 : stateI
   stateIOI -> 1 : s(s(O))
   encArg(cons_stateOOO) -> 1 : stateOOO
   encode_dice -> 1 : dice
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   encode_O -> 1 : O
   encode_stateOOO -> 1 : stateOOO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   encArg(s(cons_stateOO)) -> 1 : s(encArg(cons_stateOO))
   encArg(cons_stateIOO) -> 1 : stateIOO
   f(g(x, y)) -> 1 : g(f(x), f(y))
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateIOI) -> 1 : stateIOI
   encode_stateIII -> 1 : stateIII
   encArg(s(cons_f(y0))) -> 1 : s(encArg(cons_f(y0)))
   start -> 1 : f(dice)
   encArg(s(cons_stateOII)) -> 1 : s(encArg(cons_stateOII))
   encArg(cons_stateO) -> 1 : stateO
   encArg(s(cons_stateI)) -> 1 : s(encArg(cons_stateI))
   encode_stateOII -> 1 : stateOII
   encArg(s(cons_stateII)) -> 1 : s(encArg(cons_stateII))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_stateOOI -> 1 : stateOOI
   encArg(s(cons_stateIOI)) -> 1 : s(encArg(cons_stateIOI))
   encArg(g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   stateOOO -> 1 : s(s(s(s(s(s(O))))))
   encArg(cons_start) -> 1 : start
   encode_start -> 1 : start
   stateOII -> 1 : s(s(s(s(O))))
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(s(cons_stateO)) -> 1 : s(encArg(cons_stateO))
   encode_stateIOO -> 1 : stateIOO
   encArg(s(cons_stateOOI)) -> 1 : s(encArg(cons_stateOOI))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   encode_stateOO -> 1 : stateOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   encArg(s(cons_start)) -> 1 : s(encArg(cons_start))
   encArg(O) -> 1 : O
   encode_stateOI -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   stateIII -> 1 : s(O)
   encArg(s(cons_stateOOO)) -> 1 : s(encArg(cons_stateOOO))
   encArg(s(cons_stateIOO)) -> 1 : s(encArg(cons_stateIOO))
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateII) -> 1 : stateII
   encode_stateII -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   encArg(s(g(y0, y1))) -> 1 : s(encArg(g(y0, y1)))
   encArg(s(cons_stateIII)) -> 1 : s(encArg(cons_stateIII))
   encArg(s(s(y0))) -> 1 : s(encArg(s(y0)))
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_dice) -> 1 : dice
   encArg(s(cons_dice)) -> 1 : s(encArg(cons_dice))

----------------------------------------

(39)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:
   none
Rules with annotation in P:

   ENCARG(cons_start) -> 1 : START
   ENCODE_STATEII -> 1 : STATEII
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCARG(s(cons_stateII)) -> 1 : s(ENCARG(cons_stateII))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   STATEII -> 1 / 2 : stateIII || 1 / 2 : STATEI
   DICE -> 1 / 2 : STATEI || 1 / 2 : stateO
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCODE_DICE -> 1 : DICE
   ENCODE_START -> 1 : START
   STATEI -> 1 / 2 : STATEII || 1 / 2 : stateIO
   START -> 1 : f(DICE)
   ENCODE_STATEI -> 1 : STATEI
   ENCARG(s(cons_dice)) -> 1 : s(ENCARG(cons_dice))
   ENCARG(s(cons_stateI)) -> 1 : s(ENCARG(cons_stateI))

Rules with annotation in S:

   STATEI -> 1 / 2 : STATEII || 1 / 2 : stateIO
   STATEII -> 1 / 2 : stateIII || 1 / 2 : STATEI

Rules with annotation and a known complexity:

   ENCARG(cons_start) -> 1 : START
   ENCODE_STATEII -> 1 : STATEII
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCARG(s(cons_stateII)) -> 1 : s(ENCARG(cons_stateII))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   DICE -> 1 / 2 : STATEI || 1 / 2 : stateO
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCODE_DICE -> 1 : DICE
   ENCODE_START -> 1 : START
   START -> 1 : f(DICE)
   ENCODE_STATEI -> 1 : STATEI
   ENCARG(s(cons_dice)) -> 1 : s(ENCARG(cons_dice))
   ENCARG(s(cons_stateI)) -> 1 : s(ENCARG(cons_stateI))


----------------------------------------

(40) CpxADP_ReductionPairProof (UPPER BOUND(ADD(n^1)))


We use the reduction pair processor.
The following pairs can be oriented strictly and are moved from S:

   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   STATEI -> 1 / 2 : STATEII || 1 / 2 : stateIO
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   STATEII -> 1 / 2 : stateIII || 1 / 2 : STATEI
   DICE -> 1 / 2 : STATEI || 1 / 2 : stateO
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))

The remaining pairs can at least be oriented weakly:

   ENCARG(cons_start) -> 1 : START
   ENCODE_STATEII -> 1 : STATEII
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCARG(s(cons_stateII)) -> 1 : s(ENCARG(cons_stateII))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCODE_DICE -> 1 : DICE
   ENCODE_START -> 1 : START
   START -> 1 : f(DICE)
   ENCODE_STATEI -> 1 : STATEI
   ENCARG(s(cons_dice)) -> 1 : s(ENCARG(cons_dice))
   ENCARG(s(cons_stateI)) -> 1 : s(ENCARG(cons_stateI))

Used ordering:Polynomial interpretation [POLO]:

   POL(DICE) = 1
   POL(ENCARG(x_1)) = x_1
   POL(ENCODE_DICE) = 1
   POL(ENCODE_F(x_1)) = x_1
   POL(ENCODE_G(x_1, x_2)) = x_1 + x_2
   POL(ENCODE_O) = 0
   POL(ENCODE_S(x_1)) = 1 + x_1
   POL(ENCODE_START) = 1
   POL(ENCODE_STATEI) = 1
   POL(ENCODE_STATEII) = 1
   POL(ENCODE_STATEIII) = 0
   POL(ENCODE_STATEIO) = 0
   POL(ENCODE_STATEIOI) = 0
   POL(ENCODE_STATEIOO) = 0
   POL(ENCODE_STATEO) = 0
   POL(ENCODE_STATEOI) = 0
   POL(ENCODE_STATEOII) = 0
   POL(ENCODE_STATEOO) = 0
   POL(ENCODE_STATEOOI) = 0
   POL(ENCODE_STATEOOO) = 0
   POL(F(x_1)) = 0
   POL(START) = 1
   POL(STATEI) = 1
   POL(STATEII) = 1
   POL(STATEIII) = 0
   POL(STATEIO) = 0
   POL(STATEIOI) = 0
   POL(STATEIOO) = 0
   POL(STATEO) = 0
   POL(STATEOI) = 0
   POL(STATEOII) = 0
   POL(STATEOO) = 0
   POL(STATEOOI) = 0
   POL(STATEOOO) = 0
   POL(cons_dice) = 1
   POL(cons_f(x_1)) = 1 + x_1
   POL(cons_start) = 1
   POL(cons_stateI) = 1
   POL(cons_stateII) = 1
   POL(f(x_1)) = 0
   POL(g(x_1, x_2)) = 1 + x_1 + x_2
   POL(s(x_1)) = x_1
   POL(stateIII) = 0
   POL(stateIO) = 0
   POL(stateO) = 0

The complexity of the removed ADPs is bounded by:n^1
----------------------------------------

(41)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:
   none
Rules with annotation in P:

   ENCARG(cons_start) -> 1 : START
   ENCODE_STATEII -> 1 : STATEII
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCARG(s(cons_stateII)) -> 1 : s(ENCARG(cons_stateII))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   STATEII -> 1 / 2 : stateIII || 1 / 2 : STATEI
   DICE -> 1 / 2 : STATEI || 1 / 2 : stateO
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCODE_DICE -> 1 : DICE
   ENCODE_START -> 1 : START
   STATEI -> 1 / 2 : STATEII || 1 / 2 : stateIO
   START -> 1 : f(DICE)
   ENCODE_STATEI -> 1 : STATEI
   ENCARG(s(cons_dice)) -> 1 : s(ENCARG(cons_dice))
   ENCARG(s(cons_stateI)) -> 1 : s(ENCARG(cons_stateI))

Rules with annotation in S:

   none

Rules with annotation and a known complexity:

   ENCARG(cons_start) -> 1 : START
   ENCODE_STATEII -> 1 : STATEII
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_dice) -> 1 : DICE
   ENCARG(cons_stateI) -> 1 : STATEI
   ENCARG(s(cons_stateII)) -> 1 : s(ENCARG(cons_stateII))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   STATEII -> 1 / 2 : stateIII || 1 / 2 : STATEI
   DICE -> 1 / 2 : STATEI || 1 / 2 : stateO
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_stateII) -> 1 : STATEII
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCODE_DICE -> 1 : DICE
   ENCODE_START -> 1 : START
   STATEI -> 1 / 2 : STATEII || 1 / 2 : stateIO
   START -> 1 : f(DICE)
   ENCODE_STATEI -> 1 : STATEI
   ENCARG(s(cons_dice)) -> 1 : s(ENCARG(cons_dice))
   ENCARG(s(cons_stateI)) -> 1 : s(ENCARG(cons_stateI))


----------------------------------------

(42) SisEmptyProof (FINISHED)


S contains no annotations anymore. Hence, there exists no P-CT with infinitely many S-Nodes.
Resulting upper bound: O(1)

----------------------------------------

(43)
BOUNDS(1, 1)

----------------------------------------

(44)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   encArg(s(cons_stateIO)) -> 1 : s(encArg(cons_stateIO))
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(s(O)) -> 1 : s(encArg(O))
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   f(s(x)) -> 1 : f(g(x, x))
   encode_stateO -> 1 : stateO
   stateIOO -> 1 : s(s(s(O)))
   stateOOI -> 1 : s(s(s(s(s(O)))))
   encArg(s(cons_stateOI)) -> 1 : s(encArg(cons_stateOI))
   encode_stateI -> 1 : stateI
   stateIOI -> 1 : s(s(O))
   encArg(cons_stateOOO) -> 1 : stateOOO
   encode_dice -> 1 : dice
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   encode_O -> 1 : O
   encode_stateOOO -> 1 : stateOOO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   encArg(s(cons_stateOO)) -> 1 : s(encArg(cons_stateOO))
   encArg(cons_stateIOO) -> 1 : stateIOO
   f(g(x, y)) -> 1 : g(f(x), f(y))
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateIOI) -> 1 : stateIOI
   encode_stateIII -> 1 : stateIII
   encArg(s(cons_f(y0))) -> 1 : s(encArg(cons_f(y0)))
   start -> 1 : f(dice)
   encArg(s(cons_stateOII)) -> 1 : s(encArg(cons_stateOII))
   encArg(cons_stateO) -> 1 : stateO
   encArg(s(cons_stateI)) -> 1 : s(encArg(cons_stateI))
   encode_stateOII -> 1 : stateOII
   encArg(s(cons_stateII)) -> 1 : s(encArg(cons_stateII))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_stateOOI -> 1 : stateOOI
   encArg(s(cons_stateIOI)) -> 1 : s(encArg(cons_stateIOI))
   encArg(g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   stateOOO -> 1 : s(s(s(s(s(s(O))))))
   encArg(cons_start) -> 1 : start
   encode_start -> 1 : start
   stateOII -> 1 : s(s(s(s(O))))
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(s(cons_stateO)) -> 1 : s(encArg(cons_stateO))
   encode_stateIOO -> 1 : stateIOO
   encArg(s(cons_stateOOI)) -> 1 : s(encArg(cons_stateOOI))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   encode_stateOO -> 1 : stateOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   encArg(s(cons_start)) -> 1 : s(encArg(cons_start))
   encArg(O) -> 1 : O
   encode_stateOI -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   stateIII -> 1 : s(O)
   encArg(s(cons_stateOOO)) -> 1 : s(encArg(cons_stateOOO))
   encArg(s(cons_stateIOO)) -> 1 : s(encArg(cons_stateIOO))
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateII) -> 1 : stateII
   encode_stateII -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   encArg(s(g(y0, y1))) -> 1 : s(encArg(g(y0, y1)))
   encArg(s(cons_stateIII)) -> 1 : s(encArg(cons_stateIII))
   encArg(s(s(y0))) -> 1 : s(encArg(s(y0)))
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_dice) -> 1 : dice
   encArg(s(cons_dice)) -> 1 : s(encArg(cons_dice))

Rules with annotation in P:

   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCARG(cons_start) -> 1 : START
   ENCODE_START -> 1 : START
   START -> 1 : F(DICE)
   F(g(x, y)) -> 1 : g(F(x), F(y))
   F(s(x)) -> 1 : F(g(x, x))

Rules with annotation in S:

   F(g(x, y)) -> 1 : g(F(x), F(y))
   F(s(x)) -> 1 : F(g(x, x))

Rules with annotation and a known complexity:

   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCARG(cons_start) -> 1 : START
   ENCODE_START -> 1 : START
   START -> 1 : F(DICE)


----------------------------------------

(45) CpxADP_UsableTermsProof (UPPER BOUND(ID))


The approximation of the Dependency Graph  gives us the following unusable Terms: 
   DICE
Hence, as part of the dependency graph processor, we can remove the annotations from these terms from every RHS of every ADP in P and S.

----------------------------------------

(46)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   encArg(s(cons_stateIO)) -> 1 : s(encArg(cons_stateIO))
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(s(O)) -> 1 : s(encArg(O))
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   f(s(x)) -> 1 : f(g(x, x))
   encode_stateO -> 1 : stateO
   stateIOO -> 1 : s(s(s(O)))
   stateOOI -> 1 : s(s(s(s(s(O)))))
   encArg(s(cons_stateOI)) -> 1 : s(encArg(cons_stateOI))
   encode_stateI -> 1 : stateI
   stateIOI -> 1 : s(s(O))
   encArg(cons_stateOOO) -> 1 : stateOOO
   encode_dice -> 1 : dice
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   encode_O -> 1 : O
   encode_stateOOO -> 1 : stateOOO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   encArg(s(cons_stateOO)) -> 1 : s(encArg(cons_stateOO))
   encArg(cons_stateIOO) -> 1 : stateIOO
   f(g(x, y)) -> 1 : g(f(x), f(y))
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateIOI) -> 1 : stateIOI
   encode_stateIII -> 1 : stateIII
   encArg(s(cons_f(y0))) -> 1 : s(encArg(cons_f(y0)))
   start -> 1 : f(dice)
   encArg(s(cons_stateOII)) -> 1 : s(encArg(cons_stateOII))
   encArg(cons_stateO) -> 1 : stateO
   encArg(s(cons_stateI)) -> 1 : s(encArg(cons_stateI))
   encode_stateOII -> 1 : stateOII
   encArg(s(cons_stateII)) -> 1 : s(encArg(cons_stateII))
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_stateOOI -> 1 : stateOOI
   encArg(s(cons_stateIOI)) -> 1 : s(encArg(cons_stateIOI))
   encArg(g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   stateOOO -> 1 : s(s(s(s(s(s(O))))))
   encArg(cons_start) -> 1 : start
   encode_start -> 1 : start
   stateOII -> 1 : s(s(s(s(O))))
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(s(cons_stateO)) -> 1 : s(encArg(cons_stateO))
   encode_stateIOO -> 1 : stateIOO
   encArg(s(cons_stateOOI)) -> 1 : s(encArg(cons_stateOOI))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   encode_stateOO -> 1 : stateOO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   encArg(s(cons_start)) -> 1 : s(encArg(cons_start))
   encArg(O) -> 1 : O
   encode_stateOI -> 1 : stateOI
   encArg(cons_stateIII) -> 1 : stateIII
   stateIII -> 1 : s(O)
   encArg(s(cons_stateOOO)) -> 1 : s(encArg(cons_stateOOO))
   encArg(s(cons_stateIOO)) -> 1 : s(encArg(cons_stateIOO))
   encode_stateIO -> 1 : stateIO
   encode_stateIOI -> 1 : stateIOI
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateII) -> 1 : stateII
   encode_stateII -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   encArg(s(g(y0, y1))) -> 1 : s(encArg(g(y0, y1)))
   encArg(s(cons_stateIII)) -> 1 : s(encArg(cons_stateIII))
   encArg(s(s(y0))) -> 1 : s(encArg(s(y0)))
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_dice) -> 1 : dice
   encArg(s(cons_dice)) -> 1 : s(encArg(cons_dice))

Rules with annotation in P:

   ENCARG(cons_start) -> 1 : START
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   START -> 1 : F(dice)
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   F(s(x)) -> 1 : F(g(x, x))
   ENCODE_START -> 1 : START
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   F(g(x, y)) -> 1 : g(F(x), F(y))

Rules with annotation in S:

   F(s(x)) -> 1 : F(g(x, x))
   F(g(x, y)) -> 1 : g(F(x), F(y))

Rules with annotation and a known complexity:

   ENCARG(cons_start) -> 1 : START
   START -> 1 : F(dice)
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCODE_START -> 1 : START
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))


----------------------------------------

(47) CpxADP_UsableRulesProof (BOTH BOUNDS(ID, ID))


We use the usable rules processor.
We can deactivate the flags for all non-usable rules [FROCOS05]

Rules which have been flagged as non usable in this step:

   encode_stateIII -> 1 : stateIII
   encode_stateIOO -> 1 : stateIOO
   encode_stateO -> 1 : stateO
   encode_stateOO -> 1 : stateOO
   encode_stateII -> 1 : stateII
   encode_stateI -> 1 : stateI
   encode_stateOI -> 1 : stateOI
   encode_g(x_1, x_2) -> 1 : g(encArg(x_1), encArg(x_2))
   encode_dice -> 1 : dice
   encode_O -> 1 : O
   encode_stateOOO -> 1 : stateOOO
   encode_stateOII -> 1 : stateOII
   encode_stateIO -> 1 : stateIO
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_stateOOI -> 1 : stateOOI
   encode_stateIOI -> 1 : stateIOI
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encode_start -> 1 : start

----------------------------------------

(48)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(cons_stateIO)) -> 1 : s(encArg(cons_stateIO))
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(s(O)) -> 1 : s(encArg(O))
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(s(cons_stateOI)) -> 1 : s(encArg(cons_stateOI))
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(s(cons_stateOO)) -> 1 : s(encArg(cons_stateOO))
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(s(cons_f(y0))) -> 1 : s(encArg(cons_f(y0)))
   encArg(s(cons_stateOII)) -> 1 : s(encArg(cons_stateOII))
   encArg(cons_stateO) -> 1 : stateO
   encArg(s(cons_stateI)) -> 1 : s(encArg(cons_stateI))
   encArg(s(cons_stateII)) -> 1 : s(encArg(cons_stateII))
   encArg(s(cons_stateIOI)) -> 1 : s(encArg(cons_stateIOI))
   encArg(g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   encArg(cons_start) -> 1 : start
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(s(cons_stateO)) -> 1 : s(encArg(cons_stateO))
   encArg(s(cons_stateOOI)) -> 1 : s(encArg(cons_stateOOI))
   encArg(s(cons_start)) -> 1 : s(encArg(cons_start))
   encArg(O) -> 1 : O
   encArg(cons_stateIII) -> 1 : stateIII
   encArg(s(cons_stateOOO)) -> 1 : s(encArg(cons_stateOOO))
   encArg(s(cons_stateIOO)) -> 1 : s(encArg(cons_stateIOO))
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(s(g(y0, y1))) -> 1 : s(encArg(g(y0, y1)))
   encArg(s(cons_stateIII)) -> 1 : s(encArg(cons_stateIII))
   encArg(s(s(y0))) -> 1 : s(encArg(s(y0)))
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_dice) -> 1 : dice
   encArg(s(cons_dice)) -> 1 : s(encArg(cons_dice))
   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateIII -> 1 : s(O)
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateIOI -> 1 : s(s(O))
   stateIOO -> 1 : s(s(s(O)))
   stateOII -> 1 : s(s(s(s(O))))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOOI -> 1 : s(s(s(s(s(O)))))
   stateOOO -> 1 : s(s(s(s(s(s(O))))))
   f(s(x)) -> 1 : f(g(x, x))
   f(g(x, y)) -> 1 : g(f(x), f(y))
   start -> 1 : f(dice)

Rules with annotation in P:

   ENCARG(cons_start) -> 1 : START
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   START -> 1 : F(dice)
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   F(s(x)) -> 1 : F(g(x, x))
   ENCODE_START -> 1 : START
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   F(g(x, y)) -> 1 : g(F(x), F(y))

Rules with annotation in S:

   F(s(x)) -> 1 : F(g(x, x))
   F(g(x, y)) -> 1 : g(F(x), F(y))

Rules with annotation and a known complexity:

   ENCARG(cons_start) -> 1 : START
   START -> 1 : F(dice)
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCODE_START -> 1 : START
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))


----------------------------------------

(49) CpxADP_ReductionPairProof (UPPER BOUND(ADD(2-EXP)))


We use the reduction pair processor.
The following pairs can be oriented strictly and are moved from S:

   ENCARG(cons_start) -> 1 : START
   START -> 1 : F(dice)
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCODE_START -> 1 : START
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   F(g(x, y)) -> 1 : g(F(x), F(y))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))

The remaining pairs can at least be oriented weakly:

   F(s(x)) -> 1 : F(g(x, x))
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))

Used ordering:Polynomial interpretation [POLO]:

   POL(DICE) = 0
   POL(ENCARG(x_1)) = 1 + x_1
   POL(ENCODE_DICE) = 0
   POL(ENCODE_F(x_1)) = 54 + 39*x_1
   POL(ENCODE_G(x_1, x_2)) = 100 + 32*x_1 + 36*x_1*x_2 + 24*x_2
   POL(ENCODE_O) = 0
   POL(ENCODE_S(x_1)) = 1 + 4*x_1
   POL(ENCODE_START) = 100
   POL(ENCODE_STATEI) = 0
   POL(ENCODE_STATEII) = 0
   POL(ENCODE_STATEIII) = 0
   POL(ENCODE_STATEIO) = 0
   POL(ENCODE_STATEIOI) = 0
   POL(ENCODE_STATEIOO) = 0
   POL(ENCODE_STATEO) = 0
   POL(ENCODE_STATEOI) = 0
   POL(ENCODE_STATEOII) = 0
   POL(ENCODE_STATEOO) = 0
   POL(ENCODE_STATEOOI) = 0
   POL(ENCODE_STATEOOO) = 0
   POL(F(x_1)) = 2*x_1
   POL(O) = 0
   POL(START) = 96
   POL(STATEI) = 0
   POL(STATEII) = 0
   POL(STATEIII) = 0
   POL(STATEIO) = 0
   POL(STATEIOI) = 0
   POL(STATEIOO) = 0
   POL(STATEO) = 0
   POL(STATEOI) = 0
   POL(STATEOII) = 0
   POL(STATEOO) = 0
   POL(STATEOOI) = 0
   POL(STATEOOO) = 0
   POL(cons_dice) = 16
   POL(cons_f(x_1)) = 48*x_1
   POL(cons_start) = 97
   POL(cons_stateI) = 8
   POL(cons_stateII) = 8
   POL(cons_stateIII) = 32
   POL(cons_stateIO) = 10
   POL(cons_stateIOI) = 64
   POL(cons_stateIOO) = 2
   POL(cons_stateO) = 32
   POL(cons_stateOI) = 8
   POL(cons_stateOII) = 4
   POL(cons_stateOO) = 32
   POL(cons_stateOOI) = 8
   POL(cons_stateOOO) = 32
   POL(dice) = 42
   POL(encArg(x_1)) = 8*x_1
   POL(f(x_1)) = 2*x_1
   POL(g(x_1, x_2)) = 1 + x_1 + x_2
   POL(s(x_1)) = 1 + 2*x_1
   POL(start) = 96
   POL(stateI) = 44
   POL(stateII) = 48
   POL(stateIII) = 1
   POL(stateIO) = 32
   POL(stateIOI) = 32
   POL(stateIOO) = 16
   POL(stateO) = 40
   POL(stateOI) = 32
   POL(stateOII) = 16
   POL(stateOO) = 48
   POL(stateOOI) = 31
   POL(stateOOO) = 64

The complexity of the removed ADPs is bounded by:2-EXP
----------------------------------------

(50)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(cons_stateIO)) -> 1 : s(encArg(cons_stateIO))
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(s(O)) -> 1 : s(encArg(O))
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(s(cons_stateOI)) -> 1 : s(encArg(cons_stateOI))
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(s(cons_stateOO)) -> 1 : s(encArg(cons_stateOO))
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(s(cons_f(y0))) -> 1 : s(encArg(cons_f(y0)))
   encArg(s(cons_stateOII)) -> 1 : s(encArg(cons_stateOII))
   encArg(cons_stateO) -> 1 : stateO
   encArg(s(cons_stateI)) -> 1 : s(encArg(cons_stateI))
   encArg(s(cons_stateII)) -> 1 : s(encArg(cons_stateII))
   encArg(s(cons_stateIOI)) -> 1 : s(encArg(cons_stateIOI))
   encArg(g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   encArg(cons_start) -> 1 : start
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(s(cons_stateO)) -> 1 : s(encArg(cons_stateO))
   encArg(s(cons_stateOOI)) -> 1 : s(encArg(cons_stateOOI))
   encArg(s(cons_start)) -> 1 : s(encArg(cons_start))
   encArg(O) -> 1 : O
   encArg(cons_stateIII) -> 1 : stateIII
   encArg(s(cons_stateOOO)) -> 1 : s(encArg(cons_stateOOO))
   encArg(s(cons_stateIOO)) -> 1 : s(encArg(cons_stateIOO))
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(s(g(y0, y1))) -> 1 : s(encArg(g(y0, y1)))
   encArg(s(cons_stateIII)) -> 1 : s(encArg(cons_stateIII))
   encArg(s(s(y0))) -> 1 : s(encArg(s(y0)))
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_dice) -> 1 : dice
   encArg(s(cons_dice)) -> 1 : s(encArg(cons_dice))
   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateIII -> 1 : s(O)
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateIOI -> 1 : s(s(O))
   stateIOO -> 1 : s(s(s(O)))
   stateOII -> 1 : s(s(s(s(O))))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOOI -> 1 : s(s(s(s(s(O)))))
   stateOOO -> 1 : s(s(s(s(s(s(O))))))
   f(s(x)) -> 1 : f(g(x, x))
   f(g(x, y)) -> 1 : g(f(x), f(y))
   start -> 1 : f(dice)

Rules with annotation in P:

   ENCARG(cons_start) -> 1 : START
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   START -> 1 : F(dice)
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   F(s(x)) -> 1 : F(g(x, x))
   ENCODE_START -> 1 : START
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   F(g(x, y)) -> 1 : g(F(x), F(y))

Rules with annotation in S:

   F(s(x)) -> 1 : F(g(x, x))

Rules with annotation and a known complexity:

   ENCARG(cons_start) -> 1 : START
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   START -> 1 : F(dice)
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   ENCODE_START -> 1 : START
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   F(g(x, y)) -> 1 : g(F(x), F(y))


----------------------------------------

(51) CpxADP_KnowledgePropagationProof (BOTH BOUNDS(ID, ID))


We use the knowledge propagation processor .
We can remove rules from S, if in the dependency graph no predecessor is in S (all predecessors have a known complexity bound).

Following rules are removed from S:

   F(s(x)) -> 1 : F(g(x, x))

----------------------------------------

(52)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(s(cons_stateIO)) -> 1 : s(encArg(cons_stateIO))
   encArg(cons_stateOO) -> 1 : stateOO
   encArg(s(O)) -> 1 : s(encArg(O))
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(s(cons_stateOI)) -> 1 : s(encArg(cons_stateOI))
   encArg(cons_stateOOO) -> 1 : stateOOO
   encArg(s(cons_stateOO)) -> 1 : s(encArg(cons_stateOO))
   encArg(cons_stateIOO) -> 1 : stateIOO
   encArg(cons_stateOII) -> 1 : stateOII
   encArg(cons_stateIOI) -> 1 : stateIOI
   encArg(s(cons_f(y0))) -> 1 : s(encArg(cons_f(y0)))
   encArg(s(cons_stateOII)) -> 1 : s(encArg(cons_stateOII))
   encArg(cons_stateO) -> 1 : stateO
   encArg(s(cons_stateI)) -> 1 : s(encArg(cons_stateI))
   encArg(s(cons_stateII)) -> 1 : s(encArg(cons_stateII))
   encArg(s(cons_stateIOI)) -> 1 : s(encArg(cons_stateIOI))
   encArg(g(x_1, x_2)) -> 1 : g(encArg(x_1), encArg(x_2))
   encArg(cons_start) -> 1 : start
   encArg(cons_stateOOI) -> 1 : stateOOI
   encArg(s(cons_stateO)) -> 1 : s(encArg(cons_stateO))
   encArg(s(cons_stateOOI)) -> 1 : s(encArg(cons_stateOOI))
   encArg(s(cons_start)) -> 1 : s(encArg(cons_start))
   encArg(O) -> 1 : O
   encArg(cons_stateIII) -> 1 : stateIII
   encArg(s(cons_stateOOO)) -> 1 : s(encArg(cons_stateOOO))
   encArg(s(cons_stateIOO)) -> 1 : s(encArg(cons_stateIOO))
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_stateI) -> 1 : stateI
   encArg(cons_stateII) -> 1 : stateII
   encArg(cons_stateIO) -> 1 : stateIO
   encArg(s(g(y0, y1))) -> 1 : s(encArg(g(y0, y1)))
   encArg(s(cons_stateIII)) -> 1 : s(encArg(cons_stateIII))
   encArg(s(s(y0))) -> 1 : s(encArg(s(y0)))
   encArg(cons_stateOI) -> 1 : stateOI
   encArg(cons_dice) -> 1 : dice
   encArg(s(cons_dice)) -> 1 : s(encArg(cons_dice))
   dice -> 1 / 2 : stateI || 1 / 2 : stateO
   stateOI -> 1 / 2 : stateOII || 1 / 2 : stateO
   stateO -> 1 / 2 : stateOI || 1 / 2 : stateOO
   stateII -> 1 / 2 : stateIII || 1 / 2 : stateI
   stateI -> 1 / 2 : stateII || 1 / 2 : stateIO
   stateIII -> 1 : s(O)
   stateIO -> 1 / 2 : stateIOI || 1 / 2 : stateIOO
   stateIOI -> 1 : s(s(O))
   stateIOO -> 1 : s(s(s(O)))
   stateOII -> 1 : s(s(s(s(O))))
   stateOO -> 1 / 2 : stateOOI || 1 / 2 : stateOOO
   stateOOI -> 1 : s(s(s(s(s(O)))))
   stateOOO -> 1 : s(s(s(s(s(s(O))))))
   f(s(x)) -> 1 : f(g(x, x))
   f(g(x, y)) -> 1 : g(f(x), f(y))
   start -> 1 : f(dice)

Rules with annotation in P:

   ENCARG(cons_start) -> 1 : START
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   START -> 1 : F(dice)
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   F(s(x)) -> 1 : F(g(x, x))
   ENCODE_START -> 1 : START
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   F(g(x, y)) -> 1 : g(F(x), F(y))

Rules with annotation in S:

   none

Rules with annotation and a known complexity:

   ENCARG(cons_start) -> 1 : START
   ENCARG(g(x_1, x_2)) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(g(y0, y1))) -> 1 : s(ENCARG(g(y0, y1)))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_G(x_1, x_2) -> 1 : g(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(cons_f(y0))) -> 1 : s(ENCARG(cons_f(y0)))
   START -> 1 : F(dice)
   ENCARG(s(s(y0))) -> 1 : s(ENCARG(s(y0)))
   ENCARG(s(cons_start)) -> 1 : s(ENCARG(cons_start))
   F(s(x)) -> 1 : F(g(x, x))
   ENCODE_START -> 1 : START
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   F(g(x, y)) -> 1 : g(F(x), F(y))


----------------------------------------

(53) SisEmptyProof (FINISHED)


S contains no annotations anymore. Hence, there exists no P-CT with infinitely many S-Nodes.
Resulting upper bound: O(1)

----------------------------------------

(54)
BOUNDS(1, 1)
