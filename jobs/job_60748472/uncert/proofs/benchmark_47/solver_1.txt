SAST
proof of /home/ff862203/input_CzkosiMg3W.ari
# AProVE Commit ID: 1c9e2a6453f9f0dca490585733f1cff3767d3e54 jan-christoph 20250828 unpublished


Complexity of the given CpxPTRS could be proven:

(0) CpxPTRS
(1) CpxPTRS_DerivationToRuntimeComplexityProof [UNSOUND LOWER BOUND(ID)SOUND UPPER BOUND(ID), 0 ms]
(2) CpxPTRS
(3) CpxPTRS_ToPQTRSProof [BOTH BOUNDS(ID, ID), 0 ms]
(4) PQTRS
(5) CpxPQTRS_ToADPProblemProof [BOTH BOUNDS(ID, ID), 0 ms]
(6) ADP
(7) CpxADP_SCCSplitProof [UPPER BOUND(ID), 15 ms]
(8) MAX
    (9) ADP
        (10) CpxADP_UsableTermsProof [UPPER BOUND(ID), 0 ms]
        (11) ADP
        (12) CpxADP_UsableRulesProof [BOTH BOUNDS(ID, ID), 0 ms]
        (13) ADP
        (14) CpxADP_ProbabilityRemovalProof [UPPER BOUND(ID), 0 ms]
        (15) CdtProblem
        (16) CdtLeafRemovalProof [ComplexityIfPolyImplication, 0 ms]
        (17) CdtProblem
        (18) CdtToCpxRelTrsProof [BOTH BOUNDS(ID, ID), 0 ms]
        (19) CpxTRS
        (20) RelTrsToTrsProof [UPPER BOUND(ID), 0 ms]
        (21) CpxTRS
        (22) CpxTrsMatchBoundsTAProof [FINISHED, 0 ms]
        (23) BOUNDS(1, n^1)
    (24) ADP
        (25) CpxADP_UsableTermsProof [UPPER BOUND(ID), 0 ms]
        (26) ADP
        (27) CpxADP_UsableRulesProof [BOTH BOUNDS(ID, ID), 0 ms]
        (28) ADP
        (29) CpxADP_ReductionPairProof [UPPER BOUND(ADD(n^1)), 0 ms]
        (30) ADP
        (31) SisEmptyProof [FINISHED, 0 ms]
        (32) BOUNDS(1, 1)


----------------------------------------

(0)
Obligation:
Probabilistic term rewrite system:
The TRS has the following probabilistic rules:

   g -> 1 / 2 : f(g) || 1 / 2 : d
   f(x) -> 1 : c(x, x)

and uses the innermost rewrite strategy.

----------------------------------------

(1) CpxPTRS_DerivationToRuntimeComplexityProof (UNSOUND LOWER BOUND(ID)SOUND UPPER BOUND(ID))
The following rules have been added to R to convert the given derivational complexity problem to a runtime complexity problem:

   encArg(c(x_1, x_2)) -> 1 : c(encArg(x_1), encArg(x_2))
   encArg(d) -> 1 : d
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_g) -> 1 : g
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encode_c(x_1, x_2) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_g -> 1 : g
   encode_d -> 1 : d


----------------------------------------

(2)
Obligation:
Probabilistic term rewrite system:
The TRS has the following probabilistic rules:

   encArg(c(x_1, x_2)) -> 1 : c(encArg(x_1), encArg(x_2))
   encArg(d) -> 1 : d
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_g) -> 1 : g
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encode_c(x_1, x_2) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_g -> 1 : g
   encode_d -> 1 : d
   g -> 1 / 2 : f(g) || 1 / 2 : d
   f(x) -> 1 : c(x, x)

and uses the innermost rewrite strategy.

----------------------------------------

(3) CpxPTRS_ToPQTRSProof (BOTH BOUNDS(ID, ID))
Transformed PTRS into PQTRS. Q is:
   encArg(c(x_1, x_2)), encArg(d), encArg(cons_f(x_1)), encArg(cons_g), encode_f(x_1), encode_c(x_1, x_2), encode_g, encode_d, g, f(x)
----------------------------------------

(4)
Obligation:
Probabilistic Q term rewrite system:
The PQTRS has the following probabilistic rules:

   encArg(c(x_1, x_2)) -> 1 : c(encArg(x_1), encArg(x_2))
   encArg(d) -> 1 : d
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_g) -> 1 : g
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encode_c(x_1, x_2) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_g -> 1 : g
   encode_d -> 1 : d
   g -> 1 / 2 : f(g) || 1 / 2 : d
   f(x) -> 1 : c(x, x)

And Q contains the following terms:
   encArg(c(x0, x1)), encArg(d), encArg(cons_f(x0)), encArg(cons_g), encode_f(x0), encode_c(x0, x1), encode_g, encode_d, g, f(x0)

----------------------------------------

(5) CpxPQTRS_ToADPProblemProof (BOTH BOUNDS(ID, ID))


The complexity of a PQTRS (R,Q) is equivalent to the complexity of the ADP Problem A(R) (Chain-Criterion) (Leon's master's thesis).
The ADPs are:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(c(x_1, x_2)) -> 1 : c(encArg(x_1), encArg(x_2))
   encArg(d) -> 1 : d
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_g) -> 1 : g
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encode_c(x_1, x_2) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_g -> 1 : g
   encode_d -> 1 : d
   g -> 1 / 2 : f(g) || 1 / 2 : d
   f(x) -> 1 : c(x, x)

Rules with annotation in P:

   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(d) -> 1 : d
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCARG(cons_g) -> 1 : G
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_G -> 1 : G
   ENCODE_D -> 1 : d
   G -> 1 / 2 : F(G) || 1 / 2 : d
   F(x) -> 1 : c(x, x)

Rules with annotation in S:

   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(d) -> 1 : d
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCARG(cons_g) -> 1 : G
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_G -> 1 : G
   ENCODE_D -> 1 : d
   G -> 1 / 2 : F(G) || 1 / 2 : d
   F(x) -> 1 : c(x, x)

Rules with annotation and a known complexity:

   none

----------------------------------------

(6)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(c(x_1, x_2)) -> 1 : c(encArg(x_1), encArg(x_2))
   encArg(d) -> 1 : d
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_g) -> 1 : g
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encode_c(x_1, x_2) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_g -> 1 : g
   encode_d -> 1 : d
   g -> 1 / 2 : f(g) || 1 / 2 : d
   f(x) -> 1 : c(x, x)

Rules with annotation in P:

   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(d) -> 1 : d
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCARG(cons_g) -> 1 : G
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_G -> 1 : G
   ENCODE_D -> 1 : d
   G -> 1 / 2 : F(G) || 1 / 2 : d
   F(x) -> 1 : c(x, x)

Rules with annotation in S:

   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(d) -> 1 : d
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCARG(cons_g) -> 1 : G
   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_G -> 1 : G
   ENCODE_D -> 1 : d
   G -> 1 / 2 : F(G) || 1 / 2 : d
   F(x) -> 1 : c(x, x)

Rules with annotation and a known complexity:

   none

----------------------------------------

(7) CpxADP_SCCSplitProof (UPPER BOUND(ID))
As part of the dependency graph processor, we can split problem in 2 new components.
----------------------------------------

(8)
Complex Obligation (MAX)

----------------------------------------

(9)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(c(x_1, x_2)) -> 1 : c(encArg(x_1), encArg(x_2))
   encArg(d) -> 1 : d
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_g) -> 1 : g
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encode_c(x_1, x_2) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_g -> 1 : g
   encode_d -> 1 : d
   g -> 1 / 2 : f(g) || 1 / 2 : d
   f(x) -> 1 : c(x, x)

Rules with annotation in P:

   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))

Rules with annotation in S:

   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))

Rules with annotation and a known complexity:

   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))


----------------------------------------

(10) CpxADP_UsableTermsProof (UPPER BOUND(ID))


The approximation of the Dependency Graph  gives us the following unusable Terms: 
   F(encArg(x_1))
Hence, as part of the dependency graph processor, we can remove the annotations from these terms from every RHS of every ADP in P and S.

----------------------------------------

(11)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(c(x_1, x_2)) -> 1 : c(encArg(x_1), encArg(x_2))
   encArg(d) -> 1 : d
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_g) -> 1 : g
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encode_c(x_1, x_2) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_g -> 1 : g
   encode_d -> 1 : d
   g -> 1 / 2 : f(g) || 1 / 2 : d
   f(x) -> 1 : c(x, x)

Rules with annotation in P:

   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))

Rules with annotation in S:

   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))

Rules with annotation and a known complexity:

   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))


----------------------------------------

(12) CpxADP_UsableRulesProof (BOTH BOUNDS(ID, ID))


We use the usable rules processor.
We can deactivate the flags for all non-usable rules [FROCOS05]

Rules which have been flagged as non usable in this step:

   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(c(x_1, x_2)) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_c(x_1, x_2) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_g -> 1 : g
   encode_d -> 1 : d
   encArg(cons_g) -> 1 : g
   g -> 1 / 2 : f(g) || 1 / 2 : d
   encArg(d) -> 1 : d
   f(x) -> 1 : c(x, x)
   encode_f(x_1) -> 1 : f(encArg(x_1))

----------------------------------------

(13)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:
   none
Rules with annotation in P:

   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))

Rules with annotation in S:

   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))

Rules with annotation and a known complexity:

   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))


----------------------------------------

(14) CpxADP_ProbabilityRemovalProof (UPPER BOUND(ID))


We use the probability removal processor to move to dependecy tuples without probabilities.
As all rules have a trivial probability (1:r), we can transform it into a non-probabilistic DT problem

----------------------------------------

(15)
Obligation:
Complexity Dependency Tuples Problem

Rules:none
Tuples:
   ENCARG(c(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCODE_F(x_1) -> c3(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> c4(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> c5(ENCARG(x_2), ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> c6(ENCARG(x_2), ENCARG(x_1))
S tuples:
   ENCARG(c(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCODE_F(x_1) -> c3(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> c4(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> c5(ENCARG(x_2), ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> c6(ENCARG(x_2), ENCARG(x_1))
K tuples:none
Defined Rule Symbols:   encArg_1, encode_f_1, encode_c_2, encode_g, encode_d, g, f_1

Defined Pair Symbols:none

Compound Symbols:   c1_2, c2_2, c3_1, c4_1, c5_2, c6_2


----------------------------------------

(16) CdtLeafRemovalProof (ComplexityIfPolyImplication)
Removed 3 leading nodes:
   ENCODE_F(x_1) -> c3(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> c5(ENCARG(x_2), ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> c6(ENCARG(x_2), ENCARG(x_1))

----------------------------------------

(17)
Obligation:
Complexity Dependency Tuples Problem

Rules:none
Tuples:
   ENCARG(c(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> c4(ENCARG(x_1))
S tuples:
   ENCARG(c(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> c4(ENCARG(x_1))
K tuples:none
Defined Rule Symbols:   encArg_1, encode_f_1, encode_c_2, encode_g, encode_d, g, f_1

Defined Pair Symbols:   ENCARG_1

Compound Symbols:   c1_2, c2_2, c4_1


----------------------------------------

(18) CdtToCpxRelTrsProof (BOTH BOUNDS(ID, ID))
Converted S to standard rules, and D \ S as well as R to relative rules.
----------------------------------------

(19)
Obligation:
The Runtime Complexity (innermost) of the given CpxTRS could be proven to be BOUNDS(1, n^1).


The TRS R consists of the following rules:

   ENCARG(c(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> c4(ENCARG(x_1))

S is empty.
Rewrite Strategy: INNERMOST
----------------------------------------

(20) RelTrsToTrsProof (UPPER BOUND(ID))
transformed relative TRS to TRS
----------------------------------------

(21)
Obligation:
The Runtime Complexity (innermost) of the given CpxTRS could be proven to be BOUNDS(1, n^1).


The TRS R consists of the following rules:

   ENCARG(c(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> c4(ENCARG(x_1))

S is empty.
Rewrite Strategy: INNERMOST
----------------------------------------

(22) CpxTrsMatchBoundsTAProof (FINISHED)
A linear upper bound on the runtime complexity of the TRS R could be shown with a Match-Bound[TAB_LEFTLINEAR,TAB_NONLEFTLINEAR] (for contructor-based start-terms) of 1. 

The compatible tree automaton used to show the Match-Boundedness (for constructor-based start-terms) is represented by: 
final states : [1]
transitions: 
c0(0, 0) -> 0
c10(0, 0) -> 0
c20(0, 0) -> 0
cons_f0(0) -> 0
c40(0) -> 0
ENCARG0(0) -> 1
ENCARG1(0) -> 2
ENCARG1(0) -> 3
c11(2, 3) -> 1
ENCARG1(0) -> 4
ENCARG1(0) -> 5
c21(4, 5) -> 1
ENCARG1(0) -> 6
c41(6) -> 1
c11(2, 3) -> 2
c11(2, 3) -> 3
c11(2, 3) -> 4
c11(2, 3) -> 5
c11(2, 3) -> 6
c21(4, 5) -> 2
c21(4, 5) -> 3
c21(4, 5) -> 4
c21(4, 5) -> 5
c21(4, 5) -> 6
c41(6) -> 2
c41(6) -> 3
c41(6) -> 4
c41(6) -> 5
c41(6) -> 6

----------------------------------------

(23)
BOUNDS(1, n^1)

----------------------------------------

(24)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(c(x_1, x_2)) -> 1 : c(encArg(x_1), encArg(x_2))
   encArg(d) -> 1 : d
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_g) -> 1 : g
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encode_c(x_1, x_2) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_g -> 1 : g
   encode_d -> 1 : d
   g -> 1 / 2 : f(g) || 1 / 2 : d
   f(x) -> 1 : c(x, x)

Rules with annotation in P:

   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_g) -> 1 : G
   ENCODE_G -> 1 : G
   G -> 1 / 2 : F(G) || 1 / 2 : d

Rules with annotation in S:

   G -> 1 / 2 : F(G) || 1 / 2 : d

Rules with annotation and a known complexity:

   ENCODE_F(x_1) -> 1 : F(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_f(x_1)) -> 1 : F(ENCARG(x_1))
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_g) -> 1 : G
   ENCODE_G -> 1 : G


----------------------------------------

(25) CpxADP_UsableTermsProof (UPPER BOUND(ID))


The approximation of the Dependency Graph  gives us the following unusable Terms: 
   F(g), F(encArg(x_1))
Hence, as part of the dependency graph processor, we can remove the annotations from these terms from every RHS of every ADP in P and S.

----------------------------------------

(26)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(c(x_1, x_2)) -> 1 : c(encArg(x_1), encArg(x_2))
   encArg(d) -> 1 : d
   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(cons_g) -> 1 : g
   encode_f(x_1) -> 1 : f(encArg(x_1))
   encode_c(x_1, x_2) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_g -> 1 : g
   encode_d -> 1 : d
   g -> 1 / 2 : f(g) || 1 / 2 : d
   f(x) -> 1 : c(x, x)

Rules with annotation in P:

   ENCODE_G -> 1 : G
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_g) -> 1 : G
   G -> 1 / 2 : f(G) || 1 / 2 : d

Rules with annotation in S:

   G -> 1 / 2 : f(G) || 1 / 2 : d

Rules with annotation and a known complexity:

   ENCODE_G -> 1 : G
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_g) -> 1 : G


----------------------------------------

(27) CpxADP_UsableRulesProof (BOTH BOUNDS(ID, ID))


We use the usable rules processor.
We can deactivate the flags for all non-usable rules [FROCOS05]

Rules which have been flagged as non usable in this step:

   encArg(cons_f(x_1)) -> 1 : f(encArg(x_1))
   encArg(c(x_1, x_2)) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_c(x_1, x_2) -> 1 : c(encArg(x_1), encArg(x_2))
   encode_g -> 1 : g
   encode_d -> 1 : d
   encArg(cons_g) -> 1 : g
   g -> 1 / 2 : f(g) || 1 / 2 : d
   encArg(d) -> 1 : d
   f(x) -> 1 : c(x, x)
   encode_f(x_1) -> 1 : f(encArg(x_1))

----------------------------------------

(28)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:
   none
Rules with annotation in P:

   ENCODE_G -> 1 : G
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_g) -> 1 : G
   G -> 1 / 2 : f(G) || 1 / 2 : d

Rules with annotation in S:

   G -> 1 / 2 : f(G) || 1 / 2 : d

Rules with annotation and a known complexity:

   ENCODE_G -> 1 : G
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_g) -> 1 : G


----------------------------------------

(29) CpxADP_ReductionPairProof (UPPER BOUND(ADD(n^1)))


We use the reduction pair processor.
The following pairs can be oriented strictly and are moved from S:

   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   G -> 1 / 2 : f(G) || 1 / 2 : d

The remaining pairs can at least be oriented weakly:

   ENCODE_G -> 1 : G
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_g) -> 1 : G

Used ordering:Polynomial interpretation [POLO]:

   POL(ENCARG(x_1)) = x_1
   POL(ENCODE_C(x_1, x_2)) = x_1 + x_2
   POL(ENCODE_D) = 0
   POL(ENCODE_F(x_1)) = x_1
   POL(ENCODE_G) = 1
   POL(F(x_1)) = 0
   POL(G) = 1
   POL(c(x_1, x_2)) = 1 + x_1 + x_2
   POL(cons_f(x_1)) = 1 + x_1
   POL(cons_g) = 1
   POL(d) = 0
   POL(f(x_1)) = x_1

The complexity of the removed ADPs is bounded by:n^1
----------------------------------------

(30)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:
   none
Rules with annotation in P:

   ENCODE_G -> 1 : G
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_g) -> 1 : G
   G -> 1 / 2 : f(G) || 1 / 2 : d

Rules with annotation in S:

   none

Rules with annotation and a known complexity:

   ENCODE_G -> 1 : G
   ENCARG(c(x_1, x_2)) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCODE_F(x_1) -> 1 : f(ENCARG(x_1))
   ENCARG(cons_f(x_1)) -> 1 : f(ENCARG(x_1))
   ENCODE_C(x_1, x_2) -> 1 : c(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_g) -> 1 : G
   G -> 1 / 2 : f(G) || 1 / 2 : d


----------------------------------------

(31) SisEmptyProof (FINISHED)


S contains no annotations anymore. Hence, there exists no P-CT with infinitely many S-Nodes.
Resulting upper bound: O(1)

----------------------------------------

(32)
BOUNDS(1, 1)
