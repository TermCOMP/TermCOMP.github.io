AST
proof of /home/ff862203/input_MXp25kPJ4u.ari
# AProVE Commit ID: 1c9e2a6453f9f0dca490585733f1cff3767d3e54 jan-christoph 20250828 unpublished


Innermost AST of the given PTRS could be proven:

(0) PTRS
(1) PTRStoPQTRSProof [EQUIVALENT, 0 ms]
(2) PQTRS
(3) PQTRStoADPProblemProof [EQUIVALENT, 0 ms]
(4) ADP
(5) AST_ADPDependencyGraphProof [EQUIVALENT, 0 ms]
(6) ADP
(7) AST_ADPUsableTermsProof [EQUIVALENT, 0 ms]
(8) ADP
(9) AST_ADPUsableRulesProof [EQUIVALENT, 0 ms]
(10) ADP
(11) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(12) ADP
(13) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(14) ADP
(15) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(16) ADP
(17) AST_ADPReductionPairProof [EQUIVALENT, 121 ms]
(18) ADP
(19) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(20) ADP
(21) AST_ADPReductionPairProof [EQUIVALENT, 119 ms]
(22) ADP
(23) AST_ADPTransformationProof [EQUIVALENT, 2 ms]
(24) ADP
(25) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(26) ADP
(27) AST_ADPTransformationProof [EQUIVALENT, 1 ms]
(28) ADP
(29) AST_ADPReductionPairProof [EQUIVALENT, 86 ms]
(30) ADP
(31) AST_ADPUsableRulesProof [EQUIVALENT, 0 ms]
(32) ADP
(33) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(34) ADP
(35) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(36) ADP
(37) AST_ADPReductionPairProof [EQUIVALENT, 37 ms]
(38) ADP
(39) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(40) ADP
(41) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(42) ADP
(43) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(44) ADP
(45) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(46) ADP
(47) AST_ADPUsableRulesProof [EQUIVALENT, 0 ms]
(48) ADP
(49) AST_ADPReductionPairProof [EQUIVALENT, 23 ms]
(50) ADP
(51) AST_ADPUsableRulesProof [EQUIVALENT, 0 ms]
(52) ADP
(53) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(54) ADP
(55) AST_ADPUsableRulesProof [EQUIVALENT, 0 ms]
(56) ADP
(57) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(58) ADP
(59) AST_ADPReductionPairProof [EQUIVALENT, 5 ms]
(60) ADP
(61) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(62) ADP
(63) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(64) ADP
(65) AST_ADPReductionPairProof [EQUIVALENT, 187 ms]
(66) ADP
(67) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(68) ADP
(69) AST_ADPUsableRulesProof [EQUIVALENT, 0 ms]
(70) ADP
(71) AST_ADPTransformationProof [EQUIVALENT, 0 ms]
(72) ADP
(73) AST_ADPUsableRulesProof [EQUIVALENT, 0 ms]
(74) ADP
(75) AST_ADPReductionPairProof [EQUIVALENT, 21 ms]
(76) ADP
(77) AST_ADPDependencyGraphProof [EQUIVALENT, 0 ms]
(78) TRUE


----------------------------------------

(0)
Obligation:
Probabilistic term rewrite system:
The TRS has the following probabilistic rules:

   empty(cons(x, xs)) -> 1 : false
   head(cons(x, xs)) -> 1 : x
   move_elements(xs, ys) -> 1 : if(or(empty(xs), empty(ys)), xs, ys)
   tail(cons(x, xs)) -> 1 : xs
   if(false, xs, ys) -> 1 / 2 : move_elements(tail(xs), cons(head(xs), ys)) || 1 / 2 : move_elements(cons(head(ys), xs), tail(ys))
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(x, true) -> 1 : true
   or(false, false) -> 1 : false
   if(true, xs, ys) -> 1 : xs

and uses the innermost rewrite strategy.

----------------------------------------

(1) PTRStoPQTRSProof (EQUIVALENT)
Transformed PTRS into PQTRS. Q is:
   empty(cons(x, xs)), head(cons(x, xs)), move_elements(xs, ys), tail(cons(x, xs)), if(false, xs, ys), empty(nil), or(true, x), or(x, true), or(false, false), if(true, xs, ys)
----------------------------------------

(2)
Obligation:
Probabilistic Q term rewrite system:
The PQTRS has the following probabilistic rules:

   empty(cons(x, xs)) -> 1 : false
   head(cons(x, xs)) -> 1 : x
   move_elements(xs, ys) -> 1 : if(or(empty(xs), empty(ys)), xs, ys)
   tail(cons(x, xs)) -> 1 : xs
   if(false, xs, ys) -> 1 / 2 : move_elements(tail(xs), cons(head(xs), ys)) || 1 / 2 : move_elements(cons(head(ys), xs), tail(ys))
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(x, true) -> 1 : true
   or(false, false) -> 1 : false
   if(true, xs, ys) -> 1 : xs

And Q contains the following terms:
   empty(cons(x0, x1)), head(cons(x0, x1)), move_elements(x0, x1), tail(cons(x0, x1)), if(false, x0, x1), empty(nil), or(true, x0), or(x0, true), or(false, false), if(true, x0, x1)

----------------------------------------

(3) PQTRStoADPProblemProof (EQUIVALENT)


A PQTRS (R,Q) is innermost AST iff ADP(R) is innermost AST (Chain-Criterion)[FLOPS24].
----------------------------------------

(4)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   empty(cons(x, xs)) -> 1 : false
   head(cons(x, xs)) -> 1 : x
   move_elements(xs, ys) -> 1 : if(or(empty(xs), empty(ys)), xs, ys)
   tail(cons(x, xs)) -> 1 : xs
   if(false, xs, ys) -> 1 / 2 : move_elements(tail(xs), cons(head(xs), ys)) || 1 / 2 : move_elements(cons(head(ys), xs), tail(ys))
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(x, true) -> 1 : true
   or(false, false) -> 1 : false
   if(true, xs, ys) -> 1 : xs

The ADP Problem has the following rules with annotations:

   EMPTY(cons(x, xs)) -> 1 : false
   HEAD(cons(x, xs)) -> 1 : x
   MOVE_ELEMENTS(xs, ys) -> 1 : IF(OR(EMPTY(xs), EMPTY(ys)), xs, ys)
   TAIL(cons(x, xs)) -> 1 : xs
   IF(false, xs, ys) -> 1 / 2 : MOVE_ELEMENTS(TAIL(xs), cons(HEAD(xs), ys)) || 1 / 2 : MOVE_ELEMENTS(cons(HEAD(ys), xs), TAIL(ys))
   EMPTY(nil) -> 1 : true
   OR(true, x) -> 1 : true
   OR(x, true) -> 1 : true
   OR(false, false) -> 1 : false
   IF(true, xs, ys) -> 1 : xs


----------------------------------------

(5) AST_ADPDependencyGraphProof (EQUIVALENT)


We use the dependency graph processor [FLOPS24].
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 1 SCC with 8 less nodes.
----------------------------------------

(6)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   empty(cons(x, xs)) -> 1 : false
   head(cons(x, xs)) -> 1 : x
   move_elements(xs, ys) -> 1 : if(or(empty(xs), empty(ys)), xs, ys)
   tail(cons(x, xs)) -> 1 : xs
   if(false, xs, ys) -> 1 / 2 : move_elements(tail(xs), cons(head(xs), ys)) || 1 / 2 : move_elements(cons(head(ys), xs), tail(ys))
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(x, true) -> 1 : true
   or(false, false) -> 1 : false
   if(true, xs, ys) -> 1 : xs

The ADP Problem has the following rules with annotations:

   IF(false, xs, ys) -> 1 / 2 : MOVE_ELEMENTS(TAIL(xs), cons(HEAD(xs), ys)) || 1 / 2 : MOVE_ELEMENTS(cons(HEAD(ys), xs), TAIL(ys))
   MOVE_ELEMENTS(xs, ys) -> 1 : IF(OR(EMPTY(xs), EMPTY(ys)), xs, ys)


----------------------------------------

(7) AST_ADPUsableTermsProof (EQUIVALENT)


We use the usable terms processor [FLOPS24].
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] gives us the following unusable Terms: 
[EMPTY(ys), EMPTY(xs), TAIL(xs), TAIL(ys), OR(empty(xs), empty(ys)), HEAD(xs), HEAD(ys)]
Hence, we can remove the annotations from these terms from every RHS of every ADP
----------------------------------------

(8)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   empty(cons(x, xs)) -> 1 : false
   head(cons(x, xs)) -> 1 : x
   move_elements(xs, ys) -> 1 : if(or(empty(xs), empty(ys)), xs, ys)
   tail(cons(x, xs)) -> 1 : xs
   if(false, xs, ys) -> 1 / 2 : move_elements(tail(xs), cons(head(xs), ys)) || 1 / 2 : move_elements(cons(head(ys), xs), tail(ys))
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(x, true) -> 1 : true
   or(false, false) -> 1 : false
   if(true, xs, ys) -> 1 : xs

The ADP Problem has the following rules with annotations:

   IF(false, xs, ys) -> 1 / 2 : MOVE_ELEMENTS(tail(xs), cons(head(xs), ys)) || 1 / 2 : MOVE_ELEMENTS(cons(head(ys), xs), tail(ys))
   MOVE_ELEMENTS(xs, ys) -> 1 : IF(or(empty(xs), empty(ys)), xs, ys)


----------------------------------------

(9) AST_ADPUsableRulesProof (EQUIVALENT)


We use the usable rules processor [FLOPS24].
Hence, by the usable rules processor [FLOPS24] we can deactivate the flags for all non-usable rules [FROCOS05]
----------------------------------------

(10)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   empty(cons(x, xs)) -> 1 : false
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(x, true) -> 1 : true
   or(false, false) -> 1 : false
   tail(cons(x, xs)) -> 1 : xs
   head(cons(x, xs)) -> 1 : x

The ADP Problem has the following rules with annotations:

   IF(false, xs, ys) -> 1 / 2 : MOVE_ELEMENTS(tail(xs), cons(head(xs), ys)) || 1 / 2 : MOVE_ELEMENTS(cons(head(ys), xs), tail(ys))
   MOVE_ELEMENTS(xs, ys) -> 1 : IF(or(empty(xs), empty(ys)), xs, ys)


----------------------------------------

(11) AST_ADPTransformationProof (EQUIVALENT)
By rule overlap instantiation [FLOPS24] for the rule MOVE_ELEMENTS(xs, ys) -> 1 : IF(or(empty(xs), empty(ys)), xs, ys) we obtained the following new ADPs :

   MOVE_ELEMENTS(cons(y0, y1), x1) -> 1 : IF(or(empty(cons(y0, y1)), empty(x1)), cons(y0, y1), x1)
   MOVE_ELEMENTS(nil, x1) -> 1 : IF(or(empty(nil), empty(x1)), nil, x1)
   MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), empty(cons(y0, y1))), x0, cons(y0, y1))
   MOVE_ELEMENTS(x0, nil) -> 1 : IF(or(empty(x0), empty(nil)), x0, nil)

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(12)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   empty(cons(x, xs)) -> 1 : false
   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(x, true) -> 1 : true
   or(false, false) -> 1 : false

The ADP Problem has the following rules with annotations:

   IF(false, xs, ys) -> 1 / 2 : MOVE_ELEMENTS(tail(xs), cons(head(xs), ys)) || 1 / 2 : MOVE_ELEMENTS(cons(head(ys), xs), tail(ys))
   MOVE_ELEMENTS(cons(y0, y1), x1) -> 1 : IF(or(empty(cons(y0, y1)), empty(x1)), cons(y0, y1), x1)
   MOVE_ELEMENTS(nil, x1) -> 1 : IF(or(empty(nil), empty(x1)), nil, x1)
   MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), empty(cons(y0, y1))), x0, cons(y0, y1))
   MOVE_ELEMENTS(x0, nil) -> 1 : IF(or(empty(x0), empty(nil)), x0, nil)


----------------------------------------

(13) AST_ADPTransformationProof (EQUIVALENT)
By rewriting [FLOPS24] for the rule MOVE_ELEMENTS(cons(y0, y1), x1) -> 1 : IF(or(empty(cons(y0, y1)), empty(x1)), cons(y0, y1), x1) at position [0,0] we obtained the following new ADPs :

   MOVE_ELEMENTS(cons(y0, y1), x1) -> 1 : IF(or(false, empty(x1)), cons(y0, y1), x1)

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(14)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   empty(cons(x, xs)) -> 1 : false
   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(x, true) -> 1 : true
   or(false, false) -> 1 : false

The ADP Problem has the following rules with annotations:

   IF(false, xs, ys) -> 1 / 2 : MOVE_ELEMENTS(tail(xs), cons(head(xs), ys)) || 1 / 2 : MOVE_ELEMENTS(cons(head(ys), xs), tail(ys))
   MOVE_ELEMENTS(nil, x1) -> 1 : IF(or(empty(nil), empty(x1)), nil, x1)
   MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), empty(cons(y0, y1))), x0, cons(y0, y1))
   MOVE_ELEMENTS(x0, nil) -> 1 : IF(or(empty(x0), empty(nil)), x0, nil)
   MOVE_ELEMENTS(cons(y0, y1), x1) -> 1 : IF(or(false, empty(x1)), cons(y0, y1), x1)


----------------------------------------

(15) AST_ADPTransformationProof (EQUIVALENT)
By rewriting [FLOPS24] for the rule MOVE_ELEMENTS(nil, x1) -> 1 : IF(or(empty(nil), empty(x1)), nil, x1) at position [0,0] we obtained the following new ADPs :

   MOVE_ELEMENTS(nil, x1) -> 1 : IF(or(true, empty(x1)), nil, x1)

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(16)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   empty(cons(x, xs)) -> 1 : false
   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(x, true) -> 1 : true
   or(false, false) -> 1 : false

The ADP Problem has the following rules with annotations:

   IF(false, xs, ys) -> 1 / 2 : MOVE_ELEMENTS(tail(xs), cons(head(xs), ys)) || 1 / 2 : MOVE_ELEMENTS(cons(head(ys), xs), tail(ys))
   MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), empty(cons(y0, y1))), x0, cons(y0, y1))
   MOVE_ELEMENTS(x0, nil) -> 1 : IF(or(empty(x0), empty(nil)), x0, nil)
   MOVE_ELEMENTS(cons(y0, y1), x1) -> 1 : IF(or(false, empty(x1)), cons(y0, y1), x1)
   MOVE_ELEMENTS(nil, x1) -> 1 : IF(or(true, empty(x1)), nil, x1)


----------------------------------------

(17) AST_ADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [FLOPS24].
The following pairs can be oriented strictly and we delete all annotations:

   MOVE_ELEMENTS(nil, x1) -> 1 : IF(or(true, empty(x1)), nil, x1)

The remaining pairs can at least be oriented weakly:

   IF(false, xs, ys) -> 1 / 2 : MOVE_ELEMENTS(tail(xs), cons(head(xs), ys)) || 1 / 2 : MOVE_ELEMENTS(cons(head(ys), xs), tail(ys))
   MOVE_ELEMENTS(x0, nil) -> 1 : IF(or(empty(x0), empty(nil)), x0, nil)
   MOVE_ELEMENTS(cons(y0, y1), x1) -> 1 : IF(or(false, empty(x1)), cons(y0, y1), x1)
   MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), empty(cons(y0, y1))), x0, cons(y0, y1))

Used ordering:  Polynomial interpretation [POLO]:

   POL(IF(x_1, x_2, x_3)) = x_1
   POL(MOVE_ELEMENTS(x_1, x_2)) = 2
   POL(cons(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(empty(x_1)) = 2
   POL(false) = 2
   POL(head(x_1)) = x_1
   POL(nil) = 0
   POL(or(x_1, x_2)) = x_1
   POL(tail(x_1)) = 2*x_1
   POL(true) = 0

----------------------------------------

(18)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   empty(cons(x, xs)) -> 1 : false
   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(x, true) -> 1 : true
   or(false, false) -> 1 : false

The ADP Problem has the following rules with annotations:

   IF(false, xs, ys) -> 1 / 2 : MOVE_ELEMENTS(tail(xs), cons(head(xs), ys)) || 1 / 2 : MOVE_ELEMENTS(cons(head(ys), xs), tail(ys))
   MOVE_ELEMENTS(x0, nil) -> 1 : IF(or(empty(x0), empty(nil)), x0, nil)
   MOVE_ELEMENTS(cons(y0, y1), x1) -> 1 : IF(or(false, empty(x1)), cons(y0, y1), x1)
   MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), empty(cons(y0, y1))), x0, cons(y0, y1))


----------------------------------------

(19) AST_ADPTransformationProof (EQUIVALENT)
By rewriting [FLOPS24] for the rule MOVE_ELEMENTS(x0, nil) -> 1 : IF(or(empty(x0), empty(nil)), x0, nil) at position [0,1] we obtained the following new ADPs :

   MOVE_ELEMENTS(x0, nil) -> 1 : IF(or(empty(x0), true), x0, nil)

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(20)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   empty(cons(x, xs)) -> 1 : false
   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(x, true) -> 1 : true
   or(false, false) -> 1 : false

The ADP Problem has the following rules with annotations:

   IF(false, xs, ys) -> 1 / 2 : MOVE_ELEMENTS(tail(xs), cons(head(xs), ys)) || 1 / 2 : MOVE_ELEMENTS(cons(head(ys), xs), tail(ys))
   MOVE_ELEMENTS(cons(y0, y1), x1) -> 1 : IF(or(false, empty(x1)), cons(y0, y1), x1)
   MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), empty(cons(y0, y1))), x0, cons(y0, y1))
   MOVE_ELEMENTS(x0, nil) -> 1 : IF(or(empty(x0), true), x0, nil)


----------------------------------------

(21) AST_ADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [FLOPS24].
The following pairs can be oriented strictly and we delete all annotations:

   MOVE_ELEMENTS(x0, nil) -> 1 : IF(or(empty(x0), true), x0, nil)

The remaining pairs can at least be oriented weakly:

   IF(false, xs, ys) -> 1 / 2 : MOVE_ELEMENTS(tail(xs), cons(head(xs), ys)) || 1 / 2 : MOVE_ELEMENTS(cons(head(ys), xs), tail(ys))
   MOVE_ELEMENTS(cons(y0, y1), x1) -> 1 : IF(or(false, empty(x1)), cons(y0, y1), x1)
   MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), empty(cons(y0, y1))), x0, cons(y0, y1))

Used ordering:  Polynomial interpretation [POLO]:

   POL(IF(x_1, x_2, x_3)) = x_1
   POL(MOVE_ELEMENTS(x_1, x_2)) = 2
   POL(cons(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(empty(x_1)) = 2
   POL(false) = 2
   POL(head(x_1)) = 2*x_1
   POL(nil) = 0
   POL(or(x_1, x_2)) = x_2
   POL(tail(x_1)) = 2*x_1
   POL(true) = 0

----------------------------------------

(22)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   empty(cons(x, xs)) -> 1 : false
   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(x, true) -> 1 : true
   or(false, false) -> 1 : false

The ADP Problem has the following rules with annotations:

   IF(false, xs, ys) -> 1 / 2 : MOVE_ELEMENTS(tail(xs), cons(head(xs), ys)) || 1 / 2 : MOVE_ELEMENTS(cons(head(ys), xs), tail(ys))
   MOVE_ELEMENTS(cons(y0, y1), x1) -> 1 : IF(or(false, empty(x1)), cons(y0, y1), x1)
   MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), empty(cons(y0, y1))), x0, cons(y0, y1))


----------------------------------------

(23) AST_ADPTransformationProof (EQUIVALENT)
By rewriting [FLOPS24] for the rule MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), empty(cons(y0, y1))), x0, cons(y0, y1)) at position [0,1] we obtained the following new ADPs :

   MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), false), x0, cons(y0, y1))

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(24)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   empty(cons(x, xs)) -> 1 : false
   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(x, true) -> 1 : true
   or(false, false) -> 1 : false

The ADP Problem has the following rules with annotations:

   IF(false, xs, ys) -> 1 / 2 : MOVE_ELEMENTS(tail(xs), cons(head(xs), ys)) || 1 / 2 : MOVE_ELEMENTS(cons(head(ys), xs), tail(ys))
   MOVE_ELEMENTS(cons(y0, y1), x1) -> 1 : IF(or(false, empty(x1)), cons(y0, y1), x1)
   MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), false), x0, cons(y0, y1))


----------------------------------------

(25) AST_ADPTransformationProof (EQUIVALENT)
By rule overlap instantiation [FLOPS24] for the rule MOVE_ELEMENTS(cons(y0, y1), x1) -> 1 : IF(or(false, empty(x1)), cons(y0, y1), x1) we obtained the following new ADPs :

   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(or(false, empty(cons(y0, y1))), cons(x0, x1), cons(y0, y1))
   MOVE_ELEMENTS(cons(x0, x1), nil) -> 1 : IF(or(false, empty(nil)), cons(x0, x1), nil)

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(26)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   empty(cons(x, xs)) -> 1 : false
   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(x, true) -> 1 : true
   or(false, false) -> 1 : false

The ADP Problem has the following rules with annotations:

   IF(false, xs, ys) -> 1 / 2 : MOVE_ELEMENTS(tail(xs), cons(head(xs), ys)) || 1 / 2 : MOVE_ELEMENTS(cons(head(ys), xs), tail(ys))
   MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), false), x0, cons(y0, y1))
   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(or(false, empty(cons(y0, y1))), cons(x0, x1), cons(y0, y1))
   MOVE_ELEMENTS(cons(x0, x1), nil) -> 1 : IF(or(false, empty(nil)), cons(x0, x1), nil)


----------------------------------------

(27) AST_ADPTransformationProof (EQUIVALENT)
By rewriting [FLOPS24] for the rule MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(or(false, empty(cons(y0, y1))), cons(x0, x1), cons(y0, y1)) at position [0,1] we obtained the following new ADPs :

   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(or(false, false), cons(x0, x1), cons(y0, y1))

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(28)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   empty(cons(x, xs)) -> 1 : false
   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(x, true) -> 1 : true
   or(false, false) -> 1 : false

The ADP Problem has the following rules with annotations:

   IF(false, xs, ys) -> 1 / 2 : MOVE_ELEMENTS(tail(xs), cons(head(xs), ys)) || 1 / 2 : MOVE_ELEMENTS(cons(head(ys), xs), tail(ys))
   MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), false), x0, cons(y0, y1))
   MOVE_ELEMENTS(cons(x0, x1), nil) -> 1 : IF(or(false, empty(nil)), cons(x0, x1), nil)
   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(or(false, false), cons(x0, x1), cons(y0, y1))


----------------------------------------

(29) AST_ADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [FLOPS24].
The following pairs can be oriented strictly and we delete all annotations:

   MOVE_ELEMENTS(cons(x0, x1), nil) -> 1 : IF(or(false, empty(nil)), cons(x0, x1), nil)

The remaining pairs can at least be oriented weakly:

   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(or(false, false), cons(x0, x1), cons(y0, y1))
   IF(false, xs, ys) -> 1 / 2 : MOVE_ELEMENTS(tail(xs), cons(head(xs), ys)) || 1 / 2 : MOVE_ELEMENTS(cons(head(ys), xs), tail(ys))
   MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), false), x0, cons(y0, y1))

Used ordering:  Polynomial interpretation [POLO]:

   POL(IF(x_1, x_2, x_3)) = x_1
   POL(MOVE_ELEMENTS(x_1, x_2)) = 2
   POL(cons(x_1, x_2)) = 2 + 2*x_1 + x_2
   POL(empty(x_1)) = x_1
   POL(false) = 2
   POL(head(x_1)) = 2*x_1
   POL(nil) = 0
   POL(or(x_1, x_2)) = x_2
   POL(tail(x_1)) = 2*x_1
   POL(true) = 0

----------------------------------------

(30)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   empty(cons(x, xs)) -> 1 : false
   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(x, true) -> 1 : true
   or(false, false) -> 1 : false

The ADP Problem has the following rules with annotations:

   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(or(false, false), cons(x0, x1), cons(y0, y1))
   IF(false, xs, ys) -> 1 / 2 : MOVE_ELEMENTS(tail(xs), cons(head(xs), ys)) || 1 / 2 : MOVE_ELEMENTS(cons(head(ys), xs), tail(ys))
   MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), false), x0, cons(y0, y1))


----------------------------------------

(31) AST_ADPUsableRulesProof (EQUIVALENT)


We use the usable rules processor [FLOPS24].
Hence, by the usable rules processor [FLOPS24] we can deactivate the flags for all non-usable rules [FROCOS05]
----------------------------------------

(32)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   empty(cons(x, xs)) -> 1 : false
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(false, false) -> 1 : false
   tail(cons(x, xs)) -> 1 : xs
   head(cons(x, xs)) -> 1 : x

The ADP Problem has the following rules with annotations:

   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(or(false, false), cons(x0, x1), cons(y0, y1))
   IF(false, xs, ys) -> 1 / 2 : MOVE_ELEMENTS(tail(xs), cons(head(xs), ys)) || 1 / 2 : MOVE_ELEMENTS(cons(head(ys), xs), tail(ys))
   MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), false), x0, cons(y0, y1))


----------------------------------------

(33) AST_ADPTransformationProof (EQUIVALENT)
By rewriting [FLOPS24] for the rule MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(or(false, false), cons(x0, x1), cons(y0, y1)) at position [0] we obtained the following new ADPs :

   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(false, cons(x0, x1), cons(y0, y1))

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(34)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   empty(cons(x, xs)) -> 1 : false
   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(false, false) -> 1 : false

The ADP Problem has the following rules with annotations:

   IF(false, xs, ys) -> 1 / 2 : MOVE_ELEMENTS(tail(xs), cons(head(xs), ys)) || 1 / 2 : MOVE_ELEMENTS(cons(head(ys), xs), tail(ys))
   MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), false), x0, cons(y0, y1))
   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(false, cons(x0, x1), cons(y0, y1))


----------------------------------------

(35) AST_ADPTransformationProof (EQUIVALENT)
By rule overlap instantiation [FLOPS24] for the rule IF(false, xs, ys) -> 1 / 2 : MOVE_ELEMENTS(tail(xs), cons(head(xs), ys)) || 1 / 2 : MOVE_ELEMENTS(cons(head(ys), xs), tail(ys)) we obtained the following new ADPs :

   IF(false, x0, cons(y0, y1)) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(y0, y1))) || 1 / 2 : MOVE_ELEMENTS(cons(head(cons(y0, y1)), x0), tail(cons(y0, y1)))
   IF(false, x0, x1) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), x1)) || 1 / 2 : move_elements(cons(head(x1), x0), tail(x1))

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(36)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   empty(cons(x, xs)) -> 1 : false
   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(false, false) -> 1 : false

The ADP Problem has the following rules with annotations:

   MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), false), x0, cons(y0, y1))
   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(false, cons(x0, x1), cons(y0, y1))
   IF(false, x0, cons(y0, y1)) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(y0, y1))) || 1 / 2 : MOVE_ELEMENTS(cons(head(cons(y0, y1)), x0), tail(cons(y0, y1)))
   IF(false, x0, x1) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), x1)) || 1 / 2 : move_elements(cons(head(x1), x0), tail(x1))


----------------------------------------

(37) AST_ADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [FLOPS24].
The following pairs can be oriented strictly and we delete all annotations:

   IF(false, x0, x1) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), x1)) || 1 / 2 : move_elements(cons(head(x1), x0), tail(x1))

The remaining pairs can at least be oriented weakly:

   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(false, cons(x0, x1), cons(y0, y1))
   MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), false), x0, cons(y0, y1))
   IF(false, x0, cons(y0, y1)) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(y0, y1))) || 1 / 2 : MOVE_ELEMENTS(cons(head(cons(y0, y1)), x0), tail(cons(y0, y1)))

Used ordering:  Polynomial interpretation [POLO]:

   POL(IF(x_1, x_2, x_3)) = 1
   POL(MOVE_ELEMENTS(x_1, x_2)) = 1
   POL(cons(x_1, x_2)) = x_1 + 2*x_2
   POL(empty(x_1)) = 0
   POL(false) = 0
   POL(head(x_1)) = 2*x_1
   POL(move_elements(x_1, x_2)) = 0
   POL(nil) = 1
   POL(or(x_1, x_2)) = 0
   POL(tail(x_1)) = 2*x_1
   POL(true) = 0

----------------------------------------

(38)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   empty(cons(x, xs)) -> 1 : false
   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(false, false) -> 1 : false

The ADP Problem has the following rules with annotations:

   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(false, cons(x0, x1), cons(y0, y1))
   MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), false), x0, cons(y0, y1))
   IF(false, x0, cons(y0, y1)) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(y0, y1))) || 1 / 2 : MOVE_ELEMENTS(cons(head(cons(y0, y1)), x0), tail(cons(y0, y1)))


----------------------------------------

(39) AST_ADPTransformationProof (EQUIVALENT)
By rewriting [FLOPS24] for the rule IF(false, x0, cons(y0, y1)) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(y0, y1))) || 1 / 2 : MOVE_ELEMENTS(cons(head(cons(y0, y1)), x0), tail(cons(y0, y1))) at position [0,0] we obtained the following new ADPs :

   IF(false, x0, cons(y0, y1)) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(y0, y1))) || 1 / 2 : MOVE_ELEMENTS(cons(y0, x0), tail(cons(y0, y1)))

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(40)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   empty(cons(x, xs)) -> 1 : false
   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(false, false) -> 1 : false

The ADP Problem has the following rules with annotations:

   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(false, cons(x0, x1), cons(y0, y1))
   MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), false), x0, cons(y0, y1))
   IF(false, x0, cons(y0, y1)) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(y0, y1))) || 1 / 2 : MOVE_ELEMENTS(cons(y0, x0), tail(cons(y0, y1)))


----------------------------------------

(41) AST_ADPTransformationProof (EQUIVALENT)
By rewriting [FLOPS24] for the rule IF(false, x0, cons(y0, y1)) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(y0, y1))) || 1 / 2 : MOVE_ELEMENTS(cons(y0, x0), tail(cons(y0, y1))) at position [1] we obtained the following new ADPs :

   IF(false, x0, cons(y0, y1)) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(y0, y1))) || 1 / 2 : MOVE_ELEMENTS(cons(y0, x0), y1)

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(42)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   empty(cons(x, xs)) -> 1 : false
   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(false, false) -> 1 : false

The ADP Problem has the following rules with annotations:

   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(false, cons(x0, x1), cons(y0, y1))
   MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), false), x0, cons(y0, y1))
   IF(false, x0, cons(y0, y1)) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(y0, y1))) || 1 / 2 : MOVE_ELEMENTS(cons(y0, x0), y1)


----------------------------------------

(43) AST_ADPTransformationProof (EQUIVALENT)
By rule overlap instantiation [FLOPS24] for the rule MOVE_ELEMENTS(x0, cons(y0, y1)) -> 1 : IF(or(empty(x0), false), x0, cons(y0, y1)) we obtained the following new ADPs :

   MOVE_ELEMENTS(cons(y0, y1), cons(x1, x2)) -> 1 : IF(or(empty(cons(y0, y1)), false), cons(y0, y1), cons(x1, x2))
   MOVE_ELEMENTS(nil, cons(x1, x2)) -> 1 : IF(or(empty(nil), false), nil, cons(x1, x2))

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(44)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   empty(cons(x, xs)) -> 1 : false
   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(false, false) -> 1 : false

The ADP Problem has the following rules with annotations:

   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(false, cons(x0, x1), cons(y0, y1))
   IF(false, x0, cons(y0, y1)) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(y0, y1))) || 1 / 2 : MOVE_ELEMENTS(cons(y0, x0), y1)
   MOVE_ELEMENTS(cons(y0, y1), cons(x1, x2)) -> 1 : IF(or(empty(cons(y0, y1)), false), cons(y0, y1), cons(x1, x2))
   MOVE_ELEMENTS(nil, cons(x1, x2)) -> 1 : IF(or(empty(nil), false), nil, cons(x1, x2))


----------------------------------------

(45) AST_ADPTransformationProof (EQUIVALENT)
By rewriting [FLOPS24] for the rule MOVE_ELEMENTS(cons(y0, y1), cons(x1, x2)) -> 1 : IF(or(empty(cons(y0, y1)), false), cons(y0, y1), cons(x1, x2)) at position [0,0] we obtained the following new ADPs :

   MOVE_ELEMENTS(cons(y0, y1), cons(x1, x2)) -> 1 : IF(or(false, false), cons(y0, y1), cons(x1, x2))

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(46)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   empty(cons(x, xs)) -> 1 : false
   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   or(false, false) -> 1 : false

The ADP Problem has the following rules with annotations:

   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(false, cons(x0, x1), cons(y0, y1))
   IF(false, x0, cons(y0, y1)) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(y0, y1))) || 1 / 2 : MOVE_ELEMENTS(cons(y0, x0), y1)
   MOVE_ELEMENTS(nil, cons(x1, x2)) -> 1 : IF(or(empty(nil), false), nil, cons(x1, x2))
   MOVE_ELEMENTS(cons(y0, y1), cons(x1, x2)) -> 1 : IF(or(false, false), cons(y0, y1), cons(x1, x2))


----------------------------------------

(47) AST_ADPUsableRulesProof (EQUIVALENT)


We use the usable rules processor [FLOPS24].
Hence, by the usable rules processor [FLOPS24] we can deactivate the flags for all non-usable rules [FROCOS05]
----------------------------------------

(48)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   or(false, false) -> 1 : false
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   tail(cons(x, xs)) -> 1 : xs
   head(cons(x, xs)) -> 1 : x

The ADP Problem has the following rules with annotations:

   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(false, cons(x0, x1), cons(y0, y1))
   IF(false, x0, cons(y0, y1)) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(y0, y1))) || 1 / 2 : MOVE_ELEMENTS(cons(y0, x0), y1)
   MOVE_ELEMENTS(nil, cons(x1, x2)) -> 1 : IF(or(empty(nil), false), nil, cons(x1, x2))
   MOVE_ELEMENTS(cons(y0, y1), cons(x1, x2)) -> 1 : IF(or(false, false), cons(y0, y1), cons(x1, x2))


----------------------------------------

(49) AST_ADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [FLOPS24].
The following pairs can be oriented strictly and we delete all annotations:

   MOVE_ELEMENTS(nil, cons(x1, x2)) -> 1 : IF(or(empty(nil), false), nil, cons(x1, x2))

The remaining pairs can at least be oriented weakly:

   MOVE_ELEMENTS(cons(y0, y1), cons(x1, x2)) -> 1 : IF(or(false, false), cons(y0, y1), cons(x1, x2))
   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(false, cons(x0, x1), cons(y0, y1))
   IF(false, x0, cons(y0, y1)) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(y0, y1))) || 1 / 2 : MOVE_ELEMENTS(cons(y0, x0), y1)

Used ordering:  Polynomial interpretation [POLO]:

   POL(IF(x_1, x_2, x_3)) = x_1
   POL(MOVE_ELEMENTS(x_1, x_2)) = 2
   POL(cons(x_1, x_2)) = x_1 + x_2
   POL(empty(x_1)) = 0
   POL(false) = 2
   POL(head(x_1)) = 2*x_1
   POL(nil) = 0
   POL(or(x_1, x_2)) = x_1
   POL(tail(x_1)) = 2*x_1
   POL(true) = 0

----------------------------------------

(50)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   or(false, false) -> 1 : false
   empty(nil) -> 1 : true
   or(true, x) -> 1 : true
   tail(cons(x, xs)) -> 1 : xs
   head(cons(x, xs)) -> 1 : x

The ADP Problem has the following rules with annotations:

   MOVE_ELEMENTS(cons(y0, y1), cons(x1, x2)) -> 1 : IF(or(false, false), cons(y0, y1), cons(x1, x2))
   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(false, cons(x0, x1), cons(y0, y1))
   IF(false, x0, cons(y0, y1)) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(y0, y1))) || 1 / 2 : MOVE_ELEMENTS(cons(y0, x0), y1)


----------------------------------------

(51) AST_ADPUsableRulesProof (EQUIVALENT)


We use the usable rules processor [FLOPS24].
Hence, by the usable rules processor [FLOPS24] we can deactivate the flags for all non-usable rules [FROCOS05]
----------------------------------------

(52)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   tail(cons(x, xs)) -> 1 : xs
   head(cons(x, xs)) -> 1 : x
   or(false, false) -> 1 : false

The ADP Problem has the following rules with annotations:

   MOVE_ELEMENTS(cons(y0, y1), cons(x1, x2)) -> 1 : IF(or(false, false), cons(y0, y1), cons(x1, x2))
   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(false, cons(x0, x1), cons(y0, y1))
   IF(false, x0, cons(y0, y1)) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(y0, y1))) || 1 / 2 : MOVE_ELEMENTS(cons(y0, x0), y1)


----------------------------------------

(53) AST_ADPTransformationProof (EQUIVALENT)
By rewriting [FLOPS24] for the rule MOVE_ELEMENTS(cons(y0, y1), cons(x1, x2)) -> 1 : IF(or(false, false), cons(y0, y1), cons(x1, x2)) at position [0] we obtained the following new ADPs :

   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(false, cons(x0, x1), cons(y0, y1))

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(54)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs
   or(false, false) -> 1 : false

The ADP Problem has the following rules with annotations:

   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(false, cons(x0, x1), cons(y0, y1))
   IF(false, x0, cons(y0, y1)) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(y0, y1))) || 1 / 2 : MOVE_ELEMENTS(cons(y0, x0), y1)


----------------------------------------

(55) AST_ADPUsableRulesProof (EQUIVALENT)


We use the usable rules processor [FLOPS24].
Hence, by the usable rules processor [FLOPS24] we can deactivate the flags for all non-usable rules [FROCOS05]
----------------------------------------

(56)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   tail(cons(x, xs)) -> 1 : xs
   head(cons(x, xs)) -> 1 : x

The ADP Problem has the following rules with annotations:

   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(false, cons(x0, x1), cons(y0, y1))
   IF(false, x0, cons(y0, y1)) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(y0, y1))) || 1 / 2 : MOVE_ELEMENTS(cons(y0, x0), y1)


----------------------------------------

(57) AST_ADPTransformationProof (EQUIVALENT)
By rule overlap instantiation [FLOPS24] for the rule IF(false, x0, cons(y0, y1)) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(y0, y1))) || 1 / 2 : MOVE_ELEMENTS(cons(y0, x0), y1) we obtained the following new ADPs :

   IF(false, x0, cons(x1, cons(y2, y3))) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(x1, cons(y2, y3)))) || 1 / 2 : MOVE_ELEMENTS(cons(x1, x0), cons(y2, y3))
   IF(false, x0, cons(x1, x2)) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(x1, x2))) || 1 / 2 : move_elements(cons(x1, x0), x2)

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(58)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs

The ADP Problem has the following rules with annotations:

   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(false, cons(x0, x1), cons(y0, y1))
   IF(false, x0, cons(x1, cons(y2, y3))) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(x1, cons(y2, y3)))) || 1 / 2 : MOVE_ELEMENTS(cons(x1, x0), cons(y2, y3))
   IF(false, x0, cons(x1, x2)) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(x1, x2))) || 1 / 2 : move_elements(cons(x1, x0), x2)


----------------------------------------

(59) AST_ADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [FLOPS24].
The following pairs can be oriented strictly and we delete all annotations:

   IF(false, x0, cons(x1, x2)) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(x1, x2))) || 1 / 2 : move_elements(cons(x1, x0), x2)

The remaining pairs can at least be oriented weakly:

   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(false, cons(x0, x1), cons(y0, y1))
   IF(false, x0, cons(x1, cons(y2, y3))) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(x1, cons(y2, y3)))) || 1 / 2 : MOVE_ELEMENTS(cons(x1, x0), cons(y2, y3))

Used ordering:  Polynomial interpretation [POLO]:

   POL(IF(x_1, x_2, x_3)) = 1 + 2*x_1 + 2*x_1*x_2 + 2*x_1*x_2*x_3 + 2*x_1*x_3
   POL(MOVE_ELEMENTS(x_1, x_2)) = 1
   POL(cons(x_1, x_2)) = 2*x_1 + x_2
   POL(false) = 0
   POL(head(x_1)) = 2*x_1
   POL(move_elements(x_1, x_2)) = 0
   POL(tail(x_1)) = 2*x_1

----------------------------------------

(60)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs

The ADP Problem has the following rules with annotations:

   MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(false, cons(x0, x1), cons(y0, y1))
   IF(false, x0, cons(x1, cons(y2, y3))) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(x1, cons(y2, y3)))) || 1 / 2 : MOVE_ELEMENTS(cons(x1, x0), cons(y2, y3))


----------------------------------------

(61) AST_ADPTransformationProof (EQUIVALENT)
By rule overlap instantiation [FLOPS24] for the rule MOVE_ELEMENTS(cons(x0, x1), cons(y0, y1)) -> 1 : IF(false, cons(x0, x1), cons(y0, y1)) we obtained the following new ADPs :

   MOVE_ELEMENTS(cons(x0, x1), cons(x2, cons(y2, y3))) -> 1 : IF(false, cons(x0, x1), cons(x2, cons(y2, y3)))

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(62)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs

The ADP Problem has the following rules with annotations:

   IF(false, x0, cons(x1, cons(y2, y3))) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(x1, cons(y2, y3)))) || 1 / 2 : MOVE_ELEMENTS(cons(x1, x0), cons(y2, y3))
   MOVE_ELEMENTS(cons(x0, x1), cons(x2, cons(y2, y3))) -> 1 : IF(false, cons(x0, x1), cons(x2, cons(y2, y3)))


----------------------------------------

(63) AST_ADPTransformationProof (EQUIVALENT)
By rule overlap instantiation [FLOPS24] for the rule IF(false, x0, cons(x1, cons(y2, y3))) -> 1 / 2 : MOVE_ELEMENTS(tail(x0), cons(head(x0), cons(x1, cons(y2, y3)))) || 1 / 2 : MOVE_ELEMENTS(cons(x1, x0), cons(y2, y3)) we obtained the following new ADPs :

   IF(false, cons(y0, y1), cons(x1, cons(x2, x3))) -> 1 / 2 : MOVE_ELEMENTS(tail(cons(y0, y1)), cons(head(cons(y0, y1)), cons(x1, cons(x2, x3)))) || 1 / 2 : MOVE_ELEMENTS(cons(x1, cons(y0, y1)), cons(x2, x3))
   IF(false, x0, cons(x1, cons(x2, x3))) -> 1 / 2 : move_elements(tail(x0), cons(head(x0), cons(x1, cons(x2, x3)))) || 1 / 2 : MOVE_ELEMENTS(cons(x1, x0), cons(x2, x3))

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(64)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs

The ADP Problem has the following rules with annotations:

   MOVE_ELEMENTS(cons(x0, x1), cons(x2, cons(y2, y3))) -> 1 : IF(false, cons(x0, x1), cons(x2, cons(y2, y3)))
   IF(false, cons(y0, y1), cons(x1, cons(x2, x3))) -> 1 / 2 : MOVE_ELEMENTS(tail(cons(y0, y1)), cons(head(cons(y0, y1)), cons(x1, cons(x2, x3)))) || 1 / 2 : MOVE_ELEMENTS(cons(x1, cons(y0, y1)), cons(x2, x3))
   IF(false, x0, cons(x1, cons(x2, x3))) -> 1 / 2 : move_elements(tail(x0), cons(head(x0), cons(x1, cons(x2, x3)))) || 1 / 2 : MOVE_ELEMENTS(cons(x1, x0), cons(x2, x3))


----------------------------------------

(65) AST_ADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [FLOPS24].
The following pairs can be oriented strictly and we delete all annotations:

   IF(false, x0, cons(x1, cons(x2, x3))) -> 1 / 2 : move_elements(tail(x0), cons(head(x0), cons(x1, cons(x2, x3)))) || 1 / 2 : MOVE_ELEMENTS(cons(x1, x0), cons(x2, x3))

The remaining pairs can at least be oriented weakly:

   MOVE_ELEMENTS(cons(x0, x1), cons(x2, cons(y2, y3))) -> 1 : IF(false, cons(x0, x1), cons(x2, cons(y2, y3)))
   IF(false, cons(y0, y1), cons(x1, cons(x2, x3))) -> 1 / 2 : MOVE_ELEMENTS(tail(cons(y0, y1)), cons(head(cons(y0, y1)), cons(x1, cons(x2, x3)))) || 1 / 2 : MOVE_ELEMENTS(cons(x1, cons(y0, y1)), cons(x2, x3))

Used ordering:  Polynomial interpretation [POLO]:

   POL(IF(x_1, x_2, x_3)) = x_1
   POL(MOVE_ELEMENTS(x_1, x_2)) = 1
   POL(cons(x_1, x_2)) = x_1 + 2*x_2
   POL(false) = 1
   POL(head(x_1)) = 2*x_1
   POL(move_elements(x_1, x_2)) = 0
   POL(tail(x_1)) = 2*x_1

----------------------------------------

(66)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs

The ADP Problem has the following rules with annotations:

   MOVE_ELEMENTS(cons(x0, x1), cons(x2, cons(y2, y3))) -> 1 : IF(false, cons(x0, x1), cons(x2, cons(y2, y3)))
   IF(false, cons(y0, y1), cons(x1, cons(x2, x3))) -> 1 / 2 : MOVE_ELEMENTS(tail(cons(y0, y1)), cons(head(cons(y0, y1)), cons(x1, cons(x2, x3)))) || 1 / 2 : MOVE_ELEMENTS(cons(x1, cons(y0, y1)), cons(x2, x3))


----------------------------------------

(67) AST_ADPTransformationProof (EQUIVALENT)
By rewriting [FLOPS24] for the rule IF(false, cons(y0, y1), cons(x1, cons(x2, x3))) -> 1 / 2 : MOVE_ELEMENTS(tail(cons(y0, y1)), cons(head(cons(y0, y1)), cons(x1, cons(x2, x3)))) || 1 / 2 : MOVE_ELEMENTS(cons(x1, cons(y0, y1)), cons(x2, x3)) at position [0] we obtained the following new ADPs :

   IF(false, cons(y0, y1), cons(x1, cons(x2, x3))) -> 1 / 2 : MOVE_ELEMENTS(cons(x1, cons(y0, y1)), cons(x2, x3)) || 1 / 2 : MOVE_ELEMENTS(y1, cons(head(cons(y0, y1)), cons(x1, cons(x2, x3))))

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(68)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   head(cons(x, xs)) -> 1 : x
   tail(cons(x, xs)) -> 1 : xs

The ADP Problem has the following rules with annotations:

   MOVE_ELEMENTS(cons(x0, x1), cons(x2, cons(y2, y3))) -> 1 : IF(false, cons(x0, x1), cons(x2, cons(y2, y3)))
   IF(false, cons(y0, y1), cons(x1, cons(x2, x3))) -> 1 / 2 : MOVE_ELEMENTS(cons(x1, cons(y0, y1)), cons(x2, x3)) || 1 / 2 : MOVE_ELEMENTS(y1, cons(head(cons(y0, y1)), cons(x1, cons(x2, x3))))


----------------------------------------

(69) AST_ADPUsableRulesProof (EQUIVALENT)


We use the usable rules processor [FLOPS24].
Hence, by the usable rules processor [FLOPS24] we can deactivate the flags for all non-usable rules [FROCOS05]
----------------------------------------

(70)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   head(cons(x, xs)) -> 1 : x

The ADP Problem has the following rules with annotations:

   MOVE_ELEMENTS(cons(x0, x1), cons(x2, cons(y2, y3))) -> 1 : IF(false, cons(x0, x1), cons(x2, cons(y2, y3)))
   IF(false, cons(y0, y1), cons(x1, cons(x2, x3))) -> 1 / 2 : MOVE_ELEMENTS(cons(x1, cons(y0, y1)), cons(x2, x3)) || 1 / 2 : MOVE_ELEMENTS(y1, cons(head(cons(y0, y1)), cons(x1, cons(x2, x3))))


----------------------------------------

(71) AST_ADPTransformationProof (EQUIVALENT)
By rewriting [FLOPS24] for the rule IF(false, cons(y0, y1), cons(x1, cons(x2, x3))) -> 1 / 2 : MOVE_ELEMENTS(cons(x1, cons(y0, y1)), cons(x2, x3)) || 1 / 2 : MOVE_ELEMENTS(y1, cons(head(cons(y0, y1)), cons(x1, cons(x2, x3)))) at position [1,0] we obtained the following new ADPs :

   IF(false, cons(y0, y1), cons(x1, cons(x2, x3))) -> 1 / 2 : MOVE_ELEMENTS(cons(x1, cons(y0, y1)), cons(x2, x3)) || 1 / 2 : MOVE_ELEMENTS(y1, cons(y0, cons(x1, cons(x2, x3))))

and we added the following new probabilistic rules with active return value flag:
none

----------------------------------------

(72)
Obligation:
Probabilistic ADP Problem:
The ADP Problem has the following rules with active return value flag:

   head(cons(x, xs)) -> 1 : x

The ADP Problem has the following rules with annotations:

   MOVE_ELEMENTS(cons(x0, x1), cons(x2, cons(y2, y3))) -> 1 : IF(false, cons(x0, x1), cons(x2, cons(y2, y3)))
   IF(false, cons(y0, y1), cons(x1, cons(x2, x3))) -> 1 / 2 : MOVE_ELEMENTS(cons(x1, cons(y0, y1)), cons(x2, x3)) || 1 / 2 : MOVE_ELEMENTS(y1, cons(y0, cons(x1, cons(x2, x3))))


----------------------------------------

(73) AST_ADPUsableRulesProof (EQUIVALENT)


We use the usable rules processor [FLOPS24].
Hence, by the usable rules processor [FLOPS24] we can deactivate the flags for all non-usable rules [FROCOS05]
----------------------------------------

(74)
Obligation:
Probabilistic ADP Problem:
The set of rules with active return value flag is empty.
The ADP Problem has the following rules with annotations:

   MOVE_ELEMENTS(cons(x0, x1), cons(x2, cons(y2, y3))) -> 1 : IF(false, cons(x0, x1), cons(x2, cons(y2, y3)))
   IF(false, cons(y0, y1), cons(x1, cons(x2, x3))) -> 1 / 2 : MOVE_ELEMENTS(cons(x1, cons(y0, y1)), cons(x2, x3)) || 1 / 2 : MOVE_ELEMENTS(y1, cons(y0, cons(x1, cons(x2, x3))))


----------------------------------------

(75) AST_ADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [FLOPS24].
The following pairs can be oriented strictly and we delete all annotations:

   MOVE_ELEMENTS(cons(x0, x1), cons(x2, cons(y2, y3))) -> 1 : IF(false, cons(x0, x1), cons(x2, cons(y2, y3)))

The remaining pairs can at least be oriented weakly:

   IF(false, cons(y0, y1), cons(x1, cons(x2, x3))) -> 1 / 2 : MOVE_ELEMENTS(cons(x1, cons(y0, y1)), cons(x2, x3)) || 1 / 2 : MOVE_ELEMENTS(y1, cons(y0, cons(x1, cons(x2, x3))))

Used ordering:  Polynomial interpretation [POLO]:

   POL(IF(x_1, x_2, x_3)) = x_1*x_2*x_3 + x_1*x_3
   POL(MOVE_ELEMENTS(x_1, x_2)) = 1 + 2*x_1*x_2 + 2*x_2
   POL(cons(x_1, x_2)) = 2 + 2*x_1 + x_1*x_2 + 2*x_2
   POL(false) = 2

----------------------------------------

(76)
Obligation:
Probabilistic ADP Problem:
The set of rules with active return value flag is empty.
The ADP Problem has the following rules with annotations:

   IF(false, cons(y0, y1), cons(x1, cons(x2, x3))) -> 1 / 2 : MOVE_ELEMENTS(cons(x1, cons(y0, y1)), cons(x2, x3)) || 1 / 2 : MOVE_ELEMENTS(y1, cons(y0, cons(x1, cons(x2, x3))))


----------------------------------------

(77) AST_ADPDependencyGraphProof (EQUIVALENT)


We use the dependency graph processor [FLOPS24].
The approximation of the Dependency Graph [LPAR04,FROCOS05,EDGSTAR] contains 0 SCCs with 1 less node.
----------------------------------------

(78)
TRUE
