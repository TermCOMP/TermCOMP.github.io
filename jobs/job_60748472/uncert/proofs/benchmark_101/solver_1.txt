SAST
proof of /home/ff862203/input_4KgX6ddm2L.ari
# AProVE Commit ID: 1c9e2a6453f9f0dca490585733f1cff3767d3e54 jan-christoph 20250828 unpublished


Complexity of the given CpxPTRS could be proven:

(0) CpxPTRS
(1) CpxPTRS_DerivationToRuntimeComplexityProof [UNSOUND LOWER BOUND(ID)SOUND UPPER BOUND(ID), 0 ms]
(2) CpxPTRS
(3) CpxPTRS_ToPQTRSProof [BOTH BOUNDS(ID, ID), 0 ms]
(4) PQTRS
(5) CpxPQTRS_ToADPProblemProof [BOTH BOUNDS(ID, ID), 32 ms]
(6) ADP
(7) CpxADP_SCCSplitProof [UPPER BOUND(ID), 0 ms]
(8) MAX
    (9) ADP
        (10) CpxADP_UsableTermsProof [UPPER BOUND(ID), 0 ms]
        (11) ADP
        (12) CpxADP_UsableRulesProof [BOTH BOUNDS(ID, ID), 0 ms]
        (13) ADP
        (14) CpxADP_ProbabilityRemovalProof [UPPER BOUND(ID), 0 ms]
        (15) CdtProblem
        (16) CdtLeafRemovalProof [ComplexityIfPolyImplication, 0 ms]
        (17) CdtProblem
        (18) CdtToCpxRelTrsProof [BOTH BOUNDS(ID, ID), 0 ms]
        (19) CpxTRS
        (20) RelTrsToTrsProof [UPPER BOUND(ID), 0 ms]
        (21) CpxTRS
        (22) CpxTrsMatchBoundsTAProof [FINISHED, 0 ms]
        (23) BOUNDS(1, n^1)
    (24) ADP
        (25) CpxADP_UsableTermsProof [UPPER BOUND(ID), 0 ms]
        (26) ADP
        (27) CpxADP_UsableRulesProof [BOTH BOUNDS(ID, ID), 0 ms]
        (28) ADP
        (29) CpxADP_ReductionPairProof [UPPER BOUND(ADD(EXP)), 21 ms]
        (30) ADP
        (31) SisEmptyProof [FINISHED, 0 ms]
        (32) BOUNDS(1, 1)
    (33) ADP
        (34) CpxADP_UsableRulesProof [BOTH BOUNDS(ID, ID), 0 ms]
        (35) ADP
        (36) CpxADP_ReductionPairProof [UPPER BOUND(ADD(EXP)), 11 ms]
        (37) ADP
        (38) SisEmptyProof [FINISHED, 0 ms]
        (39) BOUNDS(1, 1)


----------------------------------------

(0)
Obligation:
Probabilistic term rewrite system:
The TRS has the following probabilistic rules:

   minus(x, x) -> 1 : 0
   minus(x, 0) -> 1 : x
   div(s(x), s(y)) -> 1 / 2 : s(div(minus(x, y), s(y))) || 1 / 2 : div(s(x), s(y))
   minus(s(x), s(y)) -> 1 : minus(x, y)
   div(0, s(x)) -> 1 : 0

and uses the innermost rewrite strategy.

----------------------------------------

(1) CpxPTRS_DerivationToRuntimeComplexityProof (UNSOUND LOWER BOUND(ID)SOUND UPPER BOUND(ID))
The following rules have been added to R to convert the given derivational complexity problem to a runtime complexity problem:

   encArg(0) -> 1 : 0
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(cons_div(x_1, x_2)) -> 1 : div(encArg(x_1), encArg(x_2))
   encArg(cons_minus(x_1, x_2)) -> 1 : minus(encArg(x_1), encArg(x_2))
   encode_div(x_1, x_2) -> 1 : div(encArg(x_1), encArg(x_2))
   encode_0 -> 1 : 0
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_minus(x_1, x_2) -> 1 : minus(encArg(x_1), encArg(x_2))


----------------------------------------

(2)
Obligation:
Probabilistic term rewrite system:
The TRS has the following probabilistic rules:

   encArg(0) -> 1 : 0
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(cons_div(x_1, x_2)) -> 1 : div(encArg(x_1), encArg(x_2))
   encArg(cons_minus(x_1, x_2)) -> 1 : minus(encArg(x_1), encArg(x_2))
   encode_div(x_1, x_2) -> 1 : div(encArg(x_1), encArg(x_2))
   encode_0 -> 1 : 0
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_minus(x_1, x_2) -> 1 : minus(encArg(x_1), encArg(x_2))
   minus(x, x) -> 1 : 0
   minus(x, 0) -> 1 : x
   div(s(x), s(y)) -> 1 / 2 : s(div(minus(x, y), s(y))) || 1 / 2 : div(s(x), s(y))
   minus(s(x), s(y)) -> 1 : minus(x, y)
   div(0, s(x)) -> 1 : 0

and uses the innermost rewrite strategy.

----------------------------------------

(3) CpxPTRS_ToPQTRSProof (BOTH BOUNDS(ID, ID))
Transformed PTRS into PQTRS. Q is:
   encArg(0), encArg(s(x_1)), encArg(cons_div(x_1, x_2)), encArg(cons_minus(x_1, x_2)), encode_div(x_1, x_2), encode_0, encode_s(x_1), encode_minus(x_1, x_2), minus(x, x), minus(x, 0), div(s(x), s(y)), minus(s(x), s(y)), div(0, s(x))
----------------------------------------

(4)
Obligation:
Probabilistic Q term rewrite system:
The PQTRS has the following probabilistic rules:

   encArg(0) -> 1 : 0
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(cons_div(x_1, x_2)) -> 1 : div(encArg(x_1), encArg(x_2))
   encArg(cons_minus(x_1, x_2)) -> 1 : minus(encArg(x_1), encArg(x_2))
   encode_div(x_1, x_2) -> 1 : div(encArg(x_1), encArg(x_2))
   encode_0 -> 1 : 0
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_minus(x_1, x_2) -> 1 : minus(encArg(x_1), encArg(x_2))
   minus(x, x) -> 1 : 0
   minus(x, 0) -> 1 : x
   div(s(x), s(y)) -> 1 / 2 : s(div(minus(x, y), s(y))) || 1 / 2 : div(s(x), s(y))
   minus(s(x), s(y)) -> 1 : minus(x, y)
   div(0, s(x)) -> 1 : 0

And Q contains the following terms:
   encArg(0), encArg(s(x0)), encArg(cons_div(x0, x1)), encArg(cons_minus(x0, x1)), encode_div(x0, x1), encode_0, encode_s(x0), encode_minus(x0, x1), minus(x0, x0), minus(x0, 0), div(s(x0), s(x1)), minus(s(x0), s(x1)), div(0, s(x0))

----------------------------------------

(5) CpxPQTRS_ToADPProblemProof (BOTH BOUNDS(ID, ID))


The complexity of a PQTRS (R,Q) is equivalent to the complexity of the ADP Problem A(R) (Chain-Criterion) (Leon's master's thesis).
The ADPs are:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(0) -> 1 : 0
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(cons_div(x_1, x_2)) -> 1 : div(encArg(x_1), encArg(x_2))
   encArg(cons_minus(x_1, x_2)) -> 1 : minus(encArg(x_1), encArg(x_2))
   encode_div(x_1, x_2) -> 1 : div(encArg(x_1), encArg(x_2))
   encode_0 -> 1 : 0
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_minus(x_1, x_2) -> 1 : minus(encArg(x_1), encArg(x_2))
   minus(x, x) -> 1 : 0
   minus(x, 0) -> 1 : x
   div(s(x), s(y)) -> 1 / 2 : s(div(minus(x, y), s(y))) || 1 / 2 : div(s(x), s(y))
   minus(s(x), s(y)) -> 1 : minus(x, y)
   div(0, s(x)) -> 1 : 0

Rules with annotation in P:

   ENCARG(0) -> 1 : 0
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_div(x_1, x_2)) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   ENCODE_DIV(x_1, x_2) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_0 -> 1 : 0
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_MINUS(x_1, x_2) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   MINUS(x, x) -> 1 : 0
   MINUS(x, 0) -> 1 : x
   DIV(s(x), s(y)) -> 1 / 2 : s(DIV(MINUS(x, y), s(y))) || 1 / 2 : DIV(s(x), s(y))
   MINUS(s(x), s(y)) -> 1 : MINUS(x, y)
   DIV(0, s(x)) -> 1 : 0

Rules with annotation in S:

   ENCARG(0) -> 1 : 0
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_div(x_1, x_2)) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   ENCODE_DIV(x_1, x_2) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_0 -> 1 : 0
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_MINUS(x_1, x_2) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   MINUS(x, x) -> 1 : 0
   MINUS(x, 0) -> 1 : x
   DIV(s(x), s(y)) -> 1 / 2 : s(DIV(MINUS(x, y), s(y))) || 1 / 2 : DIV(s(x), s(y))
   MINUS(s(x), s(y)) -> 1 : MINUS(x, y)
   DIV(0, s(x)) -> 1 : 0

Rules with annotation and a known complexity:

   none

----------------------------------------

(6)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(0) -> 1 : 0
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(cons_div(x_1, x_2)) -> 1 : div(encArg(x_1), encArg(x_2))
   encArg(cons_minus(x_1, x_2)) -> 1 : minus(encArg(x_1), encArg(x_2))
   encode_div(x_1, x_2) -> 1 : div(encArg(x_1), encArg(x_2))
   encode_0 -> 1 : 0
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_minus(x_1, x_2) -> 1 : minus(encArg(x_1), encArg(x_2))
   minus(x, x) -> 1 : 0
   minus(x, 0) -> 1 : x
   div(s(x), s(y)) -> 1 / 2 : s(div(minus(x, y), s(y))) || 1 / 2 : div(s(x), s(y))
   minus(s(x), s(y)) -> 1 : minus(x, y)
   div(0, s(x)) -> 1 : 0

Rules with annotation in P:

   ENCARG(0) -> 1 : 0
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_div(x_1, x_2)) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   ENCODE_DIV(x_1, x_2) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_0 -> 1 : 0
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_MINUS(x_1, x_2) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   MINUS(x, x) -> 1 : 0
   MINUS(x, 0) -> 1 : x
   DIV(s(x), s(y)) -> 1 / 2 : s(DIV(MINUS(x, y), s(y))) || 1 / 2 : DIV(s(x), s(y))
   MINUS(s(x), s(y)) -> 1 : MINUS(x, y)
   DIV(0, s(x)) -> 1 : 0

Rules with annotation in S:

   ENCARG(0) -> 1 : 0
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_div(x_1, x_2)) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   ENCODE_DIV(x_1, x_2) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_0 -> 1 : 0
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_MINUS(x_1, x_2) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   MINUS(x, x) -> 1 : 0
   MINUS(x, 0) -> 1 : x
   DIV(s(x), s(y)) -> 1 / 2 : s(DIV(MINUS(x, y), s(y))) || 1 / 2 : DIV(s(x), s(y))
   MINUS(s(x), s(y)) -> 1 : MINUS(x, y)
   DIV(0, s(x)) -> 1 : 0

Rules with annotation and a known complexity:

   none

----------------------------------------

(7) CpxADP_SCCSplitProof (UPPER BOUND(ID))
As part of the dependency graph processor, we can split problem in 3 new components.
----------------------------------------

(8)
Complex Obligation (MAX)

----------------------------------------

(9)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(0) -> 1 : 0
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(cons_div(x_1, x_2)) -> 1 : div(encArg(x_1), encArg(x_2))
   encArg(cons_minus(x_1, x_2)) -> 1 : minus(encArg(x_1), encArg(x_2))
   encode_div(x_1, x_2) -> 1 : div(encArg(x_1), encArg(x_2))
   encode_0 -> 1 : 0
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_minus(x_1, x_2) -> 1 : minus(encArg(x_1), encArg(x_2))
   minus(x, x) -> 1 : 0
   minus(x, 0) -> 1 : x
   div(s(x), s(y)) -> 1 / 2 : s(div(minus(x, y), s(y))) || 1 / 2 : div(s(x), s(y))
   minus(s(x), s(y)) -> 1 : minus(x, y)
   div(0, s(x)) -> 1 : 0

Rules with annotation in P:

   ENCODE_DIV(x_1, x_2) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_MINUS(x_1, x_2) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_div(x_1, x_2)) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))

Rules with annotation in S:

   ENCARG(cons_div(x_1, x_2)) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))

Rules with annotation and a known complexity:

   ENCODE_DIV(x_1, x_2) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_MINUS(x_1, x_2) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))


----------------------------------------

(10) CpxADP_UsableTermsProof (UPPER BOUND(ID))


The approximation of the Dependency Graph  gives us the following unusable Terms: 
   DIV(encArg(x_1), encArg(x_2)), MINUS(encArg(x_1), encArg(x_2))
Hence, as part of the dependency graph processor, we can remove the annotations from these terms from every RHS of every ADP in P and S.

----------------------------------------

(11)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(0) -> 1 : 0
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(cons_div(x_1, x_2)) -> 1 : div(encArg(x_1), encArg(x_2))
   encArg(cons_minus(x_1, x_2)) -> 1 : minus(encArg(x_1), encArg(x_2))
   encode_div(x_1, x_2) -> 1 : div(encArg(x_1), encArg(x_2))
   encode_0 -> 1 : 0
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_minus(x_1, x_2) -> 1 : minus(encArg(x_1), encArg(x_2))
   minus(x, x) -> 1 : 0
   minus(x, 0) -> 1 : x
   div(s(x), s(y)) -> 1 / 2 : s(div(minus(x, y), s(y))) || 1 / 2 : div(s(x), s(y))
   minus(s(x), s(y)) -> 1 : minus(x, y)
   div(0, s(x)) -> 1 : 0

Rules with annotation in P:

   ENCARG(cons_div(x_1, x_2)) -> 1 : div(ENCARG(x_1), ENCARG(x_2))
   ENCODE_MINUS(x_1, x_2) -> 1 : minus(ENCARG(x_1), ENCARG(x_2))
   ENCODE_DIV(x_1, x_2) -> 1 : div(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : minus(ENCARG(x_1), ENCARG(x_2))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation in S:

   ENCARG(cons_div(x_1, x_2)) -> 1 : div(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : minus(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation and a known complexity:

   ENCODE_MINUS(x_1, x_2) -> 1 : minus(ENCARG(x_1), ENCARG(x_2))
   ENCODE_DIV(x_1, x_2) -> 1 : div(ENCARG(x_1), ENCARG(x_2))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))


----------------------------------------

(12) CpxADP_UsableRulesProof (BOTH BOUNDS(ID, ID))


We use the usable rules processor.
We can deactivate the flags for all non-usable rules [FROCOS05]

Rules which have been flagged as non usable in this step:

   encode_minus(x_1, x_2) -> 1 : minus(encArg(x_1), encArg(x_2))
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encode_div(x_1, x_2) -> 1 : div(encArg(x_1), encArg(x_2))
   encArg(cons_div(x_1, x_2)) -> 1 : div(encArg(x_1), encArg(x_2))
   minus(x, x) -> 1 : 0
   encArg(cons_minus(x_1, x_2)) -> 1 : minus(encArg(x_1), encArg(x_2))
   encArg(0) -> 1 : 0
   minus(x, 0) -> 1 : x
   encode_0 -> 1 : 0
   encode_s(x_1) -> 1 : s(encArg(x_1))
   div(s(x), s(y)) -> 1 / 2 : s(div(minus(x, y), s(y))) || 1 / 2 : div(s(x), s(y))
   minus(s(x), s(y)) -> 1 : minus(x, y)
   div(0, s(x)) -> 1 : 0

----------------------------------------

(13)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:
   none
Rules with annotation in P:

   ENCARG(cons_div(x_1, x_2)) -> 1 : div(ENCARG(x_1), ENCARG(x_2))
   ENCODE_MINUS(x_1, x_2) -> 1 : minus(ENCARG(x_1), ENCARG(x_2))
   ENCODE_DIV(x_1, x_2) -> 1 : div(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : minus(ENCARG(x_1), ENCARG(x_2))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation in S:

   ENCARG(cons_div(x_1, x_2)) -> 1 : div(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : minus(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation and a known complexity:

   ENCODE_MINUS(x_1, x_2) -> 1 : minus(ENCARG(x_1), ENCARG(x_2))
   ENCODE_DIV(x_1, x_2) -> 1 : div(ENCARG(x_1), ENCARG(x_2))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))


----------------------------------------

(14) CpxADP_ProbabilityRemovalProof (UPPER BOUND(ID))


We use the probability removal processor to move to dependecy tuples without probabilities.
As all rules have a trivial probability (1:r), we can transform it into a non-probabilistic DT problem

----------------------------------------

(15)
Obligation:
Complexity Dependency Tuples Problem

Rules:none
Tuples:
   ENCARG(cons_div(x_1, x_2)) -> c(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_div(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCODE_MINUS(x_1, x_2) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCODE_MINUS(x_1, x_2) -> c3(ENCARG(x_2), ENCARG(x_1))
   ENCODE_DIV(x_1, x_2) -> c4(ENCARG(x_2), ENCARG(x_1))
   ENCODE_DIV(x_1, x_2) -> c5(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_minus(x_1, x_2)) -> c6(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_minus(x_1, x_2)) -> c7(ENCARG(x_2), ENCARG(x_1))
   ENCODE_S(x_1) -> c8(ENCARG(x_1))
   ENCARG(s(x_1)) -> c9(ENCARG(x_1))
S tuples:
   ENCARG(cons_div(x_1, x_2)) -> c(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_div(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCODE_MINUS(x_1, x_2) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCODE_MINUS(x_1, x_2) -> c3(ENCARG(x_2), ENCARG(x_1))
   ENCODE_DIV(x_1, x_2) -> c4(ENCARG(x_2), ENCARG(x_1))
   ENCODE_DIV(x_1, x_2) -> c5(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_minus(x_1, x_2)) -> c6(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_minus(x_1, x_2)) -> c7(ENCARG(x_2), ENCARG(x_1))
   ENCODE_S(x_1) -> c8(ENCARG(x_1))
   ENCARG(s(x_1)) -> c9(ENCARG(x_1))
K tuples:none
Defined Rule Symbols:   encArg_1, encode_div_2, encode_0, encode_s_1, encode_minus_2, minus_2, div_2

Defined Pair Symbols:none

Compound Symbols:   c_2, c1_2, c2_2, c3_2, c4_2, c5_2, c6_2, c7_2, c8_1, c9_1


----------------------------------------

(16) CdtLeafRemovalProof (ComplexityIfPolyImplication)
Removed 5 leading nodes:
   ENCODE_MINUS(x_1, x_2) -> c2(ENCARG(x_2), ENCARG(x_1))
   ENCODE_MINUS(x_1, x_2) -> c3(ENCARG(x_2), ENCARG(x_1))
   ENCODE_DIV(x_1, x_2) -> c4(ENCARG(x_2), ENCARG(x_1))
   ENCODE_DIV(x_1, x_2) -> c5(ENCARG(x_2), ENCARG(x_1))
   ENCODE_S(x_1) -> c8(ENCARG(x_1))

----------------------------------------

(17)
Obligation:
Complexity Dependency Tuples Problem

Rules:none
Tuples:
   ENCARG(cons_div(x_1, x_2)) -> c(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_div(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_minus(x_1, x_2)) -> c6(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_minus(x_1, x_2)) -> c7(ENCARG(x_2), ENCARG(x_1))
   ENCARG(s(x_1)) -> c9(ENCARG(x_1))
S tuples:
   ENCARG(cons_div(x_1, x_2)) -> c(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_div(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_minus(x_1, x_2)) -> c6(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_minus(x_1, x_2)) -> c7(ENCARG(x_2), ENCARG(x_1))
   ENCARG(s(x_1)) -> c9(ENCARG(x_1))
K tuples:none
Defined Rule Symbols:   encArg_1, encode_div_2, encode_0, encode_s_1, encode_minus_2, minus_2, div_2

Defined Pair Symbols:   ENCARG_1

Compound Symbols:   c_2, c1_2, c6_2, c7_2, c9_1


----------------------------------------

(18) CdtToCpxRelTrsProof (BOTH BOUNDS(ID, ID))
Converted S to standard rules, and D \ S as well as R to relative rules.
----------------------------------------

(19)
Obligation:
The Runtime Complexity (innermost) of the given CpxTRS could be proven to be BOUNDS(1, n^1).


The TRS R consists of the following rules:

   ENCARG(cons_div(x_1, x_2)) -> c(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_div(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_minus(x_1, x_2)) -> c6(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_minus(x_1, x_2)) -> c7(ENCARG(x_2), ENCARG(x_1))
   ENCARG(s(x_1)) -> c9(ENCARG(x_1))

S is empty.
Rewrite Strategy: INNERMOST
----------------------------------------

(20) RelTrsToTrsProof (UPPER BOUND(ID))
transformed relative TRS to TRS
----------------------------------------

(21)
Obligation:
The Runtime Complexity (innermost) of the given CpxTRS could be proven to be BOUNDS(1, n^1).


The TRS R consists of the following rules:

   ENCARG(cons_div(x_1, x_2)) -> c(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_div(x_1, x_2)) -> c1(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_minus(x_1, x_2)) -> c6(ENCARG(x_2), ENCARG(x_1))
   ENCARG(cons_minus(x_1, x_2)) -> c7(ENCARG(x_2), ENCARG(x_1))
   ENCARG(s(x_1)) -> c9(ENCARG(x_1))

S is empty.
Rewrite Strategy: INNERMOST
----------------------------------------

(22) CpxTrsMatchBoundsTAProof (FINISHED)
A linear upper bound on the runtime complexity of the TRS R could be shown with a Match-Bound[TAB_LEFTLINEAR,TAB_NONLEFTLINEAR] (for contructor-based start-terms) of 1. 

The compatible tree automaton used to show the Match-Boundedness (for constructor-based start-terms) is represented by: 
final states : [1]
transitions: 
cons_div0(0, 0) -> 0
c0(0, 0) -> 0
c10(0, 0) -> 0
cons_minus0(0, 0) -> 0
c60(0, 0) -> 0
c70(0, 0) -> 0
s0(0) -> 0
c90(0) -> 0
ENCARG0(0) -> 1
ENCARG1(0) -> 2
ENCARG1(0) -> 3
c1(2, 3) -> 1
ENCARG1(0) -> 4
ENCARG1(0) -> 5
c11(4, 5) -> 1
ENCARG1(0) -> 6
ENCARG1(0) -> 7
c61(6, 7) -> 1
ENCARG1(0) -> 8
ENCARG1(0) -> 9
c71(8, 9) -> 1
ENCARG1(0) -> 10
c91(10) -> 1
c1(2, 3) -> 2
c1(2, 3) -> 3
c1(2, 3) -> 4
c1(2, 3) -> 5
c1(2, 3) -> 6
c1(2, 3) -> 7
c1(2, 3) -> 8
c1(2, 3) -> 9
c1(2, 3) -> 10
c11(4, 5) -> 2
c11(4, 5) -> 3
c11(4, 5) -> 4
c11(4, 5) -> 5
c11(4, 5) -> 6
c11(4, 5) -> 7
c11(4, 5) -> 8
c11(4, 5) -> 9
c11(4, 5) -> 10
c61(6, 7) -> 2
c61(6, 7) -> 3
c61(6, 7) -> 4
c61(6, 7) -> 5
c61(6, 7) -> 6
c61(6, 7) -> 7
c61(6, 7) -> 8
c61(6, 7) -> 9
c61(6, 7) -> 10
c71(8, 9) -> 2
c71(8, 9) -> 3
c71(8, 9) -> 4
c71(8, 9) -> 5
c71(8, 9) -> 6
c71(8, 9) -> 7
c71(8, 9) -> 8
c71(8, 9) -> 9
c71(8, 9) -> 10
c91(10) -> 2
c91(10) -> 3
c91(10) -> 4
c91(10) -> 5
c91(10) -> 6
c91(10) -> 7
c91(10) -> 8
c91(10) -> 9
c91(10) -> 10

----------------------------------------

(23)
BOUNDS(1, n^1)

----------------------------------------

(24)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(0) -> 1 : 0
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(cons_div(x_1, x_2)) -> 1 : div(encArg(x_1), encArg(x_2))
   encArg(cons_minus(x_1, x_2)) -> 1 : minus(encArg(x_1), encArg(x_2))
   encode_div(x_1, x_2) -> 1 : div(encArg(x_1), encArg(x_2))
   encode_0 -> 1 : 0
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_minus(x_1, x_2) -> 1 : minus(encArg(x_1), encArg(x_2))
   minus(x, x) -> 1 : 0
   minus(x, 0) -> 1 : x
   div(s(x), s(y)) -> 1 / 2 : s(div(minus(x, y), s(y))) || 1 / 2 : div(s(x), s(y))
   minus(s(x), s(y)) -> 1 : minus(x, y)
   div(0, s(x)) -> 1 : 0

Rules with annotation in P:

   ENCODE_DIV(x_1, x_2) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_MINUS(x_1, x_2) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_div(x_1, x_2)) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   DIV(s(x), s(y)) -> 1 / 2 : s(DIV(MINUS(x, y), s(y))) || 1 / 2 : DIV(s(x), s(y))

Rules with annotation in S:

   DIV(s(x), s(y)) -> 1 / 2 : s(DIV(MINUS(x, y), s(y))) || 1 / 2 : DIV(s(x), s(y))

Rules with annotation and a known complexity:

   ENCODE_DIV(x_1, x_2) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_MINUS(x_1, x_2) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_div(x_1, x_2)) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))


----------------------------------------

(25) CpxADP_UsableTermsProof (UPPER BOUND(ID))


The approximation of the Dependency Graph  gives us the following unusable Terms: 
   MINUS(encArg(x_1), encArg(x_2)), MINUS(x, y)
Hence, as part of the dependency graph processor, we can remove the annotations from these terms from every RHS of every ADP in P and S.

----------------------------------------

(26)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(0) -> 1 : 0
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(cons_div(x_1, x_2)) -> 1 : div(encArg(x_1), encArg(x_2))
   encArg(cons_minus(x_1, x_2)) -> 1 : minus(encArg(x_1), encArg(x_2))
   encode_div(x_1, x_2) -> 1 : div(encArg(x_1), encArg(x_2))
   encode_0 -> 1 : 0
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_minus(x_1, x_2) -> 1 : minus(encArg(x_1), encArg(x_2))
   minus(x, x) -> 1 : 0
   minus(x, 0) -> 1 : x
   div(s(x), s(y)) -> 1 / 2 : s(div(minus(x, y), s(y))) || 1 / 2 : div(s(x), s(y))
   minus(s(x), s(y)) -> 1 : minus(x, y)
   div(0, s(x)) -> 1 : 0

Rules with annotation in P:

   ENCARG(cons_div(x_1, x_2)) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_DIV(x_1, x_2) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_MINUS(x_1, x_2) -> 1 : minus(ENCARG(x_1), ENCARG(x_2))
   DIV(s(x), s(y)) -> 1 / 2 : s(DIV(minus(x, y), s(y))) || 1 / 2 : DIV(s(x), s(y))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : minus(ENCARG(x_1), ENCARG(x_2))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation in S:

   DIV(s(x), s(y)) -> 1 / 2 : s(DIV(minus(x, y), s(y))) || 1 / 2 : DIV(s(x), s(y))

Rules with annotation and a known complexity:

   ENCARG(cons_div(x_1, x_2)) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_DIV(x_1, x_2) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_MINUS(x_1, x_2) -> 1 : minus(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : minus(ENCARG(x_1), ENCARG(x_2))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))


----------------------------------------

(27) CpxADP_UsableRulesProof (BOTH BOUNDS(ID, ID))


We use the usable rules processor.
We can deactivate the flags for all non-usable rules [FROCOS05]

Rules which have been flagged as non usable in this step:

   encode_minus(x_1, x_2) -> 1 : minus(encArg(x_1), encArg(x_2))
   encode_0 -> 1 : 0
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_div(x_1, x_2) -> 1 : div(encArg(x_1), encArg(x_2))

----------------------------------------

(28)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   minus(x, x) -> 1 : 0
   minus(x, 0) -> 1 : x
   minus(s(x), s(y)) -> 1 : minus(x, y)
   encArg(0) -> 1 : 0
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(cons_div(x_1, x_2)) -> 1 : div(encArg(x_1), encArg(x_2))
   encArg(cons_minus(x_1, x_2)) -> 1 : minus(encArg(x_1), encArg(x_2))
   div(s(x), s(y)) -> 1 / 2 : s(div(minus(x, y), s(y))) || 1 / 2 : div(s(x), s(y))
   div(0, s(x)) -> 1 : 0

Rules with annotation in P:

   ENCARG(cons_div(x_1, x_2)) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_DIV(x_1, x_2) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_MINUS(x_1, x_2) -> 1 : minus(ENCARG(x_1), ENCARG(x_2))
   DIV(s(x), s(y)) -> 1 / 2 : s(DIV(minus(x, y), s(y))) || 1 / 2 : DIV(s(x), s(y))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : minus(ENCARG(x_1), ENCARG(x_2))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation in S:

   DIV(s(x), s(y)) -> 1 / 2 : s(DIV(minus(x, y), s(y))) || 1 / 2 : DIV(s(x), s(y))

Rules with annotation and a known complexity:

   ENCARG(cons_div(x_1, x_2)) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_DIV(x_1, x_2) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_MINUS(x_1, x_2) -> 1 : minus(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : minus(ENCARG(x_1), ENCARG(x_2))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))


----------------------------------------

(29) CpxADP_ReductionPairProof (UPPER BOUND(ADD(EXP)))


We use the reduction pair processor.
The following pairs can be oriented strictly and are moved from S:

   ENCARG(cons_div(x_1, x_2)) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_DIV(x_1, x_2) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_MINUS(x_1, x_2) -> 1 : minus(ENCARG(x_1), ENCARG(x_2))
   DIV(s(x), s(y)) -> 1 / 2 : s(DIV(minus(x, y), s(y))) || 1 / 2 : DIV(s(x), s(y))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

The remaining pairs can at least be oriented weakly:

   ENCARG(cons_minus(x_1, x_2)) -> 1 : minus(ENCARG(x_1), ENCARG(x_2))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))

Used ordering:Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(DIV(x_1, x_2)) = x_1 + x_2
   POL(ENCARG(x_1)) = 2*x_1
   POL(ENCODE_0) = 0
   POL(ENCODE_DIV(x_1, x_2)) = 10 + 5*x_1 + 5*x_2
   POL(ENCODE_MINUS(x_1, x_2)) = 4 + 10*x_1 + 8*x_2
   POL(ENCODE_S(x_1)) = 8*x_1
   POL(MINUS(x_1, x_2)) = 0
   POL(cons_div(x_1, x_2)) = 8 + 6*x_1 + 8*x_2
   POL(cons_minus(x_1, x_2)) = x_1 + x_2
   POL(div(x_1, x_2)) = x_1
   POL(encArg(x_1)) = 2*x_1
   POL(minus(x_1, x_2)) = x_1
   POL(s(x_1)) = 1 + x_1

The complexity of the removed ADPs is bounded by:EXP
----------------------------------------

(30)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   minus(x, x) -> 1 : 0
   minus(x, 0) -> 1 : x
   minus(s(x), s(y)) -> 1 : minus(x, y)
   encArg(0) -> 1 : 0
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(cons_div(x_1, x_2)) -> 1 : div(encArg(x_1), encArg(x_2))
   encArg(cons_minus(x_1, x_2)) -> 1 : minus(encArg(x_1), encArg(x_2))
   div(s(x), s(y)) -> 1 / 2 : s(div(minus(x, y), s(y))) || 1 / 2 : div(s(x), s(y))
   div(0, s(x)) -> 1 : 0

Rules with annotation in P:

   ENCARG(cons_div(x_1, x_2)) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_DIV(x_1, x_2) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_MINUS(x_1, x_2) -> 1 : minus(ENCARG(x_1), ENCARG(x_2))
   DIV(s(x), s(y)) -> 1 / 2 : s(DIV(minus(x, y), s(y))) || 1 / 2 : DIV(s(x), s(y))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : minus(ENCARG(x_1), ENCARG(x_2))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

Rules with annotation in S:

   none

Rules with annotation and a known complexity:

   ENCARG(cons_div(x_1, x_2)) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_DIV(x_1, x_2) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_MINUS(x_1, x_2) -> 1 : minus(ENCARG(x_1), ENCARG(x_2))
   DIV(s(x), s(y)) -> 1 / 2 : s(DIV(minus(x, y), s(y))) || 1 / 2 : DIV(s(x), s(y))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : minus(ENCARG(x_1), ENCARG(x_2))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))


----------------------------------------

(31) SisEmptyProof (FINISHED)


S contains no annotations anymore. Hence, there exists no P-CT with infinitely many S-Nodes.
Resulting upper bound: O(1)

----------------------------------------

(32)
BOUNDS(1, 1)

----------------------------------------

(33)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   encArg(0) -> 1 : 0
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(cons_div(x_1, x_2)) -> 1 : div(encArg(x_1), encArg(x_2))
   encArg(cons_minus(x_1, x_2)) -> 1 : minus(encArg(x_1), encArg(x_2))
   encode_div(x_1, x_2) -> 1 : div(encArg(x_1), encArg(x_2))
   encode_0 -> 1 : 0
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_minus(x_1, x_2) -> 1 : minus(encArg(x_1), encArg(x_2))
   minus(x, x) -> 1 : 0
   minus(x, 0) -> 1 : x
   div(s(x), s(y)) -> 1 / 2 : s(div(minus(x, y), s(y))) || 1 / 2 : div(s(x), s(y))
   minus(s(x), s(y)) -> 1 : minus(x, y)
   div(0, s(x)) -> 1 : 0

Rules with annotation in P:

   ENCODE_DIV(x_1, x_2) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_MINUS(x_1, x_2) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_div(x_1, x_2)) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   DIV(s(x), s(y)) -> 1 / 2 : s(DIV(MINUS(x, y), s(y))) || 1 / 2 : DIV(s(x), s(y))
   MINUS(s(x), s(y)) -> 1 : MINUS(x, y)

Rules with annotation in S:

   MINUS(s(x), s(y)) -> 1 : MINUS(x, y)

Rules with annotation and a known complexity:

   ENCODE_DIV(x_1, x_2) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_MINUS(x_1, x_2) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_div(x_1, x_2)) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   DIV(s(x), s(y)) -> 1 / 2 : s(DIV(MINUS(x, y), s(y))) || 1 / 2 : DIV(s(x), s(y))


----------------------------------------

(34) CpxADP_UsableRulesProof (BOTH BOUNDS(ID, ID))


We use the usable rules processor.
We can deactivate the flags for all non-usable rules [FROCOS05]

Rules which have been flagged as non usable in this step:

   encode_minus(x_1, x_2) -> 1 : minus(encArg(x_1), encArg(x_2))
   encode_0 -> 1 : 0
   encode_s(x_1) -> 1 : s(encArg(x_1))
   encode_div(x_1, x_2) -> 1 : div(encArg(x_1), encArg(x_2))

----------------------------------------

(35)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   minus(x, x) -> 1 : 0
   minus(x, 0) -> 1 : x
   minus(s(x), s(y)) -> 1 : minus(x, y)
   encArg(0) -> 1 : 0
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(cons_div(x_1, x_2)) -> 1 : div(encArg(x_1), encArg(x_2))
   encArg(cons_minus(x_1, x_2)) -> 1 : minus(encArg(x_1), encArg(x_2))
   div(s(x), s(y)) -> 1 / 2 : s(div(minus(x, y), s(y))) || 1 / 2 : div(s(x), s(y))
   div(0, s(x)) -> 1 : 0

Rules with annotation in P:

   ENCODE_DIV(x_1, x_2) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_MINUS(x_1, x_2) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_div(x_1, x_2)) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   DIV(s(x), s(y)) -> 1 / 2 : s(DIV(MINUS(x, y), s(y))) || 1 / 2 : DIV(s(x), s(y))
   MINUS(s(x), s(y)) -> 1 : MINUS(x, y)

Rules with annotation in S:

   MINUS(s(x), s(y)) -> 1 : MINUS(x, y)

Rules with annotation and a known complexity:

   ENCODE_DIV(x_1, x_2) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_MINUS(x_1, x_2) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_div(x_1, x_2)) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   DIV(s(x), s(y)) -> 1 / 2 : s(DIV(MINUS(x, y), s(y))) || 1 / 2 : DIV(s(x), s(y))


----------------------------------------

(36) CpxADP_ReductionPairProof (UPPER BOUND(ADD(EXP)))


We use the reduction pair processor.
The following pairs can be oriented strictly and are moved from S:

   ENCODE_DIV(x_1, x_2) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_MINUS(x_1, x_2) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   DIV(s(x), s(y)) -> 1 / 2 : s(DIV(MINUS(x, y), s(y))) || 1 / 2 : DIV(s(x), s(y))
   MINUS(s(x), s(y)) -> 1 : MINUS(x, y)
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))

The remaining pairs can at least be oriented weakly:

   ENCARG(cons_div(x_1, x_2)) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))

Used ordering:Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(DIV(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(ENCARG(x_1)) = 2*x_1
   POL(ENCODE_0) = 0
   POL(ENCODE_DIV(x_1, x_2)) = 9 + 4*x_1 + 5*x_2
   POL(ENCODE_MINUS(x_1, x_2)) = 10 + 7*x_1 + 3*x_2
   POL(ENCODE_S(x_1)) = 2*x_1
   POL(MINUS(x_1, x_2)) = x_1
   POL(cons_div(x_1, x_2)) = 4*x_1 + 8*x_2
   POL(cons_minus(x_1, x_2)) = 6 + 2*x_1 + 4*x_2
   POL(div(x_1, x_2)) = 2*x_1
   POL(encArg(x_1)) = x_1
   POL(minus(x_1, x_2)) = x_1
   POL(s(x_1)) = 1 + 2*x_1

The complexity of the removed ADPs is bounded by:EXP
----------------------------------------

(37)
Obligation:
Probabilistic extended ADP Problem:
The ADP Problem <P,S> contains following rules with active return value flag:

   minus(x, x) -> 1 : 0
   minus(x, 0) -> 1 : x
   minus(s(x), s(y)) -> 1 : minus(x, y)
   encArg(0) -> 1 : 0
   encArg(s(x_1)) -> 1 : s(encArg(x_1))
   encArg(cons_div(x_1, x_2)) -> 1 : div(encArg(x_1), encArg(x_2))
   encArg(cons_minus(x_1, x_2)) -> 1 : minus(encArg(x_1), encArg(x_2))
   div(s(x), s(y)) -> 1 / 2 : s(div(minus(x, y), s(y))) || 1 / 2 : div(s(x), s(y))
   div(0, s(x)) -> 1 : 0

Rules with annotation in P:

   ENCODE_DIV(x_1, x_2) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCODE_MINUS(x_1, x_2) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_div(x_1, x_2)) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   DIV(s(x), s(y)) -> 1 / 2 : s(DIV(MINUS(x, y), s(y))) || 1 / 2 : DIV(s(x), s(y))
   MINUS(s(x), s(y)) -> 1 : MINUS(x, y)

Rules with annotation in S:

   none

Rules with annotation and a known complexity:

   ENCARG(cons_div(x_1, x_2)) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_DIV(x_1, x_2) -> 1 : DIV(ENCARG(x_1), ENCARG(x_2))
   ENCODE_MINUS(x_1, x_2) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   ENCARG(cons_minus(x_1, x_2)) -> 1 : MINUS(ENCARG(x_1), ENCARG(x_2))
   DIV(s(x), s(y)) -> 1 / 2 : s(DIV(MINUS(x, y), s(y))) || 1 / 2 : DIV(s(x), s(y))
   MINUS(s(x), s(y)) -> 1 : MINUS(x, y)
   ENCODE_S(x_1) -> 1 : s(ENCARG(x_1))
   ENCARG(s(x_1)) -> 1 : s(ENCARG(x_1))


----------------------------------------

(38) SisEmptyProof (FINISHED)


S contains no annotations anymore. Hence, there exists no P-CT with infinitely many S-Nodes.
Resulting upper bound: O(1)

----------------------------------------

(39)
BOUNDS(1, 1)
