NO
proof of /hpcwork/ff862203/termcomp25/benchmarks/WdsGa.c
# AProVE Commit ID: 48c83ccb80d5f8312cb92f4aa1b51dc35e247e65 nils 20241118 unpublished


Termination of the given C Problem could be disproven:

(0) C Problem
(1) CToLLVMProof [EQUIVALENT, 17 ms]
(2) LLVM problem
(3) LLVMToTerminationGraphProof [EQUIVALENT, 111 ms]
(4) LLVM Symbolic Execution Graph
(5) SEGraph to IRS [EQUIVALENT, 56 ms]
(6) IntTRS
(7) IRSNoOverapproximation [EQUIVALENT, 0 ms]
(8) IntTRS
(9) IRSToKoat [EQUIVALENT, 0 ms]
(10) Koat Problem
(11) LoAT [COMPLETE, 1182 ms]
(12) NO


----------------------------------------

(0)
Obligation:
c file /hpcwork/ff862203/termcomp25/benchmarks/WdsGa.c
----------------------------------------

(1) CToLLVMProof (EQUIVALENT)
Compiled c-file /hpcwork/ff862203/termcomp25/benchmarks/WdsGa.c to LLVM.
----------------------------------------

(2)
Obligation:
LLVM Problem

Aliases:

Data layout:

"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"

Machine:

"x86_64-pc-linux-gnu"

Type definitions:

Global variables:

Function declarations and definitions:

*BasicFunctionTypename: "llvm.dbg.declare" returnParam: BasicVoidType parameters: (BasicMetadataType, BasicMetadataType, BasicMetadataType) variableLength: false visibilityType: DEFAULT callingConvention: ccc
*BasicFunctionTypename: "main" linkageType: EXTERNALLY_VISIBLE returnParam: i32 parameters: () variableLength: false visibilityType: DEFAULT callingConvention: ccc debug line: 7
	0:
		%1 = alloca i32, align 4
		%2 = alloca i32, align 4
		store 0, %1
		Unnamed Call-Instruction = call BasicVoidType @llvm.dbg.declare(*i32 %2)
		store 3, %2
		br %3
	3:
		%4 = load %2
		%5 = icmp sge %4 3
		br %5, %6, %23
	6:
		%7 = load %2
		%8 = icmp sgt %7 5
		br %8, %9, %12
	9:
		%10 = load %2
		%11 = add i32 %10, 3
		store %11, %2
		br %22
	12:
		%13 = load %2
		%14 = icmp sgt %13 10
		br %14, %15, %18
	15:
		%16 = load %2
		%17 = sub i32 %16, 2
		store %17, %2
		br %21
	18:
		%19 = load %2
		%20 = add i32 %19, 1
		store %20, %2
		br %21
	21:
		br %22
	22:
		br %3
	23:
		ret 0


Analyze Termination of all function calls matching the pattern:
main()
----------------------------------------

(3) LLVMToTerminationGraphProof (EQUIVALENT)
Constructed symbolic execution graph for LLVM program.
----------------------------------------

(4)
Obligation:
Symbolic Execution Graph
----------------------------------------

(5) SEGraph to IRS (EQUIVALENT)
Transformed LLVM symbolic execution graph SCC into a rewrite problem. Log: 
Generated rules. Obtained 62 rulesP rules:
f_93 -> f_94(v1, v2, 3, 1, 4) :|: 1 <= v1 && v2 = 3 + v1 && 4 <= v2
f_94(v1, v2, 3, 1, 4) -> f_95(v1, v3, v2, v4, 3, 1, 4) :|: 1 <= v3 && v4 = 3 + v3 && 4 <= v4
f_95(v1, v3, v2, v4, 3, 1, 4) -> f_96(v1, v3, v2, v4, 0, 3, 1, 4) :|: TRUE
f_96(v1, v3, v2, v4, 0, 3, 1, 4) -> f_97(v1, v3, v2, v4, 0, 3, 1, 4) :|: TRUE
f_97(v1, v3, v2, v4, 0, 3, 1, 4) -> f_98(v1, v3, v2, v4, 0, 3, 1, 4) :|: TRUE
f_98(v1, v3, v2, v4, 0, 3, 1, 4) -> f_99(v1, v3, v2, v4, 0, 3, 1, 4) :|: TRUE
f_99(v1, v3, v2, v4, 0, 3, 1, 4) -> f_100(v1, v3, 3, v2, v4, 0, 1, 4) :|: 0 = 0
f_100(v1, v3, 3, v2, v4, 0, 1, 4) -> f_101(v1, v3, 3, 1, v2, v4, 0, 4) :|: 0 = 0
f_101(v1, v3, 3, 1, v2, v4, 0, 4) -> f_102(v1, v3, 3, 1, v2, v4, 0, 4) :|: TRUE
f_102(v1, v3, 3, 1, v2, v4, 0, 4) -> f_103(v1, v3, 3, 1, v2, v4, 0, 4) :|: 0 = 0
f_103(v1, v3, 3, 1, v2, v4, 0, 4) -> f_104(v1, v3, 3, 1, 0, v2, v4, 4) :|: 0 = 0
f_104(v1, v3, 3, 1, 0, v2, v4, 4) -> f_105(v1, v3, 3, 1, 0, v2, v4, 4) :|: TRUE
f_105(v1, v3, 3, 1, 0, v2, v4, 4) -> f_106(v1, v3, 3, 1, 0, v2, v4, 4) :|: 0 = 0
f_106(v1, v3, 3, 1, 0, v2, v4, 4) -> f_107(v1, v3, 3, 1, 0, v2, v4, 4) :|: 0 = 0
f_107(v1, v3, 3, 1, 0, v2, v4, 4) -> f_108(v1, v3, 3, 1, 0, v2, v4, 4) :|: TRUE
f_108(v1, v3, 3, 1, 0, v2, v4, 4) -> f_109(v1, v3, 3, 1, 0, v2, v4, 4) :|: 0 = 0
f_109(v1, v3, 3, 1, 0, v2, v4, 4) -> f_110(v1, v3, 3, 1, 0, 4, v2, v4) :|: 0 = 0
f_110(v1, v3, 3, 1, 0, 4, v2, v4) -> f_111(v1, v3, 3, 1, 0, 4, v2, v4) :|: TRUE
f_111(v1, v3, 3, 1, 0, 4, v2, v4) -> f_112(v1, v3, 3, 1, 0, 4, v2, v4) :|: TRUE
f_112(v1, v3, 3, 1, 0, 4, v2, v4) -> f_113(v1, v3, 3, 1, 0, 4, v2, v4) :|: TRUE
f_113(v1, v3, 3, 1, 0, 4, v2, v4) -> f_114(v1, v3, 3, 1, 0, 4, v2, v4) :|: TRUE
f_114(v1, v3, 3, 1, 0, 4, v2, v4) -> f_130(v1, v3, 3, 1, 0, 4, v2, v4, 3, 4, 5) :|: TRUE
f_130(v5, v6, v7, 1, 0, v10, v11, v12, 3, 4, 5) -> f_146(v5, v6, v7, 1, 0, v10, v11, v12, 3, 5, 4, 6) :|: TRUE
f_146(v15, v16, v17, 1, 0, v20, v21, v22, 3, 5, 4, 6) -> f_147(v15, v16, v20, 1, v17, 0, v21, v22, 3, 5, 4, 6) :|: 0 = 0
f_147(v15, v16, v20, 1, v17, 0, v21, v22, 3, 5, 4, 6) -> f_148(v15, v16, v20, 1, v17, 0, v21, v22, 3, 5, 4, 6) :|: 0 = 0
f_148(v15, v16, v20, 1, v17, 0, v21, v22, 3, 5, 4, 6) -> f_149(v15, v16, v20, 1, v17, 0, v21, v22, 3, 5, 4, 6) :|: TRUE
f_149(v15, v16, v20, 1, v17, 0, v21, v22, 3, 5, 4, 6) -> f_150(v15, v16, v20, 1, 0, v17, v21, v22, 3, 5, 4, 6) :|: 0 = 0
f_150(v15, v16, v20, 1, 0, v17, v21, v22, 3, 5, 4, 6) -> f_151(v15, v16, 6, 1, 0, 5, v21, v22, 3, 4) :|: 5 < v20 && v17 = 5 && v20 = 6 && 0 = 0
f_150(v15, v16, v20, 1, 0, v17, v21, v22, 3, 5, 4, 6) -> f_152(v15, v16, v20, 1, 0, v17, v21, v22, 3, 4, 5) :|: v20 <= 5 && v17 <= 4
f_151(v15, v16, 6, 1, 0, 5, v21, v22, 3, 4) -> f_153(v15, v16, 6, 1, 5, 0, v21, v22, 3, 4) :|: 0 = 0
f_152(v15, v16, v20, 1, 0, v17, v21, v22, 3, 4, 5) -> f_154(v15, v16, v20, 1, 0, v17, v21, v22, 3, 4, 5) :|: 0 = 0
f_153(v15, v16, 6, 1, 5, 0, v21, v22, 3, 4) -> f_155(v15, v16, 6, 1, 5, 0, v21, v22, 3, 4) :|: TRUE
f_154(v15, v16, v20, 1, 0, v17, v21, v22, 3, 4, 5) -> f_156(v15, v16, v20, 1, 0, v17, v21, v22, 3, 4, 5) :|: TRUE
f_155(v15, v16, 6, 1, 5, 0, v21, v22, 3, 4) -> f_157(v15, v16, 6, 1, 5, 0, v21, v22, 3, 4) :|: 0 = 0
f_156(v15, v16, v20, 1, 0, v17, v21, v22, 3, 4, 5) -> f_158(v15, v16, v20, 1, 0, v17, v21, v22, 3, 4, 5) :|: 0 = 0
f_157(v15, v16, 6, 1, 5, 0, v21, v22, 3, 4) -> f_159(v15, v16, 6, 1, 5, 0, 9, v21, v22, 3, 4) :|: 0 = 0
f_158(v15, v16, v20, 1, 0, v17, v21, v22, 3, 4, 5) -> f_160(v15, v16, v20, 1, 0, v17, v21, v22, 3, 4, 5) :|: 0 = 0
f_159(v15, v16, 6, 1, 5, 0, 9, v21, v22, 3, 4) -> f_161(v15, v16, 6, 1, 5, 0, 9, v21, v22, 3, 4) :|: TRUE
f_160(v15, v16, v20, 1, 0, v17, v21, v22, 3, 4, 5) -> f_162(v15, v16, v20, 1, 0, v17, v21, v22, 3, 4, 5) :|: TRUE
f_161(v15, v16, 6, 1, 5, 0, 9, v21, v22, 3, 4) -> f_163(v15, v16, 6, 1, 5, 0, 9, v21, v22, 3, 4) :|: TRUE
f_162(v15, v16, v20, 1, 0, v17, v21, v22, 3, 4, 5) -> f_164(v15, v16, v20, 1, 0, v21, v22, 3, 4, 5) :|: 0 = 0
f_163(v15, v16, 6, 1, 5, 0, 9, v21, v22, 3, 4) -> f_181(v15, v16, 6, 1, 5, 0, 6, 9, v21, v22, 3, 9, 12, 4) :|: TRUE
f_164(v15, v16, v20, 1, 0, v21, v22, 3, 4, 5) -> f_166(v15, v16, v20, 1, 0, v27, v21, v22, 3, 4, 5, 6) :|: v27 = 1 + v20 && 5 <= v27 && v27 <= 6
f_166(v15, v16, v20, 1, 0, v27, v21, v22, 3, 4, 5, 6) -> f_168(v15, v16, v20, 1, 0, v27, v21, v22, 3, 4, 5, 6) :|: TRUE
f_168(v15, v16, v20, 1, 0, v27, v21, v22, 3, 4, 5, 6) -> f_170(v15, v16, v20, 1, 0, v27, v21, v22, 3, 4, 5, 6) :|: TRUE
f_170(v15, v16, v20, 1, 0, v27, v21, v22, 3, 4, 5, 6) -> f_172(v15, v16, v20, 1, 0, v27, v21, v22, 3, 4, 5, 6) :|: TRUE
f_172(v15, v16, v20, 1, 0, v27, v21, v22, 3, 4, 5, 6) -> f_174(v15, v16, v20, 1, 0, v27, v21, v22, 3, 4, 5, 6) :|: TRUE
f_174(v15, v16, v20, 1, 0, v27, v21, v22, 3, 4, 5, 6) -> f_146(v15, v16, v20, 1, 0, v27, v21, v22, 3, 5, 4, 6) :|: TRUE
f_181(v46, v47, v48, 1, 5, 0, 6, v53, v54, v55, 3, 9, 12, 4) -> f_193(v46, v47, v48, 1, 5, 0, 6, v53, v54, v55, 3, 12, 9, 15, 4) :|: TRUE
f_193(v70, v71, v72, 1, 5, 0, 6, v77, v78, v79, 3, 12, 9, 15, 4) -> f_205(v70, v71, v72, 1, 5, 0, 6, v77, v78, v79, 3, 9, 4) :|: TRUE
f_205(v90, v91, v92, 1, 5, 0, 6, v97, v98, v99, 3, 9, 4) -> f_206(v90, v91, v92, 1, 5, 0, 6, v97, v98, v99, 3, 9, 4) :|: TRUE
f_206(v90, v91, v92, 1, 5, 0, 6, v97, v98, v99, 3, 9, 4) -> f_207(v90, v91, v97, 1, v92, 5, 0, 6, v98, v99, 3, 9, 4) :|: 0 = 0
f_207(v90, v91, v97, 1, v92, 5, 0, 6, v98, v99, 3, 9, 4) -> f_208(v90, v91, v97, 1, v92, 5, 0, 6, v98, v99, 3, 9, 4) :|: 0 = 0
f_208(v90, v91, v97, 1, v92, 5, 0, 6, v98, v99, 3, 9, 4) -> f_209(v90, v91, v97, 1, v92, 5, 0, 6, v98, v99, 3, 9, 4) :|: TRUE
f_209(v90, v91, v97, 1, v92, 5, 0, 6, v98, v99, 3, 9, 4) -> f_210(v90, v91, v97, 1, 5, 0, 6, v92, v98, v99, 3, 9, 4) :|: 0 = 0
f_210(v90, v91, v97, 1, 5, 0, 6, v92, v98, v99, 3, 9, 4) -> f_211(v90, v91, v97, 1, 5, 0, 6, v92, v98, v99, 3, 9, 4) :|: 0 = 0
f_211(v90, v91, v97, 1, 5, 0, 6, v92, v98, v99, 3, 9, 4) -> f_212(v90, v91, v97, 1, 5, 0, 6, v92, v98, v99, 3, 9, 4) :|: TRUE
f_212(v90, v91, v97, 1, 5, 0, 6, v92, v98, v99, 3, 9, 4) -> f_213(v90, v91, v97, 1, 5, 0, 6, v98, v99, 3, 9, 4) :|: 0 = 0
f_213(v90, v91, v97, 1, 5, 0, 6, v98, v99, 3, 9, 4) -> f_214(v90, v91, v97, 1, 5, 0, 6, v104, v98, v99, 3, 9, 4, 12) :|: v104 = 3 + v97 && 12 <= v104
f_214(v90, v91, v97, 1, 5, 0, 6, v104, v98, v99, 3, 9, 4, 12) -> f_215(v90, v91, v97, 1, 5, 0, 6, v104, v98, v99, 3, 9, 4, 12) :|: TRUE
f_215(v90, v91, v97, 1, 5, 0, 6, v104, v98, v99, 3, 9, 4, 12) -> f_216(v90, v91, v97, 1, 5, 0, 6, v104, v98, v99, 3, 9, 4, 12) :|: TRUE
f_216(v90, v91, v97, 1, 5, 0, 6, v104, v98, v99, 3, 9, 4, 12) -> f_205(v90, v91, v97, 1, 5, 0, 6, v104, v98, v99, 3, 9, 4) :|: TRUE
Combined rules. Obtained 4 rulesP rules:
f_93 -> f_150(v1:0, v3:0, 4, 1, 0, 3, 3 + v1:0, 3 + v3:0, 3, 5, 4, 6) :|: v3:0 > 0 && v1:0 > 0
f_150(v15:0, v16:0, 6, 1, 0, 5, v21:0, v22:0, 3, 5, 4, 6) -> f_216(v15:0, v16:0, 9, 1, 5, 0, 6, 12, v21:0, v22:0, 3, 9, 4, 12) :|: TRUE
f_150(v15:0, v16:0, v20:0, 1, 0, v17:0, v21:0, v22:0, 3, 5, 4, 6) -> f_150(v15:0, v16:0, 1 + v20:0, 1, 0, v20:0, v21:0, v22:0, 3, 5, 4, 6) :|: v17:0 < 5 && v20:0 < 6 && v20:0 > 3
f_216(v90:0, v91:0, v97:0, 1, 5, 0, 6, v104:0, v98:0, v99:0, 3, 9, 4, 12) -> f_216(v90:0, v91:0, v104:0, 1, 5, 0, 6, 3 + v104:0, v98:0, v99:0, 3, 9, 4, 12) :|: v104:0 > 8
Filtered unneeded arguments:
   f_150(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12) -> f_150(x3, x6)
   f_216(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14) -> f_216(x8)
Removed division, modulo operations, cleaned up constraints. Obtained 4 rules.P rules:
f_93 -> f_150(4, 3) :|: TRUE
f_150(cons_6, cons_5) -> f_216(12) :|: TRUE && cons_6 = 6 && cons_5 = 5
f_150(v20:0, v17:0) -> f_150(1 + v20:0, v20:0) :|: v20:0 < 6 && v20:0 > 3 && v17:0 < 5
f_216(v104:0) -> f_216(3 + v104:0) :|: v104:0 > 8

----------------------------------------

(6)
Obligation:
Rules:
f_93 -> f_150(4, 3) :|: TRUE
f_150(cons_6, cons_5) -> f_216(12) :|: TRUE && cons_6 = 6 && cons_5 = 5
f_150(v20:0, v17:0) -> f_150(1 + v20:0, v20:0) :|: v20:0 < 6 && v20:0 > 3 && v17:0 < 5
f_216(v104:0) -> f_216(3 + v104:0) :|: v104:0 > 8
Start term: f_93

----------------------------------------

(7) IRSNoOverapproximation (EQUIVALENT)
Proof of non-termination can continue
----------------------------------------

(8)
Obligation:
Rules:
f_93 -> f_150(4, 3) :|: TRUE
f_150(cons_6, cons_5) -> f_216(12) :|: TRUE && cons_6 = 6 && cons_5 = 5
f_150(v20:0, v17:0) -> f_150(1 + v20:0, v20:0) :|: v20:0 < 6 && v20:0 > 3 && v17:0 < 5
f_216(v104:0) -> f_216(3 + v104:0) :|: v104:0 > 8
Start term: f_93

----------------------------------------

(9) IRSToKoat (EQUIVALENT)
Convert an IRS to a koat problem
----------------------------------------

(10)
Obligation:
(GOAL COMPLEXITY)
(STARTTERM (FUNCTIONSYMBOLS f_93))
(VAR x2 x' k0 x'' x k3 k4 x1 k1 k2)
(RULES
  f_150(k2, k4) -> f_216(12, x'') :|: 0 = 0 && k2 = 6 && k4 = 5
  f_150(k1, k0) -> f_150(1 + k1, k1) :|: k1 < 6 && k1 > 3 && k0 < 5
  f_216(k3, x1) -> f_216(3 + k3, x2) :|: k3 > 8
  f_93(x, x') -> f_150(4, 3) :|: 0 = 0
)

----------------------------------------

(11) LoAT (COMPLETE)
LoAT was called with the following command:

/aprove/bin/loat --plain --nonterm --proof-level 3 /tmp/aprove.InputModules.Programs.loat1328832585100781393.koat 

LoAT's output was:


### Pre-processing the ITS problem ###

Initial linear ITS problem
   Start location: f_93
      0: f_150 -> f_216 : k3'=12, x1'=free, [ 0==0 && k2==6 && k4==5 ], cost: 1
      1: f_150 -> f_150 : k2'=1+k2, k4'=k2, [ k2<6 && k2>3 && k4<5 ], cost: 1
      2: f_216 -> f_216 : k3'=3+k3, x1'=free_1, [ k3>8 ], cost: 1
      3: f_93 -> f_150 : k2'=4, k4'=3, [ 0==0 ], cost: 1

Checking for constant complexity:
   The following rule is satisfiable with cost >= 1, yielding constant complexity:
      3: f_93 -> f_150 : k2'=4, k4'=3, [ 0==0 ], cost: 1

Simplified all rules, resulting in:
   Start location: f_93
      0: f_150 -> f_216 : k3'=12, x1'=free, [ k2==6 && k4==5 ], cost: 1
      1: f_150 -> f_150 : k2'=1+k2, k4'=k2, [ k2<6 && k2>3 && k4<5 ], cost: 1
      2: f_216 -> f_216 : k3'=3+k3, x1'=free_1, [ k3>8 ], cost: 1
      3: f_93 -> f_150 : k2'=4, k4'=3, [], cost: 1

### Simplification by acceleration and chaining ###

Accelerating simple loops of location 0.
   Accelerating the following rules:
      1: f_150 -> f_150 : k2'=1+k2, k4'=k2, [ k2<6 && k2>3 && k4<5 ], cost: 1

[0;36m[test] deduced invariant 1-k2+k4<=0[0m
   Accelerated rule 1 with backward acceleration, yielding the new rule 4.
   Accelerated rule 1 with backward acceleration, yielding the new rule 5.
   Also removing duplicate rules: 4.

Accelerating simple loops of location 1.
   Accelerating the following rules:
      2: f_216 -> f_216 : k3'=3+k3, x1'=free_1, [ k3>8 ], cost: 1

   Accelerated rule 2 with non-termination, yielding the new rule 6.
   Removing the simple loops: 2.

Accelerated all simple loops using metering functions (where possible):
   Start location: f_93
      0: f_150 -> f_216 : k3'=12, x1'=free, [ k2==6 && k4==5 ], cost: 1
      1: f_150 -> f_150 : k2'=1+k2, k4'=k2, [ k2<6 && k2>3 && k4<5 ], cost: 1
      5: f_150 -> f_150 : k2'=6, k4'=5, [ k2>3 && 1-k2+k4<=0 && 6-k2>=1 ], cost: 6-k2
      6: f_216 -> [4] : [ k3>8 ], cost: NONTERM
      3: f_93 -> f_150 : k2'=4, k4'=3, [], cost: 1

Chaining 3 accelerated rules with incoming rules:
   Chained incoming rule 3 with accelerated rule 1 to new rule 7.
   Removing accelerated rule 1.
   Chained incoming rule 3 with accelerated rule 5 to new rule 8.
   Removing accelerated rule 5.
   Chained incoming rule 0 with accelerated rule 6 to new rule 9.
   Removing accelerated rule 6.

Chained accelerated rules (with incoming rules):
   Start location: f_93
      0: f_150 -> f_216 : k3'=12, x1'=free, [ k2==6 && k4==5 ], cost: 1
      9: f_150 -> [4] : [ k2==6 && k4==5 ], cost: NONTERM
      3: f_93 -> f_150 : k2'=4, k4'=3, [], cost: 1
      7: f_93 -> f_150 : k2'=5, k4'=4, [], cost: 2
      8: f_93 -> f_150 : k2'=6, k4'=5, [], cost: 3

Removed unreachable locations (and leaf rules with constant cost):
   Start location: f_93
      9: f_150 -> [4] : [ k2==6 && k4==5 ], cost: NONTERM
      3: f_93 -> f_150 : k2'=4, k4'=3, [], cost: 1
      7: f_93 -> f_150 : k2'=5, k4'=4, [], cost: 2
      8: f_93 -> f_150 : k2'=6, k4'=5, [], cost: 3

Eliminating location f_150 by chaining:
   Failed to chain rules 3 and 9.
   Failed to chain rules 7 and 9.
   Chained rules 8 and 9 to new rule 10.

Eliminated locations (on tree-shaped paths):
   Start location: f_93
     10: f_93 -> [4] : [], cost: NONTERM

### Computing asymptotic complexity ###

Fully simplified ITS problem
   Start location: f_93
     10: f_93 -> [4] : [], cost: NONTERM

Computing asymptotic complexity for rule 10
   Guard is satisfiable, yielding nontermination
   Resulting cost NONTERM has complexity: Nonterm

Found new complexity Nonterm.

Obtained the following overall complexity (w.r.t. the length of the input n):
   Complexity:  Nonterm
   Cpx degree:  Nonterm
   Solved cost: NONTERM
   Rule cost:   NONTERM
   Rule guard:  []

NO


The final guard is:


Z3 found a model for the final guard:
{}

Try to generate a witness via retracing LoAT's simplifications:
  AssertionError: null
No witness generated
----------------------------------------

(12)
NO
Graph finished, checking  consistency
Graph finished, checked consistency, took 0.001s
Truth value repropagation in proof tree changed value to NO
