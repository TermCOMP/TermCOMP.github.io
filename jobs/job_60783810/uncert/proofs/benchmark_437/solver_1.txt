NO
proof of /hpcwork/ff862203/termcomp25/benchmarks/UYJim.c
# AProVE Commit ID: 48c83ccb80d5f8312cb92f4aa1b51dc35e247e65 nils 20241118 unpublished


Termination of the given C Problem could be disproven:

(0) C Problem
(1) CToLLVMProof [EQUIVALENT, 18 ms]
(2) LLVM problem
(3) LLVMToTerminationGraphProof [EQUIVALENT, 196 ms]
(4) LLVM Symbolic Execution Graph
(5) SEGraph to IRS [EQUIVALENT, 47 ms]
(6) IntTRS
(7) IRSNoOverapproximation [EQUIVALENT, 0 ms]
(8) IntTRS
(9) IRSToKoat [EQUIVALENT, 0 ms]
(10) Koat Problem
(11) LoAT [COMPLETE, 2132 ms]
(12) NO


----------------------------------------

(0)
Obligation:
c file /hpcwork/ff862203/termcomp25/benchmarks/UYJim.c
----------------------------------------

(1) CToLLVMProof (EQUIVALENT)
Compiled c-file /hpcwork/ff862203/termcomp25/benchmarks/UYJim.c to LLVM.
----------------------------------------

(2)
Obligation:
LLVM Problem

Aliases:

Data layout:

"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"

Machine:

"x86_64-pc-linux-gnu"

Type definitions:

Global variables:

Function declarations and definitions:

*BasicFunctionTypename: "llvm.dbg.declare" returnParam: BasicVoidType parameters: (BasicMetadataType, BasicMetadataType, BasicMetadataType) variableLength: false visibilityType: DEFAULT callingConvention: ccc
*BasicFunctionTypename: "main" linkageType: EXTERNALLY_VISIBLE returnParam: i32 parameters: () variableLength: false visibilityType: DEFAULT callingConvention: ccc debug line: 7
	0:
		%1 = alloca i32, align 4
		%2 = alloca i32, align 4
		store 0, %1
		Unnamed Call-Instruction = call BasicVoidType @llvm.dbg.declare(*i32 %2)
		store 0, %2
		br %3
	3:
		%4 = load %2
		%5 = icmp slt %4 100
		br %5, %6, %16
	6:
		%7 = load %2
		%8 = icmp slt %7 50
		br %8, %9, %12
	9:
		%10 = load %2
		%11 = add i32 %10, 1
		store %11, %2
		br %15
	12:
		%13 = load %2
		%14 = sub i32 %13, 1
		store %14, %2
		br %15
	15:
		br %3
	16:
		ret 0


Analyze Termination of all function calls matching the pattern:
main()
----------------------------------------

(3) LLVMToTerminationGraphProof (EQUIVALENT)
Constructed symbolic execution graph for LLVM program.
----------------------------------------

(4)
Obligation:
Symbolic Execution Graph
----------------------------------------

(5) SEGraph to IRS (EQUIVALENT)
Transformed LLVM symbolic execution graph SCC into a rewrite problem. Log: 
Generated rules. Obtained 65 rulesP rules:
f_69 -> f_70(v1, v2, 3, 1, 4) :|: 1 <= v1 && v2 = 3 + v1 && 4 <= v2
f_70(v1, v2, 3, 1, 4) -> f_71(v1, v3, v2, v4, 3, 1, 4) :|: 1 <= v3 && v4 = 3 + v3 && 4 <= v4
f_71(v1, v3, v2, v4, 3, 1, 4) -> f_72(v1, v3, v2, v4, 0, 3, 1, 4) :|: TRUE
f_72(v1, v3, v2, v4, 0, 3, 1, 4) -> f_73(v1, v3, v2, v4, 0, 3, 1, 4) :|: TRUE
f_73(v1, v3, v2, v4, 0, 3, 1, 4) -> f_74(v1, v3, v2, v4, 0, 3, 1, 4) :|: TRUE
f_74(v1, v3, v2, v4, 0, 3, 1, 4) -> f_75(v1, v3, v2, v4, 0, 3, 1, 4) :|: TRUE
f_75(v1, v3, v2, v4, 0, 3, 1, 4) -> f_76(v1, v3, 0, v2, v4, 3, 1, 4) :|: 0 = 0
f_76(v1, v3, 0, v2, v4, 3, 1, 4) -> f_77(v1, v3, 0, 1, v2, v4, 3, 4) :|: 0 = 0
f_77(v1, v3, 0, 1, v2, v4, 3, 4) -> f_78(v1, v3, 0, 1, v2, v4, 3, 4) :|: TRUE
f_78(v1, v3, 0, 1, v2, v4, 3, 4) -> f_79(v1, v3, 0, 1, v2, v4, 3, 4) :|: 0 = 0
f_79(v1, v3, 0, 1, v2, v4, 3, 4) -> f_80(v1, v3, 0, 1, v2, v4, 3, 4) :|: 0 = 0
f_80(v1, v3, 0, 1, v2, v4, 3, 4) -> f_81(v1, v3, 0, 1, v2, v4, 3, 4) :|: TRUE
f_81(v1, v3, 0, 1, v2, v4, 3, 4) -> f_82(v1, v3, 0, 1, v2, v4, 3, 4) :|: 0 = 0
f_82(v1, v3, 0, 1, v2, v4, 3, 4) -> f_83(v1, v3, 0, 1, v2, v4, 3, 4) :|: 0 = 0
f_83(v1, v3, 0, 1, v2, v4, 3, 4) -> f_84(v1, v3, 0, 1, v2, v4, 3, 4) :|: TRUE
f_84(v1, v3, 0, 1, v2, v4, 3, 4) -> f_85(v1, v3, 0, 1, v2, v4, 3, 4) :|: TRUE
f_85(v1, v3, 0, 1, v2, v4, 3, 4) -> f_86(v1, v3, 0, 1, v2, v4, 3, 4) :|: TRUE
f_86(v1, v3, 0, 1, v2, v4, 3, 4) -> f_98(v1, v3, 0, 1, 1, v2, v4, 0, 3, 2, 4) :|: TRUE
f_98(v5, v6, v7, 1, v9, v10, v11, 0, 3, 2, 4) -> f_110(v5, v6, v7, 1, v9, v10, v11, 0, 3, 2, 4) :|: TRUE
f_110(v15, v16, v17, 1, v19, v20, v21, 0, 3, 2, 4) -> f_122(v15, v16, v17, 1, v19, v20, v21, 0, 3, 49, 50, 4) :|: TRUE
f_122(v25, v26, v27, 1, v29, v30, v31, 0, 3, 49, 50, 4) -> f_142(v25, v26, v27, 1, v29, v30, v31, 0, 3, 49, 50, 4) :|: TRUE
f_142(v37, v38, v39, 1, v41, v42, v43, 0, 3, 49, 50, 4) -> f_162(v37, v38, v39, 1, v41, v42, v43, 0, 3, 49, 50, 4) :|: TRUE
f_162(v49, v50, v51, 1, v53, v54, v55, 0, 3, 49, 50, 4) -> f_163(v49, v50, v53, 1, v51, v54, v55, 0, 3, 49, 50, 4) :|: 0 = 0
f_163(v49, v50, v53, 1, v51, v54, v55, 0, 3, 49, 50, 4) -> f_164(v49, v50, v53, 1, v51, v54, v55, 0, 3, 49, 50, 4) :|: 0 = 0
f_164(v49, v50, v53, 1, v51, v54, v55, 0, 3, 49, 50, 4) -> f_165(v49, v50, v53, 1, v51, v54, v55, 0, 3, 49, 50, 4) :|: TRUE
f_165(v49, v50, v53, 1, v51, v54, v55, 0, 3, 49, 50, 4) -> f_166(v49, v50, v53, 1, v51, v54, v55, 0, 3, 49, 50, 4) :|: 0 = 0
f_166(v49, v50, v53, 1, v51, v54, v55, 0, 3, 49, 50, 4) -> f_167(v49, v50, v53, 1, v51, v54, v55, 0, 3, 48, 49, 4) :|: v53 < 50 && v51 <= 48
f_166(v49, v50, v53, 1, v51, v54, v55, 0, 3, 49, 50, 4) -> f_168(v49, v50, 50, 1, 49, v54, v55, 0, 3, 4) :|: 50 <= v53 && v51 = 49 && v53 = 50 && 0 = 0
f_167(v49, v50, v53, 1, v51, v54, v55, 0, 3, 48, 49, 4) -> f_169(v49, v50, v53, 1, v51, v54, v55, 0, 3, 48, 49, 4) :|: 0 = 0
f_168(v49, v50, 50, 1, 49, v54, v55, 0, 3, 4) -> f_170(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) :|: 0 = 0
f_169(v49, v50, v53, 1, v51, v54, v55, 0, 3, 48, 49, 4) -> f_171(v49, v50, v53, 1, v51, v54, v55, 0, 3, 48, 49, 4) :|: TRUE
f_170(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) -> f_172(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) :|: TRUE
f_171(v49, v50, v53, 1, v51, v54, v55, 0, 3, 48, 49, 4) -> f_173(v49, v50, v53, 1, v54, v55, 0, 3, 49, 4) :|: 0 = 0
f_172(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) -> f_174(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) :|: 0 = 0
f_173(v49, v50, v53, 1, v54, v55, 0, 3, 49, 4) -> f_175(v49, v50, v53, 1, v57, v54, v55, 0, 3, 49, 4, 2, 50) :|: v57 = 1 + v53 && 2 <= v57 && v57 <= 50
f_174(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) -> f_176(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) :|: 0 = 0
f_175(v49, v50, v53, 1, v57, v54, v55, 0, 3, 49, 4, 2, 50) -> f_177(v49, v50, v53, 1, v57, v54, v55, 0, 3, 49, 4, 2, 50) :|: TRUE
f_176(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) -> f_178(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) :|: TRUE
f_177(v49, v50, v53, 1, v57, v54, v55, 0, 3, 49, 4, 2, 50) -> f_179(v49, v50, v53, 1, v57, v54, v55, 0, 3, 49, 4, 2, 50) :|: TRUE
f_178(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) -> f_180(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) :|: TRUE
f_179(v49, v50, v53, 1, v57, v54, v55, 0, 3, 49, 4, 2, 50) -> f_181(v49, v50, v53, 1, v57, v54, v55, 0, 3, 49, 4, 2, 50) :|: TRUE
f_180(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) -> f_182(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) :|: TRUE
f_181(v49, v50, v53, 1, v57, v54, v55, 0, 3, 49, 4, 2, 50) -> f_162(v49, v50, v53, 1, v57, v54, v55, 0, 3, 49, 50, 4) :|: TRUE
f_182(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) -> f_183(v49, v50, 49, 1, 50, 0, v54, v55, 3, 4) :|: 0 = 0
f_183(v49, v50, 49, 1, 50, 0, v54, v55, 3, 4) -> f_184(v49, v50, 49, 1, 50, 0, v54, v55, 3, 4) :|: 0 = 0
f_184(v49, v50, 49, 1, 50, 0, v54, v55, 3, 4) -> f_185(v49, v50, 49, 1, 50, 0, v54, v55, 3, 4) :|: TRUE
f_185(v49, v50, 49, 1, 50, 0, v54, v55, 3, 4) -> f_186(v49, v50, 49, 1, 0, 50, v54, v55, 3, 4) :|: 0 = 0
f_186(v49, v50, 49, 1, 0, 50, v54, v55, 3, 4) -> f_187(v49, v50, 49, 1, 50, v54, v55, 0, 3, 4) :|: 0 = 0
f_187(v49, v50, 49, 1, 50, v54, v55, 0, 3, 4) -> f_188(v49, v50, 49, 1, 50, v54, v55, 0, 3, 4) :|: TRUE
f_188(v49, v50, 49, 1, 50, v54, v55, 0, 3, 4) -> f_189(v49, v50, 49, 1, 50, v54, v55, 0, 3, 4) :|: 0 = 0
f_189(v49, v50, 49, 1, 50, v54, v55, 0, 3, 4) -> f_190(v49, v50, 49, 1, 50, v54, v55, 0, 3, 4) :|: 0 = 0
f_190(v49, v50, 49, 1, 50, v54, v55, 0, 3, 4) -> f_191(v49, v50, 49, 1, 50, v54, v55, 0, 3, 4) :|: TRUE
f_191(v49, v50, 49, 1, 50, v54, v55, 0, 3, 4) -> f_192(v49, v50, 49, 1, 50, v54, v55, 0, 3, 4) :|: TRUE
f_192(v49, v50, 49, 1, 50, v54, v55, 0, 3, 4) -> f_193(v49, v50, 49, 1, 50, v54, v55, 0, 3, 4) :|: TRUE
f_193(v49, v50, 49, 1, 50, v54, v55, 0, 3, 4) -> f_194(v49, v50, 50, 1, 49, v54, v55, 0, 3, 4) :|: 0 = 0
f_194(v49, v50, 50, 1, 49, v54, v55, 0, 3, 4) -> f_195(v49, v50, 50, 1, 49, v54, v55, 0, 3, 4) :|: 0 = 0
f_195(v49, v50, 50, 1, 49, v54, v55, 0, 3, 4) -> f_196(v49, v50, 50, 1, 49, v54, v55, 0, 3, 4) :|: TRUE
f_196(v49, v50, 50, 1, 49, v54, v55, 0, 3, 4) -> f_197(v49, v50, 50, 1, 49, v54, v55, 0, 3, 4) :|: 0 = 0
f_197(v49, v50, 50, 1, 49, v54, v55, 0, 3, 4) -> f_198(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) :|: 0 = 0
f_198(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) -> f_199(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) :|: TRUE
f_199(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) -> f_200(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) :|: 0 = 0
f_200(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) -> f_201(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) :|: 0 = 0
f_201(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) -> f_202(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) :|: TRUE
f_202(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) -> f_203(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) :|: TRUE
f_203(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) -> f_180(v49, v50, 50, 1, 0, 49, v54, v55, 3, 4) :|: TRUE
Combined rules. Obtained 4 rulesP rules:
f_203(v49:0, v50:0, 50, 1, 0, 49, v54:0, v55:0, 3, 4) -> f_203(v49:0, v50:0, 50, 1, 0, 49, v54:0, v55:0, 3, 4) :|: TRUE
f_69 -> f_166(v1:0, v3:0, 1, 1, 0, 3 + v1:0, 3 + v3:0, 0, 3, 49, 50, 4) :|: v3:0 > 0 && v1:0 > 0
f_166(v49:0, v50:0, v53:0, 1, v51:0, v54:0, v55:0, 0, 3, 49, 50, 4) -> f_166(v49:0, v50:0, 1 + v53:0, 1, v53:0, v54:0, v55:0, 0, 3, 49, 50, 4) :|: v51:0 < 49 && v53:0 < 50 && v53:0 > 0
f_166(v49:0, v50:0, 50, 1, 49, v54:0, v55:0, 0, 3, 49, 50, 4) -> f_203(v49:0, v50:0, 50, 1, 0, 49, v54:0, v55:0, 3, 4) :|: TRUE
Filtered unneeded arguments:
   f_166(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12) -> f_166(x3, x5)
Removed division, modulo operations, cleaned up constraints. Obtained 4 rules.P rules:
f_203(v49:0, v50:0, cons_50, cons_1, cons_0, cons_49, v54:0, v55:0, cons_3, cons_4) -> f_203(v49:0, v50:0, 50, 1, 0, 49, v54:0, v55:0, 3, 4) :|: TRUE && cons_50 = 50 && cons_1 = 1 && cons_0 = 0 && cons_49 = 49 && cons_3 = 3 && cons_4 = 4
f_69 -> f_166(1, 0) :|: TRUE
f_166(v53:0, v51:0) -> f_166(1 + v53:0, v53:0) :|: v53:0 < 50 && v53:0 > 0 && v51:0 < 49
f_166(cons_50, cons_49) -> f_203(v49:0, v50:0, 50, 1, 0, 49, v54:0, v55:0, 3, 4) :|: TRUE && cons_50 = 50 && cons_49 = 49

----------------------------------------

(6)
Obligation:
Rules:
f_203(v49:0, v50:0, cons_50, cons_1, cons_0, cons_49, v54:0, v55:0, cons_3, cons_4) -> f_203(v49:0, v50:0, 50, 1, 0, 49, v54:0, v55:0, 3, 4) :|: TRUE && cons_50 = 50 && cons_1 = 1 && cons_0 = 0 && cons_49 = 49 && cons_3 = 3 && cons_4 = 4
f_69 -> f_166(1, 0) :|: TRUE
f_166(v53:0, v51:0) -> f_166(1 + v53:0, v53:0) :|: v53:0 < 50 && v53:0 > 0 && v51:0 < 49
f_166(x, x1) -> f_203(x2, x3, 50, 1, 0, 49, x4, x5, 3, 4) :|: TRUE && x = 50 && x1 = 49
Start term: f_69

----------------------------------------

(7) IRSNoOverapproximation (EQUIVALENT)
Proof of non-termination can continue
----------------------------------------

(8)
Obligation:
Rules:
f_203(v49:0, v50:0, cons_50, cons_1, cons_0, cons_49, v54:0, v55:0, cons_3, cons_4) -> f_203(v49:0, v50:0, 50, 1, 0, 49, v54:0, v55:0, 3, 4) :|: TRUE && cons_50 = 50 && cons_1 = 1 && cons_0 = 0 && cons_49 = 49 && cons_3 = 3 && cons_4 = 4
f_69 -> f_166(1, 0) :|: TRUE
f_166(v53:0, v51:0) -> f_166(1 + v53:0, v53:0) :|: v53:0 < 50 && v53:0 > 0 && v51:0 < 49
f_166(x, x1) -> f_203(x2, x3, 50, 1, 0, 49, x4, x5, 3, 4) :|: TRUE && x = 50 && x1 = 49
Start term: f_69

----------------------------------------

(9) IRSToKoat (EQUIVALENT)
Convert an IRS to a koat problem
----------------------------------------

(10)
Obligation:
(GOAL COMPLEXITY)
(STARTTERM (FUNCTIONSYMBOLS f_69))
(VAR x x39 x35 x36 x37 x38 x31 x32 x'' x33 x34 x30 k14 k15 k16 k17 k10 k11 k12 k13 x4 x28 x5 x29 x2 x3 x8 x24 x9 x25 x6 x26 x7 x27 x20 x21 x22 x23 x1 k7 k8 k5 k6 k9 x' k0 k3 k4 k1 k2 x17 x18 x19 x13 x14 x15 x16 x10 x11 x12)
(RULES
  f_166(k6, k0, x24, x25, x26, x27, x28, x29, x30, x31) -> f_166(1 + k6, k6, x32, x33, x34, x35, x36, x37, x38, x39) :|: k6 < 50 && k6 > 0 && k0 < 49
  f_203(k9, k2, k1, k7, k5, k11, k8, k3, k4, k10) -> f_203(k9, k2, 50, 1, 0, 49, k8, k3, 3, 4) :|: 0 = 0 && k1 = 50 && k7 = 1 && k5 = 0 && k11 = 49 && k4 = 3 && k10 = 4
  f_166(k16, k17, x, x', x'', x1, x2, x3, x4, x5) -> f_203(k14, k15, 50, 1, 0, 49, k12, k13, 3, 4) :|: 0 = 0 && k16 = 50 && k17 = 49
  f_69(x6, x7, x8, x9, x10, x11, x12, x13, x14, x15) -> f_166(1, 0, x16, x17, x18, x19, x20, x21, x22, x23) :|: 0 = 0
)

----------------------------------------

(11) LoAT (COMPLETE)
LoAT was called with the following command:

/aprove/bin/loat --plain --nonterm --proof-level 3 /tmp/aprove.InputModules.Programs.loat16472532567252799171.koat 

LoAT's output was:


### Pre-processing the ITS problem ###

Initial linear ITS problem
   Start location: f_69
      0: f_166 -> f_166 : k0'=k6, k6'=1+k6, x24'=free, x25'=free_3, x26'=free_5, x27'=free_7, x28'=free_2, x29'=free_4, x30'=free_6, x31'=free_1, [ k6<50 && k6>0 && k0<49 ], cost: 1
      2: f_166 -> f_203 : k1'=50, k10'=4, k11'=49, k2'=free_10, k3'=free_8, k4'=3, k5'=0, k7'=1, k8'=free_11, k9'=free_9, [ 0==0 && k6==50 && k0==49 ], cost: 1
      1: f_203 -> f_203 : k1'=50, k10'=4, k11'=49, k4'=3, k5'=0, k7'=1, [ 0==0 && k1==50 && k7==1 && k5==0 && k11==49 && k4==3 && k10==4 ], cost: 1
      3: f_69 -> f_166 : k0'=0, k6'=1, x24'=free_13, x25'=free_17, x26'=free_12, x27'=free_15, x28'=free_19, x29'=free_14, x30'=free_16, x31'=free_18, [ 0==0 ], cost: 1

Checking for constant complexity:
   The following rule is satisfiable with cost >= 1, yielding constant complexity:
      3: f_69 -> f_166 : k0'=0, k6'=1, x24'=free_13, x25'=free_17, x26'=free_12, x27'=free_15, x28'=free_19, x29'=free_14, x30'=free_16, x31'=free_18, [ 0==0 ], cost: 1

Simplified all rules, resulting in:
   Start location: f_69
      0: f_166 -> f_166 : k0'=k6, k6'=1+k6, x24'=free, x25'=free_3, x26'=free_5, x27'=free_7, x28'=free_2, x29'=free_4, x30'=free_6, x31'=free_1, [ k6<50 && k6>0 && k0<49 ], cost: 1
      2: f_166 -> f_203 : k1'=50, k10'=4, k11'=49, k2'=free_10, k3'=free_8, k4'=3, k5'=0, k7'=1, k8'=free_11, k9'=free_9, [ k6==50 && k0==49 ], cost: 1
      1: f_203 -> f_203 : k1'=50, k10'=4, k11'=49, k4'=3, k5'=0, k7'=1, [ k1==50 && k7==1 && k5==0 && k11==49 && k4==3 && k10==4 ], cost: 1
      3: f_69 -> f_166 : k0'=0, k6'=1, x24'=free_13, x25'=free_17, x26'=free_12, x27'=free_15, x28'=free_19, x29'=free_14, x30'=free_16, x31'=free_18, [], cost: 1

### Simplification by acceleration and chaining ###

Accelerating simple loops of location 0.
   Accelerating the following rules:
      0: f_166 -> f_166 : k0'=k6, k6'=1+k6, x24'=free, x25'=free_3, x26'=free_5, x27'=free_7, x28'=free_2, x29'=free_4, x30'=free_6, x31'=free_1, [ k6<50 && k6>0 && k0<49 ], cost: 1

[0;36m[test] deduced invariant 1+k0-k6<=0[0m
   Accelerated rule 0 with backward acceleration, yielding the new rule 4.
   Accelerated rule 0 with backward acceleration, yielding the new rule 5.
   Also removing duplicate rules: 4.

Accelerating simple loops of location 1.
   Accelerating the following rules:
      1: f_203 -> f_203 : k1'=50, k10'=4, k11'=49, k4'=3, k5'=0, k7'=1, [ k1==50 && k7==1 && k5==0 && k11==49 && k4==3 && k10==4 ], cost: 1

   Accelerated rule 1 with non-termination, yielding the new rule 6.
   Removing the simple loops: 1.

Accelerated all simple loops using metering functions (where possible):
   Start location: f_69
      0: f_166 -> f_166 : k0'=k6, k6'=1+k6, x24'=free, x25'=free_3, x26'=free_5, x27'=free_7, x28'=free_2, x29'=free_4, x30'=free_6, x31'=free_1, [ k6<50 && k6>0 && k0<49 ], cost: 1
      2: f_166 -> f_203 : k1'=50, k10'=4, k11'=49, k2'=free_10, k3'=free_8, k4'=3, k5'=0, k7'=1, k8'=free_11, k9'=free_9, [ k6==50 && k0==49 ], cost: 1
      5: f_166 -> f_166 : k0'=49, k6'=50, x24'=free, x25'=free_3, x26'=free_5, x27'=free_7, x28'=free_2, x29'=free_4, x30'=free_6, x31'=free_1, [ k6>0 && 1+k0-k6<=0 && 50-k6>=1 ], cost: 50-k6
      6: f_203 -> [4] : [ k1==50 && k7==1 && k5==0 && k11==49 && k4==3 && k10==4 ], cost: NONTERM
      3: f_69 -> f_166 : k0'=0, k6'=1, x24'=free_13, x25'=free_17, x26'=free_12, x27'=free_15, x28'=free_19, x29'=free_14, x30'=free_16, x31'=free_18, [], cost: 1

Chaining 3 accelerated rules with incoming rules:
   Chained incoming rule 3 with accelerated rule 0 to new rule 7.
   Removing accelerated rule 0.
   Chained incoming rule 3 with accelerated rule 5 to new rule 8.
   Removing accelerated rule 5.
   Chained incoming rule 2 with accelerated rule 6 to new rule 9.
   Removing accelerated rule 6.

Chained accelerated rules (with incoming rules):
   Start location: f_69
      2: f_166 -> f_203 : k1'=50, k10'=4, k11'=49, k2'=free_10, k3'=free_8, k4'=3, k5'=0, k7'=1, k8'=free_11, k9'=free_9, [ k6==50 && k0==49 ], cost: 1
      9: f_166 -> [4] : [ k6==50 && k0==49 ], cost: NONTERM
      3: f_69 -> f_166 : k0'=0, k6'=1, x24'=free_13, x25'=free_17, x26'=free_12, x27'=free_15, x28'=free_19, x29'=free_14, x30'=free_16, x31'=free_18, [], cost: 1
      7: f_69 -> f_166 : k0'=1, k6'=2, x24'=free, x25'=free_3, x26'=free_5, x27'=free_7, x28'=free_2, x29'=free_4, x30'=free_6, x31'=free_1, [], cost: 2
      8: f_69 -> f_166 : k0'=49, k6'=50, x24'=free, x25'=free_3, x26'=free_5, x27'=free_7, x28'=free_2, x29'=free_4, x30'=free_6, x31'=free_1, [], cost: 50

Removed unreachable locations (and leaf rules with constant cost):
   Start location: f_69
      9: f_166 -> [4] : [ k6==50 && k0==49 ], cost: NONTERM
      3: f_69 -> f_166 : k0'=0, k6'=1, x24'=free_13, x25'=free_17, x26'=free_12, x27'=free_15, x28'=free_19, x29'=free_14, x30'=free_16, x31'=free_18, [], cost: 1
      7: f_69 -> f_166 : k0'=1, k6'=2, x24'=free, x25'=free_3, x26'=free_5, x27'=free_7, x28'=free_2, x29'=free_4, x30'=free_6, x31'=free_1, [], cost: 2
      8: f_69 -> f_166 : k0'=49, k6'=50, x24'=free, x25'=free_3, x26'=free_5, x27'=free_7, x28'=free_2, x29'=free_4, x30'=free_6, x31'=free_1, [], cost: 50

Eliminating location f_166 by chaining:
   Failed to chain rules 3 and 9.
   Failed to chain rules 7 and 9.
   Chained rules 8 and 9 to new rule 10.

Eliminated locations (on tree-shaped paths):
   Start location: f_69
     10: f_69 -> [4] : [], cost: NONTERM

### Computing asymptotic complexity ###

Fully simplified ITS problem
   Start location: f_69
     10: f_69 -> [4] : [], cost: NONTERM

Computing asymptotic complexity for rule 10
   Guard is satisfiable, yielding nontermination
   Resulting cost NONTERM has complexity: Nonterm

Found new complexity Nonterm.

Obtained the following overall complexity (w.r.t. the length of the input n):
   Complexity:  Nonterm
   Cpx degree:  Nonterm
   Solved cost: NONTERM
   Rule cost:   NONTERM
   Rule guard:  []

NO


The final guard is:


Z3 found a model for the final guard:
{}

Try to generate a witness via retracing LoAT's simplifications:
  AssertionError: null
No witness generated
----------------------------------------

(12)
NO
Graph finished, checking  consistency
Graph finished, checked consistency, took 0.001s
Truth value repropagation in proof tree changed value to NO
