MAYBE
proof of /hpcwork/ff862203/termcomp25/benchmarks/x1dc7.c
# AProVE Commit ID: 48c83ccb80d5f8312cb92f4aa1b51dc35e247e65 nils 20241118 unpublished


Termination of the given C Problem could not be shown:

(0) C Problem
(1) CToLLVMProof [EQUIVALENT, 18 ms]
(2) LLVM problem
(3) CToIRSProof [EQUIVALENT, 0 ms]
(4) IntTRS
    (5) TerminationGraphProcessor [SOUND, 36 ms]
    (6) IntTRS
    (7) IntTRSCompressionProof [EQUIVALENT, 15 ms]
    (8) IntTRS
    (9) PolynomialOrderProcessor [EQUIVALENT, 12 ms]
    (10) IntTRS
    (11) TerminationGraphProcessor [EQUIVALENT, 22 ms]
    (12) IntTRS
    (13) IntTRSCompressionProof [EQUIVALENT, 0 ms]
    (14) IntTRS
    (15) IntTRSNonPeriodicNontermProof [COMPLETE, 2 ms]
    (16) NO


----------------------------------------

(0)
Obligation:
c file /hpcwork/ff862203/termcomp25/benchmarks/x1dc7.c
----------------------------------------

(1) CToLLVMProof (EQUIVALENT)
Compiled c-file /hpcwork/ff862203/termcomp25/benchmarks/x1dc7.c to LLVM.
----------------------------------------

(2)
Obligation:
LLVM Problem

Aliases:

Data layout:

"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"

Machine:

"x86_64-pc-linux-gnu"

Type definitions:

Global variables:

Function declarations and definitions:

*BasicFunctionTypename: "llvm.dbg.declare" returnParam: BasicVoidType parameters: (BasicMetadataType, BasicMetadataType, BasicMetadataType) variableLength: false visibilityType: DEFAULT callingConvention: ccc
*BasicFunctionTypename: "__VERIFIER_nondet_int" returnParam: i32 parameters: () variableLength: false visibilityType: DEFAULT callingConvention: ccc
*BasicFunctionTypename: "main" linkageType: EXTERNALLY_VISIBLE returnParam: i32 parameters: () variableLength: false visibilityType: DEFAULT callingConvention: ccc debug line: 7
	0:
		%1 = alloca i32, align 4
		%2 = alloca i32, align 4
		%3 = alloca i32, align 4
		store 0, %1
		Unnamed Call-Instruction = call BasicVoidType @llvm.dbg.declare(*i32 %2)
		Unnamed Call-Instruction = call BasicVoidType @llvm.dbg.declare(*i32 %3)
		%4 = call i32 @__VERIFIER_nondet_int()
		store %4, %2
		%5 = load %2
		store %5, %3
		br %6
	6:
		%7 = load %2
		%8 = icmp sgt %7 0
		br %8, %9, %70
	9:
		%10 = load %2
		%11 = load %3
		%12 = icmp sge %10 %11
		br %12, %13, %36
	13:
		%14 = load %2
		%15 = add i32 %14, 1
		store %15, %2
		%16 = load %3
		%17 = icmp slt %16 5
		br %17, %18, %32
	18:
		%19 = load %3
		%20 = add i32 %19, 1
		store %20, %3
		%21 = load %2
		%22 = load %3
		%23 = sub i32 %21, %22
		%24 = icmp sgt %23 2
		br %24, %25, %28
	25:
		%26 = load %2
		%27 = add i32 %26, 1
		store %27, %2
		br %31
	28:
		%29 = load %3
		%30 = add i32 %29, 1
		store %30, %3
		br %31
	31:
		br %35
	32:
		%33 = load %3
		%34 = sub i32 %33, 1
		store %34, %3
		br %35
	35:
		br %69
	36:
		%37 = load %2
		%38 = icmp sgt %37 0
		br %38, %39, %54
	39:
		%40 = load %3
		%41 = icmp slt %40 0
		br %41, %42, %54
	42:
		%43 = load %2
		%44 = sub i32 %43, 1
		store %44, %2
		%45 = load %3
		%46 = icmp slt %45 -1
		br %46, %47, %50
	47:
		%48 = load %3
		%49 = add i32 %48, 1
		store %49, %3
		br %53
	50:
		%51 = load %2
		%52 = add i32 %51, 1
		store %52, %2
		br %53
	53:
		br %68
	54:
		%55 = load %2
		%56 = add i32 %55, 1
		store %56, %2
		%57 = load %3
		%58 = mul i32 %57, 2
		%59 = load %2
		%60 = icmp sgt %58 %59
		br %60, %61, %64
	61:
		%62 = load %3
		%63 = sub i32 %62, 1
		store %63, %3
		br %67
	64:
		%65 = load %3
		%66 = add i32 %65, 1
		store %66, %3
		br %67
	67:
		br %68
	68:
		br %69
	69:
		br %6
	70:
		ret 0


Analyze Termination of all function calls matching the pattern:
main()
----------------------------------------

(3) CToIRSProof (EQUIVALENT)
Parsed C Integer Program as IRS.
----------------------------------------

(4)
Obligation:
Rules:
f1(i, j) -> f2(x_1, j) :|: TRUE
f2(x, x1) -> f3(x, x) :|: TRUE
f5(x2, x3) -> f8(arith, x3) :|: TRUE && arith = x2 + 1
f9(x78, x79) -> f12(x78, x80) :|: TRUE && x80 = x79 + 1
f13(x81, x82) -> f16(x83, x82) :|: TRUE && x83 = x81 + 1
f14(x84, x85) -> f17(x84, x86) :|: TRUE && x86 = x85 + 1
f12(x10, x11) -> f13(x10, x11) :|: x10 - x11 > 2
f12(x12, x13) -> f14(x12, x13) :|: x12 - x13 <= 2
f16(x14, x15) -> f15(x14, x15) :|: TRUE
f17(x16, x17) -> f15(x16, x17) :|: TRUE
f10(x87, x88) -> f18(x87, x89) :|: TRUE && x89 = x88 - 1
f8(x20, x21) -> f9(x20, x21) :|: x21 < 5
f8(x22, x23) -> f10(x22, x23) :|: x23 >= 5
f15(x24, x25) -> f11(x24, x25) :|: TRUE
f18(x26, x27) -> f11(x26, x27) :|: TRUE
f19(x90, x91) -> f22(x92, x91) :|: TRUE && x92 = x90 - 1
f23(x93, x94) -> f26(x93, x95) :|: TRUE && x95 = x94 + 1
f24(x96, x97) -> f27(x98, x97) :|: TRUE && x98 = x96 + 1
f22(x34, x35) -> f23(x34, x35) :|: x35 < 0 - 1
f22(x36, x37) -> f24(x36, x37) :|: x37 >= 0 - 1
f26(x38, x39) -> f25(x38, x39) :|: TRUE
f27(x40, x41) -> f25(x40, x41) :|: TRUE
f20(x99, x100) -> f28(x101, x100) :|: TRUE && x101 = x99 + 1
f29(x102, x103) -> f32(x102, x104) :|: TRUE && x104 = x103 - 1
f30(x105, x106) -> f33(x105, x107) :|: TRUE && x107 = x106 + 1
f28(x48, x49) -> f29(x48, x49) :|: x49 * 2 > x48
f28(x50, x51) -> f30(x50, x51) :|: x51 * 2 <= x50
f32(x52, x53) -> f31(x52, x53) :|: TRUE
f33(x54, x55) -> f31(x54, x55) :|: TRUE
f6(x56, x57) -> f19(x56, x57) :|: x56 > 0 && x57 < 0
f6(x58, x59) -> f20(x58, x59) :|: x58 <= 0
f6(x108, x109) -> f20(x108, x109) :|: x109 >= 0
f25(x60, x61) -> f21(x60, x61) :|: TRUE
f31(x62, x63) -> f21(x62, x63) :|: TRUE
f4(x64, x65) -> f5(x64, x65) :|: x64 >= x65
f4(x66, x67) -> f6(x66, x67) :|: x66 < x67
f11(x68, x69) -> f7(x68, x69) :|: TRUE
f21(x70, x71) -> f7(x70, x71) :|: TRUE
f3(x72, x73) -> f4(x72, x73) :|: x72 > 0
f7(x74, x75) -> f3(x74, x75) :|: TRUE
f3(x76, x77) -> f34(x76, x77) :|: x76 <= 0
Start term: f1(i, j)

----------------------------------------

(5) TerminationGraphProcessor (SOUND)
Constructed the termination graph and obtained one non-trivial SCC.

----------------------------------------

(6)
Obligation:
Rules:
f3(x72, x73) -> f4(x72, x73) :|: x72 > 0
f7(x74, x75) -> f3(x74, x75) :|: TRUE
f11(x68, x69) -> f7(x68, x69) :|: TRUE
f15(x24, x25) -> f11(x24, x25) :|: TRUE
f16(x14, x15) -> f15(x14, x15) :|: TRUE
f13(x81, x82) -> f16(x83, x82) :|: TRUE && x83 = x81 + 1
f12(x10, x11) -> f13(x10, x11) :|: x10 - x11 > 2
f9(x78, x79) -> f12(x78, x80) :|: TRUE && x80 = x79 + 1
f8(x20, x21) -> f9(x20, x21) :|: x21 < 5
f5(x2, x3) -> f8(arith, x3) :|: TRUE && arith = x2 + 1
f4(x64, x65) -> f5(x64, x65) :|: x64 >= x65
f17(x16, x17) -> f15(x16, x17) :|: TRUE
f14(x84, x85) -> f17(x84, x86) :|: TRUE && x86 = x85 + 1
f12(x12, x13) -> f14(x12, x13) :|: x12 - x13 <= 2
f18(x26, x27) -> f11(x26, x27) :|: TRUE
f10(x87, x88) -> f18(x87, x89) :|: TRUE && x89 = x88 - 1
f8(x22, x23) -> f10(x22, x23) :|: x23 >= 5
f21(x70, x71) -> f7(x70, x71) :|: TRUE
f25(x60, x61) -> f21(x60, x61) :|: TRUE
f26(x38, x39) -> f25(x38, x39) :|: TRUE
f23(x93, x94) -> f26(x93, x95) :|: TRUE && x95 = x94 + 1
f22(x34, x35) -> f23(x34, x35) :|: x35 < 0 - 1
f19(x90, x91) -> f22(x92, x91) :|: TRUE && x92 = x90 - 1
f6(x56, x57) -> f19(x56, x57) :|: x56 > 0 && x57 < 0
f4(x66, x67) -> f6(x66, x67) :|: x66 < x67
f27(x40, x41) -> f25(x40, x41) :|: TRUE
f24(x96, x97) -> f27(x98, x97) :|: TRUE && x98 = x96 + 1
f22(x36, x37) -> f24(x36, x37) :|: x37 >= 0 - 1
f31(x62, x63) -> f21(x62, x63) :|: TRUE
f32(x52, x53) -> f31(x52, x53) :|: TRUE
f29(x102, x103) -> f32(x102, x104) :|: TRUE && x104 = x103 - 1
f28(x48, x49) -> f29(x48, x49) :|: x49 * 2 > x48
f20(x99, x100) -> f28(x101, x100) :|: TRUE && x101 = x99 + 1
f6(x58, x59) -> f20(x58, x59) :|: x58 <= 0
f6(x108, x109) -> f20(x108, x109) :|: x109 >= 0
f33(x54, x55) -> f31(x54, x55) :|: TRUE
f30(x105, x106) -> f33(x105, x107) :|: TRUE && x107 = x106 + 1
f28(x50, x51) -> f30(x50, x51) :|: x51 * 2 <= x50

----------------------------------------

(7) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(8)
Obligation:
Rules:
f7(x74:0, x75:0) -> f7(x74:0, x75:0) :|: x75:0 > x74:0 && x74:0 > 0 && x75:0 > -2 && x75:0 < 0
f20(x99:0, x100:0) -> f7(x99:0 + 1, x100:0 - 1) :|: x99:0 + 1 < x100:0 * 2
f20(x, x1) -> f7(x + 1, x1 + 1) :|: x + 1 >= x1 * 2
f7(x2, x3) -> f7(x2 + 1, x3 - 1) :|: x2 > 0 && x3 <= x2 && x3 > 4
f7(x4, x5) -> f20(x4, x5) :|: x4 > 0 && x5 > x4 && x5 > -1
f7(x6, x7) -> f7(x6 - 1, x7 + 1) :|: x7 > x6 && x6 > 0 && x7 < -1 && x7 < 0
f7(x8, x9) -> f7(x8 + 1, x9 + 2) :|: x9 <= x8 && x8 > 0 && x8 + 1 - (x9 + 1) <= 2 && x9 < 5
f7(x10, x11) -> f7(x10 + 2, x11 + 1) :|: x11 <= x10 && x10 > 0 && x10 + 1 - (x11 + 1) > 2 && x11 < 5
f7(x12, x13) -> f20(x12, x13) :|: x12 > 0 && x13 > x12 && x12 < 1

----------------------------------------

(9) PolynomialOrderProcessor (EQUIVALENT)
Found the following polynomial interpretation:
[f7(x, x1)] = 0
[f20(x2, x3)] = 0

The following rules are decreasing:
f7(x12, x13) -> f20(x12, x13) :|: x12 > 0 && x13 > x12 && x12 < 1
The following rules are bounded:
f7(x74:0, x75:0) -> f7(x74:0, x75:0) :|: x75:0 > x74:0 && x74:0 > 0 && x75:0 > -2 && x75:0 < 0
f20(x99:0, x100:0) -> f7(x99:0 + 1, x100:0 - 1) :|: x99:0 + 1 < x100:0 * 2
f20(x, x1) -> f7(x + 1, x1 + 1) :|: x + 1 >= x1 * 2
f7(x2, x3) -> f7(x2 + 1, x3 - 1) :|: x2 > 0 && x3 <= x2 && x3 > 4
f7(x4, x5) -> f20(x4, x5) :|: x4 > 0 && x5 > x4 && x5 > -1
f7(x6, x7) -> f7(x6 - 1, x7 + 1) :|: x7 > x6 && x6 > 0 && x7 < -1 && x7 < 0
f7(x8, x9) -> f7(x8 + 1, x9 + 2) :|: x9 <= x8 && x8 > 0 && x8 + 1 - (x9 + 1) <= 2 && x9 < 5
f7(x10, x11) -> f7(x10 + 2, x11 + 1) :|: x11 <= x10 && x10 > 0 && x10 + 1 - (x11 + 1) > 2 && x11 < 5
f7(x12, x13) -> f20(x12, x13) :|: x12 > 0 && x13 > x12 && x12 < 1

----------------------------------------

(10)
Obligation:
Rules:
f7(x74:0, x75:0) -> f7(x74:0, x75:0) :|: x75:0 > x74:0 && x74:0 > 0 && x75:0 > -2 && x75:0 < 0
f20(x99:0, x100:0) -> f7(x99:0 + 1, x100:0 - 1) :|: x99:0 + 1 < x100:0 * 2
f20(x, x1) -> f7(x + 1, x1 + 1) :|: x + 1 >= x1 * 2
f7(x2, x3) -> f7(x2 + 1, x3 - 1) :|: x2 > 0 && x3 <= x2 && x3 > 4
f7(x4, x5) -> f20(x4, x5) :|: x4 > 0 && x5 > x4 && x5 > -1
f7(x6, x7) -> f7(x6 - 1, x7 + 1) :|: x7 > x6 && x6 > 0 && x7 < -1 && x7 < 0
f7(x8, x9) -> f7(x8 + 1, x9 + 2) :|: x9 <= x8 && x8 > 0 && x8 + 1 - (x9 + 1) <= 2 && x9 < 5
f7(x10, x11) -> f7(x10 + 2, x11 + 1) :|: x11 <= x10 && x10 > 0 && x10 + 1 - (x11 + 1) > 2 && x11 < 5

----------------------------------------

(11) TerminationGraphProcessor (EQUIVALENT)
Constructed the termination graph and obtained one non-trivial SCC.

----------------------------------------

(12)
Obligation:
Rules:
f20(x99:0, x100:0) -> f7(x99:0 + 1, x100:0 - 1) :|: x99:0 + 1 < x100:0 * 2
f7(x4, x5) -> f20(x4, x5) :|: x4 > 0 && x5 > x4 && x5 > -1
f7(x8, x9) -> f7(x8 + 1, x9 + 2) :|: x9 <= x8 && x8 > 0 && x8 + 1 - (x9 + 1) <= 2 && x9 < 5
f20(x, x1) -> f7(x + 1, x1 + 1) :|: x + 1 >= x1 * 2
f7(x2, x3) -> f7(x2 + 1, x3 - 1) :|: x2 > 0 && x3 <= x2 && x3 > 4
f7(x10, x11) -> f7(x10 + 2, x11 + 1) :|: x11 <= x10 && x10 > 0 && x10 + 1 - (x11 + 1) > 2 && x11 < 5

----------------------------------------

(13) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(14)
Obligation:
Rules:
f7(x8:0, x9:0) -> f7(x8:0 + 1, x9:0 + 2) :|: x8:0 + 1 - (x9:0 + 1) <= 2 && x9:0 < 5 && x8:0 > 0 && x9:0 <= x8:0
f7(x2:0, x3:0) -> f7(x2:0 + 1, x3:0 - 1) :|: x2:0 > 0 && x3:0 <= x2:0 && x3:0 > 4
f7(x10:0, x11:0) -> f7(x10:0 + 2, x11:0 + 1) :|: x10:0 + 1 - (x11:0 + 1) > 2 && x11:0 < 5 && x10:0 > 0 && x11:0 <= x10:0
f7(x4:0, x5:0) -> f7(x4:0 + 1, x5:0 - 1) :|: x5:0 > -1 && x5:0 * 2 > x4:0 + 1 && x5:0 > x4:0 && x4:0 > 0
f7(x, x1) -> f7(x + 1, x1 + 1) :|: x1 > -1 && x1 * 2 <= x + 1 && x1 > x && x > 0

----------------------------------------

(15) IntTRSNonPeriodicNontermProof (COMPLETE)
Normalized system to the following form:
f(pc, x8:0, x9:0) -> f(1, x8:0 + 1, x9:0 + 2) :|: pc = 1 && (x8:0 + 1 - (x9:0 + 1) <= 2 && x9:0 < 5 && x8:0 > 0 && x9:0 <= x8:0)
f(pc, x2:0, x3:0) -> f(1, x2:0 + 1, x3:0 - 1) :|: pc = 1 && (x2:0 > 0 && x3:0 <= x2:0 && x3:0 > 4)
f(pc, x10:0, x11:0) -> f(1, x10:0 + 2, x11:0 + 1) :|: pc = 1 && (x10:0 + 1 - (x11:0 + 1) > 2 && x11:0 < 5 && x10:0 > 0 && x11:0 <= x10:0)
f(pc, x4:0, x5:0) -> f(1, x4:0 + 1, x5:0 - 1) :|: pc = 1 && (x5:0 > -1 && x5:0 * 2 > x4:0 + 1 && x5:0 > x4:0 && x4:0 > 0)
f(pc, x, x1) -> f(1, x + 1, x1 + 1) :|: pc = 1 && (x1 > -1 && x1 * 2 <= x + 1 && x1 > x && x > 0)
Proved unsatisfiability of the following formula, indicating that the system is never left after entering:
((((run2_0 = ((1 * 1)) and run2_1 = ((run1_1 * 1) + (1 * 1)) and run2_2 = ((run1_2 * 1) + (1 * 2))) and (((run1_0 * 1)) = ((1 * 1)) and (((((run1_1 * 1) + (run1_2 * -1)) <= ((1 * 2)) and ((run1_2 * 1)) < ((1 * 5))) and ((run1_1 * 1)) > 0) and ((run1_2 * 1)) <= ((run1_1 * 1))))) or ((run2_0 = ((1 * 1)) and run2_1 = ((run1_1 * 1) + (1 * 1)) and run2_2 = ((run1_2 * 1) + (1 * -1))) and (((run1_0 * 1)) = ((1 * 1)) and ((((run1_1 * 1)) > 0 and ((run1_2 * 1)) <= ((run1_1 * 1))) and ((run1_2 * 1)) > ((1 * 4))))) or ((run2_0 = ((1 * 1)) and run2_1 = ((run1_1 * 1) + (1 * 2)) and run2_2 = ((run1_2 * 1) + (1 * 1))) and (((run1_0 * 1)) = ((1 * 1)) and (((((run1_1 * 1) + (run1_2 * -1)) > ((1 * 2)) and ((run1_2 * 1)) < ((1 * 5))) and ((run1_1 * 1)) > 0) and ((run1_2 * 1)) <= ((run1_1 * 1))))) or ((run2_0 = ((1 * 1)) and run2_1 = ((run1_1 * 1) + (1 * 1)) and run2_2 = ((run1_2 * 1) + (1 * -1))) and (((run1_0 * 1)) = ((1 * 1)) and (((((run1_2 * 1)) > ((1 * -1)) and ((run1_2 * 2)) > ((run1_1 * 1) + (1 * 1))) and ((run1_2 * 1)) > ((run1_1 * 1))) and ((run1_1 * 1)) > 0))) or ((run2_0 = ((1 * 1)) and run2_1 = ((run1_1 * 1) + (1 * 1)) and run2_2 = ((run1_2 * 1) + (1 * 1))) and (((run1_0 * 1)) = ((1 * 1)) and (((((run1_2 * 1)) > ((1 * -1)) and ((run1_2 * 2)) <= ((run1_1 * 1) + (1 * 1))) and ((run1_2 * 1)) > ((run1_1 * 1))) and ((run1_1 * 1)) > 0)))) and (!(((run2_0 * 1)) = ((1 * 1)) and (((((run2_1 * 1) + (run2_2 * -1)) <= ((1 * 2)) and ((run2_2 * 1)) < ((1 * 5))) and ((run2_1 * 1)) > 0) and ((run2_2 * 1)) <= ((run2_1 * 1)))) and !(((run2_0 * 1)) = ((1 * 1)) and ((((run2_1 * 1)) > 0 and ((run2_2 * 1)) <= ((run2_1 * 1))) and ((run2_2 * 1)) > ((1 * 4)))) and !(((run2_0 * 1)) = ((1 * 1)) and (((((run2_1 * 1) + (run2_2 * -1)) > ((1 * 2)) and ((run2_2 * 1)) < ((1 * 5))) and ((run2_1 * 1)) > 0) and ((run2_2 * 1)) <= ((run2_1 * 1)))) and !(((run2_0 * 1)) = ((1 * 1)) and (((((run2_2 * 1)) > ((1 * -1)) and ((run2_2 * 2)) > ((run2_1 * 1) + (1 * 1))) and ((run2_2 * 1)) > ((run2_1 * 1))) and ((run2_1 * 1)) > 0)) and !(((run2_0 * 1)) = ((1 * 1)) and (((((run2_2 * 1)) > ((1 * -1)) and ((run2_2 * 2)) <= ((run2_1 * 1) + (1 * 1))) and ((run2_2 * 1)) > ((run2_1 * 1))) and ((run2_1 * 1)) > 0))))
Proved satisfiability of the following formula, indicating that the system is entered at least once:
(((run2_0 = ((1 * 1)) and run2_1 = ((run1_1 * 1) + (1 * 1)) and run2_2 = ((run1_2 * 1) + (1 * 2))) and (((run1_0 * 1)) = ((1 * 1)) and (((((run1_1 * 1) + (run1_2 * -1)) <= ((1 * 2)) and ((run1_2 * 1)) < ((1 * 5))) and ((run1_1 * 1)) > 0) and ((run1_2 * 1)) <= ((run1_1 * 1))))) or ((run2_0 = ((1 * 1)) and run2_1 = ((run1_1 * 1) + (1 * 1)) and run2_2 = ((run1_2 * 1) + (1 * -1))) and (((run1_0 * 1)) = ((1 * 1)) and ((((run1_1 * 1)) > 0 and ((run1_2 * 1)) <= ((run1_1 * 1))) and ((run1_2 * 1)) > ((1 * 4))))) or ((run2_0 = ((1 * 1)) and run2_1 = ((run1_1 * 1) + (1 * 2)) and run2_2 = ((run1_2 * 1) + (1 * 1))) and (((run1_0 * 1)) = ((1 * 1)) and (((((run1_1 * 1) + (run1_2 * -1)) > ((1 * 2)) and ((run1_2 * 1)) < ((1 * 5))) and ((run1_1 * 1)) > 0) and ((run1_2 * 1)) <= ((run1_1 * 1))))) or ((run2_0 = ((1 * 1)) and run2_1 = ((run1_1 * 1) + (1 * 1)) and run2_2 = ((run1_2 * 1) + (1 * -1))) and (((run1_0 * 1)) = ((1 * 1)) and (((((run1_2 * 1)) > ((1 * -1)) and ((run1_2 * 2)) > ((run1_1 * 1) + (1 * 1))) and ((run1_2 * 1)) > ((run1_1 * 1))) and ((run1_1 * 1)) > 0))) or ((run2_0 = ((1 * 1)) and run2_1 = ((run1_1 * 1) + (1 * 1)) and run2_2 = ((run1_2 * 1) + (1 * 1))) and (((run1_0 * 1)) = ((1 * 1)) and (((((run1_2 * 1)) > ((1 * -1)) and ((run1_2 * 2)) <= ((run1_1 * 1) + (1 * 1))) and ((run1_2 * 1)) > ((run1_1 * 1))) and ((run1_1 * 1)) > 0))))

----------------------------------------

(16)
NO
Aborted 1756892390Exec. 4, LLVMToSEGraph with some error. Reason: InconsistentStateException [integerState=vals:
{v1=[1,+inf){-inf,+inf}, v2=[4,+inf){0,+inf}, v3=[1,+inf){-inf,+inf}, v4=[4,+inf){0,+inf}, v5=[1,+inf){-inf,+inf}, v6=[4,+inf){0,+inf}}
associations:
{v1=0, v2=0, v3=1, v4=1, v5=2, v6=2}
association offsets:
{v1=3, v2=0, v3=3, v4=0, v5=3, v6=0}
rels:
undirected inequalities:
[]
equations:
