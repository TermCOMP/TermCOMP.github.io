YES

Problem 1: 

(VAR vu95NonEmpty x y)
(RULES
le(num0,s(x)) -> ftrue
le(s(x),s(y)) -> le(x,y)
le(x,num0) -> ffalse
m -> s(s(s(s(num0))))
pop(empty) -> empty
pop(push(x,y)) -> x | le(size(x),m) ->* ftrue
size(empty) -> num0
size(push(x,y)) -> s(size(x))
top(empty) -> eentry
top(push(x,y)) -> y | le(size(x),m) ->* ftrue
)


Problem 1: 
Valid CTRS Processor:
-> Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x | le(size(x),m) ->* ftrue
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y | le(size(x),m) ->* ftrue
-> The system is a 2-CTRS.

Problem 1: 

Underlying TRS Transformation Processor:
-> Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x | le(size(x),m) ->* ftrue
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y | le(size(x),m) ->* ftrue
-> New Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y

Problem 1: 

(VAR vu95NonEmpty x y)
(RULES
le(num0,s(x)) -> ftrue
le(s(x),s(y)) -> le(x,y)
le(x,num0) -> ffalse
m -> s(s(s(s(num0))))
pop(empty) -> empty
pop(push(x,y)) -> x
size(empty) -> num0
size(push(x,y)) -> s(size(x))
top(empty) -> eentry
top(push(x,y)) -> y
)


Problem 1: 

Innermost Equivalent Processor:
-> Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y
-> The term rewriting system is non-overlaping or locally confluent overlay system. Therefore, innermost termination implies termination.
 

Problem 1: 

Dependency Pairs Processor:
-> Pairs:
 LE(s(x),s(y)) -> LE(x,y)
 SIZE(push(x,y)) -> SIZE(x)
-> Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y

Problem 1: 

SCC Processor:
-> Pairs:
 LE(s(x),s(y)) -> LE(x,y)
 SIZE(push(x,y)) -> SIZE(x)
-> Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y
->Strongly Connected Components:
->->Cycle:
->->-> Pairs:
 SIZE(push(x,y)) -> SIZE(x)
->->-> Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y
->->Cycle:
->->-> Pairs:
 LE(s(x),s(y)) -> LE(x,y)
->->-> Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y


The problem is decomposed in 2 subproblems.

Problem 1.1: 

Subterm Processor:
-> Pairs:
 SIZE(push(x,y)) -> SIZE(x)
-> Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y
->Projection:
 pi(SIZE) = 1

Problem 1.1: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.

Problem 1.2: 

Subterm Processor:
-> Pairs:
 LE(s(x),s(y)) -> LE(x,y)
-> Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y
->Projection:
 pi(LE) = 1

Problem 1.2: 

SCC Processor:
-> Pairs:
 Empty
-> Rules:
 le(num0,s(x)) -> ftrue
 le(s(x),s(y)) -> le(x,y)
 le(x,num0) -> ffalse
 m -> s(s(s(s(num0))))
 pop(empty) -> empty
 pop(push(x,y)) -> x
 size(empty) -> num0
 size(push(x,y)) -> s(size(x))
 top(empty) -> eentry
 top(push(x,y)) -> y
->Strongly Connected Components:
 There is no strongly connected component

The problem is finite.
