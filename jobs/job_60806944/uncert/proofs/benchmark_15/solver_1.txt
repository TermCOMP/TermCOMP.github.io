YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/LzqTA.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given RelTRS could be proven:

(0) RelTRS
(1) RelTRStoRelADPProof [EQUIVALENT, 0 ms]
(2) RelADPP
(3) RelADPDepGraphProof [EQUIVALENT, 0 ms]
(4) AND
    (5) RelADPP
        (6) RelADPCleverAfsProof [SOUND, 56 ms]
        (7) QDP
        (8) MRRProof [EQUIVALENT, 9 ms]
        (9) QDP
        (10) QDPOrderProof [EQUIVALENT, 3 ms]
        (11) QDP
        (12) PisEmptyProof [EQUIVALENT, 0 ms]
        (13) YES
    (14) RelADPP
        (15) RelADPCleverAfsProof [SOUND, 46 ms]
        (16) QDP
        (17) MRRProof [EQUIVALENT, 4 ms]
        (18) QDP
        (19) PisEmptyProof [EQUIVALENT, 0 ms]
        (20) YES
    (21) RelADPP
        (22) RelADPReductionPairProof [EQUIVALENT, 128 ms]
        (23) RelADPP
        (24) RelADPReductionPairProof [EQUIVALENT, 35 ms]
        (25) RelADPP
        (26) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (27) TRUE
    (28) RelADPP
        (29) RelADPReductionPairProof [EQUIVALENT, 87 ms]
        (30) RelADPP
        (31) RelADPReductionPairProof [EQUIVALENT, 25 ms]
        (32) RelADPP
        (33) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (34) TRUE
    (35) RelADPP
        (36) RelADPReductionPairProof [EQUIVALENT, 93 ms]
        (37) RelADPP
        (38) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (39) YES
    (40) RelADPP
        (41) RelADPReductionPairProof [EQUIVALENT, 96 ms]
        (42) RelADPP
        (43) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (44) YES
    (45) RelADPP
        (46) RelADPReductionPairProof [EQUIVALENT, 99 ms]
        (47) RelADPP
        (48) RelADPReductionPairProof [EQUIVALENT, 25 ms]
        (49) RelADPP
        (50) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (51) YES
    (52) RelADPP
        (53) RelADPReductionPairProof [EQUIVALENT, 100 ms]
        (54) RelADPP
        (55) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (56) YES
    (57) RelADPP
        (58) RelADPReductionPairProof [EQUIVALENT, 74 ms]
        (59) RelADPP
        (60) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (61) TRUE
    (62) RelADPP
        (63) RelADPReductionPairProof [EQUIVALENT, 105 ms]
        (64) RelADPP
        (65) RelADPReductionPairProof [EQUIVALENT, 20 ms]
        (66) RelADPP
        (67) RelADPCleverAfsProof [SOUND, 7 ms]
        (68) QDP
        (69) MRRProof [EQUIVALENT, 2 ms]
        (70) QDP
        (71) PisEmptyProof [EQUIVALENT, 0 ms]
        (72) YES
    (73) RelADPP
        (74) RelADPReductionPairProof [EQUIVALENT, 50 ms]
        (75) RelADPP
        (76) RelADPReductionPairProof [EQUIVALENT, 15 ms]
        (77) RelADPP
        (78) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (79) TRUE
    (80) RelADPP
        (81) RelADPReductionPairProof [EQUIVALENT, 114 ms]
        (82) RelADPP
        (83) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (84) TRUE
    (85) RelADPP
        (86) RelADPReductionPairProof [EQUIVALENT, 99 ms]
        (87) RelADPP
        (88) RelADPReductionPairProof [EQUIVALENT, 26 ms]
        (89) RelADPP
        (90) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (91) TRUE
    (92) RelADPP
        (93) RelADPReductionPairProof [EQUIVALENT, 70 ms]
        (94) RelADPP
        (95) RelADPReductionPairProof [EQUIVALENT, 16 ms]
        (96) RelADPP
        (97) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (98) YES
    (99) RelADPP
        (100) RelADPReductionPairProof [EQUIVALENT, 86 ms]
        (101) RelADPP
        (102) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (103) TRUE
    (104) RelADPP
        (105) RelADPReductionPairProof [EQUIVALENT, 120 ms]
        (106) RelADPP
        (107) RelADPCleverAfsProof [SOUND, 9 ms]
        (108) QDP
        (109) MRRProof [EQUIVALENT, 2 ms]
        (110) QDP
        (111) PisEmptyProof [EQUIVALENT, 0 ms]
        (112) YES
    (113) RelADPP
        (114) RelADPReductionPairProof [EQUIVALENT, 69 ms]
        (115) RelADPP
        (116) RelADPReductionPairProof [EQUIVALENT, 19 ms]
        (117) RelADPP
        (118) RelADPCleverAfsProof [SOUND, 8 ms]
        (119) QDP
        (120) MRRProof [EQUIVALENT, 2 ms]
        (121) QDP
        (122) PisEmptyProof [EQUIVALENT, 0 ms]
        (123) YES
    (124) RelADPP
        (125) RelADPReductionPairProof [EQUIVALENT, 115 ms]
        (126) RelADPP
        (127) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (128) TRUE
    (129) RelADPP
        (130) RelADPReductionPairProof [EQUIVALENT, 87 ms]
        (131) RelADPP
        (132) RelADPReductionPairProof [EQUIVALENT, 33 ms]
        (133) RelADPP
        (134) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (135) TRUE
    (136) RelADPP
        (137) RelADPReductionPairProof [EQUIVALENT, 60 ms]
        (138) RelADPP
        (139) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (140) YES
    (141) RelADPP
        (142) RelADPReductionPairProof [EQUIVALENT, 112 ms]
        (143) RelADPP
        (144) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (145) YES
    (146) RelADPP
        (147) RelADPReductionPairProof [EQUIVALENT, 77 ms]
        (148) RelADPP
        (149) RelADPCleverAfsProof [SOUND, 7 ms]
        (150) QDP
        (151) MRRProof [EQUIVALENT, 4 ms]
        (152) QDP
        (153) PisEmptyProof [EQUIVALENT, 0 ms]
        (154) YES
    (155) RelADPP
        (156) RelADPReductionPairProof [EQUIVALENT, 127 ms]
        (157) RelADPP
        (158) RelADPReductionPairProof [EQUIVALENT, 19 ms]
        (159) RelADPP
        (160) RelADPCleverAfsProof [SOUND, 5 ms]
        (161) QDP
        (162) MRRProof [EQUIVALENT, 0 ms]
        (163) QDP
        (164) PisEmptyProof [EQUIVALENT, 0 ms]
        (165) YES
    (166) RelADPP
        (167) RelADPReductionPairProof [EQUIVALENT, 104 ms]
        (168) RelADPP
        (169) RelADPReductionPairProof [EQUIVALENT, 35 ms]
        (170) RelADPP
        (171) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (172) YES
    (173) RelADPP
        (174) RelADPReductionPairProof [EQUIVALENT, 81 ms]
        (175) RelADPP
        (176) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (177) YES
    (178) RelADPP
        (179) RelADPReductionPairProof [EQUIVALENT, 83 ms]
        (180) RelADPP
        (181) RelADPReductionPairProof [EQUIVALENT, 22 ms]
        (182) RelADPP
        (183) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (184) TRUE
    (185) RelADPP
        (186) RelADPReductionPairProof [EQUIVALENT, 127 ms]
        (187) RelADPP
        (188) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (189) YES


----------------------------------------

(0)
Obligation:
Relative term rewrite system:
The relative TRS consists of the following R rules:

   minus(x, 0) -> x
   minus(x, s(y)) -> pred(minus(x, y))
   quot(0, s(y)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))

The relative TRS consists of the following S rules:

   s(pred(x)) -> pred(s(x))
   log(s(0)) -> 0
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   pred(s(x)) -> x


----------------------------------------

(1) RelTRStoRelADPProof (EQUIVALENT)


We upgrade the RelTRS problem to an equivalent Relative ADP Problem [IJCAR24].

----------------------------------------

(2)
Obligation:
Relative ADP Problem with
absolute ADPs:

   minus(x, 0) -> x
   minus(x, s(y)) -> PRED(minus(x, y))
   minus(x, s(y)) -> pred(MINUS(x, y))
   quot(0, s(y)) -> 0
   quot(s(x), s(y)) -> S(quot(minus(x, y), s(y)))
   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))
   quot(s(x), s(y)) -> s(quot(MINUS(x, y), s(y)))
   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

and relative ADPs:

   s(pred(x)) -> PRED(S(x))
   log(s(0)) -> 0
   pred(s(x)) -> S(PRED(x))
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))
   log(s(s(x))) -> S(log(S(quot(x, s(s(0))))))
   log(s(s(x))) -> S(log(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> S(log(s(quot(x, S(s(0))))))
   log(s(s(x))) -> S(log(s(quot(x, s(S(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(s(x))) -> s(log(S(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(log(S(quot(x, S(s(0))))))
   log(s(s(x))) -> s(log(S(quot(x, s(S(0))))))
   log(s(s(x))) -> s(log(s(QUOT(x, S(s(0))))))
   log(s(s(x))) -> s(log(s(QUOT(x, s(S(0))))))
   log(s(s(x))) -> s(log(s(quot(x, S(S(0))))))
   pred(s(x)) -> x


----------------------------------------

(3) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  2 SCCs with nodes from P_abs,
  25 Lassos,
Result: This relative DT problem is equivalent to 27 subproblems.

----------------------------------------

(4)
Complex Obligation (AND)

----------------------------------------

(5)
Obligation:
Relative ADP Problem with
absolute ADPs:

   minus(x, s(y)) -> pred(MINUS(x, y))

and relative ADPs:

   s(pred(x)) -> pred(s(x))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(6) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:s_1 = 
MINUS_2 = 0
log_1 = 
pred_1 = 
0 = 
minus_2 = 1
quot_2 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
MINUS(x1, x2)  =  x2

s(x1)  =  s(x1)

quot(x1, x2)  =  quot(x1, x2)

minus(x1, x2)  =  x1

pred(x1)  =  x1

0  =  0


Recursive path order with status [RPO].
Quasi-Precedence: quot_2 > 0 > s_1

Status: s_1: multiset status
quot_2: [2,1]
0: multiset status


----------------------------------------

(7)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MINUS(s0(y)) -> MINUS(y)

The TRS R consists of the following rules:

   s0(pred0(x)) -> pred0(s0(x))
   log0(s0(00)) -> 00
   quot0(s0(x), s0(y)) -> s0(quot0(minus(x), s0(y)))
   minus(x) -> pred0(minus(x))
   pred0(s0(x)) -> s0(pred0(x))
   log0(s0(s0(x))) -> s0(log0(s0(quot0(x, s0(s0(00))))))
   minus(x) -> x
   quot0(00, s0(y)) -> 00
   pred0(s0(x)) -> x

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(8) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.


Strictly oriented rules of the TRS R:

   log0(s0(00)) -> 00

Used ordering: Polynomial interpretation [POLO]:

   POL(00) = 0
   POL(MINUS(x_1)) = 2*x_1
   POL(log0(x_1)) = 1 + x_1
   POL(minus(x_1)) = x_1
   POL(pred0(x_1)) = x_1
   POL(quot0(x_1, x_2)) = x_1 + x_2
   POL(s0(x_1)) = x_1


----------------------------------------

(9)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   MINUS(s0(y)) -> MINUS(y)

The TRS R consists of the following rules:

   s0(pred0(x)) -> pred0(s0(x))
   quot0(s0(x), s0(y)) -> s0(quot0(minus(x), s0(y)))
   minus(x) -> pred0(minus(x))
   pred0(s0(x)) -> s0(pred0(x))
   log0(s0(s0(x))) -> s0(log0(s0(quot0(x, s0(s0(00))))))
   minus(x) -> x
   quot0(00, s0(y)) -> 00
   pred0(s0(x)) -> x

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(10) QDPOrderProof (EQUIVALENT)
We use the reduction pair processor [LPAR04,JAR06].


The following pairs can be oriented strictly and are deleted.

   MINUS(s0(y)) -> MINUS(y)
The remaining pairs can at least be oriented weakly.
Used ordering:  Combined order from the following AFS and order.
MINUS(x1)  =  MINUS(x1)

s0(x1)  =  s0(x1)

pred0(x1)  =  x1

quot0(x1, x2)  =  x1

minus(x1)  =  x1

log0(x1)  =  x1

00  =  00


Recursive path order with status [RPO].
Quasi-Precedence: trivial

Status: MINUS_1: multiset status
s0_1: multiset status
00: multiset status


The following usable rules [FROCOS05] with respect to the argument filtering of the ordering [JAR06] were oriented:

   s0(pred0(x)) -> pred0(s0(x))
   quot0(s0(x), s0(y)) -> s0(quot0(minus(x), s0(y)))
   minus(x) -> pred0(minus(x))
   pred0(s0(x)) -> s0(pred0(x))
   log0(s0(s0(x))) -> s0(log0(s0(quot0(x, s0(s0(00))))))
   minus(x) -> x
   quot0(00, s0(y)) -> 00
   pred0(s0(x)) -> x


----------------------------------------

(11)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   s0(pred0(x)) -> pred0(s0(x))
   quot0(s0(x), s0(y)) -> s0(quot0(minus(x), s0(y)))
   minus(x) -> pred0(minus(x))
   pred0(s0(x)) -> s0(pred0(x))
   log0(s0(s0(x))) -> s0(log0(s0(quot0(x, s0(s0(00))))))
   minus(x) -> x
   quot0(00, s0(y)) -> 00
   pred0(s0(x)) -> x

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(12) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(13)
YES

----------------------------------------

(14)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))

and relative ADPs:

   s(pred(x)) -> pred(s(x))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(15) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:s_1 = 
QUOT_2 = 
log_1 = 
pred_1 = 
0 = 
minus_2 = 1
quot_2 = 1

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
QUOT(x1, x2)  =  QUOT(x1, x2)

s(x1)  =  s(x1)

minus(x1, x2)  =  x1

pred(x1)  =  x1

0  =  0

quot(x1, x2)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: QUOT_2 > s_1 > 0

Status: QUOT_2: [1,2]
s_1: multiset status
0: multiset status


----------------------------------------

(16)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   QUOT0(s0(x), s0(y)) -> QUOT0(minus(x), s0(y))

The TRS R consists of the following rules:

   s0(pred0(x)) -> pred0(s0(x))
   log0(s0(00)) -> 00
   quot(s0(x)) -> s0(quot(minus(x)))
   minus(x) -> pred0(minus(x))
   pred0(s0(x)) -> s0(pred0(x))
   log0(s0(s0(x))) -> s0(log0(s0(quot(x))))
   minus(x) -> x
   quot(00) -> 00
   pred0(s0(x)) -> x

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(17) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   QUOT0(s0(x), s0(y)) -> QUOT0(minus(x), s0(y))

Strictly oriented rules of the TRS R:

   log0(s0(00)) -> 00
   pred0(s0(x)) -> x

Used ordering: Polynomial interpretation [POLO]:

   POL(00) = 0
   POL(QUOT0(x_1, x_2)) = x_1 + x_2
   POL(log0(x_1)) = 1 + 2*x_1
   POL(minus(x_1)) = x_1
   POL(pred0(x_1)) = x_1
   POL(quot(x_1)) = x_1
   POL(s0(x_1)) = 1 + 2*x_1


----------------------------------------

(18)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   s0(pred0(x)) -> pred0(s0(x))
   quot(s0(x)) -> s0(quot(minus(x)))
   minus(x) -> pred0(minus(x))
   pred0(s0(x)) -> s0(pred0(x))
   log0(s0(s0(x))) -> s0(log0(s0(quot(x))))
   minus(x) -> x
   quot(00) -> 00

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(19) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(20)
YES

----------------------------------------

(21)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(MINUS(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   log(s(s(x))) -> S(log(s(QUOT(x, s(s(0))))))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(22) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> S(log(s(QUOT(x, s(s(0))))))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(quot(MINUS(x, y), s(y)))

Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 1 + 2*x_1
   POL(MINUS(x_1, x_2)) = 0
   POL(PRED(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 0
   POL(S(x_1)) = 2*x_1
   POL(log(x_1)) = x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 2*x_1

----------------------------------------

(23)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(MINUS(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(24) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(quot(MINUS(x, y), s(y)))

Relative ADPs:

   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 1 + 2*x_1
   POL(MINUS(x_1, x_2)) = 0
   POL(PRED(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 0
   POL(S(x_1)) = 1 + x_1
   POL(log(x_1)) = 1 + 2*x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 1 + 2*x_1

----------------------------------------

(25)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(MINUS(x, y), s(y)))

and relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(26) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(27)
TRUE

----------------------------------------

(28)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   log(s(s(x))) -> S(log(s(QUOT(x, s(s(0))))))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(29) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> S(log(s(QUOT(x, s(s(0))))))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 2 + 2*x_1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(log(x_1)) = 0
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 2*x_1

----------------------------------------

(30)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(31) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 1 + x_1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 1 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 1 + x_1
   POL(S(x_1)) = 3
   POL(log(x_1)) = 2 + 2*x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 2 + 2*x_1

----------------------------------------

(32)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

and relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(33) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(34)
TRUE

----------------------------------------

(35)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(0, s(y)) -> 0

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(36) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   quot(0, s(y)) -> 0

Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 1 + 3*x_1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 2 + 3*x_1
   POL(S(x_1)) = 2*x_1
   POL(log(x_1)) = x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 2 + 3*x_1

----------------------------------------

(37)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(38) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(39)
YES

----------------------------------------

(40)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(0, s(y)) -> 0

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(s(QUOT(x, s(S(0))))))


----------------------------------------

(41) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   quot(0, s(y)) -> 0

Relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   pred(s(x)) -> x


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(0) = 2
   POL(LOG(x_1)) = 2*x_1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = x_1
   POL(S(x_1)) = 0
   POL(log(x_1)) = x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 2*x_1

----------------------------------------

(42)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(s(QUOT(x, s(S(0))))))


----------------------------------------

(43) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(44)
YES

----------------------------------------

(45)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> S(quot(minus(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   log(s(s(x))) -> S(log(s(QUOT(x, s(s(0))))))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(46) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> S(log(s(QUOT(x, s(s(0))))))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> S(quot(minus(x, y), s(y)))

Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 2
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 0
   POL(S(x_1)) = 0
   POL(log(x_1)) = 0
   POL(minus(x_1, x_2)) = 2*x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = 0
   POL(s(x_1)) = x_1

----------------------------------------

(47)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> S(quot(minus(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(48) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   quot(s(x), s(y)) -> S(quot(minus(x, y), s(y)))

Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 1 + 2*x_1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 1 + 2*x_1 + x_1^2
   POL(QUOT(x_1, x_2)) = x_1
   POL(S(x_1)) = 2*x_1
   POL(log(x_1)) = x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 3 + 3*x_1

----------------------------------------

(49)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(50) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(51)
YES

----------------------------------------

(52)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(0, s(y)) -> 0

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(s(QUOT(x, S(s(0))))))
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(53) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   quot(0, s(y)) -> 0

Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(s(QUOT(x, S(s(0))))))
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 3*x_1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 3 + 3*x_1 + x_1^2
   POL(QUOT(x_1, x_2)) = 3 + x_2
   POL(S(x_1)) = 1
   POL(log(x_1)) = 1 + 3*x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(54)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(55) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(56)
YES

----------------------------------------

(57)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(MINUS(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(S(QUOT(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(58) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(S(QUOT(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(quot(MINUS(x, y), s(y)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 3*x_1
   POL(MINUS(x_1, x_2)) = 0
   POL(PRED(x_1)) = 2 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 0
   POL(S(x_1)) = 2 + 2*x_1
   POL(log(x_1)) = x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(59)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(MINUS(x, y), s(y)))

and relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(60) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(61)
TRUE

----------------------------------------

(62)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(s(QUOT(x, S(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(63) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> s(log(s(QUOT(x, S(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))

Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 0
   POL(S(x_1)) = 0
   POL(log(x_1)) = 0
   POL(minus(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = 0
   POL(s(x_1)) = 2*x_1

----------------------------------------

(64)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(65) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 2 + 3*x_1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 3 + x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 1
   POL(S(x_1)) = 3 + x_1
   POL(log(x_1)) = 3 + 2*x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(66)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))

and relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(67) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:s_1 = 
QUOT_2 = 
log_1 = 
0 = 
pred_1 = 
minus_2 = 1
quot_2 = 1

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
QUOT(x1, x2)  =  QUOT(x1, x2)

s(x1)  =  s(x1)

minus(x1, x2)  =  x1

pred(x1)  =  x1

0  =  0

quot(x1, x2)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: QUOT_2 > s_1 > 0

Status: QUOT_2: [1,2]
s_1: multiset status
0: multiset status


----------------------------------------

(68)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   QUOT0(s0(x), s0(y)) -> QUOT0(minus(x), s0(y))

The TRS R consists of the following rules:

   s0(pred0(x)) -> pred0(s0(x))
   log0(s0(00)) -> 00
   quot(s0(x)) -> s0(quot(minus(x)))
   minus(x) -> pred0(minus(x))
   pred0(s0(x)) -> s0(pred0(x))
   log0(s0(s0(x))) -> s0(log0(s0(quot(x))))
   minus(x) -> x
   quot(00) -> 00
   pred0(s0(x)) -> x

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(69) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   QUOT0(s0(x), s0(y)) -> QUOT0(minus(x), s0(y))

Strictly oriented rules of the TRS R:

   log0(s0(00)) -> 00
   pred0(s0(x)) -> x

Used ordering: Polynomial interpretation [POLO]:

   POL(00) = 0
   POL(QUOT0(x_1, x_2)) = x_1 + x_2
   POL(log0(x_1)) = 1 + 2*x_1
   POL(minus(x_1)) = x_1
   POL(pred0(x_1)) = x_1
   POL(quot(x_1)) = x_1
   POL(s0(x_1)) = 1 + 2*x_1


----------------------------------------

(70)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   s0(pred0(x)) -> pred0(s0(x))
   quot(s0(x)) -> s0(quot(minus(x)))
   minus(x) -> pred0(minus(x))
   pred0(s0(x)) -> s0(pred0(x))
   log0(s0(s0(x))) -> s0(log0(s0(quot(x))))
   minus(x) -> x
   quot(00) -> 00

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(71) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(72)
YES

----------------------------------------

(73)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(s(QUOT(x, s(S(0))))))


----------------------------------------

(74) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> s(log(s(QUOT(x, s(S(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 2
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 0
   POL(S(x_1)) = 0
   POL(log(x_1)) = 0
   POL(minus(x_1, x_2)) = 2*x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = 0
   POL(s(x_1)) = 2*x_1

----------------------------------------

(75)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(76) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 1 + x_1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 1 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 1 + x_1
   POL(S(x_1)) = 3
   POL(log(x_1)) = 2 + 2*x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 2 + 2*x_1

----------------------------------------

(77)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

and relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(78) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(79)
TRUE

----------------------------------------

(80)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(MINUS(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(81) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(quot(MINUS(x, y), s(y)))

Relative ADPs:

   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 1 + 2*x_1
   POL(MINUS(x_1, x_2)) = 0
   POL(PRED(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 0
   POL(S(x_1)) = 1 + x_1
   POL(log(x_1)) = 1 + 2*x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 1 + 2*x_1

----------------------------------------

(82)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(MINUS(x, y), s(y)))

and relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(83) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(84)
TRUE

----------------------------------------

(85)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(S(QUOT(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(86) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(S(QUOT(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 2
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 0
   POL(S(x_1)) = 0
   POL(log(x_1)) = 2*x_1
   POL(minus(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = 0
   POL(s(x_1)) = 2*x_1

----------------------------------------

(87)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(88) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 1 + x_1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 1 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 1 + x_1
   POL(S(x_1)) = 3
   POL(log(x_1)) = 2 + 2*x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 2 + 2*x_1

----------------------------------------

(89)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

and relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(90) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(91)
TRUE

----------------------------------------

(92)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> S(quot(minus(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(S(QUOT(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(93) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(S(QUOT(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> S(quot(minus(x, y), s(y)))

Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 2
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 0
   POL(S(x_1)) = 0
   POL(log(x_1)) = 2*x_1
   POL(minus(x_1, x_2)) = 2*x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = 0
   POL(s(x_1)) = 2*x_1

----------------------------------------

(94)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> S(quot(minus(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(95) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   quot(s(x), s(y)) -> S(quot(minus(x, y), s(y)))

Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 1 + 2*x_1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 1 + 2*x_1 + x_1^2
   POL(QUOT(x_1, x_2)) = x_1
   POL(S(x_1)) = 2*x_1
   POL(log(x_1)) = x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 3 + 3*x_1

----------------------------------------

(96)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(97) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(98)
YES

----------------------------------------

(99)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(100) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 1 + x_1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 1 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 1 + x_1
   POL(S(x_1)) = 3
   POL(log(x_1)) = 2 + 2*x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 2 + 2*x_1

----------------------------------------

(101)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

and relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(102) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(103)
TRUE

----------------------------------------

(104)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(105) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 2 + 3*x_1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 3 + x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 1
   POL(S(x_1)) = 3 + x_1
   POL(log(x_1)) = 3 + 2*x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(106)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))

and relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(107) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:s_1 = 
QUOT_2 = 
log_1 = 
0 = 
pred_1 = 
minus_2 = 1
quot_2 = 1

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
QUOT(x1, x2)  =  QUOT(x1, x2)

s(x1)  =  s(x1)

minus(x1, x2)  =  x1

pred(x1)  =  x1

0  =  0

quot(x1, x2)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: QUOT_2 > s_1 > 0

Status: QUOT_2: [1,2]
s_1: multiset status
0: multiset status


----------------------------------------

(108)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   QUOT0(s0(x), s0(y)) -> QUOT0(minus(x), s0(y))

The TRS R consists of the following rules:

   s0(pred0(x)) -> pred0(s0(x))
   log0(s0(00)) -> 00
   quot(s0(x)) -> s0(quot(minus(x)))
   minus(x) -> pred0(minus(x))
   pred0(s0(x)) -> s0(pred0(x))
   log0(s0(s0(x))) -> s0(log0(s0(quot(x))))
   minus(x) -> x
   quot(00) -> 00
   pred0(s0(x)) -> x

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(109) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   QUOT0(s0(x), s0(y)) -> QUOT0(minus(x), s0(y))

Strictly oriented rules of the TRS R:

   log0(s0(00)) -> 00
   pred0(s0(x)) -> x

Used ordering: Polynomial interpretation [POLO]:

   POL(00) = 0
   POL(QUOT0(x_1, x_2)) = x_1 + x_2
   POL(log0(x_1)) = 1 + 2*x_1
   POL(minus(x_1)) = x_1
   POL(pred0(x_1)) = x_1
   POL(quot(x_1)) = x_1
   POL(s0(x_1)) = 1 + 2*x_1


----------------------------------------

(110)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   s0(pred0(x)) -> pred0(s0(x))
   quot(s0(x)) -> s0(quot(minus(x)))
   minus(x) -> pred0(minus(x))
   pred0(s0(x)) -> s0(pred0(x))
   log0(s0(s0(x))) -> s0(log0(s0(quot(x))))
   minus(x) -> x
   quot(00) -> 00

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(111) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(112)
YES

----------------------------------------

(113)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(S(QUOT(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(114) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(S(QUOT(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))

Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 0
   POL(S(x_1)) = 0
   POL(log(x_1)) = x_1
   POL(minus(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = 0
   POL(s(x_1)) = 2*x_1

----------------------------------------

(115)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(116) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 2 + 3*x_1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 3 + x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 1
   POL(S(x_1)) = 3 + x_1
   POL(log(x_1)) = 3 + 2*x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(117)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))

and relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(118) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:s_1 = 
QUOT_2 = 
log_1 = 
0 = 
pred_1 = 
minus_2 = 1
quot_2 = 1

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
QUOT(x1, x2)  =  QUOT(x1, x2)

s(x1)  =  s(x1)

minus(x1, x2)  =  x1

pred(x1)  =  x1

0  =  0

quot(x1, x2)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: QUOT_2 > s_1 > 0

Status: QUOT_2: [1,2]
s_1: multiset status
0: multiset status


----------------------------------------

(119)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   QUOT0(s0(x), s0(y)) -> QUOT0(minus(x), s0(y))

The TRS R consists of the following rules:

   s0(pred0(x)) -> pred0(s0(x))
   log0(s0(00)) -> 00
   quot(s0(x)) -> s0(quot(minus(x)))
   minus(x) -> pred0(minus(x))
   pred0(s0(x)) -> s0(pred0(x))
   log0(s0(s0(x))) -> s0(log0(s0(quot(x))))
   minus(x) -> x
   quot(00) -> 00
   pred0(s0(x)) -> x

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(120) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   QUOT0(s0(x), s0(y)) -> QUOT0(minus(x), s0(y))

Strictly oriented rules of the TRS R:

   log0(s0(00)) -> 00
   pred0(s0(x)) -> x

Used ordering: Polynomial interpretation [POLO]:

   POL(00) = 0
   POL(QUOT0(x_1, x_2)) = x_1 + x_2
   POL(log0(x_1)) = 1 + 2*x_1
   POL(minus(x_1)) = x_1
   POL(pred0(x_1)) = x_1
   POL(quot(x_1)) = x_1
   POL(s0(x_1)) = 1 + 2*x_1


----------------------------------------

(121)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   s0(pred0(x)) -> pred0(s0(x))
   quot(s0(x)) -> s0(quot(minus(x)))
   minus(x) -> pred0(minus(x))
   pred0(s0(x)) -> s0(pred0(x))
   log0(s0(s0(x))) -> s0(log0(s0(quot(x))))
   minus(x) -> x
   quot(00) -> 00

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(122) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(123)
YES

----------------------------------------

(124)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(0, s(y)) -> 0

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   log(s(s(x))) -> S(log(s(QUOT(x, s(s(0))))))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(125) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   log(s(s(x))) -> S(log(s(QUOT(x, s(s(0))))))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(0, s(y)) -> 0

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 2 + 2*x_1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 1 + 2*x_1 + x_1^2
   POL(QUOT(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(log(x_1)) = 2*x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 3 + 3*x_1

----------------------------------------

(126)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(0, s(y)) -> 0

and relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   pred(s(x)) -> x


----------------------------------------

(127) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(128)
TRUE

----------------------------------------

(129)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(MINUS(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(s(QUOT(x, S(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(130) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> s(log(s(QUOT(x, S(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(quot(MINUS(x, y), s(y)))

Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 1 + 2*x_1
   POL(MINUS(x_1, x_2)) = 0
   POL(PRED(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 2*x_1
   POL(log(x_1)) = 0
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 2*x_1

----------------------------------------

(131)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(MINUS(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(132) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(quot(MINUS(x, y), s(y)))

Relative ADPs:

   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 1 + 2*x_1
   POL(MINUS(x_1, x_2)) = 0
   POL(PRED(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 0
   POL(S(x_1)) = 1 + x_1
   POL(log(x_1)) = 1 + 2*x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 1 + 2*x_1

----------------------------------------

(133)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(MINUS(x, y), s(y)))

and relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(134) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(135)
TRUE

----------------------------------------

(136)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> S(quot(minus(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(137) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   quot(s(x), s(y)) -> S(quot(minus(x, y), s(y)))

Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 1 + 2*x_1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 1 + 2*x_1 + x_1^2
   POL(QUOT(x_1, x_2)) = x_1
   POL(S(x_1)) = 2*x_1
   POL(log(x_1)) = x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 3 + 3*x_1

----------------------------------------

(138)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(139) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(140)
YES

----------------------------------------

(141)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(0, s(y)) -> 0

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(S(QUOT(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(142) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   quot(0, s(y)) -> 0

Relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   pred(s(x)) -> x


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(0) = 2
   POL(LOG(x_1)) = 2*x_1
   POL(MINUS(x_1, x_2)) = 1 + x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = x_1
   POL(S(x_1)) = 0
   POL(log(x_1)) = x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 2*x_1

----------------------------------------

(143)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(S(QUOT(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(144) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(145)
YES

----------------------------------------

(146)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(s(QUOT(x, s(S(0))))))


----------------------------------------

(147) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(s(QUOT(x, s(S(0))))))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 2 + 2*x_1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 3 + 2*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 3
   POL(S(x_1)) = 1
   POL(log(x_1)) = 2*x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 2 + 3*x_1

----------------------------------------

(148)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))

and relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(149) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:s_1 = 
QUOT_2 = 
log_1 = 
0 = 
pred_1 = 
minus_2 = 1
quot_2 = 1

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
QUOT(x1, x2)  =  QUOT(x1, x2)

s(x1)  =  s(x1)

minus(x1, x2)  =  x1

pred(x1)  =  x1

0  =  0

quot(x1, x2)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: QUOT_2 > s_1 > 0

Status: QUOT_2: [1,2]
s_1: multiset status
0: multiset status


----------------------------------------

(150)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   QUOT0(s0(x), s0(y)) -> QUOT0(minus(x), s0(y))

The TRS R consists of the following rules:

   s0(pred0(x)) -> pred0(s0(x))
   log0(s0(00)) -> 00
   quot(s0(x)) -> s0(quot(minus(x)))
   minus(x) -> pred0(minus(x))
   pred0(s0(x)) -> s0(pred0(x))
   log0(s0(s0(x))) -> s0(log0(s0(quot(x))))
   minus(x) -> x
   quot(00) -> 00
   pred0(s0(x)) -> x

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(151) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   QUOT0(s0(x), s0(y)) -> QUOT0(minus(x), s0(y))

Strictly oriented rules of the TRS R:

   log0(s0(00)) -> 00
   pred0(s0(x)) -> x

Used ordering: Polynomial interpretation [POLO]:

   POL(00) = 0
   POL(QUOT0(x_1, x_2)) = x_1 + x_2
   POL(log0(x_1)) = 1 + 2*x_1
   POL(minus(x_1)) = x_1
   POL(pred0(x_1)) = x_1
   POL(quot(x_1)) = x_1
   POL(s0(x_1)) = 1 + 2*x_1


----------------------------------------

(152)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   s0(pred0(x)) -> pred0(s0(x))
   quot(s0(x)) -> s0(quot(minus(x)))
   minus(x) -> pred0(minus(x))
   pred0(s0(x)) -> s0(pred0(x))
   log0(s0(s0(x))) -> s0(log0(s0(quot(x))))
   minus(x) -> x
   quot(00) -> 00

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(153) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(154)
YES

----------------------------------------

(155)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   log(s(s(x))) -> S(log(s(QUOT(x, s(s(0))))))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(156) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> S(log(s(QUOT(x, s(s(0))))))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))

Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 2
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 0
   POL(S(x_1)) = 0
   POL(log(x_1)) = 0
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = 0
   POL(s(x_1)) = 2*x_1

----------------------------------------

(157)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(158) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 2 + 3*x_1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 3 + x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 1
   POL(S(x_1)) = 3 + x_1
   POL(log(x_1)) = 3 + 2*x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(159)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(QUOT(minus(x, y), s(y)))

and relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(160) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:s_1 = 
QUOT_2 = 
log_1 = 
0 = 
pred_1 = 
minus_2 = 1
quot_2 = 1

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
QUOT(x1, x2)  =  QUOT(x1, x2)

s(x1)  =  s(x1)

minus(x1, x2)  =  x1

pred(x1)  =  x1

0  =  0

quot(x1, x2)  =  x1


Recursive path order with status [RPO].
Quasi-Precedence: QUOT_2 > s_1 > 0

Status: QUOT_2: [1,2]
s_1: multiset status
0: multiset status


----------------------------------------

(161)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   QUOT0(s0(x), s0(y)) -> QUOT0(minus(x), s0(y))

The TRS R consists of the following rules:

   s0(pred0(x)) -> pred0(s0(x))
   log0(s0(00)) -> 00
   quot(s0(x)) -> s0(quot(minus(x)))
   minus(x) -> pred0(minus(x))
   pred0(s0(x)) -> s0(pred0(x))
   log0(s0(s0(x))) -> s0(log0(s0(quot(x))))
   minus(x) -> x
   quot(00) -> 00
   pred0(s0(x)) -> x

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(162) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   QUOT0(s0(x), s0(y)) -> QUOT0(minus(x), s0(y))

Strictly oriented rules of the TRS R:

   log0(s0(00)) -> 00
   pred0(s0(x)) -> x

Used ordering: Polynomial interpretation [POLO]:

   POL(00) = 0
   POL(QUOT0(x_1, x_2)) = x_1 + x_2
   POL(log0(x_1)) = 1 + 2*x_1
   POL(minus(x_1)) = x_1
   POL(pred0(x_1)) = x_1
   POL(quot(x_1)) = x_1
   POL(s0(x_1)) = 1 + 2*x_1


----------------------------------------

(163)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   s0(pred0(x)) -> pred0(s0(x))
   quot(s0(x)) -> s0(quot(minus(x)))
   minus(x) -> pred0(minus(x))
   pred0(s0(x)) -> s0(pred0(x))
   log0(s0(s0(x))) -> s0(log0(s0(quot(x))))
   minus(x) -> x
   quot(00) -> 00

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(164) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(165)
YES

----------------------------------------

(166)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> S(quot(minus(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(s(QUOT(x, S(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(167) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> s(log(s(QUOT(x, S(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> S(quot(minus(x, y), s(y)))

Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 1 + 2*x_1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 0
   POL(S(x_1)) = 0
   POL(log(x_1)) = 0
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 2*x_1

----------------------------------------

(168)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> S(quot(minus(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(169) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   quot(s(x), s(y)) -> S(quot(minus(x, y), s(y)))

Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 1 + 2*x_1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 1 + 2*x_1 + x_1^2
   POL(QUOT(x_1, x_2)) = x_1
   POL(S(x_1)) = 2*x_1
   POL(log(x_1)) = x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 3 + 3*x_1

----------------------------------------

(170)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(171) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(172)
YES

----------------------------------------

(173)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> S(quot(minus(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(s(QUOT(x, s(S(0))))))


----------------------------------------

(174) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   quot(s(x), s(y)) -> S(quot(minus(x, y), s(y)))

Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(s(QUOT(x, s(S(0))))))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(0) = 2
   POL(LOG(x_1)) = 3 + 3*x_1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 2 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 2 + 3*x_1
   POL(S(x_1)) = 3*x_1
   POL(log(x_1)) = 2*x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 3 + 3*x_1

----------------------------------------

(175)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(176) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(177)
YES

----------------------------------------

(178)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(s(QUOT(x, S(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(179) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> s(log(s(QUOT(x, S(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 0
   POL(S(x_1)) = 0
   POL(log(x_1)) = 2*x_1
   POL(minus(x_1, x_2)) = 2*x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = 0
   POL(s(x_1)) = 2*x_1

----------------------------------------

(180)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


----------------------------------------

(181) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(0) = 0
   POL(LOG(x_1)) = 1 + x_1
   POL(MINUS(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(PRED(x_1)) = 1 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 1 + x_1
   POL(S(x_1)) = 3
   POL(log(x_1)) = 2 + 2*x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 2 + 2*x_1

----------------------------------------

(182)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(minus(x, y), S(y)))

and relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(183) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(184)
TRUE

----------------------------------------

(185)
Obligation:
Relative ADP Problem with
absolute ADPs:

   quot(s(x), s(y)) -> s(quot(MINUS(x, y), s(y)))

and relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(s(QUOT(x, s(S(0))))))


----------------------------------------

(186) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   quot(s(x), s(y)) -> s(quot(MINUS(x, y), s(y)))

Relative ADPs:

   log(s(s(x))) -> s(LOG(s(quot(x, s(S(0))))))
   log(s(0)) -> 0
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   log(s(s(x))) -> s(LOG(s(QUOT(x, s(s(0))))))
   log(s(s(x))) -> s(LOG(S(quot(x, s(s(0))))))
   quot(0, s(y)) -> 0
   pred(s(x)) -> x
   log(s(s(x))) -> s(LOG(s(quot(x, S(s(0))))))
   s(pred(x)) -> pred(s(x))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   log(s(s(x))) -> S(LOG(s(quot(x, s(s(0))))))
   log(s(s(x))) -> s(log(s(QUOT(x, s(S(0))))))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(0) = 2
   POL(LOG(x_1)) = 3*x_1
   POL(MINUS(x_1, x_2)) = 0
   POL(PRED(x_1)) = 1 + 3*x_1 + 3*x_1^2
   POL(QUOT(x_1, x_2)) = 2 + 2*x_1
   POL(S(x_1)) = x_1
   POL(log(x_1)) = 2*x_1
   POL(minus(x_1, x_2)) = x_1
   POL(pred(x_1)) = x_1
   POL(quot(x_1, x_2)) = x_1
   POL(s(x_1)) = 2 + 2*x_1

----------------------------------------

(187)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   log(s(0)) -> 0
   s(pred(x)) -> pred(s(x))
   quot(s(x), s(y)) -> s(quot(minus(x, y), s(y)))
   minus(x, s(y)) -> pred(minus(x, y))
   pred(s(x)) -> s(pred(x))
   log(s(s(x))) -> s(log(s(quot(x, s(s(0))))))
   minus(x, 0) -> x
   quot(0, s(y)) -> 0
   pred(s(x)) -> x


----------------------------------------

(188) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(189)
YES
