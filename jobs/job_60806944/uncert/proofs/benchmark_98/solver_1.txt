YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/w4VEe.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given RelTRS could be proven:

(0) RelTRS
(1) RelTRStoRelADPProof [EQUIVALENT, 0 ms]
(2) RelADPP
(3) RelADPDepGraphProof [EQUIVALENT, 0 ms]
(4) AND
    (5) RelADPP
        (6) RelADPRuleRemovalProof [EQUIVALENT, 4 ms]
        (7) RelADPP
        (8) RelADPRuleRemovalProof [EQUIVALENT, 0 ms]
        (9) RelADPP
        (10) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (11) YES
    (12) RelADPP
        (13) RelADPRuleRemovalProof [EQUIVALENT, 5 ms]
        (14) RelADPP
        (15) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (16) YES
    (17) RelADPP
        (18) RelADPRuleRemovalProof [EQUIVALENT, 6 ms]
        (19) RelADPP
        (20) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (21) YES
    (22) RelADPP
        (23) RelADPRuleRemovalProof [EQUIVALENT, 3 ms]
        (24) RelADPP
        (25) RelADPRuleRemovalProof [EQUIVALENT, 0 ms]
        (26) RelADPP
        (27) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (28) YES
    (29) RelADPP
        (30) RelADPReductionPairProof [EQUIVALENT, 20 ms]
        (31) RelADPP
        (32) RelADPReductionPairProof [EQUIVALENT, 3 ms]
        (33) RelADPP
        (34) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (35) YES
    (36) RelADPP
        (37) RelADPReductionPairProof [EQUIVALENT, 24 ms]
        (38) RelADPP
        (39) RelADPRuleRemovalProof [EQUIVALENT, 2 ms]
        (40) RelADPP
        (41) RelADPRuleRemovalProof [EQUIVALENT, 0 ms]
        (42) RelADPP
        (43) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (44) YES
    (45) RelADPP
        (46) RelADPReductionPairProof [EQUIVALENT, 16 ms]
        (47) RelADPP
        (48) RelADPRuleRemovalProof [EQUIVALENT, 3 ms]
        (49) RelADPP
        (50) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (51) YES
    (52) RelADPP
        (53) RelADPReductionPairProof [EQUIVALENT, 15 ms]
        (54) RelADPP
        (55) RelADPReductionPairProof [EQUIVALENT, 4 ms]
        (56) RelADPP
        (57) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (58) YES
    (59) RelADPP
        (60) RelADPReductionPairProof [EQUIVALENT, 18 ms]
        (61) RelADPP
        (62) RelADPRuleRemovalProof [EQUIVALENT, 1 ms]
        (63) RelADPP
        (64) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (65) YES
    (66) RelADPP
        (67) RelADPReductionPairProof [EQUIVALENT, 18 ms]
        (68) RelADPP
        (69) RelADPRuleRemovalProof [EQUIVALENT, 3 ms]
        (70) RelADPP
        (71) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (72) YES
    (73) RelADPP
        (74) RelADPReductionPairProof [EQUIVALENT, 16 ms]
        (75) RelADPP
        (76) RelADPRuleRemovalProof [EQUIVALENT, 3 ms]
        (77) RelADPP
        (78) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (79) YES
    (80) RelADPP
        (81) RelADPReductionPairProof [EQUIVALENT, 20 ms]
        (82) RelADPP
        (83) RelADPReductionPairProof [EQUIVALENT, 2 ms]
        (84) RelADPP
        (85) RelADPCleverAfsProof [SOUND, 1 ms]
        (86) QDP
        (87) MRRProof [EQUIVALENT, 2 ms]
        (88) QDP
        (89) MRRProof [EQUIVALENT, 0 ms]
        (90) QDP
        (91) PisEmptyProof [EQUIVALENT, 0 ms]
        (92) YES
    (93) RelADPP
        (94) RelADPReductionPairProof [EQUIVALENT, 20 ms]
        (95) RelADPP
        (96) RelADPReductionPairProof [EQUIVALENT, 4 ms]
        (97) RelADPP
        (98) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (99) TRUE
    (100) RelADPP
        (101) RelADPReductionPairProof [EQUIVALENT, 14 ms]
        (102) RelADPP
        (103) RelADPRuleRemovalProof [EQUIVALENT, 2 ms]
        (104) RelADPP
        (105) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (106) YES
    (107) RelADPP
        (108) RelADPReductionPairProof [EQUIVALENT, 25 ms]
        (109) RelADPP
        (110) RelADPRuleRemovalProof [EQUIVALENT, 3 ms]
        (111) RelADPP
        (112) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (113) YES
    (114) RelADPP
        (115) RelADPReductionPairProof [EQUIVALENT, 18 ms]
        (116) RelADPP
        (117) RelADPReductionPairProof [EQUIVALENT, 4 ms]
        (118) RelADPP
        (119) RelADPCleverAfsProof [SOUND, 0 ms]
        (120) QDP
        (121) MRRProof [EQUIVALENT, 2 ms]
        (122) QDP
        (123) MRRProof [EQUIVALENT, 0 ms]
        (124) QDP
        (125) PisEmptyProof [EQUIVALENT, 0 ms]
        (126) YES
    (127) RelADPP
        (128) RelADPReductionPairProof [EQUIVALENT, 18 ms]
        (129) RelADPP
        (130) RelADPRuleRemovalProof [EQUIVALENT, 2 ms]
        (131) RelADPP
        (132) RelADPRuleRemovalProof [EQUIVALENT, 0 ms]
        (133) RelADPP
        (134) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (135) YES
    (136) RelADPP
        (137) RelADPReductionPairProof [EQUIVALENT, 24 ms]
        (138) RelADPP
        (139) RelADPRuleRemovalProof [EQUIVALENT, 2 ms]
        (140) RelADPP
        (141) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (142) YES
    (143) RelADPP
        (144) RelADPReductionPairProof [EQUIVALENT, 19 ms]
        (145) RelADPP
        (146) RelADPRuleRemovalProof [EQUIVALENT, 1 ms]
        (147) RelADPP
        (148) RelADPRuleRemovalProof [EQUIVALENT, 0 ms]
        (149) RelADPP
        (150) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (151) YES
    (152) RelADPP
        (153) RelADPReductionPairProof [EQUIVALENT, 19 ms]
        (154) RelADPP
        (155) RelADPReductionPairProof [EQUIVALENT, 5 ms]
        (156) RelADPP
        (157) RelADPCleverAfsProof [SOUND, 0 ms]
        (158) QDP
        (159) MRRProof [EQUIVALENT, 1 ms]
        (160) QDP
        (161) MRRProof [EQUIVALENT, 0 ms]
        (162) QDP
        (163) PisEmptyProof [EQUIVALENT, 0 ms]
        (164) YES
    (165) RelADPP
        (166) RelADPReductionPairProof [EQUIVALENT, 19 ms]
        (167) RelADPP
        (168) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (169) TRUE
    (170) RelADPP
        (171) RelADPReductionPairProof [EQUIVALENT, 19 ms]
        (172) RelADPP
        (173) RelADPRuleRemovalProof [EQUIVALENT, 3 ms]
        (174) RelADPP
        (175) RelADPRuleRemovalProof [EQUIVALENT, 2 ms]
        (176) RelADPP
        (177) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (178) YES
    (179) RelADPP
        (180) RelADPReductionPairProof [EQUIVALENT, 28 ms]
        (181) RelADPP
        (182) RelADPReductionPairProof [EQUIVALENT, 3 ms]
        (183) RelADPP
        (184) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (185) YES
    (186) RelADPP
        (187) RelADPReductionPairProof [EQUIVALENT, 21 ms]
        (188) RelADPP
        (189) RelADPRuleRemovalProof [EQUIVALENT, 4 ms]
        (190) RelADPP
        (191) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (192) YES
    (193) RelADPP
        (194) RelADPReductionPairProof [EQUIVALENT, 21 ms]
        (195) RelADPP
        (196) RelADPRuleRemovalProof [EQUIVALENT, 3 ms]
        (197) RelADPP
        (198) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (199) YES
    (200) RelADPP
        (201) RelADPReductionPairProof [EQUIVALENT, 14 ms]
        (202) RelADPP
        (203) RelADPRuleRemovalProof [EQUIVALENT, 2 ms]
        (204) RelADPP
        (205) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (206) YES
    (207) RelADPP
        (208) RelADPReductionPairProof [EQUIVALENT, 20 ms]
        (209) RelADPP
        (210) RelADPRuleRemovalProof [EQUIVALENT, 2 ms]
        (211) RelADPP
        (212) RelADPRuleRemovalProof [EQUIVALENT, 0 ms]
        (213) RelADPP
        (214) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (215) YES
    (216) RelADPP
        (217) RelADPReductionPairProof [EQUIVALENT, 23 ms]
        (218) RelADPP
        (219) RelADPRuleRemovalProof [EQUIVALENT, 3 ms]
        (220) RelADPP
        (221) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (222) YES
    (223) RelADPP
        (224) RelADPReductionPairProof [EQUIVALENT, 16 ms]
        (225) RelADPP
        (226) RelADPReductionPairProof [EQUIVALENT, 5 ms]
        (227) RelADPP
        (228) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (229) YES
    (230) RelADPP
        (231) RelADPReductionPairProof [EQUIVALENT, 17 ms]
        (232) RelADPP
        (233) RelADPCleverAfsProof [SOUND, 4 ms]
        (234) QDP
        (235) MRRProof [EQUIVALENT, 7 ms]
        (236) QDP
        (237) MRRProof [EQUIVALENT, 1 ms]
        (238) QDP
        (239) PisEmptyProof [EQUIVALENT, 0 ms]
        (240) YES
    (241) RelADPP
        (242) RelADPReductionPairProof [EQUIVALENT, 20 ms]
        (243) RelADPP
        (244) RelADPRuleRemovalProof [EQUIVALENT, 3 ms]
        (245) RelADPP
        (246) RelADPRuleRemovalProof [EQUIVALENT, 3 ms]
        (247) RelADPP
        (248) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (249) YES
    (250) RelADPP
        (251) RelADPReductionPairProof [EQUIVALENT, 24 ms]
        (252) RelADPP
        (253) RelADPRuleRemovalProof [EQUIVALENT, 3 ms]
        (254) RelADPP
        (255) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (256) YES
    (257) RelADPP
        (258) RelADPReductionPairProof [EQUIVALENT, 18 ms]
        (259) RelADPP
        (260) RelADPReductionPairProof [EQUIVALENT, 2 ms]
        (261) RelADPP
        (262) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (263) YES
    (264) RelADPP
        (265) RelADPReductionPairProof [EQUIVALENT, 28 ms]
        (266) RelADPP
        (267) RelADPRuleRemovalProof [EQUIVALENT, 4 ms]
        (268) RelADPP
        (269) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (270) YES
    (271) RelADPP
        (272) RelADPReductionPairProof [EQUIVALENT, 19 ms]
        (273) RelADPP
        (274) RelADPReductionPairProof [EQUIVALENT, 4 ms]
        (275) RelADPP
        (276) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (277) YES
    (278) RelADPP
        (279) RelADPReductionPairProof [EQUIVALENT, 26 ms]
        (280) RelADPP
        (281) RelADPRuleRemovalProof [EQUIVALENT, 2 ms]
        (282) RelADPP
        (283) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (284) YES


----------------------------------------

(0)
Obligation:
Relative term rewrite system:
The relative TRS consists of the following R rules:

   s(a(x)) -> s(b(x))
   b(b(x)) -> a(x)

The relative TRS consists of the following S rules:

   f(s(x), y) -> f(x, s(y))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))


----------------------------------------

(1) RelTRStoRelADPProof (EQUIVALENT)


We upgrade the RelTRS problem to an equivalent Relative ADP Problem [IJCAR24].

----------------------------------------

(2)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))
   s(a(x)) -> s(B(x))
   b(b(x)) -> A(x)

and relative ADPs:

   f(s(x), y) -> F(x, S(y))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))
   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))


----------------------------------------

(3) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  35 Lassos,
Result: This relative DT problem is equivalent to 36 subproblems.

----------------------------------------

(4)
Complex Obligation (AND)

----------------------------------------

(5)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))
   b(b(x)) -> A(x)
   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))


----------------------------------------

(6) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   b(b(x)) -> A(x)

c:

   s(a(x)) -> s(B(x))
   s(a(x)) -> S(b(x))

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(f(x_1, x_2)) = x_1 + x_2
   POL(s(x_1)) = 1 + x_1

----------------------------------------

(7)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))
   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))


----------------------------------------

(8) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   s(a(x)) -> s(B(x))
   s(a(x)) -> S(b(x))

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 3*x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 2*x_1 + x_2
   POL(s(x_1)) = x_1

----------------------------------------

(9)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))


----------------------------------------

(10) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(11)
YES

----------------------------------------

(12)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(x)) -> A(x)

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))


----------------------------------------

(13) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   b(b(x)) -> A(x)

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(f(x_1, x_2)) = 2*x_1 + x_2
   POL(s(x_1)) = x_1

----------------------------------------

(14)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))


----------------------------------------

(15) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(16)
YES

----------------------------------------

(17)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))
   b(b(x)) -> a(x)


----------------------------------------

(18) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   s(a(x)) -> s(B(x))

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   b(b(x)) -> a(x)

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(f(x_1, x_2)) = 3*x_1 + 2*x_2
   POL(s(x_1)) = 3 + x_1

----------------------------------------

(19)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))


----------------------------------------

(20) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(21)
YES

----------------------------------------

(22)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))
   b(b(x)) -> a(x)


----------------------------------------

(23) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   b(b(x)) -> a(x)

c:

   s(a(x)) -> S(b(x))

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(f(x_1, x_2)) = x_1 + x_2
   POL(s(x_1)) = 1 + x_1

----------------------------------------

(24)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))


----------------------------------------

(25) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   s(a(x)) -> S(b(x))

   s(a(x)) -> s(b(x))

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 3*x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 2*x_1 + x_2
   POL(s(x_1)) = x_1

----------------------------------------

(26)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))


----------------------------------------

(27) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(28)
YES

----------------------------------------

(29)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(30) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> s(B(x))

Relative ADPs:

   s(a(x)) -> A(S(x))
   s(b(x)) -> B(S(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(31)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(32) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   s(a(x)) -> s(B(x))

Relative ADPs:

   s(a(x)) -> A(S(x))
   s(b(x)) -> B(S(x))
   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + x_2
   POL(S(x_1)) = 3*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(f(x_1, x_2)) = 0
   POL(s(x_1)) = 2 + 2*x_1

----------------------------------------

(33)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(34) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(35)
YES

----------------------------------------

(36)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(37) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> S(b(x))

Relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 2*x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(38)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))
   b(b(x)) -> a(x)


----------------------------------------

(39) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   b(b(x)) -> a(x)

c:

   s(a(x)) -> S(b(x))

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(f(x_1, x_2)) = x_1 + x_2
   POL(s(x_1)) = 1 + x_1

----------------------------------------

(40)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))


----------------------------------------

(41) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   s(a(x)) -> S(b(x))

   s(a(x)) -> s(b(x))

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 3*x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 2*x_1 + x_2
   POL(s(x_1)) = x_1

----------------------------------------

(42)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))


----------------------------------------

(43) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(44)
YES

----------------------------------------

(45)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(46) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> s(B(x))

Relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 0
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(47)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   b(b(x)) -> a(x)


----------------------------------------

(48) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   s(a(x)) -> s(B(x))

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   b(b(x)) -> a(x)

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(f(x_1, x_2)) = 3*x_1 + 2*x_2
   POL(s(x_1)) = 3 + x_1

----------------------------------------

(49)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))


----------------------------------------

(50) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(51)
YES

----------------------------------------

(52)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(53) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> s(B(x))

Relative ADPs:

   s(a(x)) -> A(S(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(54)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(55) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   s(a(x)) -> s(B(x))

Relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1
   POL(B(x_1)) = x_1
   POL(F(x_1, x_2)) = 1 + 3*x_1 + 3*x_1*x_2 + 2*x_2
   POL(S(x_1)) = 2*x_1
   POL(a(x_1)) = 1 + 2*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(f(x_1, x_2)) = 2*x_1
   POL(s(x_1)) = 1 + 2*x_1

----------------------------------------

(56)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(57) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(58)
YES

----------------------------------------

(59)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(60) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> s(B(x))

Relative ADPs:

   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1 + x_1^2
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 2*x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(61)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(62) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   s(a(x)) -> s(B(x))

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   b(b(x)) -> a(x)

c:

Ordered with Polynomial interpretation [POLO]:

   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(f(x_1, x_2)) = 3*x_1 + 2*x_2
   POL(s(x_1)) = 3 + x_1

----------------------------------------

(63)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))


----------------------------------------

(64) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(65)
YES

----------------------------------------

(66)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(x)) -> A(x)

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> s(b(x))
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(67) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   b(s(x)) -> s(b(x))
   f(s(x), y) -> F(x, S(y))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(x)) -> A(x)

Relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(68)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(x)) -> A(x)

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))


----------------------------------------

(69) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   b(b(x)) -> A(x)

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(f(x_1, x_2)) = 2*x_1 + x_2
   POL(s(x_1)) = x_1

----------------------------------------

(70)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))


----------------------------------------

(71) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(72)
YES

----------------------------------------

(73)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> s(b(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(74) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   b(s(x)) -> s(b(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> s(B(x))

Relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 0
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(75)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))
   b(b(x)) -> a(x)


----------------------------------------

(76) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   s(a(x)) -> s(B(x))

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   b(b(x)) -> a(x)

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(f(x_1, x_2)) = 3*x_1 + 2*x_2
   POL(s(x_1)) = 3 + x_1

----------------------------------------

(77)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> s(b(x))


----------------------------------------

(78) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(79)
YES

----------------------------------------

(80)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(81) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> S(b(x))

Relative ADPs:

   s(a(x)) -> A(S(x))
   s(b(x)) -> B(S(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 0
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(82)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(83) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> A(S(x))
   s(b(x)) -> B(S(x))
   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> S(b(x))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 1 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(S(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(f(x_1, x_2)) = x_1
   POL(s(x_1)) = 1 + 2*x_1

----------------------------------------

(84)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(85) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:s_1 = 
a_1 = 
b_1 = 
S_1 = 
f_2 = 0, 1

Found this filtering by looking at the following order that orders at least one DP strictly:Polynomial interpretation [POLO]:

   POL(S(x_1)) = x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(f(x_1, x_2)) = 0
   POL(s(x_1)) = x_1

----------------------------------------

(86)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   S0(a0(x)) -> S0(b0(x))

The TRS R consists of the following rules:

   s0(a0(x)) -> s0(b0(x))
   f -> f
   s0(b0(x)) -> b0(s0(x))
   b0(s0(x)) -> s0(b0(x))
   s0(a0(x)) -> a0(s0(x))
   a0(s0(x)) -> s0(a0(x))
   b0(b0(x)) -> a0(x)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(87) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.


Strictly oriented rules of the TRS R:

   b0(b0(x)) -> a0(x)

Used ordering: Polynomial interpretation [POLO]:

   POL(S0(x_1)) = x_1
   POL(a0(x_1)) = 1 + x_1
   POL(b0(x_1)) = 1 + x_1
   POL(f) = 0
   POL(s0(x_1)) = x_1


----------------------------------------

(88)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   S0(a0(x)) -> S0(b0(x))

The TRS R consists of the following rules:

   s0(a0(x)) -> s0(b0(x))
   f -> f
   s0(b0(x)) -> b0(s0(x))
   b0(s0(x)) -> s0(b0(x))
   s0(a0(x)) -> a0(s0(x))
   a0(s0(x)) -> s0(a0(x))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(89) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   S0(a0(x)) -> S0(b0(x))

Strictly oriented rules of the TRS R:

   s0(a0(x)) -> s0(b0(x))

Used ordering: Polynomial interpretation [POLO]:

   POL(S0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = x_1
   POL(f) = 0
   POL(s0(x_1)) = 1 + 2*x_1


----------------------------------------

(90)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   f -> f
   s0(b0(x)) -> b0(s0(x))
   b0(s0(x)) -> s0(b0(x))
   s0(a0(x)) -> a0(s0(x))
   a0(s0(x)) -> s0(a0(x))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(91) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(92)
YES

----------------------------------------

(93)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(x)) -> A(x)

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(94) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(x)) -> A(x)

Relative ADPs:

   s(a(x)) -> A(S(x))
   s(b(x)) -> B(S(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 2*x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(95)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(x)) -> A(x)

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))


----------------------------------------

(96) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> A(S(x))
   s(b(x)) -> B(S(x))
   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(x)) -> A(x)

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1
   POL(B(x_1)) = 1
   POL(F(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(S(x_1)) = 3 + 2*x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(f(x_1, x_2)) = 0
   POL(s(x_1)) = x_1

----------------------------------------

(97)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(x)) -> A(x)

and relative ADPs:

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))


----------------------------------------

(98) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(99)
TRUE

----------------------------------------

(100)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(x)) -> A(x)

and relative ADPs:

   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(101) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(x)) -> A(x)

Relative ADPs:

   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(102)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(x)) -> A(x)

and relative ADPs:

   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))


----------------------------------------

(103) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   b(b(x)) -> A(x)

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(f(x_1, x_2)) = 2*x_1 + x_2
   POL(s(x_1)) = x_1

----------------------------------------

(104)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))


----------------------------------------

(105) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(106)
YES

----------------------------------------

(107)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(108) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> s(B(x))

Relative ADPs:

   s(a(x)) -> A(S(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 2*x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(109)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(110) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   s(a(x)) -> s(B(x))

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   b(b(x)) -> a(x)

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(f(x_1, x_2)) = 3*x_1 + 2*x_2
   POL(s(x_1)) = 3 + x_1

----------------------------------------

(111)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> A(S(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))
   a(s(x)) -> s(a(x))


----------------------------------------

(112) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(113)
YES

----------------------------------------

(114)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(115) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> S(b(x))

Relative ADPs:

   s(b(x)) -> B(S(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 3*x_1 + 3*x_1^2
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 2*x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(116)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(117) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(b(x)) -> B(S(x))
   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> S(b(x))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1 + 2*x_1^2
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(S(x_1)) = 3 + 2*x_1
   POL(a(x_1)) = 3 + 2*x_1
   POL(b(x_1)) = 3 + 2*x_1
   POL(f(x_1, x_2)) = 3*x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(118)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(119) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:s_1 = 
a_1 = 
b_1 = 
S_1 = 
f_2 = 0, 1

Found this filtering by looking at the following order that orders at least one DP strictly:Polynomial interpretation [POLO]:

   POL(S(x_1)) = x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(f(x_1, x_2)) = 0
   POL(s(x_1)) = x_1

----------------------------------------

(120)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   S0(a0(x)) -> S0(b0(x))

The TRS R consists of the following rules:

   s0(a0(x)) -> s0(b0(x))
   f -> f
   s0(b0(x)) -> b0(s0(x))
   b0(s0(x)) -> s0(b0(x))
   s0(a0(x)) -> a0(s0(x))
   a0(s0(x)) -> s0(a0(x))
   b0(b0(x)) -> a0(x)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(121) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.


Strictly oriented rules of the TRS R:

   b0(b0(x)) -> a0(x)

Used ordering: Polynomial interpretation [POLO]:

   POL(S0(x_1)) = x_1
   POL(a0(x_1)) = 1 + x_1
   POL(b0(x_1)) = 1 + x_1
   POL(f) = 0
   POL(s0(x_1)) = x_1


----------------------------------------

(122)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   S0(a0(x)) -> S0(b0(x))

The TRS R consists of the following rules:

   s0(a0(x)) -> s0(b0(x))
   f -> f
   s0(b0(x)) -> b0(s0(x))
   b0(s0(x)) -> s0(b0(x))
   s0(a0(x)) -> a0(s0(x))
   a0(s0(x)) -> s0(a0(x))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(123) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   S0(a0(x)) -> S0(b0(x))

Strictly oriented rules of the TRS R:

   s0(a0(x)) -> s0(b0(x))

Used ordering: Polynomial interpretation [POLO]:

   POL(S0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = x_1
   POL(f) = 0
   POL(s0(x_1)) = 1 + 2*x_1


----------------------------------------

(124)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   f -> f
   s0(b0(x)) -> b0(s0(x))
   b0(s0(x)) -> s0(b0(x))
   s0(a0(x)) -> a0(s0(x))
   a0(s0(x)) -> s0(a0(x))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(125) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(126)
YES

----------------------------------------

(127)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(128) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> S(b(x))

Relative ADPs:

   s(a(x)) -> A(S(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 2*x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(129)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(130) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   b(b(x)) -> a(x)

c:

   s(a(x)) -> S(b(x))

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))
   a(s(x)) -> s(a(x))

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(f(x_1, x_2)) = x_1 + x_2
   POL(s(x_1)) = 1 + x_1

----------------------------------------

(131)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))
   a(s(x)) -> s(a(x))


----------------------------------------

(132) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   s(a(x)) -> S(b(x))

   s(a(x)) -> s(b(x))

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 3*x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 2*x_1 + x_2
   POL(s(x_1)) = x_1

----------------------------------------

(133)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> A(S(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))
   a(s(x)) -> s(a(x))


----------------------------------------

(134) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(135)
YES

----------------------------------------

(136)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(137) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> S(b(x))

Relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 3 + 3*x_1 + x_1^2
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 2*x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(138)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   b(b(x)) -> a(x)


----------------------------------------

(139) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   s(a(x)) -> S(b(x))

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   b(b(x)) -> a(x)

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(f(x_1, x_2)) = 3*x_1 + 2*x_2
   POL(s(x_1)) = 3 + x_1

----------------------------------------

(140)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))


----------------------------------------

(141) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(142)
YES

----------------------------------------

(143)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(144) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> S(b(x))

Relative ADPs:

   s(a(x)) -> A(S(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 2*x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(145)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(146) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   b(b(x)) -> a(x)

c:

   s(a(x)) -> S(b(x))

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))
   a(s(x)) -> s(a(x))

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(f(x_1, x_2)) = x_1 + x_2
   POL(s(x_1)) = 1 + x_1

----------------------------------------

(147)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))
   a(s(x)) -> s(a(x))


----------------------------------------

(148) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   s(a(x)) -> S(b(x))

   s(a(x)) -> s(b(x))

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 3*x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 2*x_1 + x_2
   POL(s(x_1)) = x_1

----------------------------------------

(149)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> A(S(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))
   a(s(x)) -> s(a(x))


----------------------------------------

(150) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(151)
YES

----------------------------------------

(152)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(153) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> S(b(x))

Relative ADPs:

   s(a(x)) -> A(S(x))
   s(b(x)) -> B(S(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 0
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(154)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(155) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> A(S(x))
   s(b(x)) -> B(S(x))
   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> S(b(x))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 1 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(S(x_1)) = 3 + 3*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 2 + 3*x_1
   POL(f(x_1, x_2)) = x_1
   POL(s(x_1)) = 1 + 2*x_1

----------------------------------------

(156)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(157) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:s_1 = 
a_1 = 
b_1 = 
S_1 = 
f_2 = 0, 1

Found this filtering by looking at the following order that orders at least one DP strictly:Polynomial interpretation [POLO]:

   POL(S(x_1)) = x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(f(x_1, x_2)) = 0
   POL(s(x_1)) = x_1

----------------------------------------

(158)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   S0(a0(x)) -> S0(b0(x))

The TRS R consists of the following rules:

   s0(a0(x)) -> s0(b0(x))
   f -> f
   s0(b0(x)) -> b0(s0(x))
   b0(s0(x)) -> s0(b0(x))
   s0(a0(x)) -> a0(s0(x))
   a0(s0(x)) -> s0(a0(x))
   b0(b0(x)) -> a0(x)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(159) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.


Strictly oriented rules of the TRS R:

   b0(b0(x)) -> a0(x)

Used ordering: Polynomial interpretation [POLO]:

   POL(S0(x_1)) = x_1
   POL(a0(x_1)) = 1 + x_1
   POL(b0(x_1)) = 1 + x_1
   POL(f) = 0
   POL(s0(x_1)) = x_1


----------------------------------------

(160)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   S0(a0(x)) -> S0(b0(x))

The TRS R consists of the following rules:

   s0(a0(x)) -> s0(b0(x))
   f -> f
   s0(b0(x)) -> b0(s0(x))
   b0(s0(x)) -> s0(b0(x))
   s0(a0(x)) -> a0(s0(x))
   a0(s0(x)) -> s0(a0(x))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(161) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   S0(a0(x)) -> S0(b0(x))

Strictly oriented rules of the TRS R:

   s0(a0(x)) -> s0(b0(x))

Used ordering: Polynomial interpretation [POLO]:

   POL(S0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = x_1
   POL(f) = 0
   POL(s0(x_1)) = 1 + 2*x_1


----------------------------------------

(162)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   f -> f
   s0(b0(x)) -> b0(s0(x))
   b0(s0(x)) -> s0(b0(x))
   s0(a0(x)) -> a0(s0(x))
   a0(s0(x)) -> s0(a0(x))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(163) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(164)
YES

----------------------------------------

(165)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> s(b(x))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(166) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> s(B(x))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 2*x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(167)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(168) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(169)
TRUE

----------------------------------------

(170)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(171) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> S(b(x))

Relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 2*x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(172)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))
   b(b(x)) -> a(x)


----------------------------------------

(173) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   b(b(x)) -> a(x)

c:

   s(a(x)) -> S(b(x))

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(f(x_1, x_2)) = x_1 + x_2
   POL(s(x_1)) = 1 + x_1

----------------------------------------

(174)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))


----------------------------------------

(175) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   s(a(x)) -> S(b(x))

   s(a(x)) -> s(b(x))

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 3*x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 2*x_1 + x_2
   POL(s(x_1)) = x_1

----------------------------------------

(176)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))


----------------------------------------

(177) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(178)
YES

----------------------------------------

(179)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(180) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> s(B(x))

Relative ADPs:

   s(b(x)) -> B(S(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + x_1 + 3*x_1^2
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 2*x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(181)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(182) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   s(a(x)) -> s(B(x))

Relative ADPs:

   s(b(x)) -> B(S(x))
   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1 + 3*x_1^2
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 1 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(S(x_1)) = 2*x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(f(x_1, x_2)) = x_1
   POL(s(x_1)) = 1 + 2*x_1

----------------------------------------

(183)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(184) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(185)
YES

----------------------------------------

(186)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(187) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> s(B(x))

Relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(188)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))
   b(b(x)) -> a(x)


----------------------------------------

(189) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   s(a(x)) -> s(B(x))

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   b(b(x)) -> a(x)

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(f(x_1, x_2)) = 3*x_1 + 2*x_2
   POL(s(x_1)) = 3 + x_1

----------------------------------------

(190)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))


----------------------------------------

(191) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(192)
YES

----------------------------------------

(193)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(194) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> s(B(x))

Relative ADPs:

   s(a(x)) -> A(S(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 2*x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(195)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(196) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   s(a(x)) -> s(B(x))

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   b(b(x)) -> a(x)

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(f(x_1, x_2)) = 3*x_1 + 2*x_2
   POL(s(x_1)) = 3 + x_1

----------------------------------------

(197)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> A(S(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))
   a(s(x)) -> s(a(x))


----------------------------------------

(198) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(199)
YES

----------------------------------------

(200)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(x)) -> A(x)

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(201) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(x)) -> A(x)

Relative ADPs:

   s(a(x)) -> A(S(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(202)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(x)) -> A(x)

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))
   a(s(x)) -> s(a(x))


----------------------------------------

(203) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   b(b(x)) -> A(x)

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(f(x_1, x_2)) = 2*x_1 + x_2
   POL(s(x_1)) = x_1

----------------------------------------

(204)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))
   a(s(x)) -> s(a(x))


----------------------------------------

(205) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(206)
YES

----------------------------------------

(207)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> s(b(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(208) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   b(s(x)) -> s(b(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> S(b(x))

Relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 0
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(209)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))
   b(b(x)) -> a(x)


----------------------------------------

(210) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   b(b(x)) -> a(x)

c:

   s(a(x)) -> S(b(x))

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(f(x_1, x_2)) = x_1 + x_2
   POL(s(x_1)) = 1 + x_1

----------------------------------------

(211)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))


----------------------------------------

(212) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   s(a(x)) -> S(b(x))

   s(a(x)) -> s(b(x))

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 3*x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 2*x_1 + x_2
   POL(s(x_1)) = x_1

----------------------------------------

(213)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))


----------------------------------------

(214) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(215)
YES

----------------------------------------

(216)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(217) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> s(B(x))

Relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(218)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))
   b(b(x)) -> a(x)


----------------------------------------

(219) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   s(a(x)) -> s(B(x))

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   b(b(x)) -> a(x)

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(f(x_1, x_2)) = 3*x_1 + 2*x_2
   POL(s(x_1)) = 3 + x_1

----------------------------------------

(220)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))


----------------------------------------

(221) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(222)
YES

----------------------------------------

(223)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(224) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> S(b(x))

Relative ADPs:

   s(a(x)) -> A(S(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 3 + 3*x_1 + x_1^2
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 0
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(225)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(226) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   s(a(x)) -> S(b(x))

Relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(F(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(S(x_1)) = 3 + x_1
   POL(a(x_1)) = 2 + 3*x_1
   POL(b(x_1)) = 1 + 2*x_1
   POL(f(x_1, x_2)) = 2*x_1
   POL(s(x_1)) = 1 + 2*x_1

----------------------------------------

(227)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(228) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(229)
YES

----------------------------------------

(230)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> s(b(x))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(231) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> S(b(x))

Relative ADPs:
none


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 2 + 3*x_1 + 3*x_1^2
   POL(B(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 0
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(232)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(233) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:s_1 = 
a_1 = 
b_1 = 
S_1 = 
f_2 = 0, 1

Found this filtering by looking at the following order that orders at least one DP strictly:Polynomial interpretation [POLO]:

   POL(S(x_1)) = x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(f(x_1, x_2)) = 0
   POL(s(x_1)) = x_1

----------------------------------------

(234)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   S0(a0(x)) -> S0(b0(x))

The TRS R consists of the following rules:

   s0(a0(x)) -> s0(b0(x))
   f -> f
   s0(b0(x)) -> b0(s0(x))
   b0(s0(x)) -> s0(b0(x))
   s0(a0(x)) -> a0(s0(x))
   a0(s0(x)) -> s0(a0(x))
   b0(b0(x)) -> a0(x)

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(235) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.


Strictly oriented rules of the TRS R:

   b0(b0(x)) -> a0(x)

Used ordering: Polynomial interpretation [POLO]:

   POL(S0(x_1)) = x_1
   POL(a0(x_1)) = 1 + x_1
   POL(b0(x_1)) = 1 + x_1
   POL(f) = 0
   POL(s0(x_1)) = x_1


----------------------------------------

(236)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   S0(a0(x)) -> S0(b0(x))

The TRS R consists of the following rules:

   s0(a0(x)) -> s0(b0(x))
   f -> f
   s0(b0(x)) -> b0(s0(x))
   b0(s0(x)) -> s0(b0(x))
   s0(a0(x)) -> a0(s0(x))
   a0(s0(x)) -> s0(a0(x))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(237) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   S0(a0(x)) -> S0(b0(x))

Strictly oriented rules of the TRS R:

   s0(a0(x)) -> s0(b0(x))

Used ordering: Polynomial interpretation [POLO]:

   POL(S0(x_1)) = x_1
   POL(a0(x_1)) = 1 + 2*x_1
   POL(b0(x_1)) = x_1
   POL(f) = 0
   POL(s0(x_1)) = 1 + 2*x_1


----------------------------------------

(238)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   f -> f
   s0(b0(x)) -> b0(s0(x))
   b0(s0(x)) -> s0(b0(x))
   s0(a0(x)) -> a0(s0(x))
   a0(s0(x)) -> s0(a0(x))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(239) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(240)
YES

----------------------------------------

(241)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> s(b(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(242) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   b(s(x)) -> s(b(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> S(b(x))

Relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 0
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(243)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))
   b(b(x)) -> a(x)


----------------------------------------

(244) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   b(b(x)) -> a(x)

c:

   s(a(x)) -> S(b(x))

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = 1 + x_1
   POL(f(x_1, x_2)) = x_1 + x_2
   POL(s(x_1)) = 1 + x_1

----------------------------------------

(245)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))


----------------------------------------

(246) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   s(a(x)) -> S(b(x))

   s(a(x)) -> s(b(x))

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3*x_1
   POL(B(x_1)) = 3*x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 1 + x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 2*x_1 + x_2
   POL(s(x_1)) = x_1

----------------------------------------

(247)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))


----------------------------------------

(248) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(249)
YES

----------------------------------------

(250)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(251) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> S(b(x))

Relative ADPs:

   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 3 + 3*x_1 + x_1^2
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 0
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(252)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> S(b(x))

and relative ADPs:

   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(253) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   s(a(x)) -> S(b(x))

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   b(b(x)) -> a(x)

c:

Ordered with Polynomial interpretation [POLO]:

   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(f(x_1, x_2)) = 3*x_1 + 2*x_2
   POL(s(x_1)) = 3 + x_1

----------------------------------------

(254)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))


----------------------------------------

(255) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(256)
YES

----------------------------------------

(257)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(x)) -> A(x)

and relative ADPs:

   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(258) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(x)) -> A(x)

Relative ADPs:

   s(b(x)) -> B(S(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 0
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(259)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(x)) -> A(x)

and relative ADPs:

   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))


----------------------------------------

(260) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   b(b(x)) -> A(x)

Relative ADPs:

   s(b(x)) -> B(S(x))
   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 1
   POL(B(x_1)) = 2
   POL(F(x_1, x_2)) = 1 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(S(x_1)) = 3 + 2*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(f(x_1, x_2)) = 2*x_1
   POL(s(x_1)) = 2 + 2*x_1

----------------------------------------

(261)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(262) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(263)
YES

----------------------------------------

(264)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(x)) -> A(x)

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(265) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   f(s(x), y) -> F(x, S(y))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   b(b(x)) -> A(x)

Relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> S(B(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 2*x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(266)
Obligation:
Relative ADP Problem with
absolute ADPs:

   b(b(x)) -> A(x)

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))


----------------------------------------

(267) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   b(b(x)) -> A(x)

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 2 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(f(x_1, x_2)) = 2*x_1 + x_2
   POL(s(x_1)) = x_1

----------------------------------------

(268)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> S(B(x))


----------------------------------------

(269) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(270)
YES

----------------------------------------

(271)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(272) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> s(B(x))

Relative ADPs:

   s(a(x)) -> A(S(x))
   s(b(x)) -> B(S(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = x_1
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(273)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(274) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   s(a(x)) -> s(B(x))

Relative ADPs:

   s(a(x)) -> A(S(x))
   s(b(x)) -> B(S(x))
   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


No rules with annotations remain.
Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 3 + 3*x_1 + 3*x_1*x_2 + x_2
   POL(S(x_1)) = 3*x_1
   POL(a(x_1)) = 2 + 2*x_1
   POL(b(x_1)) = 2 + 2*x_1
   POL(f(x_1, x_2)) = 0
   POL(s(x_1)) = 2 + 2*x_1

----------------------------------------

(275)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   s(b(x)) -> b(s(x))
   b(s(x)) -> s(b(x))
   s(a(x)) -> a(s(x))
   a(s(x)) -> s(a(x))
   b(b(x)) -> a(x)


----------------------------------------

(276) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(277)
YES

----------------------------------------

(278)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> s(b(x))
   b(b(x)) -> a(x)
   f(s(x), y) -> F(x, S(y))


----------------------------------------

(279) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   s(a(x)) -> s(b(x))
   b(s(x)) -> s(b(x))
   f(s(x), y) -> F(x, S(y))
   b(b(x)) -> a(x)


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   s(a(x)) -> s(B(x))

Relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))


Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = 0
   POL(B(x_1)) = 0
   POL(F(x_1, x_2)) = 2*x_1
   POL(S(x_1)) = 0
   POL(a(x_1)) = x_1
   POL(b(x_1)) = x_1
   POL(f(x_1, x_2)) = 0
   POL(s(x_1)) = 3 + 2*x_1

----------------------------------------

(280)
Obligation:
Relative ADP Problem with
absolute ADPs:

   s(a(x)) -> s(B(x))

and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(a(x)) -> s(b(x))
   s(b(x)) -> B(S(x))
   f(s(x), y) -> f(x, s(y))
   b(s(x)) -> s(b(x))
   b(b(x)) -> a(x)


----------------------------------------

(281) RelADPRuleRemovalProof (EQUIVALENT)


We use the rule removal processor [IJCAR24].
The following rules can be ordered strictly and therefore removed:

   s(a(x)) -> s(B(x))

   s(a(x)) -> s(b(x))
   f(s(x), y) -> f(x, s(y))
   b(b(x)) -> a(x)

c:

Ordered with Polynomial interpretation [POLO]:

   POL(A(x_1)) = x_1
   POL(B(x_1)) = x_1
   POL(S(x_1)) = x_1
   POL(a(x_1)) = 3 + x_1
   POL(b(x_1)) = 2 + x_1
   POL(f(x_1, x_2)) = 3*x_1 + 2*x_2
   POL(s(x_1)) = 3 + x_1

----------------------------------------

(282)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   s(a(x)) -> A(S(x))
   a(s(x)) -> S(A(x))
   s(b(x)) -> B(S(x))
   b(s(x)) -> s(b(x))


----------------------------------------

(283) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(284)
YES
