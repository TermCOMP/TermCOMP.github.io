YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/eSgVC.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given RelTRS could be proven:

(0) RelTRS
(1) RelTRStoRelADPProof [EQUIVALENT, 0 ms]
(2) RelADPP
(3) RelADPDepGraphProof [EQUIVALENT, 0 ms]
(4) RelADPP
(5) RelADPCleverAfsProof [SOUND, 38 ms]
(6) QDP
(7) MRRProof [EQUIVALENT, 26 ms]
(8) QDP
(9) MRRProof [EQUIVALENT, 0 ms]
(10) QDP
(11) MRRProof [EQUIVALENT, 0 ms]
(12) QDP
(13) PisEmptyProof [EQUIVALENT, 0 ms]
(14) YES


----------------------------------------

(0)
Obligation:
Relative term rewrite system:
The relative TRS consists of the following R rules:

   top(ok(new(x))) -> top(check(x))
   top(ok(old(x))) -> top(check(x))

The relative TRS consists of the following S rules:

   check(old(x)) -> ok(old(x))
   bot -> new(bot)
   check(old(x)) -> old(check(x))
   check(new(x)) -> new(check(x))
   old(ok(x)) -> ok(old(x))
   new(ok(x)) -> ok(new(x))


----------------------------------------

(1) RelTRStoRelADPProof (EQUIVALENT)


We upgrade the RelTRS problem to an equivalent Relative ADP Problem [IJCAR24].

----------------------------------------

(2)
Obligation:
Relative ADP Problem with
absolute ADPs:

   top(ok(new(x))) -> TOP(check(x))
   top(ok(new(x))) -> top(CHECK(x))
   top(ok(old(x))) -> TOP(check(x))
   top(ok(old(x))) -> top(CHECK(x))

and relative ADPs:

   check(old(x)) -> ok(OLD(x))
   bot -> NEW(BOT)
   check(old(x)) -> OLD(CHECK(x))
   check(new(x)) -> NEW(CHECK(x))
   old(ok(x)) -> ok(OLD(x))
   new(ok(x)) -> ok(NEW(x))


----------------------------------------

(3) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(4)
Obligation:
Relative ADP Problem with
absolute ADPs:

   top(ok(old(x))) -> TOP(check(x))
   top(ok(new(x))) -> TOP(check(x))

and relative ADPs:

   check(old(x)) -> ok(old(x))
   bot -> new(bot)
   check(old(x)) -> old(check(x))
   check(new(x)) -> new(check(x))
   old(ok(x)) -> ok(old(x))
   top(ok(new(x))) -> top(check(x))
   top(ok(old(x))) -> top(check(x))
   new(ok(x)) -> ok(new(x))


----------------------------------------

(5) RelADPCleverAfsProof (SOUND)
We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.

Furthermore, We use an argument filter [LPAR04].
Filtering:old_1 = 
new_1 = 
top_1 = 
check_1 = 
bot = 
ok_1 = 
TOP_1 = 

Found this filtering by looking at the following order that orders at least one DP strictly:Combined order from the following AFS and order.
TOP(x1)  =  TOP(x1)

ok(x1)  =  x1

new(x1)  =  new(x1)

check(x1)  =  x1

old(x1)  =  old(x1)


Recursive path order with status [RPO].
Quasi-Precedence: trivial

Status: TOP_1: multiset status
new_1: multiset status
old_1: multiset status


----------------------------------------

(6)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP0(ok0(new0(x))) -> TOP0(check0(x))
   TOP0(ok0(old0(x))) -> TOP0(check0(x))

The TRS R consists of the following rules:

   check0(old0(x)) -> ok0(old0(x))
   bot0 -> new0(bot0)
   check0(old0(x)) -> old0(check0(x))
   check0(new0(x)) -> new0(check0(x))
   old0(ok0(x)) -> ok0(old0(x))
   top0(ok0(new0(x))) -> top0(check0(x))
   top0(ok0(old0(x))) -> top0(check0(x))
   new0(ok0(x)) -> ok0(new0(x))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(7) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   TOP0(ok0(old0(x))) -> TOP0(check0(x))

Strictly oriented rules of the TRS R:

   top0(ok0(old0(x))) -> top0(check0(x))

Used ordering: Polynomial interpretation [POLO]:

   POL(TOP0(x_1)) = x_1
   POL(bot0) = 0
   POL(check0(x_1)) = 1 + x_1
   POL(new0(x_1)) = x_1
   POL(ok0(x_1)) = 1 + x_1
   POL(old0(x_1)) = 1 + x_1
   POL(top0(x_1)) = x_1


----------------------------------------

(8)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP0(ok0(new0(x))) -> TOP0(check0(x))

The TRS R consists of the following rules:

   check0(old0(x)) -> ok0(old0(x))
   bot0 -> new0(bot0)
   check0(old0(x)) -> old0(check0(x))
   check0(new0(x)) -> new0(check0(x))
   old0(ok0(x)) -> ok0(old0(x))
   top0(ok0(new0(x))) -> top0(check0(x))
   new0(ok0(x)) -> ok0(new0(x))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(9) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.


Strictly oriented rules of the TRS R:

   check0(old0(x)) -> ok0(old0(x))
   check0(old0(x)) -> old0(check0(x))

Used ordering: Polynomial interpretation [POLO]:

   POL(TOP0(x_1)) = 2*x_1
   POL(bot0) = 0
   POL(check0(x_1)) = 2*x_1
   POL(new0(x_1)) = 2*x_1
   POL(ok0(x_1)) = x_1
   POL(old0(x_1)) = 1 + x_1
   POL(top0(x_1)) = 2*x_1


----------------------------------------

(10)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP0(ok0(new0(x))) -> TOP0(check0(x))

The TRS R consists of the following rules:

   bot0 -> new0(bot0)
   check0(new0(x)) -> new0(check0(x))
   old0(ok0(x)) -> ok0(old0(x))
   top0(ok0(new0(x))) -> top0(check0(x))
   new0(ok0(x)) -> ok0(new0(x))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(11) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   TOP0(ok0(new0(x))) -> TOP0(check0(x))

Strictly oriented rules of the TRS R:

   old0(ok0(x)) -> ok0(old0(x))
   top0(ok0(new0(x))) -> top0(check0(x))

Used ordering: Polynomial interpretation [POLO]:

   POL(TOP0(x_1)) = x_1
   POL(bot0) = 0
   POL(check0(x_1)) = 2*x_1
   POL(new0(x_1)) = x_1
   POL(ok0(x_1)) = 2 + 2*x_1
   POL(old0(x_1)) = 2*x_1
   POL(top0(x_1)) = x_1


----------------------------------------

(12)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   bot0 -> new0(bot0)
   check0(new0(x)) -> new0(check0(x))
   new0(ok0(x)) -> ok0(new0(x))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(13) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(14)
YES
