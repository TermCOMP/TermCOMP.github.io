NO
proof of /hpcwork/ff862203/termcomp25/benchmarks/OYKlE.ari
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


Termination of the given RelTRS could be disproven:

(0) RelTRS
(1) RelTRStoRelADPProof [EQUIVALENT, 0 ms]
(2) RelADPP
(3) RelADPDepGraphProof [EQUIVALENT, 0 ms]
(4) AND
    (5) RelADPP
        (6) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
        (7) QDP
        (8) MRRProof [EQUIVALENT, 5 ms]
        (9) QDP
        (10) MRRProof [EQUIVALENT, 3 ms]
        (11) QDP
        (12) PisEmptyProof [EQUIVALENT, 0 ms]
        (13) YES
    (14) RelADPP
        (15) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
        (16) QDP
        (17) MRRProof [EQUIVALENT, 6 ms]
        (18) QDP
        (19) MRRProof [EQUIVALENT, 3 ms]
        (20) QDP
        (21) MRRProof [EQUIVALENT, 4 ms]
        (22) QDP
        (23) PisEmptyProof [EQUIVALENT, 0 ms]
        (24) YES
    (25) RelADPP
        (26) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
        (27) QDP
        (28) MRRProof [EQUIVALENT, 11 ms]
        (29) QDP
        (30) TransformationProof [EQUIVALENT, 0 ms]
        (31) QDP
        (32) NonTerminationLoopProof [COMPLETE, 0 ms]
        (33) NO
    (34) RelADPP
        (35) RelADPReductionPairProof [EQUIVALENT, 30 ms]
        (36) RelADPP
        (37) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (38) YES
    (39) RelADPP
        (40) RelADPReductionPairProof [EQUIVALENT, 28 ms]
        (41) RelADPP
        (42) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (43) TRUE
    (44) RelADPP
        (45) RelADPReductionPairProof [EQUIVALENT, 31 ms]
        (46) RelADPP
        (47) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (48) YES
    (49) RelADPP
        (50) RelADPReductionPairProof [EQUIVALENT, 36 ms]
        (51) RelADPP
        (52) RelADPReductionPairProof [EQUIVALENT, 7 ms]
        (53) RelADPP
        (54) RelADPReductionPairProof [EQUIVALENT, 8 ms]
        (55) RelADPP
        (56) RelADPReductionPairProof [EQUIVALENT, 6 ms]
        (57) RelADPP
        (58) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (59) YES
    (60) RelADPP
        (61) RelADPReductionPairProof [EQUIVALENT, 28 ms]
        (62) RelADPP
        (63) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (64) TRUE
    (65) RelADPP
        (66) RelADPReductionPairProof [EQUIVALENT, 33 ms]
        (67) RelADPP
        (68) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (69) RelADPP
        (70) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
        (71) QDP
        (72) MRRProof [EQUIVALENT, 3 ms]
        (73) QDP
        (74) PisEmptyProof [EQUIVALENT, 0 ms]
        (75) YES
    (76) RelADPP
        (77) RelADPReductionPairProof [EQUIVALENT, 36 ms]
        (78) RelADPP
        (79) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (80) RelADPP
        (81) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
        (82) QDP
        (83) MRRProof [EQUIVALENT, 5 ms]
        (84) QDP
        (85) MRRProof [EQUIVALENT, 3 ms]
        (86) QDP
        (87) PisEmptyProof [EQUIVALENT, 0 ms]
        (88) YES
    (89) RelADPP
        (90) RelADPReductionPairProof [EQUIVALENT, 25 ms]
        (91) RelADPP
        (92) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (93) TRUE
    (94) RelADPP
        (95) RelADPReductionPairProof [EQUIVALENT, 34 ms]
        (96) RelADPP
        (97) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (98) RelADPP
        (99) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
        (100) QDP
        (101) MRRProof [EQUIVALENT, 6 ms]
        (102) QDP
        (103) MRRProof [EQUIVALENT, 5 ms]
        (104) QDP
        (105) PisEmptyProof [EQUIVALENT, 0 ms]
        (106) YES
    (107) RelADPP
        (108) RelADPReductionPairProof [EQUIVALENT, 33 ms]
        (109) RelADPP
        (110) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (111) RelADPP
        (112) RelADPDerelatifyingProof [EQUIVALENT, 0 ms]
        (113) QDP
        (114) MRRProof [EQUIVALENT, 5 ms]
        (115) QDP
        (116) MRRProof [EQUIVALENT, 0 ms]
        (117) QDP
        (118) PisEmptyProof [EQUIVALENT, 0 ms]
        (119) YES
    (120) RelADPP
        (121) RelADPReductionPairProof [EQUIVALENT, 41 ms]
        (122) RelADPP
        (123) RelADPDepGraphProof [EQUIVALENT, 0 ms]
        (124) TRUE
    (125) RelADPP
        (126) RelADPReductionPairProof [EQUIVALENT, 40 ms]
        (127) RelADPP
        (128) DAbsisEmptyProof [EQUIVALENT, 0 ms]
        (129) YES


----------------------------------------

(0)
Obligation:
Relative term rewrite system:
The relative TRS consists of the following R rules:

   top(U(x, y)) -> top(check(D(x, y)))
   D(x, B) -> U(x, B)
   F(x, U(O(y), z)) -> U(x, F(y, z))
   F(x, U(N(y), z)) -> U(x, F(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))
   D(E, F(x, y)) -> F(E, D(x, y))

The relative TRS consists of the following S rules:

   check(O(x)) -> O(x)
   check(D(x, y)) -> D(check(x), y)
   E -> N(E)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   check(U(x, y)) -> U(check(x), y)
   check(F(x, y)) -> F(check(x), y)
   check(N(x)) -> N(check(x))
   check(D(x, y)) -> D(x, check(y))


----------------------------------------

(1) RelTRStoRelADPProof (EQUIVALENT)


We upgrade the RelTRS problem to an equivalent Relative ADP Problem [IJCAR24].

----------------------------------------

(2)
Obligation:
Relative ADP Problem with
absolute ADPs:

   top(U(x, y)) -> TOP(check(D(x, y)))
   top(U(x, y)) -> top(CHECK(D(x, y)))
   top(U(x, y)) -> top(check(D^1(x, y)))
   D(x, B) -> U(x, B)
   F(x, U(O(y), z)) -> U(x, F^1(y, z))
   F(x, U(N(y), z)) -> U(x, F^1(y, z))
   D(O(x), F(y, z)) -> F^1(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D^1(y, z))
   D(N(x), F(y, z)) -> F^1(x, D(y, z))
   D(N(x), F(y, z)) -> F(x, D^1(y, z))
   F(x, U(E, y)) -> U(x, F^1(E, y))
   F(x, U(E, y)) -> U(x, F(E^1, y))
   D(E, F(x, y)) -> F^1(E, D(x, y))
   D(E, F(x, y)) -> F(E^1, D(x, y))
   D(E, F(x, y)) -> F(E, D^1(x, y))

and relative ADPs:

   check(O(x)) -> O(x)
   check(D(x, y)) -> D^1(CHECK(x), y)
   E -> N(E^1)
   check(F(x, y)) -> F^1(x, CHECK(y))
   check(U(x, y)) -> U(x, CHECK(y))
   check(O(x)) -> O(CHECK(x))
   check(U(x, y)) -> U(CHECK(x), y)
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   check(D(x, y)) -> D^1(x, CHECK(y))


----------------------------------------

(3) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  3 SCCs with nodes from P_abs,
  12 Lassos,
Result: This relative DT problem is equivalent to 15 subproblems.

----------------------------------------

(4)
Complex Obligation (AND)

----------------------------------------

(5)
Obligation:
Relative ADP Problem with
absolute ADPs:

   F(x, U(O(y), z)) -> U(x, F^1(y, z))
   F(x, U(E, y)) -> U(x, F^1(E, y))
   F(x, U(N(y), z)) -> U(x, F^1(y, z))

and relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))


----------------------------------------

(6) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(7)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F^1(x, U(O(y), z)) -> F^1(y, z)
   F^1(x, U(E, y)) -> F^1(E, y)
   F^1(x, U(N(y), z)) -> F^1(y, z)

The TRS R consists of the following rules:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(8) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   F^1(x, U(O(y), z)) -> F^1(y, z)

Strictly oriented rules of the TRS R:

   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))

Used ordering: Polynomial interpretation [POLO]:

   POL(B) = 0
   POL(D(x_1, x_2)) = 2*x_1 + x_2
   POL(E) = 0
   POL(F(x_1, x_2)) = 2*x_1 + x_2
   POL(F^1(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(N(x_1)) = x_1
   POL(O(x_1)) = 1 + 2*x_1
   POL(U(x_1, x_2)) = 2*x_1 + x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = x_1


----------------------------------------

(9)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F^1(x, U(E, y)) -> F^1(E, y)
   F^1(x, U(N(y), z)) -> F^1(y, z)

The TRS R consists of the following rules:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(10) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   F^1(x, U(E, y)) -> F^1(E, y)
   F^1(x, U(N(y), z)) -> F^1(y, z)


Used ordering: Polynomial interpretation [POLO]:

   POL(B) = 0
   POL(D(x_1, x_2)) = 1 + 2*x_1 + x_2
   POL(E) = 0
   POL(F(x_1, x_2)) = 2*x_1 + x_2
   POL(F^1(x_1, x_2)) = x_1 + 2*x_2
   POL(N(x_1)) = 2*x_1
   POL(O(x_1)) = 2*x_1
   POL(U(x_1, x_2)) = 1 + 2*x_1 + 2*x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = 2*x_1


----------------------------------------

(11)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(12) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(13)
YES

----------------------------------------

(14)
Obligation:
Relative ADP Problem with
absolute ADPs:

   D(O(x), F(y, z)) -> F(x, D^1(y, z))
   D(E, F(x, y)) -> F(E, D^1(x, y))
   D(N(x), F(y, z)) -> F(x, D^1(y, z))

and relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))


----------------------------------------

(15) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(16)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   D^1(O(x), F(y, z)) -> D^1(y, z)
   D^1(E, F(x, y)) -> D^1(x, y)
   D^1(N(x), F(y, z)) -> D^1(y, z)

The TRS R consists of the following rules:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(17) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   D^1(O(x), F(y, z)) -> D^1(y, z)

Strictly oriented rules of the TRS R:

   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))

Used ordering: Polynomial interpretation [POLO]:

   POL(B) = 0
   POL(D(x_1, x_2)) = x_1 + 2*x_2
   POL(D^1(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(E) = 0
   POL(F(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(N(x_1)) = 2*x_1
   POL(O(x_1)) = 2 + 2*x_1
   POL(U(x_1, x_2)) = x_1 + 2*x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = 2*x_1


----------------------------------------

(18)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   D^1(E, F(x, y)) -> D^1(x, y)
   D^1(N(x), F(y, z)) -> D^1(y, z)

The TRS R consists of the following rules:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(19) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   D^1(E, F(x, y)) -> D^1(x, y)


Used ordering: Polynomial interpretation [POLO]:

   POL(B) = 0
   POL(D(x_1, x_2)) = x_1 + 2*x_2
   POL(D^1(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(E) = 2
   POL(F(x_1, x_2)) = x_1 + 2*x_2
   POL(N(x_1)) = x_1
   POL(O(x_1)) = x_1
   POL(U(x_1, x_2)) = x_1 + 2*x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = x_1


----------------------------------------

(20)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   D^1(N(x), F(y, z)) -> D^1(y, z)

The TRS R consists of the following rules:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(21) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   D^1(N(x), F(y, z)) -> D^1(y, z)


Used ordering: Polynomial interpretation [POLO]:

   POL(B) = 0
   POL(D(x_1, x_2)) = x_1 + x_2
   POL(D^1(x_1, x_2)) = x_1 + x_2
   POL(E) = 0
   POL(F(x_1, x_2)) = 1 + x_1 + x_2
   POL(N(x_1)) = 2*x_1
   POL(O(x_1)) = 2*x_1
   POL(U(x_1, x_2)) = x_1 + x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = 2*x_1


----------------------------------------

(22)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(23) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(24)
YES

----------------------------------------

(25)
Obligation:
Relative ADP Problem with
absolute ADPs:

   top(U(x, y)) -> TOP(check(D(x, y)))

and relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))


----------------------------------------

(26) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(27)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP(U(x, y)) -> TOP(check(D(x, y)))

The TRS R consists of the following rules:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(28) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.


Strictly oriented rules of the TRS R:

   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))

Used ordering: Polynomial interpretation [POLO]:

   POL(B) = 0
   POL(D(x_1, x_2)) = x_1 + 2*x_2
   POL(E) = 0
   POL(F(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(N(x_1)) = 2*x_1
   POL(O(x_1)) = 1 + 2*x_1
   POL(TOP(x_1)) = 2*x_1
   POL(U(x_1, x_2)) = x_1 + 2*x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = 2*x_1


----------------------------------------

(29)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP(U(x, y)) -> TOP(check(D(x, y)))

The TRS R consists of the following rules:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(30) TransformationProof (EQUIVALENT)
By narrowing [LPAR04] the rule TOP(U(x, y)) -> TOP(check(D(x, y))) at position [0] we obtained the following new rules [LPAR04]:

   (TOP(U(x0, x1)) -> TOP(D(check(x0), x1)),TOP(U(x0, x1)) -> TOP(D(check(x0), x1)))
   (TOP(U(x0, x1)) -> TOP(D(x0, check(x1))),TOP(U(x0, x1)) -> TOP(D(x0, check(x1))))
   (TOP(U(x0, B)) -> TOP(check(U(x0, B))),TOP(U(x0, B)) -> TOP(check(U(x0, B))))
   (TOP(U(E, F(x0, x1))) -> TOP(check(F(E, D(x0, x1)))),TOP(U(E, F(x0, x1))) -> TOP(check(F(E, D(x0, x1)))))
   (TOP(U(N(x0), F(x1, x2))) -> TOP(check(F(x0, D(x1, x2)))),TOP(U(N(x0), F(x1, x2))) -> TOP(check(F(x0, D(x1, x2)))))


----------------------------------------

(31)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   TOP(U(x0, x1)) -> TOP(D(check(x0), x1))
   TOP(U(x0, x1)) -> TOP(D(x0, check(x1)))
   TOP(U(x0, B)) -> TOP(check(U(x0, B)))
   TOP(U(E, F(x0, x1))) -> TOP(check(F(E, D(x0, x1))))
   TOP(U(N(x0), F(x1, x2))) -> TOP(check(F(x0, D(x1, x2))))

The TRS R consists of the following rules:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(32) NonTerminationLoopProof (COMPLETE)
We used the non-termination processor [FROCOS05] to show that the DP problem is infinite.
Found a loop by narrowing to the left:

s = TOP(D(x, B)) evaluates to  t =TOP(D(check(x), B))

Thus s starts an infinite chain as s semiunifies with t with the following substitutions:
* Matcher: [x / check(x)]
* Semiunifier: [ ]

--------------------------------------------------------------------------------
Rewriting sequence

TOP(D(x, B)) -> TOP(U(x, B))
with rule D(x', B) -> U(x', B) at position [0] and matcher [x' / x]

TOP(U(x, B)) -> TOP(D(check(x), B))
with rule TOP(U(x0, x1)) -> TOP(D(check(x0), x1))

Now applying the matcher to the start term leads to a term which is equal to the last term in the rewriting sequence


All these steps are and every following step will be a correct step w.r.t to Q.




----------------------------------------

(33)
NO

----------------------------------------

(34)
Obligation:
Relative ADP Problem with
absolute ADPs:

   D(N(x), F(y, z)) -> F(x, D^1(y, z))

and relative ADPs:

   check(O(x)) -> O(x)
   check(D(x, y)) -> D^1(CHECK(x), y)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(F(x, y)) -> F^1(x, CHECK(y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(D(x, y)) -> D^1(x, CHECK(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(35) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   D(N(x), F(y, z)) -> F(x, D^1(y, z))

Relative ADPs:

   check(D(x, y)) -> D^1(CHECK(x), y)
   check(O(x)) -> O(x)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   check(U(x, y)) -> U(CHECK(x), y)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(F(x, y)) -> F^1(x, CHECK(y))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(D(x, y)) -> D^1(x, CHECK(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(B) = 1
   POL(CHECK(x_1)) = 1 + 2*x_1
   POL(D(x_1, x_2)) = 3 + 3*x_1 + 3*x_2
   POL(D^1(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(E) = 0
   POL(E^1) = 0
   POL(F(x_1, x_2)) = 3 + 2*x_1 + 2*x_2
   POL(F^1(x_1, x_2)) = 0
   POL(N(x_1)) = x_1
   POL(O(x_1)) = 1 + 3*x_1
   POL(TOP(x_1)) = 3*x_1 + 3*x_1^2
   POL(U(x_1, x_2)) = 1 + 2*x_1 + x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = 0

----------------------------------------

(36)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(N(x)) -> N(CHECK(x))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(D(x, y)) -> D(x, check(y))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(37) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(38)
YES

----------------------------------------

(39)
Obligation:
Relative ADP Problem with
absolute ADPs:

   D(E, F(x, y)) -> F(E^1, D(x, y))

and relative ADPs:

   check(O(x)) -> O(x)
   check(D(x, y)) -> D^1(CHECK(x), y)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(F(x, y)) -> F^1(x, CHECK(y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(D(x, y)) -> D^1(x, CHECK(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(40) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   check(D(x, y)) -> D^1(CHECK(x), y)
   check(O(x)) -> O(x)
   E -> N(E)
   check(U(x, y)) -> U(CHECK(x), y)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(U(x, y)) -> U(x, CHECK(y))
   check(D(x, y)) -> D^1(x, CHECK(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   D(E, F(x, y)) -> F(E^1, D(x, y))

Relative ADPs:

   check(F(x, y)) -> F^1(CHECK(x), y)
   check(O(x)) -> O(CHECK(x))
   check(N(x)) -> N(CHECK(x))
   check(F(x, y)) -> F^1(x, CHECK(y))


Ordered with Polynomial interpretation [POLO]:

   POL(B) = 0
   POL(CHECK(x_1)) = 3 + 3*x_1
   POL(D(x_1, x_2)) = 2 + 2*x_1 + x_2
   POL(D^1(x_1, x_2)) = 0
   POL(E) = 0
   POL(E^1) = 0
   POL(F(x_1, x_2)) = 2*x_1 + x_2
   POL(F^1(x_1, x_2)) = 0
   POL(N(x_1)) = 2*x_1
   POL(O(x_1)) = 2*x_1
   POL(TOP(x_1)) = 1 + 3*x_1 + 3*x_1^2
   POL(U(x_1, x_2)) = 2 + 2*x_1 + 2*x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = x_1

----------------------------------------

(41)
Obligation:
Relative ADP Problem with
absolute ADPs:

   D(E, F(x, y)) -> F(E^1, D(x, y))

and relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(N(x)) -> N(CHECK(x))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(F(x, y)) -> F^1(x, CHECK(y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(D(x, y)) -> D(check(x), y)
   check(U(x, y)) -> U(x, check(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(D(x, y)) -> D(x, check(y))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(42) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(43)
TRUE

----------------------------------------

(44)
Obligation:
Relative ADP Problem with
absolute ADPs:

   D(O(x), F(y, z)) -> F(x, D^1(y, z))

and relative ADPs:

   check(O(x)) -> O(x)
   check(D(x, y)) -> D^1(CHECK(x), y)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(F(x, y)) -> F^1(x, CHECK(y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(D(x, y)) -> D^1(x, CHECK(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(45) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   D(O(x), F(y, z)) -> F(x, D^1(y, z))

Relative ADPs:

   check(D(x, y)) -> D^1(CHECK(x), y)
   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(F(x, y)) -> F^1(x, CHECK(y))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(D(x, y)) -> D^1(x, CHECK(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(B) = 1
   POL(CHECK(x_1)) = 3 + 2*x_1
   POL(D(x_1, x_2)) = 3 + 3*x_1 + 3*x_2
   POL(D^1(x_1, x_2)) = 2*x_1 + x_2
   POL(E) = 0
   POL(E^1) = 0
   POL(F(x_1, x_2)) = 3 + 3*x_1 + 3*x_2
   POL(F^1(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(N(x_1)) = 2*x_1
   POL(O(x_1)) = 3*x_1
   POL(TOP(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(U(x_1, x_2)) = x_1 + x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = 0

----------------------------------------

(46)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(F(x, y)) -> F(x, check(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   check(D(x, y)) -> D(x, check(y))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(47) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(48)
YES

----------------------------------------

(49)
Obligation:
Relative ADP Problem with
absolute ADPs:

   F(x, U(E, y)) -> U(x, F(E^1, y))

and relative ADPs:

   check(O(x)) -> O(x)
   check(D(x, y)) -> D^1(CHECK(x), y)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(F(x, y)) -> F^1(x, CHECK(y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(D(x, y)) -> D^1(x, CHECK(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(50) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   F(x, U(N(y), z)) -> U(x, F(y, z))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   top(U(x, y)) -> top(check(D(x, y)))
   F(x, U(E, y)) -> U(x, F(E, y))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   F(x, U(E, y)) -> U(x, F(E^1, y))

Relative ADPs:

   check(D(x, y)) -> D^1(CHECK(x), y)
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   check(D(x, y)) -> D^1(x, CHECK(y))
   check(F(x, y)) -> F^1(x, CHECK(y))


Ordered with Polynomial interpretation [POLO]:

   POL(B) = 0
   POL(CHECK(x_1)) = 3 + x_1
   POL(D(x_1, x_2)) = 1 + x_1 + x_2
   POL(D^1(x_1, x_2)) = 1
   POL(E) = 0
   POL(E^1) = 0
   POL(F(x_1, x_2)) = x_1 + x_2
   POL(F^1(x_1, x_2)) = 0
   POL(N(x_1)) = x_1
   POL(O(x_1)) = 1 + x_1
   POL(TOP(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(U(x_1, x_2)) = x_1 + x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = 0

----------------------------------------

(51)
Obligation:
Relative ADP Problem with
absolute ADPs:

   F(x, U(E, y)) -> U(x, F(E^1, y))

and relative ADPs:

   check(O(x)) -> O(x)
   check(D(x, y)) -> D^1(CHECK(x), y)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(F(x, y)) -> F^1(x, CHECK(y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(D(x, y)) -> D^1(x, CHECK(y))
   check(O(x)) -> O(check(x))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(52) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   check(U(x, y)) -> U(CHECK(x), y)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(U(x, y)) -> U(x, CHECK(y))
   check(O(x)) -> O(check(x))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   F(x, U(E, y)) -> U(x, F(E^1, y))

Relative ADPs:

   check(D(x, y)) -> D^1(CHECK(x), y)
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   check(D(x, y)) -> D^1(x, CHECK(y))
   check(F(x, y)) -> F^1(x, CHECK(y))


Ordered with Polynomial interpretation [POLO]:

   POL(B) = 2
   POL(CHECK(x_1)) = 1 + x_1
   POL(D(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(D^1(x_1, x_2)) = 0
   POL(E) = 0
   POL(E^1) = 0
   POL(F(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(F^1(x_1, x_2)) = 0
   POL(N(x_1)) = 2*x_1
   POL(O(x_1)) = 3 + 2*x_1
   POL(TOP(x_1)) = 1 + 3*x_1 + 3*x_1^2
   POL(U(x_1, x_2)) = 2 + 2*x_1 + x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = 0

----------------------------------------

(53)
Obligation:
Relative ADP Problem with
absolute ADPs:

   F(x, U(E, y)) -> U(x, F(E^1, y))

and relative ADPs:

   check(O(x)) -> O(x)
   check(D(x, y)) -> D^1(CHECK(x), y)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(N(x)) -> N(CHECK(x))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(F(x, y)) -> F^1(x, CHECK(y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(U(x, y)) -> U(x, check(y))
   check(D(x, y)) -> D^1(x, CHECK(y))
   check(O(x)) -> O(check(x))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(54) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   check(D(x, y)) -> D^1(CHECK(x), y)
   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(U(x, y)) -> U(x, check(y))
   check(D(x, y)) -> D^1(x, CHECK(y))
   check(O(x)) -> O(check(x))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   F(x, U(E, y)) -> U(x, F(E^1, y))

Relative ADPs:

   check(F(x, y)) -> F^1(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   check(F(x, y)) -> F^1(x, CHECK(y))


Ordered with Polynomial interpretation [POLO]:

   POL(B) = 3
   POL(CHECK(x_1)) = 1 + 2*x_1
   POL(D(x_1, x_2)) = 1 + 2*x_1 + 3*x_2
   POL(D^1(x_1, x_2)) = 2*x_2
   POL(E) = 3
   POL(E^1) = 0
   POL(F(x_1, x_2)) = 2*x_1 + x_2
   POL(F^1(x_1, x_2)) = 0
   POL(N(x_1)) = x_1
   POL(O(x_1)) = 3 + 2*x_1
   POL(TOP(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(U(x_1, x_2)) = 2*x_1
   POL(check(x_1)) = x_1
   POL(top(x_1)) = 0

----------------------------------------

(55)
Obligation:
Relative ADP Problem with
absolute ADPs:

   F(x, U(E, y)) -> U(x, F(E^1, y))

and relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(N(x)) -> N(CHECK(x))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(F(x, y)) -> F^1(x, CHECK(y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(D(x, y)) -> D(check(x), y)
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(D(x, y)) -> D(x, check(y))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(56) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   F(x, U(E, y)) -> U(x, F(E^1, y))

Relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   check(F(x, y)) -> F^1(x, CHECK(y))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(D(x, y)) -> D(check(x), y)
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(D(x, y)) -> D(x, check(y))
   F(x, U(E, y)) -> U(x, F(E, y))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(B) = 2
   POL(CHECK(x_1)) = 3 + 3*x_1
   POL(D(x_1, x_2)) = 2*x_1 + 3*x_2
   POL(D^1(x_1, x_2)) = 1 + 3*x_1 + 3*x_1*x_2 + 3*x_2
   POL(E) = 0
   POL(E^1) = 0
   POL(F(x_1, x_2)) = 2 + 2*x_1 + 3*x_2
   POL(F^1(x_1, x_2)) = 2*x_1 + x_2
   POL(N(x_1)) = 2*x_1
   POL(O(x_1)) = 2*x_1
   POL(TOP(x_1)) = 1 + 3*x_1 + 3*x_1^2
   POL(U(x_1, x_2)) = 2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = 0

----------------------------------------

(57)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(N(x)) -> N(CHECK(x))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))


----------------------------------------

(58) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(59)
YES

----------------------------------------

(60)
Obligation:
Relative ADP Problem with
absolute ADPs:

   D(x, B) -> U(x, B)

and relative ADPs:

   check(O(x)) -> O(x)
   check(D(x, y)) -> D^1(CHECK(x), y)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   D(E, F(x, y)) -> F(E, D(x, y))
   check(F(x, y)) -> F^1(x, CHECK(y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(D(x, y)) -> D^1(x, CHECK(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(61) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   check(D(x, y)) -> D^1(CHECK(x), y)
   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(F(x, y)) -> F^1(x, CHECK(y))
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(D(x, y)) -> D^1(x, CHECK(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   D(x, B) -> U(x, B)

Relative ADPs:

   check(U(x, y)) -> U(x, CHECK(y))
   check(O(x)) -> O(CHECK(x))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))


Ordered with Polynomial interpretation [POLO]:

   POL(B) = 0
   POL(CHECK(x_1)) = 3 + 3*x_1
   POL(D(x_1, x_2)) = 2 + 3*x_1 + 2*x_2
   POL(D^1(x_1, x_2)) = 0
   POL(E) = 0
   POL(E^1) = 0
   POL(F(x_1, x_2)) = 2 + 2*x_1 + x_2
   POL(F^1(x_1, x_2)) = 0
   POL(N(x_1)) = 2*x_1
   POL(O(x_1)) = 3*x_1
   POL(TOP(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(U(x_1, x_2)) = x_1 + x_2
   POL(check(x_1)) = 2*x_1
   POL(top(x_1)) = 0

----------------------------------------

(62)
Obligation:
Relative ADP Problem with
absolute ADPs:

   D(x, B) -> U(x, B)

and relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(F(x, y)) -> F(x, check(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(D(x, y)) -> D(x, check(y))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(63) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(64)
TRUE

----------------------------------------

(65)
Obligation:
Relative ADP Problem with
absolute ADPs:

   F(x, U(O(y), z)) -> U(x, F^1(y, z))

and relative ADPs:

   check(O(x)) -> O(x)
   check(D(x, y)) -> D^1(CHECK(x), y)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(F(x, y)) -> F^1(x, CHECK(y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(D(x, y)) -> D^1(x, CHECK(y))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(66) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   check(D(x, y)) -> D^1(CHECK(x), y)
   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(F(x, y)) -> F^1(x, CHECK(y))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(D(x, y)) -> D^1(x, CHECK(y))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   F(x, U(O(y), z)) -> U(x, F^1(y, z))

Relative ADPs:

   check(U(x, y)) -> U(x, CHECK(y))
   check(O(x)) -> O(CHECK(x))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))


Ordered with Polynomial interpretation [POLO]:

   POL(B) = 0
   POL(CHECK(x_1)) = 3 + 2*x_1
   POL(D(x_1, x_2)) = 3 + 3*x_1 + 3*x_2
   POL(D^1(x_1, x_2)) = 2*x_1
   POL(E) = 0
   POL(E^1) = 0
   POL(F(x_1, x_2)) = 3 + 3*x_1 + 2*x_2
   POL(F^1(x_1, x_2)) = 0
   POL(N(x_1)) = 3*x_1
   POL(O(x_1)) = 3*x_1
   POL(TOP(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(U(x_1, x_2)) = x_1 + x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = 0

----------------------------------------

(67)
Obligation:
Relative ADP Problem with
absolute ADPs:

   F(x, U(O(y), z)) -> U(x, F^1(y, z))

and relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(F(x, y)) -> F(x, check(y))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(D(x, y)) -> D(x, check(y))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(68) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(69)
Obligation:
Relative ADP Problem with
absolute ADPs:

   F(x, U(O(y), z)) -> U(x, F^1(y, z))

and relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   check(N(x)) -> N(check(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(D(x, y)) -> D(x, check(y))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(70) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(71)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F^1(x, U(O(y), z)) -> F^1(y, z)

The TRS R consists of the following rules:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(72) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   F^1(x, U(O(y), z)) -> F^1(y, z)

Strictly oriented rules of the TRS R:

   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))

Used ordering: Polynomial interpretation [POLO]:

   POL(B) = 0
   POL(D(x_1, x_2)) = x_1 + 2*x_2
   POL(E) = 0
   POL(F(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(F^1(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(N(x_1)) = 2*x_1
   POL(O(x_1)) = 2 + 2*x_1
   POL(U(x_1, x_2)) = x_1 + 2*x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = x_1


----------------------------------------

(73)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(74) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(75)
YES

----------------------------------------

(76)
Obligation:
Relative ADP Problem with
absolute ADPs:

   D(E, F(x, y)) -> F(E, D^1(x, y))

and relative ADPs:

   check(O(x)) -> O(x)
   check(D(x, y)) -> D^1(CHECK(x), y)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(F(x, y)) -> F^1(x, CHECK(y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(D(x, y)) -> D^1(x, CHECK(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(77) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   check(D(x, y)) -> D^1(CHECK(x), y)
   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(D(x, y)) -> D^1(x, CHECK(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   top(U(x, y)) -> top(check(D(x, y)))
   F(x, U(E, y)) -> U(x, F(E, y))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   D(E, F(x, y)) -> F(E, D^1(x, y))

Relative ADPs:

   check(F(x, y)) -> F^1(CHECK(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(O(x)) -> O(CHECK(x))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   check(F(x, y)) -> F^1(x, CHECK(y))


Ordered with Polynomial interpretation [POLO]:

   POL(B) = 2
   POL(CHECK(x_1)) = 3 + 3*x_1
   POL(D(x_1, x_2)) = 2 + 2*x_1 + 3*x_2
   POL(D^1(x_1, x_2)) = 0
   POL(E) = 0
   POL(E^1) = 0
   POL(F(x_1, x_2)) = x_1 + x_2
   POL(F^1(x_1, x_2)) = 0
   POL(N(x_1)) = 2*x_1
   POL(O(x_1)) = 3*x_1
   POL(TOP(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(U(x_1, x_2)) = x_1 + 2*x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = 0

----------------------------------------

(78)
Obligation:
Relative ADP Problem with
absolute ADPs:

   D(E, F(x, y)) -> F(E, D^1(x, y))

and relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(F(x, y)) -> F^1(x, CHECK(y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(D(x, y)) -> D(check(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(D(x, y)) -> D(x, check(y))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(79) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(80)
Obligation:
Relative ADP Problem with
absolute ADPs:

   D(E, F(x, y)) -> F(E, D^1(x, y))

and relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   check(N(x)) -> N(check(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(D(x, y)) -> D(x, check(y))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(81) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(82)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   D^1(E, F(x, y)) -> D^1(x, y)

The TRS R consists of the following rules:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(83) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.


Strictly oriented rules of the TRS R:

   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))

Used ordering: Polynomial interpretation [POLO]:

   POL(B) = 0
   POL(D(x_1, x_2)) = x_1 + 2*x_2
   POL(D^1(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(E) = 0
   POL(F(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(N(x_1)) = 2*x_1
   POL(O(x_1)) = 2 + 2*x_1
   POL(U(x_1, x_2)) = x_1 + 2*x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = x_1


----------------------------------------

(84)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   D^1(E, F(x, y)) -> D^1(x, y)

The TRS R consists of the following rules:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(85) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   D^1(E, F(x, y)) -> D^1(x, y)


Used ordering: Polynomial interpretation [POLO]:

   POL(B) = 0
   POL(D(x_1, x_2)) = 2*x_1 + x_2
   POL(D^1(x_1, x_2)) = x_1 + x_2
   POL(E) = 0
   POL(F(x_1, x_2)) = 1 + 2*x_1 + x_2
   POL(N(x_1)) = 2*x_1
   POL(O(x_1)) = 2*x_1
   POL(U(x_1, x_2)) = 2*x_1 + x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = 2*x_1


----------------------------------------

(86)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(87) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(88)
YES

----------------------------------------

(89)
Obligation:
Relative ADP Problem with
absolute ADPs:

   D(N(x), F(y, z)) -> F^1(x, D(y, z))

and relative ADPs:

   check(O(x)) -> O(x)
   check(D(x, y)) -> D^1(CHECK(x), y)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(F(x, y)) -> F^1(x, CHECK(y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(D(x, y)) -> D^1(x, CHECK(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(90) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   check(D(x, y)) -> D^1(CHECK(x), y)
   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(F(x, y)) -> F^1(x, CHECK(y))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(D(x, y)) -> D^1(x, CHECK(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   D(N(x), F(y, z)) -> F^1(x, D(y, z))

Relative ADPs:

   check(U(x, y)) -> U(x, CHECK(y))
   check(O(x)) -> O(CHECK(x))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))


Ordered with Polynomial interpretation [POLO]:

   POL(B) = 1
   POL(CHECK(x_1)) = 3 + 2*x_1
   POL(D(x_1, x_2)) = 3 + 3*x_1 + x_2
   POL(D^1(x_1, x_2)) = 3*x_1
   POL(E) = 0
   POL(E^1) = 0
   POL(F(x_1, x_2)) = 3 + 3*x_1 + x_2
   POL(F^1(x_1, x_2)) = 0
   POL(N(x_1)) = 3*x_1
   POL(O(x_1)) = 3*x_1
   POL(TOP(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(U(x_1, x_2)) = x_1 + x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = 0

----------------------------------------

(91)
Obligation:
Relative ADP Problem with
absolute ADPs:

   D(N(x), F(y, z)) -> F^1(x, D(y, z))

and relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(F(x, y)) -> F(x, check(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(D(x, y)) -> D(x, check(y))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(92) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(93)
TRUE

----------------------------------------

(94)
Obligation:
Relative ADP Problem with
absolute ADPs:

   F(x, U(E, y)) -> U(x, F^1(E, y))

and relative ADPs:

   check(O(x)) -> O(x)
   check(D(x, y)) -> D^1(CHECK(x), y)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(F(x, y)) -> F^1(x, CHECK(y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(D(x, y)) -> D^1(x, CHECK(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(95) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   check(D(x, y)) -> D^1(CHECK(x), y)
   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(F(x, y)) -> F^1(x, CHECK(y))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(D(x, y)) -> D^1(x, CHECK(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   F(x, U(E, y)) -> U(x, F^1(E, y))

Relative ADPs:

   check(U(x, y)) -> U(x, CHECK(y))
   check(O(x)) -> O(CHECK(x))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))


Ordered with Polynomial interpretation [POLO]:

   POL(B) = 0
   POL(CHECK(x_1)) = 3 + 3*x_1
   POL(D(x_1, x_2)) = 2 + 3*x_1 + 3*x_2
   POL(D^1(x_1, x_2)) = 2*x_1
   POL(E) = 3
   POL(E^1) = 0
   POL(F(x_1, x_2)) = 2 + 2*x_1 + 2*x_2
   POL(F^1(x_1, x_2)) = 0
   POL(N(x_1)) = x_1
   POL(O(x_1)) = x_1
   POL(TOP(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(U(x_1, x_2)) = 2*x_1 + x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = 0

----------------------------------------

(96)
Obligation:
Relative ADP Problem with
absolute ADPs:

   F(x, U(E, y)) -> U(x, F^1(E, y))

and relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(F(x, y)) -> F(x, check(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(D(x, y)) -> D(x, check(y))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(97) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(98)
Obligation:
Relative ADP Problem with
absolute ADPs:

   F(x, U(E, y)) -> U(x, F^1(E, y))

and relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   check(N(x)) -> N(check(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(D(x, y)) -> D(x, check(y))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(99) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(100)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F^1(x, U(E, y)) -> F^1(E, y)

The TRS R consists of the following rules:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(101) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.


Strictly oriented rules of the TRS R:

   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))

Used ordering: Polynomial interpretation [POLO]:

   POL(B) = 0
   POL(D(x_1, x_2)) = 2*x_1 + x_2
   POL(E) = 0
   POL(F(x_1, x_2)) = 2*x_1 + x_2
   POL(F^1(x_1, x_2)) = 2*x_1 + x_2
   POL(N(x_1)) = 2*x_1
   POL(O(x_1)) = 1 + x_1
   POL(U(x_1, x_2)) = 2*x_1 + x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = 2*x_1


----------------------------------------

(102)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F^1(x, U(E, y)) -> F^1(E, y)

The TRS R consists of the following rules:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(103) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   F^1(x, U(E, y)) -> F^1(E, y)


Used ordering: Polynomial interpretation [POLO]:

   POL(B) = 1
   POL(D(x_1, x_2)) = 1 + x_1 + x_2
   POL(E) = 0
   POL(F(x_1, x_2)) = 1 + x_1 + x_2
   POL(F^1(x_1, x_2)) = 2*x_1 + x_2
   POL(N(x_1)) = x_1
   POL(O(x_1)) = 2*x_1
   POL(U(x_1, x_2)) = 1 + x_1 + x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = 2*x_1


----------------------------------------

(104)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(105) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(106)
YES

----------------------------------------

(107)
Obligation:
Relative ADP Problem with
absolute ADPs:

   F(x, U(N(y), z)) -> U(x, F^1(y, z))

and relative ADPs:

   check(O(x)) -> O(x)
   check(D(x, y)) -> D^1(CHECK(x), y)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(F(x, y)) -> F^1(x, CHECK(y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(D(x, y)) -> D^1(x, CHECK(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(108) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   check(D(x, y)) -> D^1(CHECK(x), y)
   check(O(x)) -> O(x)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   check(F(x, y)) -> F^1(x, CHECK(y))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(D(x, y)) -> D^1(x, CHECK(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   F(x, U(N(y), z)) -> U(x, F^1(y, z))

Relative ADPs:

   check(U(x, y)) -> U(x, CHECK(y))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))


Ordered with Polynomial interpretation [POLO]:

   POL(B) = 0
   POL(CHECK(x_1)) = 3 + 3*x_1
   POL(D(x_1, x_2)) = 2 + 3*x_1 + 3*x_2
   POL(D^1(x_1, x_2)) = x_1
   POL(E) = 0
   POL(E^1) = 0
   POL(F(x_1, x_2)) = 1 + 3*x_1 + 2*x_2
   POL(F^1(x_1, x_2)) = 3*x_1 + x_2
   POL(N(x_1)) = 3*x_1
   POL(O(x_1)) = 3 + 3*x_1
   POL(TOP(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(U(x_1, x_2)) = x_1 + x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = 0

----------------------------------------

(109)
Obligation:
Relative ADP Problem with
absolute ADPs:

   F(x, U(N(y), z)) -> U(x, F^1(y, z))

and relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(F(x, y)) -> F(x, check(y))
   check(O(x)) -> O(check(x))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(D(x, y)) -> D(x, check(y))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(110) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  1 SCC with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 1 subproblem.

----------------------------------------

(111)
Obligation:
Relative ADP Problem with
absolute ADPs:

   F(x, U(N(y), z)) -> U(x, F^1(y, z))

and relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   check(U(x, y)) -> U(check(x), y)
   check(N(x)) -> N(check(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(D(x, y)) -> D(x, check(y))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(112) RelADPDerelatifyingProof (EQUIVALENT)


We use the first derelatifying processor [IJCAR24].
There are no annotations in relative ADPs, so the relative ADP problem can be transformed into a non-relative DP problem.
----------------------------------------

(113)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F^1(x, U(N(y), z)) -> F^1(y, z)

The TRS R consists of the following rules:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(114) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.


Strictly oriented rules of the TRS R:

   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))

Used ordering: Polynomial interpretation [POLO]:

   POL(B) = 0
   POL(D(x_1, x_2)) = x_1 + 2*x_2
   POL(E) = 0
   POL(F(x_1, x_2)) = 2*x_1 + 2*x_2
   POL(F^1(x_1, x_2)) = 2*x_1 + x_2
   POL(N(x_1)) = 2*x_1
   POL(O(x_1)) = 2 + 2*x_1
   POL(U(x_1, x_2)) = x_1 + 2*x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = x_1


----------------------------------------

(115)
Obligation:
Q DP problem:
The TRS P consists of the following rules:

   F^1(x, U(N(y), z)) -> F^1(y, z)

The TRS R consists of the following rules:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(116) MRRProof (EQUIVALENT)
By using the rule removal processor [LPAR04] with the following ordering, at least one Dependency Pair or term rewrite system rule of this QDP problem can be strictly oriented.

Strictly oriented dependency pairs:

   F^1(x, U(N(y), z)) -> F^1(y, z)


Used ordering: Polynomial interpretation [POLO]:

   POL(B) = 0
   POL(D(x_1, x_2)) = 1 + x_1 + 2*x_2
   POL(E) = 0
   POL(F(x_1, x_2)) = x_1 + x_2
   POL(F^1(x_1, x_2)) = 2*x_1 + x_2
   POL(N(x_1)) = 2*x_1
   POL(O(x_1)) = 2*x_1
   POL(U(x_1, x_2)) = 1 + x_1 + 2*x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = x_1


----------------------------------------

(117)
Obligation:
Q DP problem:
P is empty.
The TRS R consists of the following rules:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(N(x)) -> N(check(x))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   F(x, U(E, y)) -> U(x, F(E, y))
   check(D(x, y)) -> D(x, check(y))

Q is empty.
We have to consider all (P,Q,R)-chains.
----------------------------------------

(118) PisEmptyProof (EQUIVALENT)
The TRS P is empty. Hence, there is no (P,Q,R) chain.
----------------------------------------

(119)
YES

----------------------------------------

(120)
Obligation:
Relative ADP Problem with
absolute ADPs:

   D(E, F(x, y)) -> F^1(E, D(x, y))

and relative ADPs:

   check(O(x)) -> O(x)
   check(D(x, y)) -> D^1(CHECK(x), y)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(F(x, y)) -> F^1(x, CHECK(y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(D(x, y)) -> D^1(x, CHECK(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(121) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Relative ADPs:

   check(D(x, y)) -> D^1(CHECK(x), y)
   check(O(x)) -> O(x)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(F(x, y)) -> F^1(x, CHECK(y))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(D(x, y)) -> D^1(x, CHECK(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


The remaining rules can at least be oriented weakly:
Absolute ADPs:

   D(E, F(x, y)) -> F^1(E, D(x, y))

Relative ADPs:

   check(U(x, y)) -> U(x, CHECK(y))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))


Ordered with Polynomial interpretation [POLO]:

   POL(B) = 3
   POL(CHECK(x_1)) = 3 + 3*x_1
   POL(D(x_1, x_2)) = 2 + 2*x_1 + 2*x_2
   POL(D^1(x_1, x_2)) = 0
   POL(E) = 0
   POL(E^1) = 0
   POL(F(x_1, x_2)) = 2 + 2*x_1 + x_2
   POL(F^1(x_1, x_2)) = 2*x_1
   POL(N(x_1)) = 2*x_1
   POL(O(x_1)) = 2 + 2*x_1
   POL(TOP(x_1)) = 3 + 3*x_1 + 3*x_1^2
   POL(U(x_1, x_2)) = 2*x_1 + x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = 0

----------------------------------------

(122)
Obligation:
Relative ADP Problem with
absolute ADPs:

   D(E, F(x, y)) -> F^1(E, D(x, y))

and relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(F(x, y)) -> F(x, check(y))
   check(O(x)) -> O(check(x))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(D(x, y)) -> D(x, check(y))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(123) RelADPDepGraphProof (EQUIVALENT)


We use the relative dependency graph processor [IJCAR24].
The approximation of the Relative Dependency Graph contains:
  0 SCCs with nodes from P_abs,
  0 Lassos,
Result: This relative DT problem is equivalent to 0 subproblems.

----------------------------------------

(124)
TRUE

----------------------------------------

(125)
Obligation:
Relative ADP Problem with
absolute ADPs:

   D(O(x), F(y, z)) -> F^1(x, D(y, z))

and relative ADPs:

   check(O(x)) -> O(x)
   check(D(x, y)) -> D^1(CHECK(x), y)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(U(x, y)) -> U(CHECK(x), y)
   check(N(x)) -> N(CHECK(x))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   check(F(x, y)) -> F^1(x, CHECK(y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(D(x, y)) -> D^1(x, CHECK(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(126) RelADPReductionPairProof (EQUIVALENT)


We use the reduction pair processor [IJCAR24].
The following rules can be oriented strictly (l^# > ann(r)) 
and therefore we can remove all of its annotations in the right-hand side:
Absolute ADPs:

   D(O(x), F(y, z)) -> F^1(x, D(y, z))

Relative ADPs:

   check(D(x, y)) -> D^1(CHECK(x), y)
   check(O(x)) -> O(x)
   E -> N(E)
   check(O(x)) -> O(CHECK(x))
   check(U(x, y)) -> U(CHECK(x), y)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(F(x, y)) -> F^1(x, CHECK(y))
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(F(x, y)) -> F^1(CHECK(x), y)
   check(U(x, y)) -> U(x, CHECK(y))
   check(D(x, y)) -> D^1(x, CHECK(y))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   F(x, U(E, y)) -> U(x, F(E, y))


The remaining rules can at least be oriented weakly:

Ordered with Polynomial interpretation [POLO]:

   POL(B) = 2
   POL(CHECK(x_1)) = 3 + 3*x_1
   POL(D(x_1, x_2)) = 2 + 2*x_1 + 3*x_2
   POL(D^1(x_1, x_2)) = 2*x_1 + 3*x_2
   POL(E) = 0
   POL(E^1) = 0
   POL(F(x_1, x_2)) = 2 + 2*x_1 + 2*x_2
   POL(F^1(x_1, x_2)) = 2*x_2
   POL(N(x_1)) = x_1
   POL(O(x_1)) = 2 + 2*x_1
   POL(TOP(x_1)) = 2 + 3*x_1 + 3*x_1^2
   POL(U(x_1, x_2)) = 3 + x_1 + x_2
   POL(check(x_1)) = x_1
   POL(top(x_1)) = 0

----------------------------------------

(127)
Obligation:
Relative ADP Problem with
No absolute ADPs, and relative ADPs:

   check(O(x)) -> O(x)
   E -> N(E)
   F(x, U(N(y), z)) -> U(x, F(y, z))
   check(N(x)) -> N(CHECK(x))
   check(U(x, y)) -> U(check(x), y)
   D(x, B) -> U(x, B)
   D(E, F(x, y)) -> F(E, D(x, y))
   top(U(x, y)) -> top(check(D(x, y)))
   check(D(x, y)) -> D(check(x), y)
   check(F(x, y)) -> F(x, check(y))
   check(U(x, y)) -> U(x, check(y))
   check(O(x)) -> O(check(x))
   F(x, U(O(y), z)) -> U(x, F(y, z))
   D(N(x), F(y, z)) -> F(x, D(y, z))
   D(O(x), F(y, z)) -> F(x, D(y, z))
   check(F(x, y)) -> F(check(x), y)
   check(D(x, y)) -> D(x, check(y))
   F(x, U(E, y)) -> U(x, F(E, y))


----------------------------------------

(128) DAbsisEmptyProof (EQUIVALENT)
The relative ADP Problem has an empty P_abs. Hence, no infinite chain exists.
----------------------------------------

(129)
YES
