YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/SJrHX.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be proven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 0 ms]
(2) JBC problem
(3) JBCToGraph [EQUIVALENT, 252 ms]
(4) JBCTerminationGraph
(5) TerminationGraphToSCCProof [SOUND, 0 ms]
(6) JBCTerminationSCC
(7) SCCToIRSProof [SOUND, 74 ms]
(8) IRSwT
(9) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
(10) IRSwT
(11) IRSwTTerminationDigraphProof [EQUIVALENT, 21 ms]
(12) IRSwT
(13) IntTRSCompressionProof [EQUIVALENT, 0 ms]
(14) IRSwT
(15) TempFilterProof [SOUND, 22 ms]
(16) IntTRS
(17) PolynomialOrderProcessor [EQUIVALENT, 9 ms]
(18) YES


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
public class EqUserDefRec {
	public static void main(String[] args) {
		int x = args[0].length();
		int y = args[1].length();
		eq(x, y);
	}

	public static boolean eq(int x, int y) {
		if (x > 0 && y > 0) {
			return eq(x-1, y-1);
		} else {
			return (x == 0 && y == 0);
		}
	}
}



----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
public class EqUserDefRec {
	public static void main(String[] args) {
		int x = args[0].length();
		int y = args[1].length();
		eq(x, y);
	}

	public static boolean eq(int x, int y) {
		if (x > 0 && y > 0) {
			return eq(x-1, y-1);
		} else {
			return (x == 0 && y == 0);
		}
	}
}



----------------------------------------

(3) JBCToGraph (EQUIVALENT)
Constructed TerminationGraph.
----------------------------------------

(4)
Obligation:
Termination Graph based on JBC Program:
EqUserDefRec.main([Ljava/lang/String;)V: Graph of 129 nodes with 0 SCCs.



EqUserDefRec.eq(II)Z: Graph of 43 nodes with 0 SCCs.





----------------------------------------

(5) TerminationGraphToSCCProof (SOUND)
Splitted TerminationGraph to 1 SCCs.
----------------------------------------

(6)
Obligation:
SCC of termination graph based on JBC Program.
SCC contains nodes from the following methods: EqUserDefRec.eq(II)Z
SCC calls the following helper methods: EqUserDefRec.eq(II)Z
Performed SCC analyses:
*Used field analysis yielded the following read fields:

*Marker field analysis yielded the following relations that could be markers:

----------------------------------------

(7) SCCToIRSProof (SOUND)
Transformed FIGraph SCCs to intTRSs. Log: 
Generated rules. Obtained 16 IRulesP rules:
f237_0_eq_LE(EOS(STATIC_237), i43, i30, i43, i30, i43) -> f303_0_eq_LE(EOS(STATIC_303), i43, i30, i43, i30, i43) :|: TRUE
f303_0_eq_LE(EOS(STATIC_303), i43, i30, i43, i30, i43) -> f320_0_eq_Load(EOS(STATIC_320), i43, i30, i43, i30) :|: i43 > 0
f320_0_eq_Load(EOS(STATIC_320), i43, i30, i43, i30) -> f338_0_eq_LE(EOS(STATIC_338), i43, i30, i43, i30, i30) :|: TRUE
f338_0_eq_LE(EOS(STATIC_338), i43, i48, i43, i48, i48) -> f351_0_eq_LE(EOS(STATIC_351), i43, i48, i43, i48, i48) :|: TRUE
f351_0_eq_LE(EOS(STATIC_351), i43, i48, i43, i48, i48) -> f386_0_eq_Load(EOS(STATIC_386), i43, i48, i43, i48) :|: i48 > 0
f386_0_eq_Load(EOS(STATIC_386), i43, i48, i43, i48) -> f401_0_eq_ConstantStackPush(EOS(STATIC_401), i43, i48, i48, i43) :|: TRUE
f401_0_eq_ConstantStackPush(EOS(STATIC_401), i43, i48, i48, i43) -> f418_0_eq_IntArithmetic(EOS(STATIC_418), i43, i48, i48, i43, 1) :|: TRUE
f418_0_eq_IntArithmetic(EOS(STATIC_418), i43, i48, i48, i43, matching1) -> f433_0_eq_Load(EOS(STATIC_433), i43, i48, i48, i43 - 1) :|: i43 > 0 && matching1 = 1
f433_0_eq_Load(EOS(STATIC_433), i43, i48, i48, i56) -> f466_0_eq_ConstantStackPush(EOS(STATIC_466), i43, i48, i56, i48) :|: TRUE
f466_0_eq_ConstantStackPush(EOS(STATIC_466), i43, i48, i56, i48) -> f520_0_eq_IntArithmetic(EOS(STATIC_520), i43, i48, i56, i48, 1) :|: TRUE
f520_0_eq_IntArithmetic(EOS(STATIC_520), i43, i48, i56, i48, matching1) -> f563_0_eq_InvokeMethod(EOS(STATIC_563), i43, i48, i56, i48 - 1) :|: i48 > 0 && matching1 = 1
f563_0_eq_InvokeMethod(EOS(STATIC_563), i43, i48, i56, i74) -> f585_0_eq_Load(EOS(STATIC_585), i56, i74, i56, i74) :|: i43 >= 1 && i48 >= 1 && i56 < i43 && i74 < i48
f563_0_eq_InvokeMethod(EOS(STATIC_563), i43, i48, i56, i74) -> f585_1_eq_Load(EOS(STATIC_585), i43, i48, i56, i74) :|: i43 >= 1 && i48 >= 1 && i56 < i43 && i74 < i48
f585_0_eq_Load(EOS(STATIC_585), i56, i74, i56, i74) -> f593_0_eq_Load(EOS(STATIC_593), i56, i74, i56, i74) :|: TRUE
f593_0_eq_Load(EOS(STATIC_593), i56, i74, i56, i74) -> f230_0_eq_Load(EOS(STATIC_230), i56, i74, i56, i74) :|: TRUE
f230_0_eq_Load(EOS(STATIC_230), i13, i30, i13, i30) -> f237_0_eq_LE(EOS(STATIC_237), i13, i30, i13, i30, i13) :|: TRUE
Combined rules. Obtained 2 IRulesP rules:
f237_0_eq_LE(EOS(STATIC_237), i43:0, i30:0, i43:0, i30:0, i43:0) -> f237_0_eq_LE(EOS(STATIC_237), i43:0 - 1, i30:0 - 1, i43:0 - 1, i30:0 - 1, i43:0 - 1) :|: i43:0 > 0 && i30:0 > 0 && i43:0 - 1 < i43:0 && i30:0 - 1 < i30:0
Removed following non-SCC rules:
f237_0_eq_LE(EOS(STATIC_237), i43:0, i30:0, i43:0, i30:0, i43:0) -> f585_1_eq_Load(EOS(STATIC_585), i43:0, i30:0, i43:0 - 1, i30:0 - 1) :|: i43:0 > 0 && i30:0 > 0 && i43:0 - 1 < i43:0 && i30:0 - 1 < i30:0
Filtered constant ground arguments:
   f237_0_eq_LE(x1, x2, x3, x4, x5, x6) -> f237_0_eq_LE(x2, x3, x4, x5, x6)
   EOS(x1) -> EOS
Filtered duplicate arguments:
   f237_0_eq_LE(x1, x2, x3, x4, x5) -> f237_0_eq_LE(x4, x5)
Finished conversion. Obtained 1 rules.P rules:
f237_0_eq_LE(i30:0, i43:0) -> f237_0_eq_LE(i30:0 - 1, i43:0 - 1) :|: i30:0 > 0 && i43:0 > 0 && i30:0 - 1 < i30:0 && i43:0 - 1 < i43:0

----------------------------------------

(8)
Obligation:
Rules:
f237_0_eq_LE(i30:0, i43:0) -> f237_0_eq_LE(i30:0 - 1, i43:0 - 1) :|: i30:0 > 0 && i43:0 > 0 && i30:0 - 1 < i30:0 && i43:0 - 1 < i43:0

----------------------------------------

(9) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(10)
Obligation:
Rules:
f237_0_eq_LE(i30:0, i43:0) -> f237_0_eq_LE(arith, arith1) :|: i30:0 > 0 && i43:0 > 0 && i30:0 - 1 < i30:0 && i43:0 - 1 < i43:0 && arith = i30:0 - 1 && arith1 = i43:0 - 1

----------------------------------------

(11) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f237_0_eq_LE(i30:0, i43:0) -> f237_0_eq_LE(arith, arith1) :|: i30:0 > 0 && i43:0 > 0 && i30:0 - 1 < i30:0 && i43:0 - 1 < i43:0 && arith = i30:0 - 1 && arith1 = i43:0 - 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(12)
Obligation:

Termination digraph:
Nodes:
(1) f237_0_eq_LE(i30:0, i43:0) -> f237_0_eq_LE(arith, arith1) :|: i30:0 > 0 && i43:0 > 0 && i30:0 - 1 < i30:0 && i43:0 - 1 < i43:0 && arith = i30:0 - 1 && arith1 = i43:0 - 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(13) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(14)
Obligation:
Rules:
f237_0_eq_LE(i30:0:0, i43:0:0) -> f237_0_eq_LE(i30:0:0 - 1, i43:0:0 - 1) :|: i30:0:0 - 1 < i30:0:0 && i43:0:0 - 1 < i43:0:0 && i43:0:0 > 0 && i30:0:0 > 0

----------------------------------------

(15) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f237_0_eq_LE(INTEGER, INTEGER)
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(16)
Obligation:
Rules:
f237_0_eq_LE(i30:0:0, i43:0:0) -> f237_0_eq_LE(c, c1) :|: c1 = i43:0:0 - 1 && c = i30:0:0 - 1 && (i30:0:0 - 1 < i30:0:0 && i43:0:0 - 1 < i43:0:0 && i43:0:0 > 0 && i30:0:0 > 0)

----------------------------------------

(17) PolynomialOrderProcessor (EQUIVALENT)
Found the following polynomial interpretation:
[f237_0_eq_LE(x, x1)] = x1

The following rules are decreasing:
f237_0_eq_LE(i30:0:0, i43:0:0) -> f237_0_eq_LE(c, c1) :|: c1 = i43:0:0 - 1 && c = i30:0:0 - 1 && (i30:0:0 - 1 < i30:0:0 && i43:0:0 - 1 < i43:0:0 && i43:0:0 > 0 && i30:0:0 > 0)
The following rules are bounded:
f237_0_eq_LE(i30:0:0, i43:0:0) -> f237_0_eq_LE(c, c1) :|: c1 = i43:0:0 - 1 && c = i30:0:0 - 1 && (i30:0:0 - 1 < i30:0:0 && i43:0:0 - 1 < i43:0:0 && i43:0:0 > 0 && i30:0:0 > 0)

----------------------------------------

(18)
YES
