YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/cagoR.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be proven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 0 ms]
(2) JBC problem
(3) JBCToGraph [EQUIVALENT, 192 ms]
(4) JBCTerminationGraph
(5) TerminationGraphToSCCProof [SOUND, 0 ms]
(6) JBCTerminationSCC
(7) SCCToIRSProof [SOUND, 37 ms]
(8) IRSwT
(9) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
(10) IRSwT
(11) IRSwTTerminationDigraphProof [EQUIVALENT, 12 ms]
(12) IRSwT
(13) IntTRSCompressionProof [EQUIVALENT, 0 ms]
(14) IRSwT
(15) TempFilterProof [SOUND, 7 ms]
(16) IntTRS
(17) PolynomialOrderProcessor [EQUIVALENT, 0 ms]
(18) YES


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
package TwoWay;

public class Random {
  static String[] args;
  static int index = 0;

  public static int random() {
    final String string = args[index];
    index++;
    return string.length();
  }
}


package TwoWay;

public class TwoWay {
	public static void main(String[] args) {
		Random.args = args;
		twoWay(true, Random.random());
	}

	public static int twoWay(boolean terminate, int n) {
		if (n < 0) {
			return 1;
		} else {
			int m = n;
			if (terminate) {
				m--;
			} else {
				m++;
			}
			return m*twoWay(terminate, m);
		}
	}
}



----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
package TwoWay;

public class Random {
  static String[] args;
  static int index = 0;

  public static int random() {
    final String string = args[index];
    index++;
    return string.length();
  }
}


package TwoWay;

public class TwoWay {
	public static void main(String[] args) {
		Random.args = args;
		twoWay(true, Random.random());
	}

	public static int twoWay(boolean terminate, int n) {
		if (n < 0) {
			return 1;
		} else {
			int m = n;
			if (terminate) {
				m--;
			} else {
				m++;
			}
			return m*twoWay(terminate, m);
		}
	}
}



----------------------------------------

(3) JBCToGraph (EQUIVALENT)
Constructed TerminationGraph.
----------------------------------------

(4)
Obligation:
Termination Graph based on JBC Program:
TwoWay.TwoWay.main([Ljava/lang/String;)V: Graph of 108 nodes with 0 SCCs.



TwoWay.TwoWay.twoWay(ZI)I: Graph of 29 nodes with 0 SCCs.





----------------------------------------

(5) TerminationGraphToSCCProof (SOUND)
Splitted TerminationGraph to 1 SCCs.
----------------------------------------

(6)
Obligation:
SCC of termination graph based on JBC Program.
SCC contains nodes from the following methods: TwoWay.TwoWay.twoWay(ZI)I
SCC calls the following helper methods: TwoWay.TwoWay.twoWay(ZI)I
Performed SCC analyses:
*Used field analysis yielded the following read fields:

*Marker field analysis yielded the following relations that could be markers:

----------------------------------------

(7) SCCToIRSProof (SOUND)
Transformed FIGraph SCCs to intTRSs. Log: 
Generated rules. Obtained 16 IRulesP rules:
f418_0_twoWay_GE(EOS(STATIC_418), matching1, i67, matching2, i67, i67) -> f421_0_twoWay_GE(EOS(STATIC_421), 1, i67, 1, i67, i67) :|: TRUE && matching1 = 1 && matching2 = 1
f421_0_twoWay_GE(EOS(STATIC_421), matching1, i67, matching2, i67, i67) -> f423_0_twoWay_Load(EOS(STATIC_423), 1, i67, 1, i67) :|: i67 >= 0 && matching1 = 1 && matching2 = 1
f423_0_twoWay_Load(EOS(STATIC_423), matching1, i67, matching2, i67) -> f425_0_twoWay_Store(EOS(STATIC_425), 1, i67, 1, i67) :|: TRUE && matching1 = 1 && matching2 = 1
f425_0_twoWay_Store(EOS(STATIC_425), matching1, i67, matching2, i67) -> f428_0_twoWay_Load(EOS(STATIC_428), 1, i67, 1, i67) :|: TRUE && matching1 = 1 && matching2 = 1
f428_0_twoWay_Load(EOS(STATIC_428), matching1, i67, matching2, i67) -> f456_0_twoWay_EQ(EOS(STATIC_456), 1, i67, 1, i67, 1) :|: TRUE && matching1 = 1 && matching2 = 1
f456_0_twoWay_EQ(EOS(STATIC_456), matching1, i67, matching2, i67, matching3) -> f458_0_twoWay_Inc(EOS(STATIC_458), 1, i67, 1, i67) :|: 1 > 0 && matching1 = 1 && matching2 = 1 && matching3 = 1
f458_0_twoWay_Inc(EOS(STATIC_458), matching1, i67, matching2, i67) -> f459_0_twoWay_JMP(EOS(STATIC_459), 1, i67, 1, i67 + -1) :|: TRUE && matching1 = 1 && matching2 = 1
f459_0_twoWay_JMP(EOS(STATIC_459), matching1, i67, matching2, i80) -> f462_0_twoWay_Load(EOS(STATIC_462), 1, i67, 1, i80) :|: TRUE && matching1 = 1 && matching2 = 1
f462_0_twoWay_Load(EOS(STATIC_462), matching1, i67, matching2, i80) -> f464_0_twoWay_Load(EOS(STATIC_464), 1, i67, 1, i80, i80) :|: TRUE && matching1 = 1 && matching2 = 1
f464_0_twoWay_Load(EOS(STATIC_464), matching1, i67, matching2, i80, i80) -> f466_0_twoWay_Load(EOS(STATIC_466), 1, i67, i80, i80, 1) :|: TRUE && matching1 = 1 && matching2 = 1
f466_0_twoWay_Load(EOS(STATIC_466), matching1, i67, i80, i80, matching2) -> f468_0_twoWay_InvokeMethod(EOS(STATIC_468), 1, i67, i80, 1, i80) :|: TRUE && matching1 = 1 && matching2 = 1
f468_0_twoWay_InvokeMethod(EOS(STATIC_468), matching1, i67, i80, matching2, i80) -> f470_0_twoWay_Load(EOS(STATIC_470), 1, i80, 1, i80) :|: i15 >= 1 && i80 < i67 && matching1 = 1 && matching2 = 1
f468_0_twoWay_InvokeMethod(EOS(STATIC_468), matching1, i67, i80, matching2, i80) -> f470_1_twoWay_Load(EOS(STATIC_470), 1, i67, i80, 1, i80) :|: i15 >= 1 && i80 < i67 && matching1 = 1 && matching2 = 1
f470_0_twoWay_Load(EOS(STATIC_470), matching1, i80, matching2, i80) -> f475_0_twoWay_Load(EOS(STATIC_475), 1, i80, 1, i80) :|: TRUE && matching1 = 1 && matching2 = 1
f475_0_twoWay_Load(EOS(STATIC_475), matching1, i80, matching2, i80) -> f413_0_twoWay_Load(EOS(STATIC_413), 1, i80, 1, i80) :|: TRUE && matching1 = 1 && matching2 = 1
f413_0_twoWay_Load(EOS(STATIC_413), matching1, i65, matching2, i65) -> f418_0_twoWay_GE(EOS(STATIC_418), 1, i65, 1, i65, i65) :|: TRUE && matching1 = 1 && matching2 = 1
Combined rules. Obtained 2 IRulesP rules:
f418_0_twoWay_GE(EOS(STATIC_418), 1, i67:0, 1, i67:0, i67:0) -> f418_0_twoWay_GE(EOS(STATIC_418), 1, i67:0 - 1, 1, i67:0 - 1, i67:0 - 1) :|: i67:0 > -1 && i15:0 > 0 && i67:0 - 1 < i67:0
Removed following non-SCC rules:
f418_0_twoWay_GE(EOS(STATIC_418), 1, i67:0, 1, i67:0, i67:0) -> f470_1_twoWay_Load(EOS(STATIC_470), 1, i67:0, i67:0 - 1, 1, i67:0 - 1) :|: i67:0 > -1 && i15:0 > 0 && i67:0 - 1 < i67:0
Filtered constant ground arguments:
   f418_0_twoWay_GE(x1, x2, x3, x4, x5, x6) -> f418_0_twoWay_GE(x3, x5, x6)
   EOS(x1) -> EOS
Filtered duplicate arguments:
   f418_0_twoWay_GE(x1, x2, x3) -> f418_0_twoWay_GE(x3)
Finished conversion. Obtained 1 rules.P rules:
f418_0_twoWay_GE(i67:0) -> f418_0_twoWay_GE(i67:0 - 1) :|: i15:0 > 0 && i67:0 - 1 < i67:0 && i67:0 > -1

----------------------------------------

(8)
Obligation:
Rules:
f418_0_twoWay_GE(i67:0) -> f418_0_twoWay_GE(i67:0 - 1) :|: i15:0 > 0 && i67:0 - 1 < i67:0 && i67:0 > -1

----------------------------------------

(9) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(10)
Obligation:
Rules:
f418_0_twoWay_GE(i67:0) -> f418_0_twoWay_GE(arith) :|: i15:0 > 0 && i67:0 - 1 < i67:0 && i67:0 > -1 && arith = i67:0 - 1

----------------------------------------

(11) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f418_0_twoWay_GE(i67:0) -> f418_0_twoWay_GE(arith) :|: i15:0 > 0 && i67:0 - 1 < i67:0 && i67:0 > -1 && arith = i67:0 - 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(12)
Obligation:

Termination digraph:
Nodes:
(1) f418_0_twoWay_GE(i67:0) -> f418_0_twoWay_GE(arith) :|: i15:0 > 0 && i67:0 - 1 < i67:0 && i67:0 > -1 && arith = i67:0 - 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(13) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(14)
Obligation:
Rules:
f418_0_twoWay_GE(i67:0:0) -> f418_0_twoWay_GE(i67:0:0 - 1) :|: i15:0:0 > 0 && i67:0:0 - 1 < i67:0:0 && i67:0:0 > -1

----------------------------------------

(15) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f418_0_twoWay_GE(INTEGER)
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(16)
Obligation:
Rules:
f418_0_twoWay_GE(i67:0:0) -> f418_0_twoWay_GE(c) :|: c = i67:0:0 - 1 && (i15:0:0 > 0 && i67:0:0 - 1 < i67:0:0 && i67:0:0 > -1)

----------------------------------------

(17) PolynomialOrderProcessor (EQUIVALENT)
Found the following polynomial interpretation:
[f418_0_twoWay_GE(x)] = x

The following rules are decreasing:
f418_0_twoWay_GE(i67:0:0) -> f418_0_twoWay_GE(c) :|: c = i67:0:0 - 1 && (i15:0:0 > 0 && i67:0:0 - 1 < i67:0:0 && i67:0:0 > -1)
The following rules are bounded:
f418_0_twoWay_GE(i67:0:0) -> f418_0_twoWay_GE(c) :|: c = i67:0:0 - 1 && (i15:0:0 > 0 && i67:0:0 - 1 < i67:0:0 && i67:0:0 > -1)

----------------------------------------

(18)
YES
