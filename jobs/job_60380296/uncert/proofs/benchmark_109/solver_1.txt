YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/CSqnL.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be proven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 53 ms]
(2) JBC problem
(3) JBCToGraph [EQUIVALENT, 314 ms]
(4) JBCTerminationGraph
(5) TerminationGraphToSCCProof [SOUND, 0 ms]
(6) JBCTerminationSCC
(7) SCCToIRSProof [SOUND, 80 ms]
(8) IRSwT
(9) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
(10) IRSwT
(11) IRSwTTerminationDigraphProof [EQUIVALENT, 26 ms]
(12) IRSwT
(13) IntTRSCompressionProof [EQUIVALENT, 0 ms]
(14) IRSwT
(15) IRSwTChainingProof [EQUIVALENT, 0 ms]
(16) IRSwT
(17) IRSwTTerminationDigraphProof [EQUIVALENT, 0 ms]
(18) IRSwT
(19) IntTRSCompressionProof [EQUIVALENT, 0 ms]
(20) IRSwT
(21) TempFilterProof [SOUND, 26 ms]
(22) IntTRS
(23) PolynomialOrderProcessor [EQUIVALENT, 0 ms]
(24) YES


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
public class Et1 {
    public static void main(String[] args) {
		Random.args = args;
	    int a = - Random.random(); 
	   	int b = - Random.random();	
	   	loop(a,b);
	}
	public static void loop(int a, int b){
	   	if (a > b) {
	   		b = b + a;
 			a = a + 1;
 			loop(a,b);
	   	}
    }
}


public class Random {
  static String[] args;
  static int index = 0;

  public static int random() {
      if (index >= args.length)
	  return 0;

      String string = args[index];
      index++;
      return string.length();
  }
}



----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
public class Et1 {
    public static void main(String[] args) {
		Random.args = args;
	    int a = - Random.random(); 
	   	int b = - Random.random();	
	   	loop(a,b);
	}
	public static void loop(int a, int b){
	   	if (a > b) {
	   		b = b + a;
 			a = a + 1;
 			loop(a,b);
	   	}
    }
}


public class Random {
  static String[] args;
  static int index = 0;

  public static int random() {
      if (index >= args.length)
	  return 0;

      String string = args[index];
      index++;
      return string.length();
  }
}



----------------------------------------

(3) JBCToGraph (EQUIVALENT)
Constructed TerminationGraph.
----------------------------------------

(4)
Obligation:
Termination Graph based on JBC Program:
Et1.main([Ljava/lang/String;)V: Graph of 234 nodes with 0 SCCs.



Et1.loop(II)V: Graph of 24 nodes with 0 SCCs.





----------------------------------------

(5) TerminationGraphToSCCProof (SOUND)
Splitted TerminationGraph to 1 SCCs.
----------------------------------------

(6)
Obligation:
SCC of termination graph based on JBC Program.
SCC contains nodes from the following methods: Et1.loop(II)V
SCC calls the following helper methods: Et1.loop(II)V
Performed SCC analyses:
*Used field analysis yielded the following read fields:

*Marker field analysis yielded the following relations that could be markers:

----------------------------------------

(7) SCCToIRSProof (SOUND)
Transformed FIGraph SCCs to intTRSs. Log: 
Generated rules. Obtained 18 IRulesP rules:
f1068_0_loop_Load(EOS(STATIC_1068), i215, i216, i215, i216, i215) -> f1069_0_loop_LE(EOS(STATIC_1069), i215, i216, i215, i216, i215, i216) :|: TRUE
f1069_0_loop_LE(EOS(STATIC_1069), i215, i216, i215, i216, i215, i216) -> f1086_0_loop_LE(EOS(STATIC_1086), i215, i216, i215, i216, i215, i216) :|: i215 > i216
f1086_0_loop_LE(EOS(STATIC_1086), i215, i216, i215, i216, i215, i216) -> f1100_0_loop_Load(EOS(STATIC_1100), i215, i216, i215, i216) :|: i215 > i216
f1100_0_loop_Load(EOS(STATIC_1100), i215, i216, i215, i216) -> f1105_0_loop_Load(EOS(STATIC_1105), i215, i216, i215, i216) :|: TRUE
f1105_0_loop_Load(EOS(STATIC_1105), i215, i216, i215, i216) -> f1124_0_loop_IntArithmetic(EOS(STATIC_1124), i215, i216, i215, i216, i215) :|: TRUE
f1124_0_loop_IntArithmetic(EOS(STATIC_1124), i215, i216, i215, i216, i215) -> f1157_0_loop_Store(EOS(STATIC_1157), i215, i216, i215, i216 + i215) :|: TRUE
f1157_0_loop_Store(EOS(STATIC_1157), i215, i216, i215, i245) -> f1159_0_loop_Load(EOS(STATIC_1159), i215, i216, i215, i245) :|: TRUE
f1159_0_loop_Load(EOS(STATIC_1159), i215, i216, i215, i245) -> f1161_0_loop_ConstantStackPush(EOS(STATIC_1161), i215, i216, i245, i215) :|: TRUE
f1161_0_loop_ConstantStackPush(EOS(STATIC_1161), i215, i216, i245, i215) -> f1165_0_loop_IntArithmetic(EOS(STATIC_1165), i215, i216, i245, i215, 1) :|: TRUE
f1165_0_loop_IntArithmetic(EOS(STATIC_1165), i215, i216, i245, i215, matching1) -> f1210_0_loop_Store(EOS(STATIC_1210), i215, i216, i245, i215 + 1) :|: TRUE && matching1 = 1
f1210_0_loop_Store(EOS(STATIC_1210), i215, i216, i245, i249) -> f1212_0_loop_Load(EOS(STATIC_1212), i215, i216, i249, i245) :|: TRUE
f1212_0_loop_Load(EOS(STATIC_1212), i215, i216, i249, i245) -> f1214_0_loop_Load(EOS(STATIC_1214), i215, i216, i245, i249) :|: TRUE
f1214_0_loop_Load(EOS(STATIC_1214), i215, i216, i245, i249) -> f1216_0_loop_InvokeMethod(EOS(STATIC_1216), i215, i216, i249, i245) :|: TRUE
f1216_0_loop_InvokeMethod(EOS(STATIC_1216), i215, i216, i249, i245) -> f1220_0_loop_Load(EOS(STATIC_1220), i249, i245, i249, i245) :|: i215 > i216 && i249 > i215 && i249 > i216
f1216_0_loop_InvokeMethod(EOS(STATIC_1216), i215, i216, i249, i245) -> f1220_1_loop_Load(EOS(STATIC_1220), i215, i216, i249, i245) :|: i215 > i216 && i249 > i215 && i249 > i216
f1220_0_loop_Load(EOS(STATIC_1220), i249, i245, i249, i245) -> f1224_0_loop_Load(EOS(STATIC_1224), i249, i245, i249, i245) :|: TRUE
f1224_0_loop_Load(EOS(STATIC_1224), i249, i245, i249, i245) -> f1064_0_loop_Load(EOS(STATIC_1064), i249, i245, i249, i245) :|: TRUE
f1064_0_loop_Load(EOS(STATIC_1064), i215, i216, i215, i216) -> f1068_0_loop_Load(EOS(STATIC_1068), i215, i216, i215, i216, i215) :|: TRUE
Combined rules. Obtained 2 IRulesP rules:
f1068_0_loop_Load(EOS(STATIC_1068), i215:0, i216:0, i215:0, i216:0, i215:0) -> f1068_0_loop_Load(EOS(STATIC_1068), i215:0 + 1, i216:0 + i215:0, i215:0 + 1, i216:0 + i215:0, i215:0 + 1) :|: i216:0 < i215:0 && i215:0 + 1 > i215:0 && i216:0 < i215:0 + 1
Removed following non-SCC rules:
f1068_0_loop_Load(EOS(STATIC_1068), i215:0, i216:0, i215:0, i216:0, i215:0) -> f1220_1_loop_Load(EOS(STATIC_1220), i215:0, i216:0, i215:0 + 1, i216:0 + i215:0) :|: i216:0 < i215:0 && i215:0 + 1 > i215:0 && i216:0 < i215:0 + 1
Filtered constant ground arguments:
   f1068_0_loop_Load(x1, x2, x3, x4, x5, x6) -> f1068_0_loop_Load(x2, x3, x4, x5, x6)
   EOS(x1) -> EOS
Filtered duplicate arguments:
   f1068_0_loop_Load(x1, x2, x3, x4, x5) -> f1068_0_loop_Load(x4, x5)
Finished conversion. Obtained 1 rules.P rules:
f1068_0_loop_Load(i216:0, i215:0) -> f1068_0_loop_Load(i216:0 + i215:0, i215:0 + 1) :|: i215:0 + 1 > i215:0 && i216:0 < i215:0 + 1 && i216:0 < i215:0

----------------------------------------

(8)
Obligation:
Rules:
f1068_0_loop_Load(i216:0, i215:0) -> f1068_0_loop_Load(i216:0 + i215:0, i215:0 + 1) :|: i215:0 + 1 > i215:0 && i216:0 < i215:0 + 1 && i216:0 < i215:0

----------------------------------------

(9) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(10)
Obligation:
Rules:
f1068_0_loop_Load(i216:0, i215:0) -> f1068_0_loop_Load(arith, arith1) :|: i215:0 + 1 > i215:0 && i216:0 < i215:0 + 1 && i216:0 < i215:0 && arith = i216:0 + i215:0 && arith1 = i215:0 + 1

----------------------------------------

(11) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f1068_0_loop_Load(i216:0, i215:0) -> f1068_0_loop_Load(arith, arith1) :|: i215:0 + 1 > i215:0 && i216:0 < i215:0 + 1 && i216:0 < i215:0 && arith = i216:0 + i215:0 && arith1 = i215:0 + 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(12)
Obligation:

Termination digraph:
Nodes:
(1) f1068_0_loop_Load(i216:0, i215:0) -> f1068_0_loop_Load(arith, arith1) :|: i215:0 + 1 > i215:0 && i216:0 < i215:0 + 1 && i216:0 < i215:0 && arith = i216:0 + i215:0 && arith1 = i215:0 + 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(13) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(14)
Obligation:
Rules:
f1068_0_loop_Load(i216:0:0, i215:0:0) -> f1068_0_loop_Load(i216:0:0 + i215:0:0, i215:0:0 + 1) :|: i215:0:0 + 1 > i215:0:0 && i216:0:0 < i215:0:0 + 1 && i216:0:0 < i215:0:0

----------------------------------------

(15) IRSwTChainingProof (EQUIVALENT)
Chaining!
----------------------------------------

(16)
Obligation:
Rules:
f1068_0_loop_Load(x, x1) -> f1068_0_loop_Load(x + 2 * x1 + 1, x1 + 2) :|: TRUE && x + -1 * x1 <= -1 && x <= 0

----------------------------------------

(17) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f1068_0_loop_Load(x, x1) -> f1068_0_loop_Load(x + 2 * x1 + 1, x1 + 2) :|: TRUE && x + -1 * x1 <= -1 && x <= 0

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(18)
Obligation:

Termination digraph:
Nodes:
(1) f1068_0_loop_Load(x, x1) -> f1068_0_loop_Load(x + 2 * x1 + 1, x1 + 2) :|: TRUE && x + -1 * x1 <= -1 && x <= 0

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(19) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(20)
Obligation:
Rules:
f1068_0_loop_Load(x:0, x1:0) -> f1068_0_loop_Load(x:0 + 2 * x1:0 + 1, x1:0 + 2) :|: x:0 < 1 && x:0 + -1 * x1:0 <= -1

----------------------------------------

(21) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f1068_0_loop_Load(INTEGER, INTEGER)
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(22)
Obligation:
Rules:
f1068_0_loop_Load(x:0, x1:0) -> f1068_0_loop_Load(c, c1) :|: c1 = x1:0 + 2 && c = x:0 + 2 * x1:0 + 1 && (x:0 < 1 && x:0 + -1 * x1:0 <= -1)

----------------------------------------

(23) PolynomialOrderProcessor (EQUIVALENT)
Found the following polynomial interpretation:
[f1068_0_loop_Load(x, x1)] = 1 - 2*x - 2*x1 + x1^2

The following rules are decreasing:
f1068_0_loop_Load(x:0, x1:0) -> f1068_0_loop_Load(c, c1) :|: c1 = x1:0 + 2 && c = x:0 + 2 * x1:0 + 1 && (x:0 < 1 && x:0 + -1 * x1:0 <= -1)
The following rules are bounded:
f1068_0_loop_Load(x:0, x1:0) -> f1068_0_loop_Load(c, c1) :|: c1 = x1:0 + 2 && c = x:0 + 2 * x1:0 + 1 && (x:0 < 1 && x:0 + -1 * x1:0 <= -1)

----------------------------------------

(24)
YES
