YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/mVFzi.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be proven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 53 ms]
(2) JBC problem
(3) JBCToGraph [EQUIVALENT, 271 ms]
(4) JBCTerminationGraph
(5) TerminationGraphToSCCProof [SOUND, 0 ms]
(6) JBCTerminationSCC
(7) SCCToIRSProof [SOUND, 70 ms]
(8) IRSwT
(9) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
(10) IRSwT
(11) IRSwTTerminationDigraphProof [EQUIVALENT, 0 ms]
(12) IRSwT
(13) IntTRSCompressionProof [EQUIVALENT, 0 ms]
(14) IRSwT
(15) IRSwTChainingProof [EQUIVALENT, 0 ms]
(16) IRSwT
(17) IRSwTTerminationDigraphProof [EQUIVALENT, 0 ms]
(18) IRSwT
(19) IntTRSCompressionProof [EQUIVALENT, 0 ms]
(20) IRSwT
(21) IRSwTChainingProof [EQUIVALENT, 0 ms]
(22) IRSwT
(23) IRSwTTerminationDigraphProof [EQUIVALENT, 0 ms]
(24) IRSwT
(25) IntTRSCompressionProof [EQUIVALENT, 0 ms]
(26) IRSwT
(27) TempFilterProof [SOUND, 19 ms]
(28) IntTRS
(29) PolynomialOrderProcessor [EQUIVALENT, 0 ms]
(30) YES


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
public class Et3 {
    public static void main(String[] args) {
		Random.args = args;
	    int a =  Random.random(); 
	   	int b =  Random.random();
	   	loop(a,b);
	}
	public static void loop(int a, int b) {
	   	if (a > 0) {
	   	    a = a + b;
	   	    b = b - 1;
			loop(a,b);
	   	}
    }
}


public class Random {
  static String[] args;
  static int index = 0;

  public static int random() {
      if (index >= args.length)
	  return 0;

      String string = args[index];
      index++;
      return string.length();
  }
}



----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
public class Et3 {
    public static void main(String[] args) {
		Random.args = args;
	    int a =  Random.random(); 
	   	int b =  Random.random();
	   	loop(a,b);
	}
	public static void loop(int a, int b) {
	   	if (a > 0) {
	   	    a = a + b;
	   	    b = b - 1;
			loop(a,b);
	   	}
    }
}


public class Random {
  static String[] args;
  static int index = 0;

  public static int random() {
      if (index >= args.length)
	  return 0;

      String string = args[index];
      index++;
      return string.length();
  }
}



----------------------------------------

(3) JBCToGraph (EQUIVALENT)
Constructed TerminationGraph.
----------------------------------------

(4)
Obligation:
Termination Graph based on JBC Program:
Et3.main([Ljava/lang/String;)V: Graph of 229 nodes with 0 SCCs.



Et3.loop(II)V: Graph of 23 nodes with 0 SCCs.





----------------------------------------

(5) TerminationGraphToSCCProof (SOUND)
Splitted TerminationGraph to 1 SCCs.
----------------------------------------

(6)
Obligation:
SCC of termination graph based on JBC Program.
SCC contains nodes from the following methods: Et3.loop(II)V
SCC calls the following helper methods: Et3.loop(II)V
Performed SCC analyses:
*Used field analysis yielded the following read fields:

*Marker field analysis yielded the following relations that could be markers:

----------------------------------------

(7) SCCToIRSProof (SOUND)
Transformed FIGraph SCCs to intTRSs. Log: 
Generated rules. Obtained 17 IRulesP rules:
f1976_0_loop_LE(EOS(STATIC_1976), i322, i319, i322, i319, i322) -> f1981_0_loop_LE(EOS(STATIC_1981), i322, i319, i322, i319, i322) :|: TRUE
f1981_0_loop_LE(EOS(STATIC_1981), i322, i319, i322, i319, i322) -> f1986_0_loop_Load(EOS(STATIC_1986), i322, i319, i322, i319) :|: i322 > 0
f1986_0_loop_Load(EOS(STATIC_1986), i322, i319, i322, i319) -> f1991_0_loop_Load(EOS(STATIC_1991), i322, i319, i319, i322) :|: TRUE
f1991_0_loop_Load(EOS(STATIC_1991), i322, i319, i319, i322) -> f2056_0_loop_IntArithmetic(EOS(STATIC_2056), i322, i319, i319, i322, i319) :|: TRUE
f2056_0_loop_IntArithmetic(EOS(STATIC_2056), i322, i319, i319, i322, i319) -> f2191_0_loop_Store(EOS(STATIC_2191), i322, i319, i319, i322 + i319) :|: i322 > 0
f2191_0_loop_Store(EOS(STATIC_2191), i322, i319, i319, i363) -> f2194_0_loop_Load(EOS(STATIC_2194), i322, i319, i363, i319) :|: TRUE
f2194_0_loop_Load(EOS(STATIC_2194), i322, i319, i363, i319) -> f2197_0_loop_ConstantStackPush(EOS(STATIC_2197), i322, i319, i363, i319) :|: TRUE
f2197_0_loop_ConstantStackPush(EOS(STATIC_2197), i322, i319, i363, i319) -> f2201_0_loop_IntArithmetic(EOS(STATIC_2201), i322, i319, i363, i319, 1) :|: TRUE
f2201_0_loop_IntArithmetic(EOS(STATIC_2201), i322, i319, i363, i319, matching1) -> f2205_0_loop_Store(EOS(STATIC_2205), i322, i319, i363, i319 - 1) :|: TRUE && matching1 = 1
f2205_0_loop_Store(EOS(STATIC_2205), i322, i319, i363, i364) -> f2207_0_loop_Load(EOS(STATIC_2207), i322, i319, i363, i364) :|: TRUE
f2207_0_loop_Load(EOS(STATIC_2207), i322, i319, i363, i364) -> f2209_0_loop_Load(EOS(STATIC_2209), i322, i319, i364, i363) :|: TRUE
f2209_0_loop_Load(EOS(STATIC_2209), i322, i319, i364, i363) -> f2211_0_loop_InvokeMethod(EOS(STATIC_2211), i322, i319, i363, i364) :|: TRUE
f2211_0_loop_InvokeMethod(EOS(STATIC_2211), i322, i319, i363, i364) -> f2214_0_loop_Load(EOS(STATIC_2214), i363, i364, i363, i364) :|: i322 >= 1 && i364 < i319
f2211_0_loop_InvokeMethod(EOS(STATIC_2211), i322, i319, i363, i364) -> f2214_1_loop_Load(EOS(STATIC_2214), i322, i319, i363, i364) :|: i322 >= 1 && i364 < i319
f2214_0_loop_Load(EOS(STATIC_2214), i363, i364, i363, i364) -> f2220_0_loop_Load(EOS(STATIC_2220), i363, i364, i363, i364) :|: TRUE
f2220_0_loop_Load(EOS(STATIC_2220), i363, i364, i363, i364) -> f1968_0_loop_Load(EOS(STATIC_1968), i363, i364, i363, i364) :|: TRUE
f1968_0_loop_Load(EOS(STATIC_1968), i318, i319, i318, i319) -> f1976_0_loop_LE(EOS(STATIC_1976), i318, i319, i318, i319, i318) :|: TRUE
Combined rules. Obtained 2 IRulesP rules:
f1976_0_loop_LE(EOS(STATIC_1976), i322:0, i319:0, i322:0, i319:0, i322:0) -> f1976_0_loop_LE(EOS(STATIC_1976), i322:0 + i319:0, i319:0 - 1, i322:0 + i319:0, i319:0 - 1, i322:0 + i319:0) :|: i322:0 > 0 && i319:0 - 1 < i319:0
Removed following non-SCC rules:
f1976_0_loop_LE(EOS(STATIC_1976), i322:0, i319:0, i322:0, i319:0, i322:0) -> f2214_1_loop_Load(EOS(STATIC_2214), i322:0, i319:0, i322:0 + i319:0, i319:0 - 1) :|: i322:0 > 0 && i319:0 - 1 < i319:0
Filtered constant ground arguments:
   f1976_0_loop_LE(x1, x2, x3, x4, x5, x6) -> f1976_0_loop_LE(x2, x3, x4, x5, x6)
   EOS(x1) -> EOS
Filtered duplicate arguments:
   f1976_0_loop_LE(x1, x2, x3, x4, x5) -> f1976_0_loop_LE(x4, x5)
Finished conversion. Obtained 1 rules.P rules:
f1976_0_loop_LE(i319:0, i322:0) -> f1976_0_loop_LE(i319:0 - 1, i322:0 + i319:0) :|: i322:0 > 0 && i319:0 - 1 < i319:0

----------------------------------------

(8)
Obligation:
Rules:
f1976_0_loop_LE(i319:0, i322:0) -> f1976_0_loop_LE(i319:0 - 1, i322:0 + i319:0) :|: i322:0 > 0 && i319:0 - 1 < i319:0

----------------------------------------

(9) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(10)
Obligation:
Rules:
f1976_0_loop_LE(i319:0, i322:0) -> f1976_0_loop_LE(arith, arith1) :|: i322:0 > 0 && i319:0 - 1 < i319:0 && arith = i319:0 - 1 && arith1 = i322:0 + i319:0

----------------------------------------

(11) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f1976_0_loop_LE(i319:0, i322:0) -> f1976_0_loop_LE(arith, arith1) :|: i322:0 > 0 && i319:0 - 1 < i319:0 && arith = i319:0 - 1 && arith1 = i322:0 + i319:0

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(12)
Obligation:

Termination digraph:
Nodes:
(1) f1976_0_loop_LE(i319:0, i322:0) -> f1976_0_loop_LE(arith, arith1) :|: i322:0 > 0 && i319:0 - 1 < i319:0 && arith = i319:0 - 1 && arith1 = i322:0 + i319:0

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(13) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(14)
Obligation:
Rules:
f1976_0_loop_LE(i319:0:0, i322:0:0) -> f1976_0_loop_LE(i319:0:0 - 1, i322:0:0 + i319:0:0) :|: i322:0:0 > 0 && i319:0:0 - 1 < i319:0:0

----------------------------------------

(15) IRSwTChainingProof (EQUIVALENT)
Chaining!
----------------------------------------

(16)
Obligation:
Rules:
f1976_0_loop_LE(x, x1) -> f1976_0_loop_LE(x + -2, x1 + 2 * x + -1) :|: TRUE && x1 >= 1 && x1 + x >= 1

----------------------------------------

(17) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f1976_0_loop_LE(x, x1) -> f1976_0_loop_LE(x + -2, x1 + 2 * x + -1) :|: TRUE && x1 >= 1 && x1 + x >= 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(18)
Obligation:

Termination digraph:
Nodes:
(1) f1976_0_loop_LE(x, x1) -> f1976_0_loop_LE(x + -2, x1 + 2 * x + -1) :|: TRUE && x1 >= 1 && x1 + x >= 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(19) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(20)
Obligation:
Rules:
f1976_0_loop_LE(x:0, x1:0) -> f1976_0_loop_LE(x:0 - 2, x1:0 + 2 * x:0 - 1) :|: x1:0 + x:0 >= 1 && x1:0 > 0

----------------------------------------

(21) IRSwTChainingProof (EQUIVALENT)
Chaining!
----------------------------------------

(22)
Obligation:
Rules:
f1976_0_loop_LE(x, x1) -> f1976_0_loop_LE(x + -4, x1 + 4 * x + -6) :|: TRUE && x1 + x >= 1 && x1 >= 1 && x1 + 3 * x >= 4 && x1 + 2 * x >= 2

----------------------------------------

(23) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f1976_0_loop_LE(x, x1) -> f1976_0_loop_LE(x + -4, x1 + 4 * x + -6) :|: TRUE && x1 + x >= 1 && x1 >= 1 && x1 + 3 * x >= 4 && x1 + 2 * x >= 2

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(24)
Obligation:

Termination digraph:
Nodes:
(1) f1976_0_loop_LE(x, x1) -> f1976_0_loop_LE(x + -4, x1 + 4 * x + -6) :|: TRUE && x1 + x >= 1 && x1 >= 1 && x1 + 3 * x >= 4 && x1 + 2 * x >= 2

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(25) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(26)
Obligation:
Rules:
f1976_0_loop_LE(x:0, x1:0) -> f1976_0_loop_LE(x:0 - 4, x1:0 + 4 * x:0 - 6) :|: x1:0 + 3 * x:0 >= 4 && x1:0 + 2 * x:0 >= 2 && x1:0 + x:0 >= 1 && x1:0 > 0

----------------------------------------

(27) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f1976_0_loop_LE(INTEGER, INTEGER)
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(28)
Obligation:
Rules:
f1976_0_loop_LE(x:0, x1:0) -> f1976_0_loop_LE(c, c1) :|: c1 = x1:0 + 4 * x:0 - 6 && c = x:0 - 4 && (x1:0 + 3 * x:0 >= 4 && x1:0 + 2 * x:0 >= 2 && x1:0 + x:0 >= 1 && x1:0 > 0)

----------------------------------------

(29) PolynomialOrderProcessor (EQUIVALENT)
Found the following polynomial interpretation:
[f1976_0_loop_LE(x, x1)] = -2 + 2*x + x^2 + 2*x1

The following rules are decreasing:
f1976_0_loop_LE(x:0, x1:0) -> f1976_0_loop_LE(c, c1) :|: c1 = x1:0 + 4 * x:0 - 6 && c = x:0 - 4 && (x1:0 + 3 * x:0 >= 4 && x1:0 + 2 * x:0 >= 2 && x1:0 + x:0 >= 1 && x1:0 > 0)
The following rules are bounded:
f1976_0_loop_LE(x:0, x1:0) -> f1976_0_loop_LE(c, c1) :|: c1 = x1:0 + 4 * x:0 - 6 && c = x:0 - 4 && (x1:0 + 3 * x:0 >= 4 && x1:0 + 2 * x:0 >= 2 && x1:0 + x:0 >= 1 && x1:0 > 0)

----------------------------------------

(30)
YES
