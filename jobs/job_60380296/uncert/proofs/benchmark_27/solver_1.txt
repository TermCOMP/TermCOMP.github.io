YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/FeJmB.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be proven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 0 ms]
(2) JBC problem
(3) JBCToGraph [EQUIVALENT, 600 ms]
(4) JBCTerminationGraph
(5) TerminationGraphToSCCProof [SOUND, 0 ms]
(6) JBCTerminationSCC
(7) SCCToIRSProof [SOUND, 0 ms]
(8) IRSwT
(9) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
(10) IRSwT
(11) IRSwTTerminationDigraphProof [EQUIVALENT, 0 ms]
(12) IRSwT
(13) IntTRSCompressionProof [EQUIVALENT, 0 ms]
(14) IRSwT
(15) TempFilterProof [SOUND, 12 ms]
(16) IntTRS
(17) PolynomialOrderProcessor [EQUIVALENT, 2 ms]
(18) YES


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
public class Fibonacci {
	public static void main(String[] args) {
		fib(args.length);
	}

	public static int fib(int x) {
		if (x == 0) {
			return 0;
		} else if (x == 1) {
			return 1;
		} else {
			return fib(x-1) + fib(x-2);
		}
	}
}



----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
public class Fibonacci {
	public static void main(String[] args) {
		fib(args.length);
	}

	public static int fib(int x) {
		if (x == 0) {
			return 0;
		} else if (x == 1) {
			return 1;
		} else {
			return fib(x-1) + fib(x-2);
		}
	}
}



----------------------------------------

(3) JBCToGraph (EQUIVALENT)
Constructed TerminationGraph.
----------------------------------------

(4)
Obligation:
Termination Graph based on JBC Program:
Fibonacci.main([Ljava/lang/String;)V: Graph of 19 nodes with 0 SCCs.



Fibonacci.fib(I)I: Graph of 42 nodes with 0 SCCs.





----------------------------------------

(5) TerminationGraphToSCCProof (SOUND)
Splitted TerminationGraph to 1 SCCs.
----------------------------------------

(6)
Obligation:
SCC of termination graph based on JBC Program.
SCC contains nodes from the following methods: Fibonacci.fib(I)I
SCC calls the following helper methods: Fibonacci.fib(I)I
Performed SCC analyses:
*Used field analysis yielded the following read fields:

*Marker field analysis yielded the following relations that could be markers:

----------------------------------------

(7) SCCToIRSProof (SOUND)
Transformed FIGraph SCCs to intTRSs. Log: 
Generated rules. Obtained 29 IRulesP rules:
f22_0_fib_NE(EOS(STATIC_22), i4, i4, i4) -> f23_0_fib_NE(EOS(STATIC_23), i4, i4, i4) :|: TRUE
f23_0_fib_NE(EOS(STATIC_23), i4, i4, i4) -> f25_0_fib_Load(EOS(STATIC_25), i4, i4) :|: i4 > 0
f25_0_fib_Load(EOS(STATIC_25), i4, i4) -> f27_0_fib_ConstantStackPush(EOS(STATIC_27), i4, i4, i4) :|: TRUE
f27_0_fib_ConstantStackPush(EOS(STATIC_27), i4, i4, i4) -> f29_0_fib_NE(EOS(STATIC_29), i4, i4, i4, 1) :|: TRUE
f29_0_fib_NE(EOS(STATIC_29), i7, i7, i7, matching1) -> f43_0_fib_NE(EOS(STATIC_43), i7, i7, i7, 1) :|: TRUE && matching1 = 1
f43_0_fib_NE(EOS(STATIC_43), i7, i7, i7, matching1) -> f90_0_fib_Load(EOS(STATIC_90), i7, i7) :|: i7 > 1 && matching1 = 1
f90_0_fib_Load(EOS(STATIC_90), i7, i7) -> f94_0_fib_ConstantStackPush(EOS(STATIC_94), i7, i7, i7) :|: TRUE
f94_0_fib_ConstantStackPush(EOS(STATIC_94), i7, i7, i7) -> f100_0_fib_IntArithmetic(EOS(STATIC_100), i7, i7, i7, 1) :|: TRUE
f100_0_fib_IntArithmetic(EOS(STATIC_100), i7, i7, i7, matching1) -> f111_0_fib_InvokeMethod(EOS(STATIC_111), i7, i7, i7 - 1) :|: i7 > 0 && matching1 = 1
f111_0_fib_InvokeMethod(EOS(STATIC_111), i7, i7, i18) -> f116_0_fib_Load(EOS(STATIC_116), i18, i18) :|: i7 > 1 && i18 >= 1 && i18 < i7
f111_0_fib_InvokeMethod(EOS(STATIC_111), i7, i7, i18) -> f116_1_fib_Load(EOS(STATIC_116), i7, i7, i18) :|: i7 > 1 && i18 >= 1 && i18 < i7
f116_0_fib_Load(EOS(STATIC_116), i18, i18) -> f135_0_fib_Load(EOS(STATIC_135), i18, i18) :|: TRUE
f135_0_fib_Load(EOS(STATIC_135), i18, i18) -> f21_0_fib_Load(EOS(STATIC_21), i18, i18) :|: TRUE
f21_0_fib_Load(EOS(STATIC_21), i2, i2) -> f22_0_fib_NE(EOS(STATIC_22), i2, i2, i2) :|: TRUE
f1105_0_fib_Return(EOS(STATIC_1105), i7, i7, matching1) -> f1106_0_fib_Load(EOS(STATIC_1106), i7, i7, 1) :|: TRUE && matching1 = 1
f1106_0_fib_Load(EOS(STATIC_1106), i7, i7, matching1) -> f1868_0_fib_Load(EOS(STATIC_1868), i7, i7, 1) :|: TRUE && matching1 = 1
f1868_0_fib_Load(EOS(STATIC_1868), i7, i7, i317) -> f6789_0_fib_Load(EOS(STATIC_6789), i7, i7, i317) :|: TRUE
f6789_0_fib_Load(EOS(STATIC_6789), i7, i7, i1206) -> f8026_0_fib_Load(EOS(STATIC_8026), i7, i7, i1206) :|: TRUE
f8026_0_fib_Load(EOS(STATIC_8026), i7, i7, i1420) -> f8028_0_fib_ConstantStackPush(EOS(STATIC_8028), i7, i1420, i7) :|: TRUE
f8028_0_fib_ConstantStackPush(EOS(STATIC_8028), i7, i1420, i7) -> f8030_0_fib_IntArithmetic(EOS(STATIC_8030), i7, i1420, i7, 2) :|: TRUE
f8030_0_fib_IntArithmetic(EOS(STATIC_8030), i7, i1420, i7, matching1) -> f8031_0_fib_InvokeMethod(EOS(STATIC_8031), i7, i1420, i7 - 2) :|: i7 > 0 && matching1 = 2
f8031_0_fib_InvokeMethod(EOS(STATIC_8031), i7, i1420, i1425) -> f8032_0_fib_Load(EOS(STATIC_8032), i1425, i1425) :|: i7 > 1 && i1425 < i7
f8031_0_fib_InvokeMethod(EOS(STATIC_8031), i7, i1420, i1425) -> f8032_1_fib_Load(EOS(STATIC_8032), i7, i1420, i1425) :|: i7 > 1 && i1425 < i7
f8032_0_fib_Load(EOS(STATIC_8032), i1425, i1425) -> f8033_0_fib_Load(EOS(STATIC_8033), i1425, i1425) :|: TRUE
f8033_0_fib_Load(EOS(STATIC_8033), i1425, i1425) -> f21_0_fib_Load(EOS(STATIC_21), i1425, i1425) :|: TRUE
f8052_0_fib_Return(EOS(STATIC_8052), i7, i7, i1453) -> f8022_0_fib_Return(EOS(STATIC_8022), i7, i7, i1453) :|: TRUE
f8022_0_fib_Return(EOS(STATIC_8022), i7, i7, i1420) -> f8026_0_fib_Load(EOS(STATIC_8026), i7, i7, i1420) :|: TRUE
f116_1_fib_Load(EOS(STATIC_116), i7, i7, matching1) -> f1105_0_fib_Return(EOS(STATIC_1105), i7, i7, 1) :|: TRUE && matching1 = 1
f116_1_fib_Load(EOS(STATIC_116), i7, i7, i18) -> f8052_0_fib_Return(EOS(STATIC_8052), i7, i7, i1453) :|: TRUE
Combined rules. Obtained 5 IRulesP rules:
f8031_0_fib_InvokeMethod(EOS(STATIC_8031), i7:0, i1420:0, i1425:0) -> f22_0_fib_NE(EOS(STATIC_22), i1425:0, i1425:0, i1425:0) :|: i7:0 > 1 && i7:0 > i1425:0
f22_0_fib_NE(EOS(STATIC_22), 2, 2, 2) -> f8031_0_fib_InvokeMethod(EOS(STATIC_8031), 2, 1, 0) :|: TRUE
f22_0_fib_NE(EOS(STATIC_22), i4:0, i4:0, i4:0) -> f22_0_fib_NE(EOS(STATIC_22), i4:0 - 1, i4:0 - 1, i4:0 - 1) :|: i4:0 > 1 && i4:0 - 1 < i4:0
f22_0_fib_NE(EOS(STATIC_22), i4:0, i4:0, i4:0) -> f8031_0_fib_InvokeMethod(EOS(STATIC_8031), i4:0, i1453:0, i4:0 - 2) :|: i4:0 > 1 && i4:0 - 1 < i4:0
Removed following non-SCC rules:
f8031_0_fib_InvokeMethod(EOS(STATIC_8031), i7:0, i1420:0, i1425:0) -> f8032_1_fib_Load(EOS(STATIC_8032), i7:0, i1420:0, i1425:0) :|: i7:0 > 1 && i7:0 > i1425:0
Filtered constant ground arguments:
   f8031_0_fib_InvokeMethod(x1, x2, x3, x4) -> f8031_0_fib_InvokeMethod(x2, x3, x4)
   f22_0_fib_NE(x1, x2, x3, x4) -> f22_0_fib_NE(x2, x3, x4)
Filtered duplicate arguments:
   f22_0_fib_NE(x1, x2, x3) -> f22_0_fib_NE(x3)
Filtered unneeded arguments:
   f8031_0_fib_InvokeMethod(x1, x2, x3) -> f8031_0_fib_InvokeMethod(x1, x3)
Finished conversion. Obtained 4 rules.P rules:
f8031_0_fib_InvokeMethod(i7:0, i1425:0) -> f22_0_fib_NE(i1425:0) :|: i7:0 > 1 && i7:0 > i1425:0
f22_0_fib_NE(cons_2) -> f8031_0_fib_InvokeMethod(2, 0) :|: TRUE && cons_2 = 2
f22_0_fib_NE(i4:0) -> f22_0_fib_NE(i4:0 - 1) :|: i4:0 > 1 && i4:0 - 1 < i4:0
f22_0_fib_NE(i4:0) -> f8031_0_fib_InvokeMethod(i4:0, i4:0 - 2) :|: i4:0 > 1 && i4:0 - 1 < i4:0

----------------------------------------

(8)
Obligation:
Rules:
f8031_0_fib_InvokeMethod(i7:0, i1425:0) -> f22_0_fib_NE(i1425:0) :|: i7:0 > 1 && i7:0 > i1425:0
f22_0_fib_NE(cons_2) -> f8031_0_fib_InvokeMethod(2, 0) :|: TRUE && cons_2 = 2
f22_0_fib_NE(i4:0) -> f22_0_fib_NE(i4:0 - 1) :|: i4:0 > 1 && i4:0 - 1 < i4:0
f22_0_fib_NE(x) -> f8031_0_fib_InvokeMethod(x, x - 2) :|: x > 1 && x - 1 < x

----------------------------------------

(9) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(10)
Obligation:
Rules:
f8031_0_fib_InvokeMethod(i7:0, i1425:0) -> f22_0_fib_NE(i1425:0) :|: i7:0 > 1 && i7:0 > i1425:0
f22_0_fib_NE(cons_2) -> f8031_0_fib_InvokeMethod(2, 0) :|: TRUE && cons_2 = 2
f22_0_fib_NE(i4:0) -> f22_0_fib_NE(arith) :|: i4:0 > 1 && i4:0 - 1 < i4:0 && arith = i4:0 - 1
f22_0_fib_NE(x1) -> f8031_0_fib_InvokeMethod(x1, x2) :|: x1 > 1 && x1 - 1 < x1 && x2 = x1 - 2

----------------------------------------

(11) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f8031_0_fib_InvokeMethod(i7:0, i1425:0) -> f22_0_fib_NE(i1425:0) :|: i7:0 > 1 && i7:0 > i1425:0
(2) f22_0_fib_NE(cons_2) -> f8031_0_fib_InvokeMethod(2, 0) :|: TRUE && cons_2 = 2
(3) f22_0_fib_NE(i4:0) -> f22_0_fib_NE(arith) :|: i4:0 > 1 && i4:0 - 1 < i4:0 && arith = i4:0 - 1
(4) f22_0_fib_NE(x1) -> f8031_0_fib_InvokeMethod(x1, x2) :|: x1 > 1 && x1 - 1 < x1 && x2 = x1 - 2

Arcs:
(1) -> (2), (3), (4)
(2) -> (1)
(3) -> (2), (3), (4)
(4) -> (1)

This digraph is fully evaluated!
----------------------------------------

(12)
Obligation:

Termination digraph:
Nodes:
(1) f8031_0_fib_InvokeMethod(i7:0, i1425:0) -> f22_0_fib_NE(i1425:0) :|: i7:0 > 1 && i7:0 > i1425:0
(2) f22_0_fib_NE(x1) -> f8031_0_fib_InvokeMethod(x1, x2) :|: x1 > 1 && x1 - 1 < x1 && x2 = x1 - 2
(3) f22_0_fib_NE(cons_2) -> f8031_0_fib_InvokeMethod(2, 0) :|: TRUE && cons_2 = 2
(4) f22_0_fib_NE(i4:0) -> f22_0_fib_NE(arith) :|: i4:0 > 1 && i4:0 - 1 < i4:0 && arith = i4:0 - 1

Arcs:
(1) -> (2), (3), (4)
(2) -> (1)
(3) -> (1)
(4) -> (2), (3), (4)

This digraph is fully evaluated!

----------------------------------------

(13) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(14)
Obligation:
Rules:
f22_0_fib_NE(cons_2) -> f22_0_fib_NE(0) :|: TRUE && cons_2 = 2
f22_0_fib_NE(i4:0:0) -> f22_0_fib_NE(i4:0:0 - 1) :|: i4:0:0 > 1 && i4:0:0 - 1 < i4:0:0
f22_0_fib_NE(x1:0) -> f22_0_fib_NE(x1:0 - 2) :|: x1:0 - 2 < x1:0 && x1:0 - 1 < x1:0 && x1:0 > 1

----------------------------------------

(15) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f22_0_fib_NE(VARIABLE)
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(16)
Obligation:
Rules:
f22_0_fib_NE(c) -> f22_0_fib_NE(c1) :|: c1 = 0 && c = 2 && (TRUE && cons_2 = 2)
f22_0_fib_NE(i4:0:0) -> f22_0_fib_NE(c2) :|: c2 = i4:0:0 - 1 && (i4:0:0 > 1 && i4:0:0 - 1 < i4:0:0)
f22_0_fib_NE(x1:0) -> f22_0_fib_NE(c3) :|: c3 = x1:0 - 2 && (x1:0 - 2 < x1:0 && x1:0 - 1 < x1:0 && x1:0 > 1)

----------------------------------------

(17) PolynomialOrderProcessor (EQUIVALENT)
Found the following polynomial interpretation:
[f22_0_fib_NE(x)] = x

The following rules are decreasing:
f22_0_fib_NE(c) -> f22_0_fib_NE(c1) :|: c1 = 0 && c = 2 && (TRUE && cons_2 = 2)
f22_0_fib_NE(i4:0:0) -> f22_0_fib_NE(c2) :|: c2 = i4:0:0 - 1 && (i4:0:0 > 1 && i4:0:0 - 1 < i4:0:0)
f22_0_fib_NE(x1:0) -> f22_0_fib_NE(c3) :|: c3 = x1:0 - 2 && (x1:0 - 2 < x1:0 && x1:0 - 1 < x1:0 && x1:0 > 1)
The following rules are bounded:
f22_0_fib_NE(c) -> f22_0_fib_NE(c1) :|: c1 = 0 && c = 2 && (TRUE && cons_2 = 2)
f22_0_fib_NE(i4:0:0) -> f22_0_fib_NE(c2) :|: c2 = i4:0:0 - 1 && (i4:0:0 > 1 && i4:0:0 - 1 < i4:0:0)
f22_0_fib_NE(x1:0) -> f22_0_fib_NE(c3) :|: c3 = x1:0 - 2 && (x1:0 - 2 < x1:0 && x1:0 - 1 < x1:0 && x1:0 > 1)

----------------------------------------

(18)
YES
