YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/Dh1aS.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be proven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 0 ms]
(2) JBC problem
(3) JBCToGraph [EQUIVALENT, 195 ms]
(4) JBCTerminationGraph
(5) TerminationGraphToSCCProof [SOUND, 0 ms]
(6) JBCTerminationSCC
(7) SCCToIRSProof [SOUND, 78 ms]
(8) IRSwT
(9) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
(10) IRSwT
(11) IRSwTTerminationDigraphProof [EQUIVALENT, 17 ms]
(12) IRSwT
(13) IntTRSCompressionProof [EQUIVALENT, 0 ms]
(14) IRSwT
(15) TempFilterProof [SOUND, 30 ms]
(16) IntTRS
(17) PolynomialOrderProcessor [EQUIVALENT, 12 ms]
(18) YES


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
public class LeUserDefRec {
	public static void main(String[] args) {
		int x = args[0].length();
		int y = args[1].length();
		le(x, y);
	}

	public static boolean le(int x, int y) {
		if (x > 0 && y > 0) {
			return le(x-1, y-1);
		} else {
			return (x == 0);
		}
	}
}



----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
public class LeUserDefRec {
	public static void main(String[] args) {
		int x = args[0].length();
		int y = args[1].length();
		le(x, y);
	}

	public static boolean le(int x, int y) {
		if (x > 0 && y > 0) {
			return le(x-1, y-1);
		} else {
			return (x == 0);
		}
	}
}



----------------------------------------

(3) JBCToGraph (EQUIVALENT)
Constructed TerminationGraph.
----------------------------------------

(4)
Obligation:
Termination Graph based on JBC Program:
LeUserDefRec.main([Ljava/lang/String;)V: Graph of 128 nodes with 0 SCCs.



LeUserDefRec.le(II)Z: Graph of 35 nodes with 0 SCCs.





----------------------------------------

(5) TerminationGraphToSCCProof (SOUND)
Splitted TerminationGraph to 1 SCCs.
----------------------------------------

(6)
Obligation:
SCC of termination graph based on JBC Program.
SCC contains nodes from the following methods: LeUserDefRec.le(II)Z
SCC calls the following helper methods: LeUserDefRec.le(II)Z
Performed SCC analyses:
*Used field analysis yielded the following read fields:

*Marker field analysis yielded the following relations that could be markers:

----------------------------------------

(7) SCCToIRSProof (SOUND)
Transformed FIGraph SCCs to intTRSs. Log: 
Generated rules. Obtained 16 IRulesP rules:
f285_0_le_LE(EOS(STATIC_285), i44, i31, i44, i31, i44) -> f311_0_le_LE(EOS(STATIC_311), i44, i31, i44, i31, i44) :|: TRUE
f311_0_le_LE(EOS(STATIC_311), i44, i31, i44, i31, i44) -> f324_0_le_Load(EOS(STATIC_324), i44, i31, i44, i31) :|: i44 > 0
f324_0_le_Load(EOS(STATIC_324), i44, i31, i44, i31) -> f340_0_le_LE(EOS(STATIC_340), i44, i31, i44, i31, i31) :|: TRUE
f340_0_le_LE(EOS(STATIC_340), i44, i48, i44, i48, i48) -> f353_0_le_LE(EOS(STATIC_353), i44, i48, i44, i48, i48) :|: TRUE
f353_0_le_LE(EOS(STATIC_353), i44, i48, i44, i48, i48) -> f388_0_le_Load(EOS(STATIC_388), i44, i48, i44, i48) :|: i48 > 0
f388_0_le_Load(EOS(STATIC_388), i44, i48, i44, i48) -> f403_0_le_ConstantStackPush(EOS(STATIC_403), i44, i48, i48, i44) :|: TRUE
f403_0_le_ConstantStackPush(EOS(STATIC_403), i44, i48, i48, i44) -> f425_0_le_IntArithmetic(EOS(STATIC_425), i44, i48, i48, i44, 1) :|: TRUE
f425_0_le_IntArithmetic(EOS(STATIC_425), i44, i48, i48, i44, matching1) -> f624_0_le_Load(EOS(STATIC_624), i44, i48, i48, i44 - 1) :|: i44 > 0 && matching1 = 1
f624_0_le_Load(EOS(STATIC_624), i44, i48, i48, i77) -> f635_0_le_ConstantStackPush(EOS(STATIC_635), i44, i48, i77, i48) :|: TRUE
f635_0_le_ConstantStackPush(EOS(STATIC_635), i44, i48, i77, i48) -> f654_0_le_IntArithmetic(EOS(STATIC_654), i44, i48, i77, i48, 1) :|: TRUE
f654_0_le_IntArithmetic(EOS(STATIC_654), i44, i48, i77, i48, matching1) -> f698_0_le_InvokeMethod(EOS(STATIC_698), i44, i48, i77, i48 - 1) :|: i48 > 0 && matching1 = 1
f698_0_le_InvokeMethod(EOS(STATIC_698), i44, i48, i77, i87) -> f703_0_le_Load(EOS(STATIC_703), i77, i87, i77, i87) :|: i44 >= 1 && i48 >= 1 && i77 < i44 && i87 < i48
f698_0_le_InvokeMethod(EOS(STATIC_698), i44, i48, i77, i87) -> f703_1_le_Load(EOS(STATIC_703), i44, i48, i77, i87) :|: i44 >= 1 && i48 >= 1 && i77 < i44 && i87 < i48
f703_0_le_Load(EOS(STATIC_703), i77, i87, i77, i87) -> f709_0_le_Load(EOS(STATIC_709), i77, i87, i77, i87) :|: TRUE
f709_0_le_Load(EOS(STATIC_709), i77, i87, i77, i87) -> f282_0_le_Load(EOS(STATIC_282), i77, i87, i77, i87) :|: TRUE
f282_0_le_Load(EOS(STATIC_282), i13, i31, i13, i31) -> f285_0_le_LE(EOS(STATIC_285), i13, i31, i13, i31, i13) :|: TRUE
Combined rules. Obtained 2 IRulesP rules:
f285_0_le_LE(EOS(STATIC_285), i44:0, i31:0, i44:0, i31:0, i44:0) -> f285_0_le_LE(EOS(STATIC_285), i44:0 - 1, i31:0 - 1, i44:0 - 1, i31:0 - 1, i44:0 - 1) :|: i44:0 > 0 && i31:0 > 0 && i44:0 - 1 < i44:0 && i31:0 - 1 < i31:0
Removed following non-SCC rules:
f285_0_le_LE(EOS(STATIC_285), i44:0, i31:0, i44:0, i31:0, i44:0) -> f703_1_le_Load(EOS(STATIC_703), i44:0, i31:0, i44:0 - 1, i31:0 - 1) :|: i44:0 > 0 && i31:0 > 0 && i44:0 - 1 < i44:0 && i31:0 - 1 < i31:0
Filtered constant ground arguments:
   f285_0_le_LE(x1, x2, x3, x4, x5, x6) -> f285_0_le_LE(x2, x3, x4, x5, x6)
   EOS(x1) -> EOS
Filtered duplicate arguments:
   f285_0_le_LE(x1, x2, x3, x4, x5) -> f285_0_le_LE(x4, x5)
Finished conversion. Obtained 1 rules.P rules:
f285_0_le_LE(i31:0, i44:0) -> f285_0_le_LE(i31:0 - 1, i44:0 - 1) :|: i31:0 > 0 && i44:0 > 0 && i31:0 - 1 < i31:0 && i44:0 - 1 < i44:0

----------------------------------------

(8)
Obligation:
Rules:
f285_0_le_LE(i31:0, i44:0) -> f285_0_le_LE(i31:0 - 1, i44:0 - 1) :|: i31:0 > 0 && i44:0 > 0 && i31:0 - 1 < i31:0 && i44:0 - 1 < i44:0

----------------------------------------

(9) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(10)
Obligation:
Rules:
f285_0_le_LE(i31:0, i44:0) -> f285_0_le_LE(arith, arith1) :|: i31:0 > 0 && i44:0 > 0 && i31:0 - 1 < i31:0 && i44:0 - 1 < i44:0 && arith = i31:0 - 1 && arith1 = i44:0 - 1

----------------------------------------

(11) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f285_0_le_LE(i31:0, i44:0) -> f285_0_le_LE(arith, arith1) :|: i31:0 > 0 && i44:0 > 0 && i31:0 - 1 < i31:0 && i44:0 - 1 < i44:0 && arith = i31:0 - 1 && arith1 = i44:0 - 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(12)
Obligation:

Termination digraph:
Nodes:
(1) f285_0_le_LE(i31:0, i44:0) -> f285_0_le_LE(arith, arith1) :|: i31:0 > 0 && i44:0 > 0 && i31:0 - 1 < i31:0 && i44:0 - 1 < i44:0 && arith = i31:0 - 1 && arith1 = i44:0 - 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(13) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(14)
Obligation:
Rules:
f285_0_le_LE(i31:0:0, i44:0:0) -> f285_0_le_LE(i31:0:0 - 1, i44:0:0 - 1) :|: i31:0:0 - 1 < i31:0:0 && i44:0:0 - 1 < i44:0:0 && i44:0:0 > 0 && i31:0:0 > 0

----------------------------------------

(15) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f285_0_le_LE(INTEGER, INTEGER)
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(16)
Obligation:
Rules:
f285_0_le_LE(i31:0:0, i44:0:0) -> f285_0_le_LE(c, c1) :|: c1 = i44:0:0 - 1 && c = i31:0:0 - 1 && (i31:0:0 - 1 < i31:0:0 && i44:0:0 - 1 < i44:0:0 && i44:0:0 > 0 && i31:0:0 > 0)

----------------------------------------

(17) PolynomialOrderProcessor (EQUIVALENT)
Found the following polynomial interpretation:
[f285_0_le_LE(x, x1)] = x1

The following rules are decreasing:
f285_0_le_LE(i31:0:0, i44:0:0) -> f285_0_le_LE(c, c1) :|: c1 = i44:0:0 - 1 && c = i31:0:0 - 1 && (i31:0:0 - 1 < i31:0:0 && i44:0:0 - 1 < i44:0:0 && i44:0:0 > 0 && i31:0:0 > 0)
The following rules are bounded:
f285_0_le_LE(i31:0:0, i44:0:0) -> f285_0_le_LE(c, c1) :|: c1 = i44:0:0 - 1 && c = i31:0:0 - 1 && (i31:0:0 - 1 < i31:0:0 && i44:0:0 - 1 < i44:0:0 && i44:0:0 > 0 && i31:0:0 > 0)

----------------------------------------

(18)
YES
