YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/xuSjp.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be proven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 0 ms]
(2) JBC problem
(3) JBCToGraph [EQUIVALENT, 405 ms]
(4) JBCTerminationGraph
(5) TerminationGraphToSCCProof [SOUND, 0 ms]
(6) AND
    (7) JBCTerminationSCC
        (8) SCCToIRSProof [SOUND, 35 ms]
        (9) IRSwT
        (10) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
        (11) IRSwT
        (12) IRSwTTerminationDigraphProof [EQUIVALENT, 15 ms]
        (13) AND
            (14) IRSwT
                (15) IntTRSCompressionProof [EQUIVALENT, 0 ms]
                (16) IRSwT
                (17) IntTRSUnneededArgumentFilterProof [EQUIVALENT, 0 ms]
                (18) IRSwT
                (19) TempFilterProof [SOUND, 11 ms]
                (20) IntTRS
                (21) PolynomialOrderProcessor [EQUIVALENT, 3 ms]
                (22) YES
            (23) IRSwT
                (24) IntTRSCompressionProof [EQUIVALENT, 0 ms]
                (25) IRSwT
                (26) TempFilterProof [SOUND, 4 ms]
                (27) IntTRS
                (28) PolynomialOrderProcessor [EQUIVALENT, 0 ms]
                (29) YES
    (30) JBCTerminationSCC
        (31) SCCToIRSProof [SOUND, 30 ms]
        (32) IRSwT
        (33) IRSFormatTransformerProof [EQUIVALENT, 0 ms]
        (34) IRSwT
        (35) IRSwTTerminationDigraphProof [EQUIVALENT, 0 ms]
        (36) IRSwT
        (37) IntTRSCompressionProof [EQUIVALENT, 0 ms]
        (38) IRSwT
        (39) TempFilterProof [SOUND, 2 ms]
        (40) IntTRS
        (41) PolynomialOrderProcessor [EQUIVALENT, 0 ms]
        (42) YES


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:
public class TimesPlusUserDef {
	public static void main(String[] args) {
		int x, y;
		x = args[0].length();
		y = args[1].length();
		times(x, y);
	}

	public static int times(int x, int y) {
		if (y == 0)
			return 0;
		if (y > 0)
			return plus(times(x, y - 1), x);
		return 0;
	}

	public static int plus(int x, int y) {
		if (y > 0) {
			return 1 + plus(x, y-1);
		} else if (x > 0) {
			return 1 + plus(x-1, y);
		} else {
			return 0;
		}
	}
}



----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:
public class TimesPlusUserDef {
	public static void main(String[] args) {
		int x, y;
		x = args[0].length();
		y = args[1].length();
		times(x, y);
	}

	public static int times(int x, int y) {
		if (y == 0)
			return 0;
		if (y > 0)
			return plus(times(x, y - 1), x);
		return 0;
	}

	public static int plus(int x, int y) {
		if (y > 0) {
			return 1 + plus(x, y-1);
		} else if (x > 0) {
			return 1 + plus(x-1, y);
		} else {
			return 0;
		}
	}
}



----------------------------------------

(3) JBCToGraph (EQUIVALENT)
Constructed TerminationGraph.
----------------------------------------

(4)
Obligation:
Termination Graph based on JBC Program:
TimesPlusUserDef.main([Ljava/lang/String;)V: Graph of 130 nodes with 0 SCCs.



TimesPlusUserDef.times(II)I: Graph of 39 nodes with 0 SCCs.



TimesPlusUserDef.plus(II)I: Graph of 47 nodes with 0 SCCs.





----------------------------------------

(5) TerminationGraphToSCCProof (SOUND)
Splitted TerminationGraph to 2 SCCss.
----------------------------------------

(6)
Complex Obligation (AND)

----------------------------------------

(7)
Obligation:
SCC of termination graph based on JBC Program.
SCC contains nodes from the following methods: TimesPlusUserDef.plus(II)I
SCC calls the following helper methods: TimesPlusUserDef.plus(II)I
Performed SCC analyses:
*Used field analysis yielded the following read fields:

*Marker field analysis yielded the following relations that could be markers:

----------------------------------------

(8) SCCToIRSProof (SOUND)
Transformed FIGraph SCCs to intTRSs. Log: 
Generated rules. Obtained 26 IRulesP rules:
f23426_0_plus_LE(EOS(STATIC_23426), i1872, matching1, i1872, matching2, matching3) -> f23429_0_plus_LE(EOS(STATIC_23429), i1872, 0, i1872, 0, 0) :|: TRUE && matching1 = 0 && matching2 = 0 && matching3 = 0
f23426_0_plus_LE(EOS(STATIC_23426), i1872, i1878, i1872, i1878, i1878) -> f23430_0_plus_LE(EOS(STATIC_23430), i1872, i1878, i1872, i1878, i1878) :|: TRUE
f23429_0_plus_LE(EOS(STATIC_23429), i1872, matching1, i1872, matching2, matching3) -> f23432_0_plus_Load(EOS(STATIC_23432), i1872, 0, i1872, 0) :|: 0 <= 0 && matching1 = 0 && matching2 = 0 && matching3 = 0
f23432_0_plus_Load(EOS(STATIC_23432), i1872, matching1, i1872, matching2) -> f23436_0_plus_LE(EOS(STATIC_23436), i1872, 0, i1872, 0, i1872) :|: TRUE && matching1 = 0 && matching2 = 0
f23436_0_plus_LE(EOS(STATIC_23436), i1881, matching1, i1881, matching2, i1881) -> f23442_0_plus_LE(EOS(STATIC_23442), i1881, 0, i1881, 0, i1881) :|: TRUE && matching1 = 0 && matching2 = 0
f23442_0_plus_LE(EOS(STATIC_23442), i1881, matching1, i1881, matching2, i1881) -> f23448_0_plus_ConstantStackPush(EOS(STATIC_23448), i1881, 0, i1881, 0) :|: i1881 > 0 && matching1 = 0 && matching2 = 0
f23448_0_plus_ConstantStackPush(EOS(STATIC_23448), i1881, matching1, i1881, matching2) -> f23454_0_plus_Load(EOS(STATIC_23454), i1881, 0, i1881, 0, 1) :|: TRUE && matching1 = 0 && matching2 = 0
f23454_0_plus_Load(EOS(STATIC_23454), i1881, matching1, i1881, matching2, matching3) -> f23459_0_plus_ConstantStackPush(EOS(STATIC_23459), i1881, 0, 0, 1, i1881) :|: TRUE && matching1 = 0 && matching2 = 0 && matching3 = 1
f23459_0_plus_ConstantStackPush(EOS(STATIC_23459), i1881, matching1, matching2, matching3, i1881) -> f23491_0_plus_IntArithmetic(EOS(STATIC_23491), i1881, 0, 0, 1, i1881, 1) :|: TRUE && matching1 = 0 && matching2 = 0 && matching3 = 1
f23491_0_plus_IntArithmetic(EOS(STATIC_23491), i1881, matching1, matching2, matching3, i1881, matching4) -> f23498_0_plus_Load(EOS(STATIC_23498), i1881, 0, 0, 1, i1881 - 1) :|: i1881 > 0 && matching1 = 0 && matching2 = 0 && matching3 = 1 && matching4 = 1
f23498_0_plus_Load(EOS(STATIC_23498), i1881, matching1, matching2, matching3, i1886) -> f23508_0_plus_InvokeMethod(EOS(STATIC_23508), i1881, 0, 1, i1886, 0) :|: TRUE && matching1 = 0 && matching2 = 0 && matching3 = 1
f23508_0_plus_InvokeMethod(EOS(STATIC_23508), i1881, matching1, matching2, i1886, matching3) -> f23512_0_plus_Load(EOS(STATIC_23512), i1886, 0, i1886, 0) :|: i1881 >= 1 && i1886 < i1881 && matching1 = 0 && matching2 = 1 && matching3 = 0
f23508_0_plus_InvokeMethod(EOS(STATIC_23508), i1881, matching1, matching2, i1886, matching3) -> f23512_1_plus_Load(EOS(STATIC_23512), i1881, 0, 1, i1886, 0) :|: i1881 >= 1 && i1886 < i1881 && matching1 = 0 && matching2 = 1 && matching3 = 0
f23512_0_plus_Load(EOS(STATIC_23512), i1886, matching1, i1886, matching2) -> f23567_0_plus_Load(EOS(STATIC_23567), i1886, 0, i1886, 0) :|: TRUE && matching1 = 0 && matching2 = 0
f23567_0_plus_Load(EOS(STATIC_23567), i1886, matching1, i1886, matching2) -> f23400_0_plus_Load(EOS(STATIC_23400), i1886, 0, i1886, 0) :|: TRUE && matching1 = 0 && matching2 = 0
f23400_0_plus_Load(EOS(STATIC_23400), i1872, i1873, i1872, i1873) -> f23426_0_plus_LE(EOS(STATIC_23426), i1872, i1873, i1872, i1873, i1873) :|: TRUE
f23430_0_plus_LE(EOS(STATIC_23430), i1872, i1878, i1872, i1878, i1878) -> f23435_0_plus_ConstantStackPush(EOS(STATIC_23435), i1872, i1878, i1872, i1878) :|: i1878 > 0
f23435_0_plus_ConstantStackPush(EOS(STATIC_23435), i1872, i1878, i1872, i1878) -> f23439_0_plus_Load(EOS(STATIC_23439), i1872, i1878, i1872, i1878, 1) :|: TRUE
f23439_0_plus_Load(EOS(STATIC_23439), i1872, i1878, i1872, i1878, matching1) -> f23444_0_plus_Load(EOS(STATIC_23444), i1872, i1878, i1878, 1, i1872) :|: TRUE && matching1 = 1
f23444_0_plus_Load(EOS(STATIC_23444), i1872, i1878, i1878, matching1, i1872) -> f23450_0_plus_ConstantStackPush(EOS(STATIC_23450), i1872, i1878, 1, i1872, i1878) :|: TRUE && matching1 = 1
f23450_0_plus_ConstantStackPush(EOS(STATIC_23450), i1872, i1878, matching1, i1872, i1878) -> f23455_0_plus_IntArithmetic(EOS(STATIC_23455), i1872, i1878, 1, i1872, i1878, 1) :|: TRUE && matching1 = 1
f23455_0_plus_IntArithmetic(EOS(STATIC_23455), i1872, i1878, matching1, i1872, i1878, matching2) -> f23461_0_plus_InvokeMethod(EOS(STATIC_23461), i1872, i1878, 1, i1872, i1878 - 1) :|: i1878 > 0 && matching1 = 1 && matching2 = 1
f23461_0_plus_InvokeMethod(EOS(STATIC_23461), i1872, i1878, matching1, i1872, i1882) -> f23493_0_plus_Load(EOS(STATIC_23493), i1872, i1882, i1872, i1882) :|: i1878 >= 1 && i1882 < i1878 && matching1 = 1
f23461_0_plus_InvokeMethod(EOS(STATIC_23461), i1872, i1878, matching1, i1872, i1882) -> f23493_1_plus_Load(EOS(STATIC_23493), i1872, i1878, 1, i1872, i1882) :|: i1878 >= 1 && i1882 < i1878 && matching1 = 1
f23493_0_plus_Load(EOS(STATIC_23493), i1872, i1882, i1872, i1882) -> f23502_0_plus_Load(EOS(STATIC_23502), i1872, i1882, i1872, i1882) :|: TRUE
f23502_0_plus_Load(EOS(STATIC_23502), i1872, i1882, i1872, i1882) -> f23400_0_plus_Load(EOS(STATIC_23400), i1872, i1882, i1872, i1882) :|: TRUE
Combined rules. Obtained 4 IRulesP rules:
f23426_0_plus_LE(EOS(STATIC_23426), i1872:0, i1878:0, i1872:0, i1878:0, i1878:0) -> f23426_0_plus_LE(EOS(STATIC_23426), i1872:0, i1878:0 - 1, i1872:0, i1878:0 - 1, i1878:0 - 1) :|: i1878:0 > 0 && i1878:0 - 1 < i1878:0
f23426_0_plus_LE(EOS(STATIC_23426), i1872:0, 0, i1872:0, 0, 0) -> f23426_0_plus_LE(EOS(STATIC_23426), i1872:0 - 1, 0, i1872:0 - 1, 0, 0) :|: i1872:0 > 0 && i1872:0 - 1 < i1872:0
Removed following non-SCC rules:
f23426_0_plus_LE(EOS(STATIC_23426), i1872:0, 0, i1872:0, 0, 0) -> f23512_1_plus_Load(EOS(STATIC_23512), i1872:0, 0, 1, i1872:0 - 1, 0) :|: i1872:0 > 0 && i1872:0 - 1 < i1872:0
f23426_0_plus_LE(EOS(STATIC_23426), i1872:0, i1878:0, i1872:0, i1878:0, i1878:0) -> f23493_1_plus_Load(EOS(STATIC_23493), i1872:0, i1878:0, 1, i1872:0, i1878:0 - 1) :|: i1878:0 > 0 && i1878:0 - 1 < i1878:0
Filtered constant ground arguments:
   f23426_0_plus_LE(x1, x2, x3, x4, x5, x6) -> f23426_0_plus_LE(x2, x3, x4, x5, x6)
   EOS(x1) -> EOS
Filtered duplicate arguments:
   f23426_0_plus_LE(x1, x2, x3, x4, x5) -> f23426_0_plus_LE(x3, x5)
Finished conversion. Obtained 2 rules.P rules:
f23426_0_plus_LE(i1872:0, i1878:0) -> f23426_0_plus_LE(i1872:0, i1878:0 - 1) :|: i1878:0 > 0 && i1878:0 - 1 < i1878:0
f23426_0_plus_LE(i1872:0, cons_0) -> f23426_0_plus_LE(i1872:0 - 1, 0) :|: i1872:0 > 0 && i1872:0 - 1 < i1872:0 && cons_0 = 0

----------------------------------------

(9)
Obligation:
Rules:
f23426_0_plus_LE(i1872:0, i1878:0) -> f23426_0_plus_LE(i1872:0, i1878:0 - 1) :|: i1878:0 > 0 && i1878:0 - 1 < i1878:0
f23426_0_plus_LE(x, x1) -> f23426_0_plus_LE(x - 1, 0) :|: x > 0 && x - 1 < x && x1 = 0

----------------------------------------

(10) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(11)
Obligation:
Rules:
f23426_0_plus_LE(i1872:0, i1878:0) -> f23426_0_plus_LE(i1872:0, arith) :|: i1878:0 > 0 && i1878:0 - 1 < i1878:0 && arith = i1878:0 - 1
f23426_0_plus_LE(x2, x3) -> f23426_0_plus_LE(x4, 0) :|: x2 > 0 && x2 - 1 < x2 && x3 = 0 && x4 = x2 - 1

----------------------------------------

(12) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f23426_0_plus_LE(i1872:0, i1878:0) -> f23426_0_plus_LE(i1872:0, arith) :|: i1878:0 > 0 && i1878:0 - 1 < i1878:0 && arith = i1878:0 - 1
(2) f23426_0_plus_LE(x2, x3) -> f23426_0_plus_LE(x4, 0) :|: x2 > 0 && x2 - 1 < x2 && x3 = 0 && x4 = x2 - 1

Arcs:
(1) -> (1), (2)
(2) -> (2)

This digraph is fully evaluated!
----------------------------------------

(13)
Complex Obligation (AND)

----------------------------------------

(14)
Obligation:

Termination digraph:
Nodes:
(1) f23426_0_plus_LE(i1872:0, i1878:0) -> f23426_0_plus_LE(i1872:0, arith) :|: i1878:0 > 0 && i1878:0 - 1 < i1878:0 && arith = i1878:0 - 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(15) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(16)
Obligation:
Rules:
f23426_0_plus_LE(i1872:0:0, i1878:0:0) -> f23426_0_plus_LE(i1872:0:0, i1878:0:0 - 1) :|: i1878:0:0 > 0 && i1878:0:0 - 1 < i1878:0:0

----------------------------------------

(17) IntTRSUnneededArgumentFilterProof (EQUIVALENT)
Some arguments are removed because they cannot influence termination. We removed arguments according to the following replacements:

   f23426_0_plus_LE(x1, x2) -> f23426_0_plus_LE(x2)

----------------------------------------

(18)
Obligation:
Rules:
f23426_0_plus_LE(i1878:0:0) -> f23426_0_plus_LE(i1878:0:0 - 1) :|: i1878:0:0 > 0 && i1878:0:0 - 1 < i1878:0:0

----------------------------------------

(19) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f23426_0_plus_LE(INTEGER)
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(20)
Obligation:
Rules:
f23426_0_plus_LE(i1878:0:0) -> f23426_0_plus_LE(c) :|: c = i1878:0:0 - 1 && (i1878:0:0 > 0 && i1878:0:0 - 1 < i1878:0:0)

----------------------------------------

(21) PolynomialOrderProcessor (EQUIVALENT)
Found the following polynomial interpretation:
[f23426_0_plus_LE(x)] = x

The following rules are decreasing:
f23426_0_plus_LE(i1878:0:0) -> f23426_0_plus_LE(c) :|: c = i1878:0:0 - 1 && (i1878:0:0 > 0 && i1878:0:0 - 1 < i1878:0:0)
The following rules are bounded:
f23426_0_plus_LE(i1878:0:0) -> f23426_0_plus_LE(c) :|: c = i1878:0:0 - 1 && (i1878:0:0 > 0 && i1878:0:0 - 1 < i1878:0:0)

----------------------------------------

(22)
YES

----------------------------------------

(23)
Obligation:

Termination digraph:
Nodes:
(1) f23426_0_plus_LE(x2, x3) -> f23426_0_plus_LE(x4, 0) :|: x2 > 0 && x2 - 1 < x2 && x3 = 0 && x4 = x2 - 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(24) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(25)
Obligation:
Rules:
f23426_0_plus_LE(x2:0, cons_0) -> f23426_0_plus_LE(x2:0 - 1, 0) :|: x2:0 > 0 && x2:0 - 1 < x2:0 && cons_0 = 0

----------------------------------------

(26) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f23426_0_plus_LE(INTEGER, VARIABLE)
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(27)
Obligation:
Rules:
f23426_0_plus_LE(x2:0, c) -> f23426_0_plus_LE(c1, c2) :|: c2 = 0 && (c1 = x2:0 - 1 && c = 0) && (x2:0 > 0 && x2:0 - 1 < x2:0 && cons_0 = 0)

----------------------------------------

(28) PolynomialOrderProcessor (EQUIVALENT)
Found the following polynomial interpretation:
[f23426_0_plus_LE(x, x1)] = x + c1*x1

The following rules are decreasing:
f23426_0_plus_LE(x2:0, c) -> f23426_0_plus_LE(c1, c2) :|: c2 = 0 && (c1 = x2:0 - 1 && c = 0) && (x2:0 > 0 && x2:0 - 1 < x2:0 && cons_0 = 0)
The following rules are bounded:
f23426_0_plus_LE(x2:0, c) -> f23426_0_plus_LE(c1, c2) :|: c2 = 0 && (c1 = x2:0 - 1 && c = 0) && (x2:0 > 0 && x2:0 - 1 < x2:0 && cons_0 = 0)

----------------------------------------

(29)
YES

----------------------------------------

(30)
Obligation:
SCC of termination graph based on JBC Program.
SCC contains nodes from the following methods: TimesPlusUserDef.times(II)I
SCC calls the following helper methods: TimesPlusUserDef.times(II)I, TimesPlusUserDef.plus(II)I
Performed SCC analyses:
*Used field analysis yielded the following read fields:

*Marker field analysis yielded the following relations that could be markers:

----------------------------------------

(31) SCCToIRSProof (SOUND)
Transformed FIGraph SCCs to intTRSs. Log: 
Generated rules. Obtained 13 IRulesP rules:
f227_0_times_NE(EOS(STATIC_227), i13, i34, i13, i34, i34) -> f230_0_times_NE(EOS(STATIC_230), i13, i34, i13, i34, i34) :|: TRUE
f230_0_times_NE(EOS(STATIC_230), i13, i34, i13, i34, i34) -> f234_0_times_Load(EOS(STATIC_234), i13, i34, i13, i34) :|: i34 > 0
f234_0_times_Load(EOS(STATIC_234), i13, i34, i13, i34) -> f238_0_times_LE(EOS(STATIC_238), i13, i34, i13, i34, i34) :|: TRUE
f238_0_times_LE(EOS(STATIC_238), i13, i34, i13, i34, i34) -> f245_0_times_Load(EOS(STATIC_245), i13, i34, i13, i34) :|: i34 > 0
f245_0_times_Load(EOS(STATIC_245), i13, i34, i13, i34) -> f257_0_times_Load(EOS(STATIC_257), i13, i34, i13, i34, i13) :|: TRUE
f257_0_times_Load(EOS(STATIC_257), i13, i34, i13, i34, i13) -> f358_0_times_ConstantStackPush(EOS(STATIC_358), i13, i34, i13, i13, i34) :|: TRUE
f358_0_times_ConstantStackPush(EOS(STATIC_358), i13, i34, i13, i13, i34) -> f367_0_times_IntArithmetic(EOS(STATIC_367), i13, i34, i13, i13, i34, 1) :|: TRUE
f367_0_times_IntArithmetic(EOS(STATIC_367), i13, i34, i13, i13, i34, matching1) -> f377_0_times_InvokeMethod(EOS(STATIC_377), i13, i34, i13, i13, i34 - 1) :|: i34 > 0 && matching1 = 1
f377_0_times_InvokeMethod(EOS(STATIC_377), i13, i34, i13, i13, i52) -> f385_0_times_Load(EOS(STATIC_385), i13, i52, i13, i52) :|: i34 >= 1 && i52 < i34
f377_0_times_InvokeMethod(EOS(STATIC_377), i13, i34, i13, i13, i52) -> f385_1_times_Load(EOS(STATIC_385), i13, i34, i13, i13, i52) :|: i34 >= 1 && i52 < i34
f385_0_times_Load(EOS(STATIC_385), i13, i52, i13, i52) -> f391_0_times_Load(EOS(STATIC_391), i13, i52, i13, i52) :|: TRUE
f391_0_times_Load(EOS(STATIC_391), i13, i52, i13, i52) -> f215_0_times_Load(EOS(STATIC_215), i13, i52, i13, i52) :|: TRUE
f215_0_times_Load(EOS(STATIC_215), i13, i30, i13, i30) -> f227_0_times_NE(EOS(STATIC_227), i13, i30, i13, i30, i30) :|: TRUE
Combined rules. Obtained 2 IRulesP rules:
f227_0_times_NE(EOS(STATIC_227), i13:0, i34:0, i13:0, i34:0, i34:0) -> f227_0_times_NE(EOS(STATIC_227), i13:0, i34:0 - 1, i13:0, i34:0 - 1, i34:0 - 1) :|: i34:0 > 0 && i34:0 - 1 < i34:0
Removed following non-SCC rules:
f227_0_times_NE(EOS(STATIC_227), i13:0, i34:0, i13:0, i34:0, i34:0) -> f385_1_times_Load(EOS(STATIC_385), i13:0, i34:0, i13:0, i13:0, i34:0 - 1) :|: i34:0 > 0 && i34:0 - 1 < i34:0
Filtered constant ground arguments:
   f227_0_times_NE(x1, x2, x3, x4, x5, x6) -> f227_0_times_NE(x2, x3, x4, x5, x6)
   EOS(x1) -> EOS
Filtered duplicate arguments:
   f227_0_times_NE(x1, x2, x3, x4, x5) -> f227_0_times_NE(x3, x5)
Filtered unneeded arguments:
   f227_0_times_NE(x1, x2) -> f227_0_times_NE(x2)
Finished conversion. Obtained 1 rules.P rules:
f227_0_times_NE(i34:0) -> f227_0_times_NE(i34:0 - 1) :|: i34:0 > 0 && i34:0 - 1 < i34:0

----------------------------------------

(32)
Obligation:
Rules:
f227_0_times_NE(i34:0) -> f227_0_times_NE(i34:0 - 1) :|: i34:0 > 0 && i34:0 - 1 < i34:0

----------------------------------------

(33) IRSFormatTransformerProof (EQUIVALENT)
Reformatted IRS to match normalized format (transformed away non-linear left-hand sides, !=, / and %).
----------------------------------------

(34)
Obligation:
Rules:
f227_0_times_NE(i34:0) -> f227_0_times_NE(arith) :|: i34:0 > 0 && i34:0 - 1 < i34:0 && arith = i34:0 - 1

----------------------------------------

(35) IRSwTTerminationDigraphProof (EQUIVALENT)
Constructed termination digraph!
Nodes:
(1) f227_0_times_NE(i34:0) -> f227_0_times_NE(arith) :|: i34:0 > 0 && i34:0 - 1 < i34:0 && arith = i34:0 - 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!
----------------------------------------

(36)
Obligation:

Termination digraph:
Nodes:
(1) f227_0_times_NE(i34:0) -> f227_0_times_NE(arith) :|: i34:0 > 0 && i34:0 - 1 < i34:0 && arith = i34:0 - 1

Arcs:
(1) -> (1)

This digraph is fully evaluated!

----------------------------------------

(37) IntTRSCompressionProof (EQUIVALENT)
Compressed rules.
----------------------------------------

(38)
Obligation:
Rules:
f227_0_times_NE(i34:0:0) -> f227_0_times_NE(i34:0:0 - 1) :|: i34:0:0 > 0 && i34:0:0 - 1 < i34:0:0

----------------------------------------

(39) TempFilterProof (SOUND)
Used the following sort dictionary for filtering: 
f227_0_times_NE(INTEGER)
Replaced non-predefined constructor symbols by 0.
----------------------------------------

(40)
Obligation:
Rules:
f227_0_times_NE(i34:0:0) -> f227_0_times_NE(c) :|: c = i34:0:0 - 1 && (i34:0:0 > 0 && i34:0:0 - 1 < i34:0:0)

----------------------------------------

(41) PolynomialOrderProcessor (EQUIVALENT)
Found the following polynomial interpretation:
[f227_0_times_NE(x)] = x

The following rules are decreasing:
f227_0_times_NE(i34:0:0) -> f227_0_times_NE(c) :|: c = i34:0:0 - 1 && (i34:0:0 > 0 && i34:0:0 - 1 < i34:0:0)
The following rules are bounded:
f227_0_times_NE(i34:0:0) -> f227_0_times_NE(c) :|: c = i34:0:0 - 1 && (i34:0:0 > 0 && i34:0:0 - 1 < i34:0:0)

----------------------------------------

(42)
YES
