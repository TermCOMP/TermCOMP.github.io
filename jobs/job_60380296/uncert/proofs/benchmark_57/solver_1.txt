YES
proof of /hpcwork/ff862203/termcomp25/benchmarks/o0Dxc.jar
# AProVE Commit ID: 6a57d5d12fc64508e0a03bd649c96e4df8acddf2 jan-christoph 20250809 unpublished dirty


termination of the given Bare JBC problem could be proven:

(0) Bare JBC problem
(1) BareJBCToJBCProof [EQUIVALENT, 0 ms]
(2) JBC problem
(3) JBCToGraph [EQUIVALENT, 85 ms]
(4) JBCTerminationGraph
(5) TerminationGraphToSCCProof [SOUND, 0 ms]
(6) TRUE


----------------------------------------

(0)
Obligation:
need to prove termination of the following program:

class BinarySearchTree{
    private LinkedList data;
    private BinarySearchTree lc;
    private BinarySearchTree rc;
    //    private int numData;

    public BinarySearchTree(){
	data = new Null();
	lc = null;
	rc = null;
           }

    public BinarySearchTree copy(){
	BinarySearchTree aux = new BinarySearchTree();
	aux.data=data.copy();
	if (lc==null) aux.lc=null;
	else aux.lc=lc.copy();
	if (rc==null) aux.rc=null;
	else aux.rc=rc.copy();
	return aux;
    }

    public static void main(String[] args) {
	BinarySearchTree bst = new BinarySearchTree();
	bst.lc = new BinarySearchTree();
	bst.rc = new BinarySearchTree();
	bst.data = new Null(); //Cons();
	//((Cons)bst.data).elem = 13;
	//((Cons)bst.data).next = new Null();
	bst.copy();
    }
}


abstract class LinkedList {
    abstract LinkedList copy();
  
}


class Null extends LinkedList {
      LinkedList copy() {
	  return new Null();
      }
    /*		
      List add(int e){
	  Cons aux = new Cons();
	  aux.elem = e;
	  aux.next = this;
	  return aux;
      }
    */
    /*		
      String print(){
       	  return "";
      }
    */
}



----------------------------------------

(1) BareJBCToJBCProof (EQUIVALENT)
initialized classpath
----------------------------------------

(2)
Obligation:
need to prove termination of the following program:

class BinarySearchTree{
    private LinkedList data;
    private BinarySearchTree lc;
    private BinarySearchTree rc;
    //    private int numData;

    public BinarySearchTree(){
	data = new Null();
	lc = null;
	rc = null;
           }

    public BinarySearchTree copy(){
	BinarySearchTree aux = new BinarySearchTree();
	aux.data=data.copy();
	if (lc==null) aux.lc=null;
	else aux.lc=lc.copy();
	if (rc==null) aux.rc=null;
	else aux.rc=rc.copy();
	return aux;
    }

    public static void main(String[] args) {
	BinarySearchTree bst = new BinarySearchTree();
	bst.lc = new BinarySearchTree();
	bst.rc = new BinarySearchTree();
	bst.data = new Null(); //Cons();
	//((Cons)bst.data).elem = 13;
	//((Cons)bst.data).next = new Null();
	bst.copy();
    }
}


abstract class LinkedList {
    abstract LinkedList copy();
  
}


class Null extends LinkedList {
      LinkedList copy() {
	  return new Null();
      }
    /*		
      List add(int e){
	  Cons aux = new Cons();
	  aux.elem = e;
	  aux.next = this;
	  return aux;
      }
    */
    /*		
      String print(){
       	  return "";
      }
    */
}



----------------------------------------

(3) JBCToGraph (EQUIVALENT)
Constructed TerminationGraph.
----------------------------------------

(4)
Obligation:
Termination Graph based on JBC Program:
BinarySearchTree.main([Ljava/lang/String;)V: Graph of 257 nodes with 0 SCCs.





----------------------------------------

(5) TerminationGraphToSCCProof (SOUND)
Proven termination by absence of SCCs
----------------------------------------

(6)
TRUE
